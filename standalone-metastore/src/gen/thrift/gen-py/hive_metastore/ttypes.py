#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import fb303.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class HiveObjectType:
  GLOBAL = 1
  DATABASE = 2
  TABLE = 3
  PARTITION = 4
  COLUMN = 5

  _VALUES_TO_NAMES = {
    1: "GLOBAL",
    2: "DATABASE",
    3: "TABLE",
    4: "PARTITION",
    5: "COLUMN",
  }

  _NAMES_TO_VALUES = {
    "GLOBAL": 1,
    "DATABASE": 2,
    "TABLE": 3,
    "PARTITION": 4,
    "COLUMN": 5,
  }

class PrincipalType:
  USER = 1
  ROLE = 2
  GROUP = 3

  _VALUES_TO_NAMES = {
    1: "USER",
    2: "ROLE",
    3: "GROUP",
  }

  _NAMES_TO_VALUES = {
    "USER": 1,
    "ROLE": 2,
    "GROUP": 3,
  }

class PartitionEventType:
  LOAD_DONE = 1

  _VALUES_TO_NAMES = {
    1: "LOAD_DONE",
  }

  _NAMES_TO_VALUES = {
    "LOAD_DONE": 1,
  }

class TxnState:
  COMMITTED = 1
  ABORTED = 2
  OPEN = 3

  _VALUES_TO_NAMES = {
    1: "COMMITTED",
    2: "ABORTED",
    3: "OPEN",
  }

  _NAMES_TO_VALUES = {
    "COMMITTED": 1,
    "ABORTED": 2,
    "OPEN": 3,
  }

class LockLevel:
  DB = 1
  TABLE = 2
  PARTITION = 3

  _VALUES_TO_NAMES = {
    1: "DB",
    2: "TABLE",
    3: "PARTITION",
  }

  _NAMES_TO_VALUES = {
    "DB": 1,
    "TABLE": 2,
    "PARTITION": 3,
  }

class LockState:
  ACQUIRED = 1
  WAITING = 2
  ABORT = 3
  NOT_ACQUIRED = 4

  _VALUES_TO_NAMES = {
    1: "ACQUIRED",
    2: "WAITING",
    3: "ABORT",
    4: "NOT_ACQUIRED",
  }

  _NAMES_TO_VALUES = {
    "ACQUIRED": 1,
    "WAITING": 2,
    "ABORT": 3,
    "NOT_ACQUIRED": 4,
  }

class LockType:
  SHARED_READ = 1
  SHARED_WRITE = 2
  EXCLUSIVE = 3

  _VALUES_TO_NAMES = {
    1: "SHARED_READ",
    2: "SHARED_WRITE",
    3: "EXCLUSIVE",
  }

  _NAMES_TO_VALUES = {
    "SHARED_READ": 1,
    "SHARED_WRITE": 2,
    "EXCLUSIVE": 3,
  }

class CompactionType:
  MINOR = 1
  MAJOR = 2

  _VALUES_TO_NAMES = {
    1: "MINOR",
    2: "MAJOR",
  }

  _NAMES_TO_VALUES = {
    "MINOR": 1,
    "MAJOR": 2,
  }

class GrantRevokeType:
  GRANT = 1
  REVOKE = 2

  _VALUES_TO_NAMES = {
    1: "GRANT",
    2: "REVOKE",
  }

  _NAMES_TO_VALUES = {
    "GRANT": 1,
    "REVOKE": 2,
  }

class DataOperationType:
  SELECT = 1
  INSERT = 2
  UPDATE = 3
  DELETE = 4
  UNSET = 5
  NO_TXN = 6

  _VALUES_TO_NAMES = {
    1: "SELECT",
    2: "INSERT",
    3: "UPDATE",
    4: "DELETE",
    5: "UNSET",
    6: "NO_TXN",
  }

  _NAMES_TO_VALUES = {
    "SELECT": 1,
    "INSERT": 2,
    "UPDATE": 3,
    "DELETE": 4,
    "UNSET": 5,
    "NO_TXN": 6,
  }

class EventRequestType:
  INSERT = 1
  UPDATE = 2
  DELETE = 3

  _VALUES_TO_NAMES = {
    1: "INSERT",
    2: "UPDATE",
    3: "DELETE",
  }

  _NAMES_TO_VALUES = {
    "INSERT": 1,
    "UPDATE": 2,
    "DELETE": 3,
  }

class SerdeType:
  HIVE = 1
  SCHEMA_REGISTRY = 2

  _VALUES_TO_NAMES = {
    1: "HIVE",
    2: "SCHEMA_REGISTRY",
  }

  _NAMES_TO_VALUES = {
    "HIVE": 1,
    "SCHEMA_REGISTRY": 2,
  }

class SchemaType:
  HIVE = 1
  AVRO = 2

  _VALUES_TO_NAMES = {
    1: "HIVE",
    2: "AVRO",
  }

  _NAMES_TO_VALUES = {
    "HIVE": 1,
    "AVRO": 2,
  }

class SchemaCompatibility:
  NONE = 1
  BACKWARD = 2
  FORWARD = 3
  BOTH = 4

  _VALUES_TO_NAMES = {
    1: "NONE",
    2: "BACKWARD",
    3: "FORWARD",
    4: "BOTH",
  }

  _NAMES_TO_VALUES = {
    "NONE": 1,
    "BACKWARD": 2,
    "FORWARD": 3,
    "BOTH": 4,
  }

class SchemaValidation:
  LATEST = 1
  ALL = 2

  _VALUES_TO_NAMES = {
    1: "LATEST",
    2: "ALL",
  }

  _NAMES_TO_VALUES = {
    "LATEST": 1,
    "ALL": 2,
  }

class SchemaVersionState:
  INITIATED = 1
  START_REVIEW = 2
  CHANGES_REQUIRED = 3
  REVIEWED = 4
  ENABLED = 5
  DISABLED = 6
  ARCHIVED = 7
  DELETED = 8

  _VALUES_TO_NAMES = {
    1: "INITIATED",
    2: "START_REVIEW",
    3: "CHANGES_REQUIRED",
    4: "REVIEWED",
    5: "ENABLED",
    6: "DISABLED",
    7: "ARCHIVED",
    8: "DELETED",
  }

  _NAMES_TO_VALUES = {
    "INITIATED": 1,
    "START_REVIEW": 2,
    "CHANGES_REQUIRED": 3,
    "REVIEWED": 4,
    "ENABLED": 5,
    "DISABLED": 6,
    "ARCHIVED": 7,
    "DELETED": 8,
  }

class FunctionType:
  JAVA = 1

  _VALUES_TO_NAMES = {
    1: "JAVA",
  }

  _NAMES_TO_VALUES = {
    "JAVA": 1,
  }

class ResourceType:
  JAR = 1
  FILE = 2
  ARCHIVE = 3

  _VALUES_TO_NAMES = {
    1: "JAR",
    2: "FILE",
    3: "ARCHIVE",
  }

  _NAMES_TO_VALUES = {
    "JAR": 1,
    "FILE": 2,
    "ARCHIVE": 3,
  }

class FileMetadataExprType:
  ORC_SARG = 1

  _VALUES_TO_NAMES = {
    1: "ORC_SARG",
  }

  _NAMES_TO_VALUES = {
    "ORC_SARG": 1,
  }

class ClientCapability:
  TEST_CAPABILITY = 1
  INSERT_ONLY_TABLES = 2

  _VALUES_TO_NAMES = {
    1: "TEST_CAPABILITY",
    2: "INSERT_ONLY_TABLES",
  }

  _NAMES_TO_VALUES = {
    "TEST_CAPABILITY": 1,
    "INSERT_ONLY_TABLES": 2,
  }

class WMResourcePlanStatus:
  ACTIVE = 1
  ENABLED = 2
  DISABLED = 3

  _VALUES_TO_NAMES = {
    1: "ACTIVE",
    2: "ENABLED",
    3: "DISABLED",
  }

  _NAMES_TO_VALUES = {
    "ACTIVE": 1,
    "ENABLED": 2,
    "DISABLED": 3,
  }

class WMPoolSchedulingPolicy:
  FAIR = 1
  FIFO = 2

  _VALUES_TO_NAMES = {
    1: "FAIR",
    2: "FIFO",
  }

  _NAMES_TO_VALUES = {
    "FAIR": 1,
    "FIFO": 2,
  }


class Version:
  """
  Attributes:
   - version
   - comments
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'version', None, None, ), # 1
    (2, TType.STRING, 'comments', None, None, ), # 2
  )

  def __init__(self, version=None, comments=None,):
    self.version = version
    self.comments = comments

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.version = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comments = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Version')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 1)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 2)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.comments)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FieldSchema:
  """
  Attributes:
   - name
   - type
   - comment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type', None, None, ), # 2
    (3, TType.STRING, 'comment', None, None, ), # 3
  )

  def __init__(self, name=None, type=None, comment=None,):
    self.name = name
    self.type = type
    self.comment = comment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FieldSchema')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 2)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 3)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.comment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLPrimaryKey:
  """
  Attributes:
   - table_db
   - table_name
   - column_name
   - key_seq
   - pk_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_db', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'column_name', None, None, ), # 3
    (4, TType.I32, 'key_seq', None, None, ), # 4
    (5, TType.STRING, 'pk_name', None, None, ), # 5
    (6, TType.BOOL, 'enable_cstr', None, None, ), # 6
    (7, TType.BOOL, 'validate_cstr', None, None, ), # 7
    (8, TType.BOOL, 'rely_cstr', None, None, ), # 8
    (9, TType.STRING, 'catName', None, None, ), # 9
  )

  def __init__(self, table_db=None, table_name=None, column_name=None, key_seq=None, pk_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None, catName=None,):
    self.table_db = table_db
    self.table_name = table_name
    self.column_name = column_name
    self.key_seq = key_seq
    self.pk_name = pk_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.key_seq = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.pk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLPrimaryKey')
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 1)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.column_name is not None:
      oprot.writeFieldBegin('column_name', TType.STRING, 3)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.key_seq is not None:
      oprot.writeFieldBegin('key_seq', TType.I32, 4)
      oprot.writeI32(self.key_seq)
      oprot.writeFieldEnd()
    if self.pk_name is not None:
      oprot.writeFieldBegin('pk_name', TType.STRING, 5)
      oprot.writeString(self.pk_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 6)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 7)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 8)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 9)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table_db)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.column_name)
    value = (value * 31) ^ hash(self.key_seq)
    value = (value * 31) ^ hash(self.pk_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLForeignKey:
  """
  Attributes:
   - pktable_db
   - pktable_name
   - pkcolumn_name
   - fktable_db
   - fktable_name
   - fkcolumn_name
   - key_seq
   - update_rule
   - delete_rule
   - fk_name
   - pk_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pktable_db', None, None, ), # 1
    (2, TType.STRING, 'pktable_name', None, None, ), # 2
    (3, TType.STRING, 'pkcolumn_name', None, None, ), # 3
    (4, TType.STRING, 'fktable_db', None, None, ), # 4
    (5, TType.STRING, 'fktable_name', None, None, ), # 5
    (6, TType.STRING, 'fkcolumn_name', None, None, ), # 6
    (7, TType.I32, 'key_seq', None, None, ), # 7
    (8, TType.I32, 'update_rule', None, None, ), # 8
    (9, TType.I32, 'delete_rule', None, None, ), # 9
    (10, TType.STRING, 'fk_name', None, None, ), # 10
    (11, TType.STRING, 'pk_name', None, None, ), # 11
    (12, TType.BOOL, 'enable_cstr', None, None, ), # 12
    (13, TType.BOOL, 'validate_cstr', None, None, ), # 13
    (14, TType.BOOL, 'rely_cstr', None, None, ), # 14
    (15, TType.STRING, 'catName', None, None, ), # 15
  )

  def __init__(self, pktable_db=None, pktable_name=None, pkcolumn_name=None, fktable_db=None, fktable_name=None, fkcolumn_name=None, key_seq=None, update_rule=None, delete_rule=None, fk_name=None, pk_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None, catName=None,):
    self.pktable_db = pktable_db
    self.pktable_name = pktable_name
    self.pkcolumn_name = pkcolumn_name
    self.fktable_db = fktable_db
    self.fktable_name = fktable_name
    self.fkcolumn_name = fkcolumn_name
    self.key_seq = key_seq
    self.update_rule = update_rule
    self.delete_rule = delete_rule
    self.fk_name = fk_name
    self.pk_name = pk_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pktable_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pktable_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pkcolumn_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.fktable_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.fktable_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.fkcolumn_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.key_seq = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.update_rule = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.delete_rule = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.fk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.pk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLForeignKey')
    if self.pktable_db is not None:
      oprot.writeFieldBegin('pktable_db', TType.STRING, 1)
      oprot.writeString(self.pktable_db)
      oprot.writeFieldEnd()
    if self.pktable_name is not None:
      oprot.writeFieldBegin('pktable_name', TType.STRING, 2)
      oprot.writeString(self.pktable_name)
      oprot.writeFieldEnd()
    if self.pkcolumn_name is not None:
      oprot.writeFieldBegin('pkcolumn_name', TType.STRING, 3)
      oprot.writeString(self.pkcolumn_name)
      oprot.writeFieldEnd()
    if self.fktable_db is not None:
      oprot.writeFieldBegin('fktable_db', TType.STRING, 4)
      oprot.writeString(self.fktable_db)
      oprot.writeFieldEnd()
    if self.fktable_name is not None:
      oprot.writeFieldBegin('fktable_name', TType.STRING, 5)
      oprot.writeString(self.fktable_name)
      oprot.writeFieldEnd()
    if self.fkcolumn_name is not None:
      oprot.writeFieldBegin('fkcolumn_name', TType.STRING, 6)
      oprot.writeString(self.fkcolumn_name)
      oprot.writeFieldEnd()
    if self.key_seq is not None:
      oprot.writeFieldBegin('key_seq', TType.I32, 7)
      oprot.writeI32(self.key_seq)
      oprot.writeFieldEnd()
    if self.update_rule is not None:
      oprot.writeFieldBegin('update_rule', TType.I32, 8)
      oprot.writeI32(self.update_rule)
      oprot.writeFieldEnd()
    if self.delete_rule is not None:
      oprot.writeFieldBegin('delete_rule', TType.I32, 9)
      oprot.writeI32(self.delete_rule)
      oprot.writeFieldEnd()
    if self.fk_name is not None:
      oprot.writeFieldBegin('fk_name', TType.STRING, 10)
      oprot.writeString(self.fk_name)
      oprot.writeFieldEnd()
    if self.pk_name is not None:
      oprot.writeFieldBegin('pk_name', TType.STRING, 11)
      oprot.writeString(self.pk_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 12)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 13)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 14)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 15)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pktable_db)
    value = (value * 31) ^ hash(self.pktable_name)
    value = (value * 31) ^ hash(self.pkcolumn_name)
    value = (value * 31) ^ hash(self.fktable_db)
    value = (value * 31) ^ hash(self.fktable_name)
    value = (value * 31) ^ hash(self.fkcolumn_name)
    value = (value * 31) ^ hash(self.key_seq)
    value = (value * 31) ^ hash(self.update_rule)
    value = (value * 31) ^ hash(self.delete_rule)
    value = (value * 31) ^ hash(self.fk_name)
    value = (value * 31) ^ hash(self.pk_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLUniqueConstraint:
  """
  Attributes:
   - catName
   - table_db
   - table_name
   - column_name
   - key_seq
   - uk_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'catName', None, None, ), # 1
    (2, TType.STRING, 'table_db', None, None, ), # 2
    (3, TType.STRING, 'table_name', None, None, ), # 3
    (4, TType.STRING, 'column_name', None, None, ), # 4
    (5, TType.I32, 'key_seq', None, None, ), # 5
    (6, TType.STRING, 'uk_name', None, None, ), # 6
    (7, TType.BOOL, 'enable_cstr', None, None, ), # 7
    (8, TType.BOOL, 'validate_cstr', None, None, ), # 8
    (9, TType.BOOL, 'rely_cstr', None, None, ), # 9
  )

  def __init__(self, catName=None, table_db=None, table_name=None, column_name=None, key_seq=None, uk_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
    self.catName = catName
    self.table_db = table_db
    self.table_name = table_name
    self.column_name = column_name
    self.key_seq = key_seq
    self.uk_name = uk_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.key_seq = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.uk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLUniqueConstraint')
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 1)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 2)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 3)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.column_name is not None:
      oprot.writeFieldBegin('column_name', TType.STRING, 4)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.key_seq is not None:
      oprot.writeFieldBegin('key_seq', TType.I32, 5)
      oprot.writeI32(self.key_seq)
      oprot.writeFieldEnd()
    if self.uk_name is not None:
      oprot.writeFieldBegin('uk_name', TType.STRING, 6)
      oprot.writeString(self.uk_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 7)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 8)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 9)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.table_db)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.column_name)
    value = (value * 31) ^ hash(self.key_seq)
    value = (value * 31) ^ hash(self.uk_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLNotNullConstraint:
  """
  Attributes:
   - catName
   - table_db
   - table_name
   - column_name
   - nn_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'catName', None, None, ), # 1
    (2, TType.STRING, 'table_db', None, None, ), # 2
    (3, TType.STRING, 'table_name', None, None, ), # 3
    (4, TType.STRING, 'column_name', None, None, ), # 4
    (5, TType.STRING, 'nn_name', None, None, ), # 5
    (6, TType.BOOL, 'enable_cstr', None, None, ), # 6
    (7, TType.BOOL, 'validate_cstr', None, None, ), # 7
    (8, TType.BOOL, 'rely_cstr', None, None, ), # 8
  )

  def __init__(self, catName=None, table_db=None, table_name=None, column_name=None, nn_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
    self.catName = catName
    self.table_db = table_db
    self.table_name = table_name
    self.column_name = column_name
    self.nn_name = nn_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.nn_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLNotNullConstraint')
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 1)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 2)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 3)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.column_name is not None:
      oprot.writeFieldBegin('column_name', TType.STRING, 4)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.nn_name is not None:
      oprot.writeFieldBegin('nn_name', TType.STRING, 5)
      oprot.writeString(self.nn_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 6)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 7)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 8)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.table_db)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.column_name)
    value = (value * 31) ^ hash(self.nn_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLDefaultConstraint:
  """
  Attributes:
   - catName
   - table_db
   - table_name
   - column_name
   - default_value
   - dc_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'catName', None, None, ), # 1
    (2, TType.STRING, 'table_db', None, None, ), # 2
    (3, TType.STRING, 'table_name', None, None, ), # 3
    (4, TType.STRING, 'column_name', None, None, ), # 4
    (5, TType.STRING, 'default_value', None, None, ), # 5
    (6, TType.STRING, 'dc_name', None, None, ), # 6
    (7, TType.BOOL, 'enable_cstr', None, None, ), # 7
    (8, TType.BOOL, 'validate_cstr', None, None, ), # 8
    (9, TType.BOOL, 'rely_cstr', None, None, ), # 9
  )

  def __init__(self, catName=None, table_db=None, table_name=None, column_name=None, default_value=None, dc_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
    self.catName = catName
    self.table_db = table_db
    self.table_name = table_name
    self.column_name = column_name
    self.default_value = default_value
    self.dc_name = dc_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.default_value = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.dc_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLDefaultConstraint')
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 1)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 2)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 3)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.column_name is not None:
      oprot.writeFieldBegin('column_name', TType.STRING, 4)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.default_value is not None:
      oprot.writeFieldBegin('default_value', TType.STRING, 5)
      oprot.writeString(self.default_value)
      oprot.writeFieldEnd()
    if self.dc_name is not None:
      oprot.writeFieldBegin('dc_name', TType.STRING, 6)
      oprot.writeString(self.dc_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 7)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 8)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 9)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.table_db)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.column_name)
    value = (value * 31) ^ hash(self.default_value)
    value = (value * 31) ^ hash(self.dc_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLCheckConstraint:
  """
  Attributes:
   - catName
   - table_db
   - table_name
   - column_name
   - check_expression
   - dc_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'catName', None, None, ), # 1
    (2, TType.STRING, 'table_db', None, None, ), # 2
    (3, TType.STRING, 'table_name', None, None, ), # 3
    (4, TType.STRING, 'column_name', None, None, ), # 4
    (5, TType.STRING, 'check_expression', None, None, ), # 5
    (6, TType.STRING, 'dc_name', None, None, ), # 6
    (7, TType.BOOL, 'enable_cstr', None, None, ), # 7
    (8, TType.BOOL, 'validate_cstr', None, None, ), # 8
    (9, TType.BOOL, 'rely_cstr', None, None, ), # 9
  )

  def __init__(self, catName=None, table_db=None, table_name=None, column_name=None, check_expression=None, dc_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
    self.catName = catName
    self.table_db = table_db
    self.table_name = table_name
    self.column_name = column_name
    self.check_expression = check_expression
    self.dc_name = dc_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.check_expression = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.dc_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLCheckConstraint')
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 1)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 2)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 3)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.column_name is not None:
      oprot.writeFieldBegin('column_name', TType.STRING, 4)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.check_expression is not None:
      oprot.writeFieldBegin('check_expression', TType.STRING, 5)
      oprot.writeString(self.check_expression)
      oprot.writeFieldEnd()
    if self.dc_name is not None:
      oprot.writeFieldBegin('dc_name', TType.STRING, 6)
      oprot.writeString(self.dc_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 7)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 8)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 9)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.table_db)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.column_name)
    value = (value * 31) ^ hash(self.check_expression)
    value = (value * 31) ^ hash(self.dc_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Type:
  """
  Attributes:
   - name
   - type1
   - type2
   - fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type1', None, None, ), # 2
    (3, TType.STRING, 'type2', None, None, ), # 3
    (4, TType.LIST, 'fields', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 4
  )

  def __init__(self, name=None, type1=None, type2=None, fields=None,):
    self.name = name
    self.type1 = type1
    self.type2 = type2
    self.fields = fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type1 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.type2 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fields = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = FieldSchema()
            _elem5.read(iprot)
            self.fields.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Type')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type1 is not None:
      oprot.writeFieldBegin('type1', TType.STRING, 2)
      oprot.writeString(self.type1)
      oprot.writeFieldEnd()
    if self.type2 is not None:
      oprot.writeFieldBegin('type2', TType.STRING, 3)
      oprot.writeString(self.type2)
      oprot.writeFieldEnd()
    if self.fields is not None:
      oprot.writeFieldBegin('fields', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter6 in self.fields:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.type1)
    value = (value * 31) ^ hash(self.type2)
    value = (value * 31) ^ hash(self.fields)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HiveObjectRef:
  """
  Attributes:
   - objectType
   - dbName
   - objectName
   - partValues
   - columnName
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'objectType', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'objectName', None, None, ), # 3
    (4, TType.LIST, 'partValues', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'columnName', None, None, ), # 5
    (6, TType.STRING, 'catName', None, None, ), # 6
  )

  def __init__(self, objectType=None, dbName=None, objectName=None, partValues=None, columnName=None, catName=None,):
    self.objectType = objectType
    self.dbName = dbName
    self.objectName = objectName
    self.partValues = partValues
    self.columnName = columnName
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.objectType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.objectName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partValues = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString()
            self.partValues.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.columnName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HiveObjectRef')
    if self.objectType is not None:
      oprot.writeFieldBegin('objectType', TType.I32, 1)
      oprot.writeI32(self.objectType)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.objectName is not None:
      oprot.writeFieldBegin('objectName', TType.STRING, 3)
      oprot.writeString(self.objectName)
      oprot.writeFieldEnd()
    if self.partValues is not None:
      oprot.writeFieldBegin('partValues', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.partValues))
      for iter13 in self.partValues:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.columnName is not None:
      oprot.writeFieldBegin('columnName', TType.STRING, 5)
      oprot.writeString(self.columnName)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 6)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.objectType)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.objectName)
    value = (value * 31) ^ hash(self.partValues)
    value = (value * 31) ^ hash(self.columnName)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrivilegeGrantInfo:
  """
  Attributes:
   - privilege
   - createTime
   - grantor
   - grantorType
   - grantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'privilege', None, None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.STRING, 'grantor', None, None, ), # 3
    (4, TType.I32, 'grantorType', None, None, ), # 4
    (5, TType.BOOL, 'grantOption', None, None, ), # 5
  )

  def __init__(self, privilege=None, createTime=None, grantor=None, grantorType=None, grantOption=None,):
    self.privilege = privilege
    self.createTime = createTime
    self.grantor = grantor
    self.grantorType = grantorType
    self.grantOption = grantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.privilege = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.grantor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrivilegeGrantInfo')
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.STRING, 1)
      oprot.writeString(self.privilege)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 3)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 4)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 5)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privilege)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.grantor)
    value = (value * 31) ^ hash(self.grantorType)
    value = (value * 31) ^ hash(self.grantOption)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HiveObjectPrivilege:
  """
  Attributes:
   - hiveObject
   - principalName
   - principalType
   - grantInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 1
    (2, TType.STRING, 'principalName', None, None, ), # 2
    (3, TType.I32, 'principalType', None, None, ), # 3
    (4, TType.STRUCT, 'grantInfo', (PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec), None, ), # 4
  )

  def __init__(self, hiveObject=None, principalName=None, principalType=None, grantInfo=None,):
    self.hiveObject = hiveObject
    self.principalName = principalName
    self.principalType = principalType
    self.grantInfo = grantInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principalName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.grantInfo = PrivilegeGrantInfo()
          self.grantInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HiveObjectPrivilege')
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 2)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 3)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantInfo is not None:
      oprot.writeFieldBegin('grantInfo', TType.STRUCT, 4)
      self.grantInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hiveObject)
    value = (value * 31) ^ hash(self.principalName)
    value = (value * 31) ^ hash(self.principalType)
    value = (value * 31) ^ hash(self.grantInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrivilegeBag:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'privileges', (TType.STRUCT,(HiveObjectPrivilege, HiveObjectPrivilege.thrift_spec)), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.privileges = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = HiveObjectPrivilege()
            _elem19.read(iprot)
            self.privileges.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrivilegeBag')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.privileges))
      for iter20 in self.privileges:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrincipalPrivilegeSet:
  """
  Attributes:
   - userPrivileges
   - groupPrivileges
   - rolePrivileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'userPrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 1
    (2, TType.MAP, 'groupPrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 2
    (3, TType.MAP, 'rolePrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 3
  )

  def __init__(self, userPrivileges=None, groupPrivileges=None, rolePrivileges=None,):
    self.userPrivileges = userPrivileges
    self.groupPrivileges = groupPrivileges
    self.rolePrivileges = rolePrivileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.userPrivileges = {}
          (_ktype22, _vtype23, _size21 ) = iprot.readMapBegin()
          for _i25 in xrange(_size21):
            _key26 = iprot.readString()
            _val27 = []
            (_etype31, _size28) = iprot.readListBegin()
            for _i32 in xrange(_size28):
              _elem33 = PrivilegeGrantInfo()
              _elem33.read(iprot)
              _val27.append(_elem33)
            iprot.readListEnd()
            self.userPrivileges[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.groupPrivileges = {}
          (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin()
          for _i38 in xrange(_size34):
            _key39 = iprot.readString()
            _val40 = []
            (_etype44, _size41) = iprot.readListBegin()
            for _i45 in xrange(_size41):
              _elem46 = PrivilegeGrantInfo()
              _elem46.read(iprot)
              _val40.append(_elem46)
            iprot.readListEnd()
            self.groupPrivileges[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.rolePrivileges = {}
          (_ktype48, _vtype49, _size47 ) = iprot.readMapBegin()
          for _i51 in xrange(_size47):
            _key52 = iprot.readString()
            _val53 = []
            (_etype57, _size54) = iprot.readListBegin()
            for _i58 in xrange(_size54):
              _elem59 = PrivilegeGrantInfo()
              _elem59.read(iprot)
              _val53.append(_elem59)
            iprot.readListEnd()
            self.rolePrivileges[_key52] = _val53
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrincipalPrivilegeSet')
    if self.userPrivileges is not None:
      oprot.writeFieldBegin('userPrivileges', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.userPrivileges))
      for kiter60,viter61 in self.userPrivileges.items():
        oprot.writeString(kiter60)
        oprot.writeListBegin(TType.STRUCT, len(viter61))
        for iter62 in viter61:
          iter62.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.groupPrivileges is not None:
      oprot.writeFieldBegin('groupPrivileges', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.groupPrivileges))
      for kiter63,viter64 in self.groupPrivileges.items():
        oprot.writeString(kiter63)
        oprot.writeListBegin(TType.STRUCT, len(viter64))
        for iter65 in viter64:
          iter65.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.rolePrivileges is not None:
      oprot.writeFieldBegin('rolePrivileges', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.rolePrivileges))
      for kiter66,viter67 in self.rolePrivileges.items():
        oprot.writeString(kiter66)
        oprot.writeListBegin(TType.STRUCT, len(viter67))
        for iter68 in viter67:
          iter68.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.userPrivileges)
    value = (value * 31) ^ hash(self.groupPrivileges)
    value = (value * 31) ^ hash(self.rolePrivileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokePrivilegeRequest:
  """
  Attributes:
   - requestType
   - privileges
   - revokeGrantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'requestType', None, None, ), # 1
    (2, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'revokeGrantOption', None, None, ), # 3
  )

  def __init__(self, requestType=None, privileges=None, revokeGrantOption=None,):
    self.requestType = requestType
    self.privileges = privileges
    self.revokeGrantOption = revokeGrantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.requestType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.revokeGrantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokePrivilegeRequest')
    if self.requestType is not None:
      oprot.writeFieldBegin('requestType', TType.I32, 1)
      oprot.writeI32(self.requestType)
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 2)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.revokeGrantOption is not None:
      oprot.writeFieldBegin('revokeGrantOption', TType.BOOL, 3)
      oprot.writeBool(self.revokeGrantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestType)
    value = (value * 31) ^ hash(self.privileges)
    value = (value * 31) ^ hash(self.revokeGrantOption)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokePrivilegeResponse:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokePrivilegeResponse')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Role:
  """
  Attributes:
   - roleName
   - createTime
   - ownerName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.STRING, 'ownerName', None, None, ), # 3
  )

  def __init__(self, roleName=None, createTime=None, ownerName=None,):
    self.roleName = roleName
    self.createTime = createTime
    self.ownerName = ownerName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Role')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 3)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roleName)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.ownerName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RolePrincipalGrant:
  """
  Attributes:
   - roleName
   - principalName
   - principalType
   - grantOption
   - grantTime
   - grantorName
   - grantorPrincipalType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
    (2, TType.STRING, 'principalName', None, None, ), # 2
    (3, TType.I32, 'principalType', None, None, ), # 3
    (4, TType.BOOL, 'grantOption', None, None, ), # 4
    (5, TType.I32, 'grantTime', None, None, ), # 5
    (6, TType.STRING, 'grantorName', None, None, ), # 6
    (7, TType.I32, 'grantorPrincipalType', None, None, ), # 7
  )

  def __init__(self, roleName=None, principalName=None, principalType=None, grantOption=None, grantTime=None, grantorName=None, grantorPrincipalType=None,):
    self.roleName = roleName
    self.principalName = principalName
    self.principalType = principalType
    self.grantOption = grantOption
    self.grantTime = grantTime
    self.grantorName = grantorName
    self.grantorPrincipalType = grantorPrincipalType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principalName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.grantTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.grantorName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.grantorPrincipalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RolePrincipalGrant')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 2)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 3)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 4)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    if self.grantTime is not None:
      oprot.writeFieldBegin('grantTime', TType.I32, 5)
      oprot.writeI32(self.grantTime)
      oprot.writeFieldEnd()
    if self.grantorName is not None:
      oprot.writeFieldBegin('grantorName', TType.STRING, 6)
      oprot.writeString(self.grantorName)
      oprot.writeFieldEnd()
    if self.grantorPrincipalType is not None:
      oprot.writeFieldBegin('grantorPrincipalType', TType.I32, 7)
      oprot.writeI32(self.grantorPrincipalType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roleName)
    value = (value * 31) ^ hash(self.principalName)
    value = (value * 31) ^ hash(self.principalType)
    value = (value * 31) ^ hash(self.grantOption)
    value = (value * 31) ^ hash(self.grantTime)
    value = (value * 31) ^ hash(self.grantorName)
    value = (value * 31) ^ hash(self.grantorPrincipalType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRoleGrantsForPrincipalRequest:
  """
  Attributes:
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
  )

  def __init__(self, principal_name=None, principal_type=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRoleGrantsForPrincipalRequest')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.principal_name is None:
      raise TProtocol.TProtocolException(message='Required field principal_name is unset!')
    if self.principal_type is None:
      raise TProtocol.TProtocolException(message='Required field principal_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRoleGrantsForPrincipalResponse:
  """
  Attributes:
   - principalGrants
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'principalGrants', (TType.STRUCT,(RolePrincipalGrant, RolePrincipalGrant.thrift_spec)), None, ), # 1
  )

  def __init__(self, principalGrants=None,):
    self.principalGrants = principalGrants

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.principalGrants = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = RolePrincipalGrant()
            _elem74.read(iprot)
            self.principalGrants.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRoleGrantsForPrincipalResponse')
    if self.principalGrants is not None:
      oprot.writeFieldBegin('principalGrants', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.principalGrants))
      for iter75 in self.principalGrants:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.principalGrants is None:
      raise TProtocol.TProtocolException(message='Required field principalGrants is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principalGrants)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPrincipalsInRoleRequest:
  """
  Attributes:
   - roleName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
  )

  def __init__(self, roleName=None,):
    self.roleName = roleName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPrincipalsInRoleRequest')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.roleName is None:
      raise TProtocol.TProtocolException(message='Required field roleName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roleName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPrincipalsInRoleResponse:
  """
  Attributes:
   - principalGrants
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'principalGrants', (TType.STRUCT,(RolePrincipalGrant, RolePrincipalGrant.thrift_spec)), None, ), # 1
  )

  def __init__(self, principalGrants=None,):
    self.principalGrants = principalGrants

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.principalGrants = []
          (_etype79, _size76) = iprot.readListBegin()
          for _i80 in xrange(_size76):
            _elem81 = RolePrincipalGrant()
            _elem81.read(iprot)
            self.principalGrants.append(_elem81)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPrincipalsInRoleResponse')
    if self.principalGrants is not None:
      oprot.writeFieldBegin('principalGrants', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.principalGrants))
      for iter82 in self.principalGrants:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.principalGrants is None:
      raise TProtocol.TProtocolException(message='Required field principalGrants is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principalGrants)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokeRoleRequest:
  """
  Attributes:
   - requestType
   - roleName
   - principalName
   - principalType
   - grantor
   - grantorType
   - grantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'requestType', None, None, ), # 1
    (2, TType.STRING, 'roleName', None, None, ), # 2
    (3, TType.STRING, 'principalName', None, None, ), # 3
    (4, TType.I32, 'principalType', None, None, ), # 4
    (5, TType.STRING, 'grantor', None, None, ), # 5
    (6, TType.I32, 'grantorType', None, None, ), # 6
    (7, TType.BOOL, 'grantOption', None, None, ), # 7
  )

  def __init__(self, requestType=None, roleName=None, principalName=None, principalType=None, grantor=None, grantorType=None, grantOption=None,):
    self.requestType = requestType
    self.roleName = roleName
    self.principalName = principalName
    self.principalType = principalType
    self.grantor = grantor
    self.grantorType = grantorType
    self.grantOption = grantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.requestType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.principalName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.principalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.grantor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokeRoleRequest')
    if self.requestType is not None:
      oprot.writeFieldBegin('requestType', TType.I32, 1)
      oprot.writeI32(self.requestType)
      oprot.writeFieldEnd()
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 2)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 3)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 4)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 5)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 6)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 7)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestType)
    value = (value * 31) ^ hash(self.roleName)
    value = (value * 31) ^ hash(self.principalName)
    value = (value * 31) ^ hash(self.principalType)
    value = (value * 31) ^ hash(self.grantor)
    value = (value * 31) ^ hash(self.grantorType)
    value = (value * 31) ^ hash(self.grantOption)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokeRoleResponse:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokeRoleResponse')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Catalog:
  """
  Attributes:
   - name
   - description
   - locationUri
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
    (3, TType.STRING, 'locationUri', None, None, ), # 3
  )

  def __init__(self, name=None, description=None, locationUri=None,):
    self.name = name
    self.description = description
    self.locationUri = locationUri

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.locationUri = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Catalog')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.locationUri is not None:
      oprot.writeFieldBegin('locationUri', TType.STRING, 3)
      oprot.writeString(self.locationUri)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.locationUri)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateCatalogRequest:
  """
  Attributes:
   - catalog
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'catalog', (Catalog, Catalog.thrift_spec), None, ), # 1
  )

  def __init__(self, catalog=None,):
    self.catalog = catalog

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.catalog = Catalog()
          self.catalog.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateCatalogRequest')
    if self.catalog is not None:
      oprot.writeFieldBegin('catalog', TType.STRUCT, 1)
      self.catalog.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catalog)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCatalogRequest:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCatalogRequest')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCatalogResponse:
  """
  Attributes:
   - catalog
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'catalog', (Catalog, Catalog.thrift_spec), None, ), # 1
  )

  def __init__(self, catalog=None,):
    self.catalog = catalog

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.catalog = Catalog()
          self.catalog.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCatalogResponse')
    if self.catalog is not None:
      oprot.writeFieldBegin('catalog', TType.STRUCT, 1)
      self.catalog.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catalog)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCatalogsResponse:
  """
  Attributes:
   - names
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'names', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, names=None,):
    self.names = names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.names = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = iprot.readString()
            self.names.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCatalogsResponse')
    if self.names is not None:
      oprot.writeFieldBegin('names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.names))
      for iter89 in self.names:
        oprot.writeString(iter89)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropCatalogRequest:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropCatalogRequest')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Database:
  """
  Attributes:
   - name
   - description
   - locationUri
   - parameters
   - privileges
   - ownerName
   - ownerType
   - catalogName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
    (3, TType.STRING, 'locationUri', None, None, ), # 3
    (4, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 4
    (5, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 5
    (6, TType.STRING, 'ownerName', None, None, ), # 6
    (7, TType.I32, 'ownerType', None, None, ), # 7
    (8, TType.STRING, 'catalogName', None, None, ), # 8
  )

  def __init__(self, name=None, description=None, locationUri=None, parameters=None, privileges=None, ownerName=None, ownerType=None, catalogName=None,):
    self.name = name
    self.description = description
    self.locationUri = locationUri
    self.parameters = parameters
    self.privileges = privileges
    self.ownerName = ownerName
    self.ownerType = ownerType
    self.catalogName = catalogName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.locationUri = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype91, _vtype92, _size90 ) = iprot.readMapBegin()
          for _i94 in xrange(_size90):
            _key95 = iprot.readString()
            _val96 = iprot.readString()
            self.parameters[_key95] = _val96
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.ownerType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.catalogName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Database')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.locationUri is not None:
      oprot.writeFieldBegin('locationUri', TType.STRING, 3)
      oprot.writeString(self.locationUri)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter97,viter98 in self.parameters.items():
        oprot.writeString(kiter97)
        oprot.writeString(viter98)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 5)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 6)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    if self.ownerType is not None:
      oprot.writeFieldBegin('ownerType', TType.I32, 7)
      oprot.writeI32(self.ownerType)
      oprot.writeFieldEnd()
    if self.catalogName is not None:
      oprot.writeFieldBegin('catalogName', TType.STRING, 8)
      oprot.writeString(self.catalogName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.locationUri)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.privileges)
    value = (value * 31) ^ hash(self.ownerName)
    value = (value * 31) ^ hash(self.ownerType)
    value = (value * 31) ^ hash(self.catalogName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SerDeInfo:
  """
  Attributes:
   - name
   - serializationLib
   - parameters
   - description
   - serializerClass
   - deserializerClass
   - serdeType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'serializationLib', None, None, ), # 2
    (3, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'description', None, None, ), # 4
    (5, TType.STRING, 'serializerClass', None, None, ), # 5
    (6, TType.STRING, 'deserializerClass', None, None, ), # 6
    (7, TType.I32, 'serdeType', None, None, ), # 7
  )

  def __init__(self, name=None, serializationLib=None, parameters=None, description=None, serializerClass=None, deserializerClass=None, serdeType=None,):
    self.name = name
    self.serializationLib = serializationLib
    self.parameters = parameters
    self.description = description
    self.serializerClass = serializerClass
    self.deserializerClass = deserializerClass
    self.serdeType = serdeType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serializationLib = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype100, _vtype101, _size99 ) = iprot.readMapBegin()
          for _i103 in xrange(_size99):
            _key104 = iprot.readString()
            _val105 = iprot.readString()
            self.parameters[_key104] = _val105
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.description = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.serializerClass = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.deserializerClass = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.serdeType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SerDeInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.serializationLib is not None:
      oprot.writeFieldBegin('serializationLib', TType.STRING, 2)
      oprot.writeString(self.serializationLib)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter106,viter107 in self.parameters.items():
        oprot.writeString(kiter106)
        oprot.writeString(viter107)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 4)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.serializerClass is not None:
      oprot.writeFieldBegin('serializerClass', TType.STRING, 5)
      oprot.writeString(self.serializerClass)
      oprot.writeFieldEnd()
    if self.deserializerClass is not None:
      oprot.writeFieldBegin('deserializerClass', TType.STRING, 6)
      oprot.writeString(self.deserializerClass)
      oprot.writeFieldEnd()
    if self.serdeType is not None:
      oprot.writeFieldBegin('serdeType', TType.I32, 7)
      oprot.writeI32(self.serdeType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.serializationLib)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.serializerClass)
    value = (value * 31) ^ hash(self.deserializerClass)
    value = (value * 31) ^ hash(self.serdeType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Order:
  """
  Attributes:
   - col
   - order
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col', None, None, ), # 1
    (2, TType.I32, 'order', None, None, ), # 2
  )

  def __init__(self, col=None, order=None,):
    self.col = col
    self.order = order

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.order = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Order')
    if self.col is not None:
      oprot.writeFieldBegin('col', TType.STRING, 1)
      oprot.writeString(self.col)
      oprot.writeFieldEnd()
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 2)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.col)
    value = (value * 31) ^ hash(self.order)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SkewedInfo:
  """
  Attributes:
   - skewedColNames
   - skewedColValues
   - skewedColValueLocationMaps
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'skewedColNames', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'skewedColValues', (TType.LIST,(TType.STRING,None)), None, ), # 2
    (3, TType.MAP, 'skewedColValueLocationMaps', (TType.LIST,(TType.STRING,None),TType.STRING,None), None, ), # 3
  )

  def __init__(self, skewedColNames=None, skewedColValues=None, skewedColValueLocationMaps=None,):
    self.skewedColNames = skewedColNames
    self.skewedColValues = skewedColValues
    self.skewedColValueLocationMaps = skewedColValueLocationMaps

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.skewedColNames = []
          (_etype111, _size108) = iprot.readListBegin()
          for _i112 in xrange(_size108):
            _elem113 = iprot.readString()
            self.skewedColNames.append(_elem113)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.skewedColValues = []
          (_etype117, _size114) = iprot.readListBegin()
          for _i118 in xrange(_size114):
            _elem119 = []
            (_etype123, _size120) = iprot.readListBegin()
            for _i124 in xrange(_size120):
              _elem125 = iprot.readString()
              _elem119.append(_elem125)
            iprot.readListEnd()
            self.skewedColValues.append(_elem119)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.skewedColValueLocationMaps = {}
          (_ktype127, _vtype128, _size126 ) = iprot.readMapBegin()
          for _i130 in xrange(_size126):
            _key131 = []
            (_etype136, _size133) = iprot.readListBegin()
            for _i137 in xrange(_size133):
              _elem138 = iprot.readString()
              _key131.append(_elem138)
            iprot.readListEnd()
            _val132 = iprot.readString()
            self.skewedColValueLocationMaps[_key131] = _val132
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SkewedInfo')
    if self.skewedColNames is not None:
      oprot.writeFieldBegin('skewedColNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.skewedColNames))
      for iter139 in self.skewedColNames:
        oprot.writeString(iter139)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewedColValues is not None:
      oprot.writeFieldBegin('skewedColValues', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.skewedColValues))
      for iter140 in self.skewedColValues:
        oprot.writeListBegin(TType.STRING, len(iter140))
        for iter141 in iter140:
          oprot.writeString(iter141)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewedColValueLocationMaps is not None:
      oprot.writeFieldBegin('skewedColValueLocationMaps', TType.MAP, 3)
      oprot.writeMapBegin(TType.LIST, TType.STRING, len(self.skewedColValueLocationMaps))
      for kiter142,viter143 in self.skewedColValueLocationMaps.items():
        oprot.writeListBegin(TType.STRING, len(kiter142))
        for iter144 in kiter142:
          oprot.writeString(iter144)
        oprot.writeListEnd()
        oprot.writeString(viter143)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.skewedColNames)
    value = (value * 31) ^ hash(self.skewedColValues)
    value = (value * 31) ^ hash(self.skewedColValueLocationMaps)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StorageDescriptor:
  """
  Attributes:
   - cols
   - location
   - inputFormat
   - outputFormat
   - compressed
   - numBuckets
   - serdeInfo
   - bucketCols
   - sortCols
   - parameters
   - skewedInfo
   - storedAsSubDirectories
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cols', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'location', None, None, ), # 2
    (3, TType.STRING, 'inputFormat', None, None, ), # 3
    (4, TType.STRING, 'outputFormat', None, None, ), # 4
    (5, TType.BOOL, 'compressed', None, None, ), # 5
    (6, TType.I32, 'numBuckets', None, None, ), # 6
    (7, TType.STRUCT, 'serdeInfo', (SerDeInfo, SerDeInfo.thrift_spec), None, ), # 7
    (8, TType.LIST, 'bucketCols', (TType.STRING,None), None, ), # 8
    (9, TType.LIST, 'sortCols', (TType.STRUCT,(Order, Order.thrift_spec)), None, ), # 9
    (10, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 10
    (11, TType.STRUCT, 'skewedInfo', (SkewedInfo, SkewedInfo.thrift_spec), None, ), # 11
    (12, TType.BOOL, 'storedAsSubDirectories', None, None, ), # 12
  )

  def __init__(self, cols=None, location=None, inputFormat=None, outputFormat=None, compressed=None, numBuckets=None, serdeInfo=None, bucketCols=None, sortCols=None, parameters=None, skewedInfo=None, storedAsSubDirectories=None,):
    self.cols = cols
    self.location = location
    self.inputFormat = inputFormat
    self.outputFormat = outputFormat
    self.compressed = compressed
    self.numBuckets = numBuckets
    self.serdeInfo = serdeInfo
    self.bucketCols = bucketCols
    self.sortCols = sortCols
    self.parameters = parameters
    self.skewedInfo = skewedInfo
    self.storedAsSubDirectories = storedAsSubDirectories

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cols = []
          (_etype148, _size145) = iprot.readListBegin()
          for _i149 in xrange(_size145):
            _elem150 = FieldSchema()
            _elem150.read(iprot)
            self.cols.append(_elem150)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.location = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.inputFormat = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.outputFormat = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.compressed = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.numBuckets = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.serdeInfo = SerDeInfo()
          self.serdeInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.bucketCols = []
          (_etype154, _size151) = iprot.readListBegin()
          for _i155 in xrange(_size151):
            _elem156 = iprot.readString()
            self.bucketCols.append(_elem156)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.sortCols = []
          (_etype160, _size157) = iprot.readListBegin()
          for _i161 in xrange(_size157):
            _elem162 = Order()
            _elem162.read(iprot)
            self.sortCols.append(_elem162)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype164, _vtype165, _size163 ) = iprot.readMapBegin()
          for _i167 in xrange(_size163):
            _key168 = iprot.readString()
            _val169 = iprot.readString()
            self.parameters[_key168] = _val169
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.skewedInfo = SkewedInfo()
          self.skewedInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.storedAsSubDirectories = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StorageDescriptor')
    if self.cols is not None:
      oprot.writeFieldBegin('cols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cols))
      for iter170 in self.cols:
        iter170.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 2)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.inputFormat is not None:
      oprot.writeFieldBegin('inputFormat', TType.STRING, 3)
      oprot.writeString(self.inputFormat)
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.STRING, 4)
      oprot.writeString(self.outputFormat)
      oprot.writeFieldEnd()
    if self.compressed is not None:
      oprot.writeFieldBegin('compressed', TType.BOOL, 5)
      oprot.writeBool(self.compressed)
      oprot.writeFieldEnd()
    if self.numBuckets is not None:
      oprot.writeFieldBegin('numBuckets', TType.I32, 6)
      oprot.writeI32(self.numBuckets)
      oprot.writeFieldEnd()
    if self.serdeInfo is not None:
      oprot.writeFieldBegin('serdeInfo', TType.STRUCT, 7)
      self.serdeInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.bucketCols is not None:
      oprot.writeFieldBegin('bucketCols', TType.LIST, 8)
      oprot.writeListBegin(TType.STRING, len(self.bucketCols))
      for iter171 in self.bucketCols:
        oprot.writeString(iter171)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sortCols is not None:
      oprot.writeFieldBegin('sortCols', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.sortCols))
      for iter172 in self.sortCols:
        iter172.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter173,viter174 in self.parameters.items():
        oprot.writeString(kiter173)
        oprot.writeString(viter174)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.skewedInfo is not None:
      oprot.writeFieldBegin('skewedInfo', TType.STRUCT, 11)
      self.skewedInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.storedAsSubDirectories is not None:
      oprot.writeFieldBegin('storedAsSubDirectories', TType.BOOL, 12)
      oprot.writeBool(self.storedAsSubDirectories)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cols)
    value = (value * 31) ^ hash(self.location)
    value = (value * 31) ^ hash(self.inputFormat)
    value = (value * 31) ^ hash(self.outputFormat)
    value = (value * 31) ^ hash(self.compressed)
    value = (value * 31) ^ hash(self.numBuckets)
    value = (value * 31) ^ hash(self.serdeInfo)
    value = (value * 31) ^ hash(self.bucketCols)
    value = (value * 31) ^ hash(self.sortCols)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.skewedInfo)
    value = (value * 31) ^ hash(self.storedAsSubDirectories)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Table:
  """
  Attributes:
   - tableName
   - dbName
   - owner
   - createTime
   - lastAccessTime
   - retention
   - sd
   - partitionKeys
   - parameters
   - viewOriginalText
   - viewExpandedText
   - tableType
   - privileges
   - temporary
   - rewriteEnabled
   - creationMetadata
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'owner', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.I32, 'retention', None, None, ), # 6
    (7, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 7
    (8, TType.LIST, 'partitionKeys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 8
    (9, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 9
    (10, TType.STRING, 'viewOriginalText', None, None, ), # 10
    (11, TType.STRING, 'viewExpandedText', None, None, ), # 11
    (12, TType.STRING, 'tableType', None, None, ), # 12
    (13, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 13
    (14, TType.BOOL, 'temporary', None, False, ), # 14
    (15, TType.BOOL, 'rewriteEnabled', None, None, ), # 15
    (16, TType.STRUCT, 'creationMetadata', (CreationMetadata, CreationMetadata.thrift_spec), None, ), # 16
    (17, TType.STRING, 'catName', None, None, ), # 17
  )

  def __init__(self, tableName=None, dbName=None, owner=None, createTime=None, lastAccessTime=None, retention=None, sd=None, partitionKeys=None, parameters=None, viewOriginalText=None, viewExpandedText=None, tableType=None, privileges=None, temporary=thrift_spec[14][4], rewriteEnabled=None, creationMetadata=None, catName=None,):
    self.tableName = tableName
    self.dbName = dbName
    self.owner = owner
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.retention = retention
    self.sd = sd
    self.partitionKeys = partitionKeys
    self.parameters = parameters
    self.viewOriginalText = viewOriginalText
    self.viewExpandedText = viewExpandedText
    self.tableType = tableType
    self.privileges = privileges
    self.temporary = temporary
    self.rewriteEnabled = rewriteEnabled
    self.creationMetadata = creationMetadata
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.owner = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.retention = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.partitionKeys = []
          (_etype178, _size175) = iprot.readListBegin()
          for _i179 in xrange(_size175):
            _elem180 = FieldSchema()
            _elem180.read(iprot)
            self.partitionKeys.append(_elem180)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype182, _vtype183, _size181 ) = iprot.readMapBegin()
          for _i185 in xrange(_size181):
            _key186 = iprot.readString()
            _val187 = iprot.readString()
            self.parameters[_key186] = _val187
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.viewOriginalText = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.viewExpandedText = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.tableType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.temporary = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.rewriteEnabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.creationMetadata = CreationMetadata()
          self.creationMetadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Table')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 3)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.retention is not None:
      oprot.writeFieldBegin('retention', TType.I32, 6)
      oprot.writeI32(self.retention)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 7)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.partitionKeys is not None:
      oprot.writeFieldBegin('partitionKeys', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionKeys))
      for iter188 in self.partitionKeys:
        iter188.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter189,viter190 in self.parameters.items():
        oprot.writeString(kiter189)
        oprot.writeString(viter190)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.viewOriginalText is not None:
      oprot.writeFieldBegin('viewOriginalText', TType.STRING, 10)
      oprot.writeString(self.viewOriginalText)
      oprot.writeFieldEnd()
    if self.viewExpandedText is not None:
      oprot.writeFieldBegin('viewExpandedText', TType.STRING, 11)
      oprot.writeString(self.viewExpandedText)
      oprot.writeFieldEnd()
    if self.tableType is not None:
      oprot.writeFieldBegin('tableType', TType.STRING, 12)
      oprot.writeString(self.tableType)
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 13)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.temporary is not None:
      oprot.writeFieldBegin('temporary', TType.BOOL, 14)
      oprot.writeBool(self.temporary)
      oprot.writeFieldEnd()
    if self.rewriteEnabled is not None:
      oprot.writeFieldBegin('rewriteEnabled', TType.BOOL, 15)
      oprot.writeBool(self.rewriteEnabled)
      oprot.writeFieldEnd()
    if self.creationMetadata is not None:
      oprot.writeFieldBegin('creationMetadata', TType.STRUCT, 16)
      self.creationMetadata.write(oprot)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 17)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.owner)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.retention)
    value = (value * 31) ^ hash(self.sd)
    value = (value * 31) ^ hash(self.partitionKeys)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.viewOriginalText)
    value = (value * 31) ^ hash(self.viewExpandedText)
    value = (value * 31) ^ hash(self.tableType)
    value = (value * 31) ^ hash(self.privileges)
    value = (value * 31) ^ hash(self.temporary)
    value = (value * 31) ^ hash(self.rewriteEnabled)
    value = (value * 31) ^ hash(self.creationMetadata)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Partition:
  """
  Attributes:
   - values
   - dbName
   - tableName
   - createTime
   - lastAccessTime
   - sd
   - parameters
   - privileges
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 6
    (7, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 7
    (8, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 8
    (9, TType.STRING, 'catName', None, None, ), # 9
  )

  def __init__(self, values=None, dbName=None, tableName=None, createTime=None, lastAccessTime=None, sd=None, parameters=None, privileges=None, catName=None,):
    self.values = values
    self.dbName = dbName
    self.tableName = tableName
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.sd = sd
    self.parameters = parameters
    self.privileges = privileges
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype194, _size191) = iprot.readListBegin()
          for _i195 in xrange(_size191):
            _elem196 = iprot.readString()
            self.values.append(_elem196)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype198, _vtype199, _size197 ) = iprot.readMapBegin()
          for _i201 in xrange(_size197):
            _key202 = iprot.readString()
            _val203 = iprot.readString()
            self.parameters[_key202] = _val203
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Partition')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter204 in self.values:
        oprot.writeString(iter204)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 6)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter205,viter206 in self.parameters.items():
        oprot.writeString(kiter205)
        oprot.writeString(viter206)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 8)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 9)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.sd)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.privileges)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionWithoutSD:
  """
  Attributes:
   - values
   - createTime
   - lastAccessTime
   - relativePath
   - parameters
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.I32, 'lastAccessTime', None, None, ), # 3
    (4, TType.STRING, 'relativePath', None, None, ), # 4
    (5, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 5
    (6, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 6
  )

  def __init__(self, values=None, createTime=None, lastAccessTime=None, relativePath=None, parameters=None, privileges=None,):
    self.values = values
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.relativePath = relativePath
    self.parameters = parameters
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype210, _size207) = iprot.readListBegin()
          for _i211 in xrange(_size207):
            _elem212 = iprot.readString()
            self.values.append(_elem212)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.relativePath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype214, _vtype215, _size213 ) = iprot.readMapBegin()
          for _i217 in xrange(_size213):
            _key218 = iprot.readString()
            _val219 = iprot.readString()
            self.parameters[_key218] = _val219
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionWithoutSD')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter220 in self.values:
        oprot.writeString(iter220)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 3)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.relativePath is not None:
      oprot.writeFieldBegin('relativePath', TType.STRING, 4)
      oprot.writeString(self.relativePath)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter221,viter222 in self.parameters.items():
        oprot.writeString(kiter221)
        oprot.writeString(viter222)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 6)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.relativePath)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionSpecWithSharedSD:
  """
  Attributes:
   - partitions
   - sd
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(PartitionWithoutSD, PartitionWithoutSD.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 2
  )

  def __init__(self, partitions=None, sd=None,):
    self.partitions = partitions
    self.sd = sd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype226, _size223) = iprot.readListBegin()
          for _i227 in xrange(_size223):
            _elem228 = PartitionWithoutSD()
            _elem228.read(iprot)
            self.partitions.append(_elem228)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionSpecWithSharedSD')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter229 in self.partitions:
        iter229.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 2)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    value = (value * 31) ^ hash(self.sd)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionListComposingSpec:
  """
  Attributes:
   - partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitions=None,):
    self.partitions = partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype233, _size230) = iprot.readListBegin()
          for _i234 in xrange(_size230):
            _elem235 = Partition()
            _elem235.read(iprot)
            self.partitions.append(_elem235)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionListComposingSpec')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter236 in self.partitions:
        iter236.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionSpec:
  """
  Attributes:
   - dbName
   - tableName
   - rootPath
   - sharedSDPartitionSpec
   - partitionList
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'rootPath', None, None, ), # 3
    (4, TType.STRUCT, 'sharedSDPartitionSpec', (PartitionSpecWithSharedSD, PartitionSpecWithSharedSD.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'partitionList', (PartitionListComposingSpec, PartitionListComposingSpec.thrift_spec), None, ), # 5
    (6, TType.STRING, 'catName', None, None, ), # 6
  )

  def __init__(self, dbName=None, tableName=None, rootPath=None, sharedSDPartitionSpec=None, partitionList=None, catName=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.rootPath = rootPath
    self.sharedSDPartitionSpec = sharedSDPartitionSpec
    self.partitionList = partitionList
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.rootPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.sharedSDPartitionSpec = PartitionSpecWithSharedSD()
          self.sharedSDPartitionSpec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.partitionList = PartitionListComposingSpec()
          self.partitionList.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionSpec')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.rootPath is not None:
      oprot.writeFieldBegin('rootPath', TType.STRING, 3)
      oprot.writeString(self.rootPath)
      oprot.writeFieldEnd()
    if self.sharedSDPartitionSpec is not None:
      oprot.writeFieldBegin('sharedSDPartitionSpec', TType.STRUCT, 4)
      self.sharedSDPartitionSpec.write(oprot)
      oprot.writeFieldEnd()
    if self.partitionList is not None:
      oprot.writeFieldBegin('partitionList', TType.STRUCT, 5)
      self.partitionList.write(oprot)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 6)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.rootPath)
    value = (value * 31) ^ hash(self.sharedSDPartitionSpec)
    value = (value * 31) ^ hash(self.partitionList)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BooleanColumnStatsData:
  """
  Attributes:
   - numTrues
   - numFalses
   - numNulls
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'numTrues', None, None, ), # 1
    (2, TType.I64, 'numFalses', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.STRING, 'bitVectors', None, None, ), # 4
  )

  def __init__(self, numTrues=None, numFalses=None, numNulls=None, bitVectors=None,):
    self.numTrues = numTrues
    self.numFalses = numFalses
    self.numNulls = numNulls
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.numTrues = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.numFalses = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BooleanColumnStatsData')
    if self.numTrues is not None:
      oprot.writeFieldBegin('numTrues', TType.I64, 1)
      oprot.writeI64(self.numTrues)
      oprot.writeFieldEnd()
    if self.numFalses is not None:
      oprot.writeFieldBegin('numFalses', TType.I64, 2)
      oprot.writeI64(self.numFalses)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 4)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numTrues is None:
      raise TProtocol.TProtocolException(message='Required field numTrues is unset!')
    if self.numFalses is None:
      raise TProtocol.TProtocolException(message='Required field numFalses is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.numTrues)
    value = (value * 31) ^ hash(self.numFalses)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DoubleColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'lowValue', None, None, ), # 1
    (2, TType.DOUBLE, 'highValue', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.lowValue = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.highValue = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DoubleColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.DOUBLE, 1)
      oprot.writeDouble(self.lowValue)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.DOUBLE, 2)
      oprot.writeDouble(self.highValue)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LongColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lowValue', None, None, ), # 1
    (2, TType.I64, 'highValue', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lowValue = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.highValue = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LongColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.I64, 1)
      oprot.writeI64(self.lowValue)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.I64, 2)
      oprot.writeI64(self.highValue)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StringColumnStatsData:
  """
  Attributes:
   - maxColLen
   - avgColLen
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxColLen', None, None, ), # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, maxColLen=None, avgColLen=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.maxColLen = maxColLen
    self.avgColLen = avgColLen
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxColLen = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.avgColLen = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StringColumnStatsData')
    if self.maxColLen is not None:
      oprot.writeFieldBegin('maxColLen', TType.I64, 1)
      oprot.writeI64(self.maxColLen)
      oprot.writeFieldEnd()
    if self.avgColLen is not None:
      oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
      oprot.writeDouble(self.avgColLen)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.maxColLen is None:
      raise TProtocol.TProtocolException(message='Required field maxColLen is unset!')
    if self.avgColLen is None:
      raise TProtocol.TProtocolException(message='Required field avgColLen is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.maxColLen)
    value = (value * 31) ^ hash(self.avgColLen)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BinaryColumnStatsData:
  """
  Attributes:
   - maxColLen
   - avgColLen
   - numNulls
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxColLen', None, None, ), # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.STRING, 'bitVectors', None, None, ), # 4
  )

  def __init__(self, maxColLen=None, avgColLen=None, numNulls=None, bitVectors=None,):
    self.maxColLen = maxColLen
    self.avgColLen = avgColLen
    self.numNulls = numNulls
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxColLen = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.avgColLen = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BinaryColumnStatsData')
    if self.maxColLen is not None:
      oprot.writeFieldBegin('maxColLen', TType.I64, 1)
      oprot.writeI64(self.maxColLen)
      oprot.writeFieldEnd()
    if self.avgColLen is not None:
      oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
      oprot.writeDouble(self.avgColLen)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 4)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.maxColLen is None:
      raise TProtocol.TProtocolException(message='Required field maxColLen is unset!')
    if self.avgColLen is None:
      raise TProtocol.TProtocolException(message='Required field avgColLen is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.maxColLen)
    value = (value * 31) ^ hash(self.avgColLen)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Decimal:
  """
  Attributes:
   - scale
   - unscaled
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'unscaled', None, None, ), # 1
    None, # 2
    (3, TType.I16, 'scale', None, None, ), # 3
  )

  def __init__(self, scale=None, unscaled=None,):
    self.scale = scale
    self.unscaled = unscaled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 3:
        if ftype == TType.I16:
          self.scale = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRING:
          self.unscaled = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Decimal')
    if self.unscaled is not None:
      oprot.writeFieldBegin('unscaled', TType.STRING, 1)
      oprot.writeString(self.unscaled)
      oprot.writeFieldEnd()
    if self.scale is not None:
      oprot.writeFieldBegin('scale', TType.I16, 3)
      oprot.writeI16(self.scale)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scale is None:
      raise TProtocol.TProtocolException(message='Required field scale is unset!')
    if self.unscaled is None:
      raise TProtocol.TProtocolException(message='Required field unscaled is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.scale)
    value = (value * 31) ^ hash(self.unscaled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DecimalColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'lowValue', (Decimal, Decimal.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'highValue', (Decimal, Decimal.thrift_spec), None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.lowValue = Decimal()
          self.lowValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.highValue = Decimal()
          self.highValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DecimalColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.STRUCT, 1)
      self.lowValue.write(oprot)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.STRUCT, 2)
      self.highValue.write(oprot)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Date:
  """
  Attributes:
   - daysSinceEpoch
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'daysSinceEpoch', None, None, ), # 1
  )

  def __init__(self, daysSinceEpoch=None,):
    self.daysSinceEpoch = daysSinceEpoch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.daysSinceEpoch = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Date')
    if self.daysSinceEpoch is not None:
      oprot.writeFieldBegin('daysSinceEpoch', TType.I64, 1)
      oprot.writeI64(self.daysSinceEpoch)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.daysSinceEpoch is None:
      raise TProtocol.TProtocolException(message='Required field daysSinceEpoch is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.daysSinceEpoch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DateColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'lowValue', (Date, Date.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'highValue', (Date, Date.thrift_spec), None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.lowValue = Date()
          self.lowValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.highValue = Date()
          self.highValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DateColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.STRUCT, 1)
      self.lowValue.write(oprot)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.STRUCT, 2)
      self.highValue.write(oprot)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsData:
  """
  Attributes:
   - booleanStats
   - longStats
   - doubleStats
   - stringStats
   - binaryStats
   - decimalStats
   - dateStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'booleanStats', (BooleanColumnStatsData, BooleanColumnStatsData.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'longStats', (LongColumnStatsData, LongColumnStatsData.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'doubleStats', (DoubleColumnStatsData, DoubleColumnStatsData.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'stringStats', (StringColumnStatsData, StringColumnStatsData.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'binaryStats', (BinaryColumnStatsData, BinaryColumnStatsData.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'decimalStats', (DecimalColumnStatsData, DecimalColumnStatsData.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'dateStats', (DateColumnStatsData, DateColumnStatsData.thrift_spec), None, ), # 7
  )

  def __init__(self, booleanStats=None, longStats=None, doubleStats=None, stringStats=None, binaryStats=None, decimalStats=None, dateStats=None,):
    self.booleanStats = booleanStats
    self.longStats = longStats
    self.doubleStats = doubleStats
    self.stringStats = stringStats
    self.binaryStats = binaryStats
    self.decimalStats = decimalStats
    self.dateStats = dateStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.booleanStats = BooleanColumnStatsData()
          self.booleanStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.longStats = LongColumnStatsData()
          self.longStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.doubleStats = DoubleColumnStatsData()
          self.doubleStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.stringStats = StringColumnStatsData()
          self.stringStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.binaryStats = BinaryColumnStatsData()
          self.binaryStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.decimalStats = DecimalColumnStatsData()
          self.decimalStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.dateStats = DateColumnStatsData()
          self.dateStats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsData')
    if self.booleanStats is not None:
      oprot.writeFieldBegin('booleanStats', TType.STRUCT, 1)
      self.booleanStats.write(oprot)
      oprot.writeFieldEnd()
    if self.longStats is not None:
      oprot.writeFieldBegin('longStats', TType.STRUCT, 2)
      self.longStats.write(oprot)
      oprot.writeFieldEnd()
    if self.doubleStats is not None:
      oprot.writeFieldBegin('doubleStats', TType.STRUCT, 3)
      self.doubleStats.write(oprot)
      oprot.writeFieldEnd()
    if self.stringStats is not None:
      oprot.writeFieldBegin('stringStats', TType.STRUCT, 4)
      self.stringStats.write(oprot)
      oprot.writeFieldEnd()
    if self.binaryStats is not None:
      oprot.writeFieldBegin('binaryStats', TType.STRUCT, 5)
      self.binaryStats.write(oprot)
      oprot.writeFieldEnd()
    if self.decimalStats is not None:
      oprot.writeFieldBegin('decimalStats', TType.STRUCT, 6)
      self.decimalStats.write(oprot)
      oprot.writeFieldEnd()
    if self.dateStats is not None:
      oprot.writeFieldBegin('dateStats', TType.STRUCT, 7)
      self.dateStats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.booleanStats)
    value = (value * 31) ^ hash(self.longStats)
    value = (value * 31) ^ hash(self.doubleStats)
    value = (value * 31) ^ hash(self.stringStats)
    value = (value * 31) ^ hash(self.binaryStats)
    value = (value * 31) ^ hash(self.decimalStats)
    value = (value * 31) ^ hash(self.dateStats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsObj:
  """
  Attributes:
   - colName
   - colType
   - statsData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'colName', None, None, ), # 1
    (2, TType.STRING, 'colType', None, None, ), # 2
    (3, TType.STRUCT, 'statsData', (ColumnStatisticsData, ColumnStatisticsData.thrift_spec), None, ), # 3
  )

  def __init__(self, colName=None, colType=None, statsData=None,):
    self.colName = colName
    self.colType = colType
    self.statsData = statsData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.colName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.statsData = ColumnStatisticsData()
          self.statsData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsObj')
    if self.colName is not None:
      oprot.writeFieldBegin('colName', TType.STRING, 1)
      oprot.writeString(self.colName)
      oprot.writeFieldEnd()
    if self.colType is not None:
      oprot.writeFieldBegin('colType', TType.STRING, 2)
      oprot.writeString(self.colType)
      oprot.writeFieldEnd()
    if self.statsData is not None:
      oprot.writeFieldBegin('statsData', TType.STRUCT, 3)
      self.statsData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colName is None:
      raise TProtocol.TProtocolException(message='Required field colName is unset!')
    if self.colType is None:
      raise TProtocol.TProtocolException(message='Required field colType is unset!')
    if self.statsData is None:
      raise TProtocol.TProtocolException(message='Required field statsData is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.colName)
    value = (value * 31) ^ hash(self.colType)
    value = (value * 31) ^ hash(self.statsData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsDesc:
  """
  Attributes:
   - isTblLevel
   - dbName
   - tableName
   - partName
   - lastAnalyzed
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isTblLevel', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.STRING, 'partName', None, None, ), # 4
    (5, TType.I64, 'lastAnalyzed', None, None, ), # 5
    (6, TType.STRING, 'catName', None, None, ), # 6
  )

  def __init__(self, isTblLevel=None, dbName=None, tableName=None, partName=None, lastAnalyzed=None, catName=None,):
    self.isTblLevel = isTblLevel
    self.dbName = dbName
    self.tableName = tableName
    self.partName = partName
    self.lastAnalyzed = lastAnalyzed
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isTblLevel = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.partName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.lastAnalyzed = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsDesc')
    if self.isTblLevel is not None:
      oprot.writeFieldBegin('isTblLevel', TType.BOOL, 1)
      oprot.writeBool(self.isTblLevel)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partName is not None:
      oprot.writeFieldBegin('partName', TType.STRING, 4)
      oprot.writeString(self.partName)
      oprot.writeFieldEnd()
    if self.lastAnalyzed is not None:
      oprot.writeFieldBegin('lastAnalyzed', TType.I64, 5)
      oprot.writeI64(self.lastAnalyzed)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 6)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isTblLevel is None:
      raise TProtocol.TProtocolException(message='Required field isTblLevel is unset!')
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isTblLevel)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partName)
    value = (value * 31) ^ hash(self.lastAnalyzed)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatistics:
  """
  Attributes:
   - statsDesc
   - statsObj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'statsDesc', (ColumnStatisticsDesc, ColumnStatisticsDesc.thrift_spec), None, ), # 1
    (2, TType.LIST, 'statsObj', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 2
  )

  def __init__(self, statsDesc=None, statsObj=None,):
    self.statsDesc = statsDesc
    self.statsObj = statsObj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.statsDesc = ColumnStatisticsDesc()
          self.statsDesc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.statsObj = []
          (_etype240, _size237) = iprot.readListBegin()
          for _i241 in xrange(_size237):
            _elem242 = ColumnStatisticsObj()
            _elem242.read(iprot)
            self.statsObj.append(_elem242)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatistics')
    if self.statsDesc is not None:
      oprot.writeFieldBegin('statsDesc', TType.STRUCT, 1)
      self.statsDesc.write(oprot)
      oprot.writeFieldEnd()
    if self.statsObj is not None:
      oprot.writeFieldBegin('statsObj', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.statsObj))
      for iter243 in self.statsObj:
        iter243.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.statsDesc is None:
      raise TProtocol.TProtocolException(message='Required field statsDesc is unset!')
    if self.statsObj is None:
      raise TProtocol.TProtocolException(message='Required field statsObj is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.statsDesc)
    value = (value * 31) ^ hash(self.statsObj)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AggrStats:
  """
  Attributes:
   - colStats
   - partsFound
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'colStats', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 1
    (2, TType.I64, 'partsFound', None, None, ), # 2
  )

  def __init__(self, colStats=None, partsFound=None,):
    self.colStats = colStats
    self.partsFound = partsFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.colStats = []
          (_etype247, _size244) = iprot.readListBegin()
          for _i248 in xrange(_size244):
            _elem249 = ColumnStatisticsObj()
            _elem249.read(iprot)
            self.colStats.append(_elem249)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.partsFound = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AggrStats')
    if self.colStats is not None:
      oprot.writeFieldBegin('colStats', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.colStats))
      for iter250 in self.colStats:
        iter250.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partsFound is not None:
      oprot.writeFieldBegin('partsFound', TType.I64, 2)
      oprot.writeI64(self.partsFound)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colStats is None:
      raise TProtocol.TProtocolException(message='Required field colStats is unset!')
    if self.partsFound is None:
      raise TProtocol.TProtocolException(message='Required field partsFound is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.colStats)
    value = (value * 31) ^ hash(self.partsFound)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPartitionsStatsRequest:
  """
  Attributes:
   - colStats
   - needMerge
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'colStats', (TType.STRUCT,(ColumnStatistics, ColumnStatistics.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'needMerge', None, None, ), # 2
  )

  def __init__(self, colStats=None, needMerge=None,):
    self.colStats = colStats
    self.needMerge = needMerge

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.colStats = []
          (_etype254, _size251) = iprot.readListBegin()
          for _i255 in xrange(_size251):
            _elem256 = ColumnStatistics()
            _elem256.read(iprot)
            self.colStats.append(_elem256)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.needMerge = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPartitionsStatsRequest')
    if self.colStats is not None:
      oprot.writeFieldBegin('colStats', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.colStats))
      for iter257 in self.colStats:
        iter257.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.needMerge is not None:
      oprot.writeFieldBegin('needMerge', TType.BOOL, 2)
      oprot.writeBool(self.needMerge)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colStats is None:
      raise TProtocol.TProtocolException(message='Required field colStats is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.colStats)
    value = (value * 31) ^ hash(self.needMerge)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Schema:
  """
  Attributes:
   - fieldSchemas
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fieldSchemas', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, fieldSchemas=None, properties=None,):
    self.fieldSchemas = fieldSchemas
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fieldSchemas = []
          (_etype261, _size258) = iprot.readListBegin()
          for _i262 in xrange(_size258):
            _elem263 = FieldSchema()
            _elem263.read(iprot)
            self.fieldSchemas.append(_elem263)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype265, _vtype266, _size264 ) = iprot.readMapBegin()
          for _i268 in xrange(_size264):
            _key269 = iprot.readString()
            _val270 = iprot.readString()
            self.properties[_key269] = _val270
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Schema')
    if self.fieldSchemas is not None:
      oprot.writeFieldBegin('fieldSchemas', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.fieldSchemas))
      for iter271 in self.fieldSchemas:
        iter271.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter272,viter273 in self.properties.items():
        oprot.writeString(kiter272)
        oprot.writeString(viter273)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fieldSchemas)
    value = (value * 31) ^ hash(self.properties)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EnvironmentContext:
  """
  Attributes:
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, properties=None,):
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype275, _vtype276, _size274 ) = iprot.readMapBegin()
          for _i278 in xrange(_size274):
            _key279 = iprot.readString()
            _val280 = iprot.readString()
            self.properties[_key279] = _val280
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EnvironmentContext')
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter281,viter282 in self.properties.items():
        oprot.writeString(kiter281)
        oprot.writeString(viter282)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.properties)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrimaryKeysRequest:
  """
  Attributes:
   - db_name
   - tbl_name
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'catName', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, catName=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrimaryKeysRequest')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 3)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrimaryKeysResponse:
  """
  Attributes:
   - primaryKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'primaryKeys', (TType.STRUCT,(SQLPrimaryKey, SQLPrimaryKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, primaryKeys=None,):
    self.primaryKeys = primaryKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.primaryKeys = []
          (_etype286, _size283) = iprot.readListBegin()
          for _i287 in xrange(_size283):
            _elem288 = SQLPrimaryKey()
            _elem288.read(iprot)
            self.primaryKeys.append(_elem288)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrimaryKeysResponse')
    if self.primaryKeys is not None:
      oprot.writeFieldBegin('primaryKeys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryKeys))
      for iter289 in self.primaryKeys:
        iter289.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.primaryKeys is None:
      raise TProtocol.TProtocolException(message='Required field primaryKeys is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.primaryKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ForeignKeysRequest:
  """
  Attributes:
   - parent_db_name
   - parent_tbl_name
   - foreign_db_name
   - foreign_tbl_name
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'parent_db_name', None, None, ), # 1
    (2, TType.STRING, 'parent_tbl_name', None, None, ), # 2
    (3, TType.STRING, 'foreign_db_name', None, None, ), # 3
    (4, TType.STRING, 'foreign_tbl_name', None, None, ), # 4
    (5, TType.STRING, 'catName', None, None, ), # 5
  )

  def __init__(self, parent_db_name=None, parent_tbl_name=None, foreign_db_name=None, foreign_tbl_name=None, catName=None,):
    self.parent_db_name = parent_db_name
    self.parent_tbl_name = parent_tbl_name
    self.foreign_db_name = foreign_db_name
    self.foreign_tbl_name = foreign_tbl_name
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.parent_db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.parent_tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.foreign_db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.foreign_tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ForeignKeysRequest')
    if self.parent_db_name is not None:
      oprot.writeFieldBegin('parent_db_name', TType.STRING, 1)
      oprot.writeString(self.parent_db_name)
      oprot.writeFieldEnd()
    if self.parent_tbl_name is not None:
      oprot.writeFieldBegin('parent_tbl_name', TType.STRING, 2)
      oprot.writeString(self.parent_tbl_name)
      oprot.writeFieldEnd()
    if self.foreign_db_name is not None:
      oprot.writeFieldBegin('foreign_db_name', TType.STRING, 3)
      oprot.writeString(self.foreign_db_name)
      oprot.writeFieldEnd()
    if self.foreign_tbl_name is not None:
      oprot.writeFieldBegin('foreign_tbl_name', TType.STRING, 4)
      oprot.writeString(self.foreign_tbl_name)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 5)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.parent_db_name)
    value = (value * 31) ^ hash(self.parent_tbl_name)
    value = (value * 31) ^ hash(self.foreign_db_name)
    value = (value * 31) ^ hash(self.foreign_tbl_name)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ForeignKeysResponse:
  """
  Attributes:
   - foreignKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'foreignKeys', (TType.STRUCT,(SQLForeignKey, SQLForeignKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, foreignKeys=None,):
    self.foreignKeys = foreignKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.foreignKeys = []
          (_etype293, _size290) = iprot.readListBegin()
          for _i294 in xrange(_size290):
            _elem295 = SQLForeignKey()
            _elem295.read(iprot)
            self.foreignKeys.append(_elem295)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ForeignKeysResponse')
    if self.foreignKeys is not None:
      oprot.writeFieldBegin('foreignKeys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.foreignKeys))
      for iter296 in self.foreignKeys:
        iter296.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.foreignKeys is None:
      raise TProtocol.TProtocolException(message='Required field foreignKeys is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.foreignKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UniqueConstraintsRequest:
  """
  Attributes:
   - catName
   - db_name
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'catName', None, None, ), # 1
    (2, TType.STRING, 'db_name', None, None, ), # 2
    (3, TType.STRING, 'tbl_name', None, None, ), # 3
  )

  def __init__(self, catName=None, db_name=None, tbl_name=None,):
    self.catName = catName
    self.db_name = db_name
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UniqueConstraintsRequest')
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 1)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 2)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 3)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catName is None:
      raise TProtocol.TProtocolException(message='Required field catName is unset!')
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UniqueConstraintsResponse:
  """
  Attributes:
   - uniqueConstraints
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'uniqueConstraints', (TType.STRUCT,(SQLUniqueConstraint, SQLUniqueConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, uniqueConstraints=None,):
    self.uniqueConstraints = uniqueConstraints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.uniqueConstraints = []
          (_etype300, _size297) = iprot.readListBegin()
          for _i301 in xrange(_size297):
            _elem302 = SQLUniqueConstraint()
            _elem302.read(iprot)
            self.uniqueConstraints.append(_elem302)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UniqueConstraintsResponse')
    if self.uniqueConstraints is not None:
      oprot.writeFieldBegin('uniqueConstraints', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.uniqueConstraints))
      for iter303 in self.uniqueConstraints:
        iter303.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uniqueConstraints is None:
      raise TProtocol.TProtocolException(message='Required field uniqueConstraints is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uniqueConstraints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotNullConstraintsRequest:
  """
  Attributes:
   - catName
   - db_name
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'catName', None, None, ), # 1
    (2, TType.STRING, 'db_name', None, None, ), # 2
    (3, TType.STRING, 'tbl_name', None, None, ), # 3
  )

  def __init__(self, catName=None, db_name=None, tbl_name=None,):
    self.catName = catName
    self.db_name = db_name
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotNullConstraintsRequest')
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 1)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 2)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 3)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catName is None:
      raise TProtocol.TProtocolException(message='Required field catName is unset!')
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotNullConstraintsResponse:
  """
  Attributes:
   - notNullConstraints
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'notNullConstraints', (TType.STRUCT,(SQLNotNullConstraint, SQLNotNullConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, notNullConstraints=None,):
    self.notNullConstraints = notNullConstraints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.notNullConstraints = []
          (_etype307, _size304) = iprot.readListBegin()
          for _i308 in xrange(_size304):
            _elem309 = SQLNotNullConstraint()
            _elem309.read(iprot)
            self.notNullConstraints.append(_elem309)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotNullConstraintsResponse')
    if self.notNullConstraints is not None:
      oprot.writeFieldBegin('notNullConstraints', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.notNullConstraints))
      for iter310 in self.notNullConstraints:
        iter310.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.notNullConstraints is None:
      raise TProtocol.TProtocolException(message='Required field notNullConstraints is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.notNullConstraints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DefaultConstraintsRequest:
  """
  Attributes:
   - catName
   - db_name
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'catName', None, None, ), # 1
    (2, TType.STRING, 'db_name', None, None, ), # 2
    (3, TType.STRING, 'tbl_name', None, None, ), # 3
  )

  def __init__(self, catName=None, db_name=None, tbl_name=None,):
    self.catName = catName
    self.db_name = db_name
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DefaultConstraintsRequest')
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 1)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 2)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 3)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catName is None:
      raise TProtocol.TProtocolException(message='Required field catName is unset!')
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DefaultConstraintsResponse:
  """
  Attributes:
   - defaultConstraints
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'defaultConstraints', (TType.STRUCT,(SQLDefaultConstraint, SQLDefaultConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, defaultConstraints=None,):
    self.defaultConstraints = defaultConstraints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.defaultConstraints = []
          (_etype314, _size311) = iprot.readListBegin()
          for _i315 in xrange(_size311):
            _elem316 = SQLDefaultConstraint()
            _elem316.read(iprot)
            self.defaultConstraints.append(_elem316)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DefaultConstraintsResponse')
    if self.defaultConstraints is not None:
      oprot.writeFieldBegin('defaultConstraints', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.defaultConstraints))
      for iter317 in self.defaultConstraints:
        iter317.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.defaultConstraints is None:
      raise TProtocol.TProtocolException(message='Required field defaultConstraints is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.defaultConstraints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckConstraintsRequest:
  """
  Attributes:
   - catName
   - db_name
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'catName', None, None, ), # 1
    (2, TType.STRING, 'db_name', None, None, ), # 2
    (3, TType.STRING, 'tbl_name', None, None, ), # 3
  )

  def __init__(self, catName=None, db_name=None, tbl_name=None,):
    self.catName = catName
    self.db_name = db_name
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckConstraintsRequest')
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 1)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 2)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 3)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catName is None:
      raise TProtocol.TProtocolException(message='Required field catName is unset!')
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckConstraintsResponse:
  """
  Attributes:
   - checkConstraints
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'checkConstraints', (TType.STRUCT,(SQLCheckConstraint, SQLCheckConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, checkConstraints=None,):
    self.checkConstraints = checkConstraints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.checkConstraints = []
          (_etype321, _size318) = iprot.readListBegin()
          for _i322 in xrange(_size318):
            _elem323 = SQLCheckConstraint()
            _elem323.read(iprot)
            self.checkConstraints.append(_elem323)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckConstraintsResponse')
    if self.checkConstraints is not None:
      oprot.writeFieldBegin('checkConstraints', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.checkConstraints))
      for iter324 in self.checkConstraints:
        iter324.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.checkConstraints is None:
      raise TProtocol.TProtocolException(message='Required field checkConstraints is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.checkConstraints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropConstraintRequest:
  """
  Attributes:
   - dbname
   - tablename
   - constraintname
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'constraintname', None, None, ), # 3
    (4, TType.STRING, 'catName', None, None, ), # 4
  )

  def __init__(self, dbname=None, tablename=None, constraintname=None, catName=None,):
    self.dbname = dbname
    self.tablename = tablename
    self.constraintname = constraintname
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.constraintname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropConstraintRequest')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.constraintname is not None:
      oprot.writeFieldBegin('constraintname', TType.STRING, 3)
      oprot.writeString(self.constraintname)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 4)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.constraintname is None:
      raise TProtocol.TProtocolException(message='Required field constraintname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.constraintname)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddPrimaryKeyRequest:
  """
  Attributes:
   - primaryKeyCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'primaryKeyCols', (TType.STRUCT,(SQLPrimaryKey, SQLPrimaryKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, primaryKeyCols=None,):
    self.primaryKeyCols = primaryKeyCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.primaryKeyCols = []
          (_etype328, _size325) = iprot.readListBegin()
          for _i329 in xrange(_size325):
            _elem330 = SQLPrimaryKey()
            _elem330.read(iprot)
            self.primaryKeyCols.append(_elem330)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddPrimaryKeyRequest')
    if self.primaryKeyCols is not None:
      oprot.writeFieldBegin('primaryKeyCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryKeyCols))
      for iter331 in self.primaryKeyCols:
        iter331.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.primaryKeyCols is None:
      raise TProtocol.TProtocolException(message='Required field primaryKeyCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.primaryKeyCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddForeignKeyRequest:
  """
  Attributes:
   - foreignKeyCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'foreignKeyCols', (TType.STRUCT,(SQLForeignKey, SQLForeignKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, foreignKeyCols=None,):
    self.foreignKeyCols = foreignKeyCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.foreignKeyCols = []
          (_etype335, _size332) = iprot.readListBegin()
          for _i336 in xrange(_size332):
            _elem337 = SQLForeignKey()
            _elem337.read(iprot)
            self.foreignKeyCols.append(_elem337)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddForeignKeyRequest')
    if self.foreignKeyCols is not None:
      oprot.writeFieldBegin('foreignKeyCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.foreignKeyCols))
      for iter338 in self.foreignKeyCols:
        iter338.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.foreignKeyCols is None:
      raise TProtocol.TProtocolException(message='Required field foreignKeyCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.foreignKeyCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddUniqueConstraintRequest:
  """
  Attributes:
   - uniqueConstraintCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'uniqueConstraintCols', (TType.STRUCT,(SQLUniqueConstraint, SQLUniqueConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, uniqueConstraintCols=None,):
    self.uniqueConstraintCols = uniqueConstraintCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.uniqueConstraintCols = []
          (_etype342, _size339) = iprot.readListBegin()
          for _i343 in xrange(_size339):
            _elem344 = SQLUniqueConstraint()
            _elem344.read(iprot)
            self.uniqueConstraintCols.append(_elem344)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddUniqueConstraintRequest')
    if self.uniqueConstraintCols is not None:
      oprot.writeFieldBegin('uniqueConstraintCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.uniqueConstraintCols))
      for iter345 in self.uniqueConstraintCols:
        iter345.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uniqueConstraintCols is None:
      raise TProtocol.TProtocolException(message='Required field uniqueConstraintCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uniqueConstraintCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddNotNullConstraintRequest:
  """
  Attributes:
   - notNullConstraintCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'notNullConstraintCols', (TType.STRUCT,(SQLNotNullConstraint, SQLNotNullConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, notNullConstraintCols=None,):
    self.notNullConstraintCols = notNullConstraintCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.notNullConstraintCols = []
          (_etype349, _size346) = iprot.readListBegin()
          for _i350 in xrange(_size346):
            _elem351 = SQLNotNullConstraint()
            _elem351.read(iprot)
            self.notNullConstraintCols.append(_elem351)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddNotNullConstraintRequest')
    if self.notNullConstraintCols is not None:
      oprot.writeFieldBegin('notNullConstraintCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.notNullConstraintCols))
      for iter352 in self.notNullConstraintCols:
        iter352.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.notNullConstraintCols is None:
      raise TProtocol.TProtocolException(message='Required field notNullConstraintCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.notNullConstraintCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddDefaultConstraintRequest:
  """
  Attributes:
   - defaultConstraintCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'defaultConstraintCols', (TType.STRUCT,(SQLDefaultConstraint, SQLDefaultConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, defaultConstraintCols=None,):
    self.defaultConstraintCols = defaultConstraintCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.defaultConstraintCols = []
          (_etype356, _size353) = iprot.readListBegin()
          for _i357 in xrange(_size353):
            _elem358 = SQLDefaultConstraint()
            _elem358.read(iprot)
            self.defaultConstraintCols.append(_elem358)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddDefaultConstraintRequest')
    if self.defaultConstraintCols is not None:
      oprot.writeFieldBegin('defaultConstraintCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.defaultConstraintCols))
      for iter359 in self.defaultConstraintCols:
        iter359.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.defaultConstraintCols is None:
      raise TProtocol.TProtocolException(message='Required field defaultConstraintCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.defaultConstraintCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddCheckConstraintRequest:
  """
  Attributes:
   - checkConstraintCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'checkConstraintCols', (TType.STRUCT,(SQLCheckConstraint, SQLCheckConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, checkConstraintCols=None,):
    self.checkConstraintCols = checkConstraintCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.checkConstraintCols = []
          (_etype363, _size360) = iprot.readListBegin()
          for _i364 in xrange(_size360):
            _elem365 = SQLCheckConstraint()
            _elem365.read(iprot)
            self.checkConstraintCols.append(_elem365)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddCheckConstraintRequest')
    if self.checkConstraintCols is not None:
      oprot.writeFieldBegin('checkConstraintCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.checkConstraintCols))
      for iter366 in self.checkConstraintCols:
        iter366.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.checkConstraintCols is None:
      raise TProtocol.TProtocolException(message='Required field checkConstraintCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.checkConstraintCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsByExprResult:
  """
  Attributes:
   - partitions
   - hasUnknownPartitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'hasUnknownPartitions', None, None, ), # 2
  )

  def __init__(self, partitions=None, hasUnknownPartitions=None,):
    self.partitions = partitions
    self.hasUnknownPartitions = hasUnknownPartitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype370, _size367) = iprot.readListBegin()
          for _i371 in xrange(_size367):
            _elem372 = Partition()
            _elem372.read(iprot)
            self.partitions.append(_elem372)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.hasUnknownPartitions = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsByExprResult')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter373 in self.partitions:
        iter373.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.hasUnknownPartitions is not None:
      oprot.writeFieldBegin('hasUnknownPartitions', TType.BOOL, 2)
      oprot.writeBool(self.hasUnknownPartitions)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partitions is None:
      raise TProtocol.TProtocolException(message='Required field partitions is unset!')
    if self.hasUnknownPartitions is None:
      raise TProtocol.TProtocolException(message='Required field hasUnknownPartitions is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    value = (value * 31) ^ hash(self.hasUnknownPartitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsByExprRequest:
  """
  Attributes:
   - dbName
   - tblName
   - expr
   - defaultPartitionName
   - maxParts
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRING, 'expr', None, None, ), # 3
    (4, TType.STRING, 'defaultPartitionName', None, None, ), # 4
    (5, TType.I16, 'maxParts', None, -1, ), # 5
    (6, TType.STRING, 'catName', None, None, ), # 6
  )

  def __init__(self, dbName=None, tblName=None, expr=None, defaultPartitionName=None, maxParts=thrift_spec[5][4], catName=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.expr = expr
    self.defaultPartitionName = defaultPartitionName
    self.maxParts = maxParts
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.defaultPartitionName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.maxParts = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsByExprRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.expr is not None:
      oprot.writeFieldBegin('expr', TType.STRING, 3)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    if self.defaultPartitionName is not None:
      oprot.writeFieldBegin('defaultPartitionName', TType.STRING, 4)
      oprot.writeString(self.defaultPartitionName)
      oprot.writeFieldEnd()
    if self.maxParts is not None:
      oprot.writeFieldBegin('maxParts', TType.I16, 5)
      oprot.writeI16(self.maxParts)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 6)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.expr is None:
      raise TProtocol.TProtocolException(message='Required field expr is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.expr)
    value = (value * 31) ^ hash(self.defaultPartitionName)
    value = (value * 31) ^ hash(self.maxParts)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableStatsResult:
  """
  Attributes:
   - tableStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tableStats', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 1
  )

  def __init__(self, tableStats=None,):
    self.tableStats = tableStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tableStats = []
          (_etype377, _size374) = iprot.readListBegin()
          for _i378 in xrange(_size374):
            _elem379 = ColumnStatisticsObj()
            _elem379.read(iprot)
            self.tableStats.append(_elem379)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableStatsResult')
    if self.tableStats is not None:
      oprot.writeFieldBegin('tableStats', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tableStats))
      for iter380 in self.tableStats:
        iter380.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tableStats is None:
      raise TProtocol.TProtocolException(message='Required field tableStats is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableStats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsStatsResult:
  """
  Attributes:
   - partStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'partStats', (TType.STRING,None,TType.LIST,(TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec))), None, ), # 1
  )

  def __init__(self, partStats=None,):
    self.partStats = partStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.partStats = {}
          (_ktype382, _vtype383, _size381 ) = iprot.readMapBegin()
          for _i385 in xrange(_size381):
            _key386 = iprot.readString()
            _val387 = []
            (_etype391, _size388) = iprot.readListBegin()
            for _i392 in xrange(_size388):
              _elem393 = ColumnStatisticsObj()
              _elem393.read(iprot)
              _val387.append(_elem393)
            iprot.readListEnd()
            self.partStats[_key386] = _val387
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsStatsResult')
    if self.partStats is not None:
      oprot.writeFieldBegin('partStats', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.partStats))
      for kiter394,viter395 in self.partStats.items():
        oprot.writeString(kiter394)
        oprot.writeListBegin(TType.STRUCT, len(viter395))
        for iter396 in viter395:
          iter396.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partStats is None:
      raise TProtocol.TProtocolException(message='Required field partStats is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partStats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableStatsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - colNames
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'colNames', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'catName', None, None, ), # 4
  )

  def __init__(self, dbName=None, tblName=None, colNames=None, catName=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.colNames = colNames
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.colNames = []
          (_etype400, _size397) = iprot.readListBegin()
          for _i401 in xrange(_size397):
            _elem402 = iprot.readString()
            self.colNames.append(_elem402)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableStatsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.colNames is not None:
      oprot.writeFieldBegin('colNames', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.colNames))
      for iter403 in self.colNames:
        oprot.writeString(iter403)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 4)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.colNames is None:
      raise TProtocol.TProtocolException(message='Required field colNames is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.colNames)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsStatsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - colNames
   - partNames
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'colNames', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'partNames', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'catName', None, None, ), # 5
  )

  def __init__(self, dbName=None, tblName=None, colNames=None, partNames=None, catName=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.colNames = colNames
    self.partNames = partNames
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.colNames = []
          (_etype407, _size404) = iprot.readListBegin()
          for _i408 in xrange(_size404):
            _elem409 = iprot.readString()
            self.colNames.append(_elem409)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partNames = []
          (_etype413, _size410) = iprot.readListBegin()
          for _i414 in xrange(_size410):
            _elem415 = iprot.readString()
            self.partNames.append(_elem415)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsStatsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.colNames is not None:
      oprot.writeFieldBegin('colNames', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.colNames))
      for iter416 in self.colNames:
        oprot.writeString(iter416)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partNames is not None:
      oprot.writeFieldBegin('partNames', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.partNames))
      for iter417 in self.partNames:
        oprot.writeString(iter417)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 5)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.colNames is None:
      raise TProtocol.TProtocolException(message='Required field colNames is unset!')
    if self.partNames is None:
      raise TProtocol.TProtocolException(message='Required field partNames is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.colNames)
    value = (value * 31) ^ hash(self.partNames)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddPartitionsResult:
  """
  Attributes:
   - partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitions=None,):
    self.partitions = partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype421, _size418) = iprot.readListBegin()
          for _i422 in xrange(_size418):
            _elem423 = Partition()
            _elem423.read(iprot)
            self.partitions.append(_elem423)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddPartitionsResult')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter424 in self.partitions:
        iter424.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddPartitionsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - parts
   - ifNotExists
   - needResult
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 3
    (4, TType.BOOL, 'ifNotExists', None, None, ), # 4
    (5, TType.BOOL, 'needResult', None, True, ), # 5
    (6, TType.STRING, 'catName', None, None, ), # 6
  )

  def __init__(self, dbName=None, tblName=None, parts=None, ifNotExists=None, needResult=thrift_spec[5][4], catName=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.parts = parts
    self.ifNotExists = ifNotExists
    self.needResult = needResult
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.parts = []
          (_etype428, _size425) = iprot.readListBegin()
          for _i429 in xrange(_size425):
            _elem430 = Partition()
            _elem430.read(iprot)
            self.parts.append(_elem430)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.ifNotExists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.needResult = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddPartitionsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.parts is not None:
      oprot.writeFieldBegin('parts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.parts))
      for iter431 in self.parts:
        iter431.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ifNotExists is not None:
      oprot.writeFieldBegin('ifNotExists', TType.BOOL, 4)
      oprot.writeBool(self.ifNotExists)
      oprot.writeFieldEnd()
    if self.needResult is not None:
      oprot.writeFieldBegin('needResult', TType.BOOL, 5)
      oprot.writeBool(self.needResult)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 6)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.parts is None:
      raise TProtocol.TProtocolException(message='Required field parts is unset!')
    if self.ifNotExists is None:
      raise TProtocol.TProtocolException(message='Required field ifNotExists is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.parts)
    value = (value * 31) ^ hash(self.ifNotExists)
    value = (value * 31) ^ hash(self.needResult)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropPartitionsResult:
  """
  Attributes:
   - partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitions=None,):
    self.partitions = partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype435, _size432) = iprot.readListBegin()
          for _i436 in xrange(_size432):
            _elem437 = Partition()
            _elem437.read(iprot)
            self.partitions.append(_elem437)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropPartitionsResult')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter438 in self.partitions:
        iter438.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropPartitionsExpr:
  """
  Attributes:
   - expr
   - partArchiveLevel
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'expr', None, None, ), # 1
    (2, TType.I32, 'partArchiveLevel', None, None, ), # 2
  )

  def __init__(self, expr=None, partArchiveLevel=None,):
    self.expr = expr
    self.partArchiveLevel = partArchiveLevel

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.partArchiveLevel = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropPartitionsExpr')
    if self.expr is not None:
      oprot.writeFieldBegin('expr', TType.STRING, 1)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    if self.partArchiveLevel is not None:
      oprot.writeFieldBegin('partArchiveLevel', TType.I32, 2)
      oprot.writeI32(self.partArchiveLevel)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.expr is None:
      raise TProtocol.TProtocolException(message='Required field expr is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.expr)
    value = (value * 31) ^ hash(self.partArchiveLevel)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestPartsSpec:
  """
  Attributes:
   - names
   - exprs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'names', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'exprs', (TType.STRUCT,(DropPartitionsExpr, DropPartitionsExpr.thrift_spec)), None, ), # 2
  )

  def __init__(self, names=None, exprs=None,):
    self.names = names
    self.exprs = exprs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.names = []
          (_etype442, _size439) = iprot.readListBegin()
          for _i443 in xrange(_size439):
            _elem444 = iprot.readString()
            self.names.append(_elem444)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.exprs = []
          (_etype448, _size445) = iprot.readListBegin()
          for _i449 in xrange(_size445):
            _elem450 = DropPartitionsExpr()
            _elem450.read(iprot)
            self.exprs.append(_elem450)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestPartsSpec')
    if self.names is not None:
      oprot.writeFieldBegin('names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.names))
      for iter451 in self.names:
        oprot.writeString(iter451)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exprs is not None:
      oprot.writeFieldBegin('exprs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.exprs))
      for iter452 in self.exprs:
        iter452.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.names)
    value = (value * 31) ^ hash(self.exprs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropPartitionsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - parts
   - deleteData
   - ifExists
   - ignoreProtection
   - environmentContext
   - needResult
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRUCT, 'parts', (RequestPartsSpec, RequestPartsSpec.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
    (5, TType.BOOL, 'ifExists', None, True, ), # 5
    (6, TType.BOOL, 'ignoreProtection', None, None, ), # 6
    (7, TType.STRUCT, 'environmentContext', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 7
    (8, TType.BOOL, 'needResult', None, True, ), # 8
    (9, TType.STRING, 'catName', None, None, ), # 9
  )

  def __init__(self, dbName=None, tblName=None, parts=None, deleteData=None, ifExists=thrift_spec[5][4], ignoreProtection=None, environmentContext=None, needResult=thrift_spec[8][4], catName=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.parts = parts
    self.deleteData = deleteData
    self.ifExists = ifExists
    self.ignoreProtection = ignoreProtection
    self.environmentContext = environmentContext
    self.needResult = needResult
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.parts = RequestPartsSpec()
          self.parts.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.ifExists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.ignoreProtection = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.environmentContext = EnvironmentContext()
          self.environmentContext.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.needResult = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropPartitionsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.parts is not None:
      oprot.writeFieldBegin('parts', TType.STRUCT, 3)
      self.parts.write(oprot)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.ifExists is not None:
      oprot.writeFieldBegin('ifExists', TType.BOOL, 5)
      oprot.writeBool(self.ifExists)
      oprot.writeFieldEnd()
    if self.ignoreProtection is not None:
      oprot.writeFieldBegin('ignoreProtection', TType.BOOL, 6)
      oprot.writeBool(self.ignoreProtection)
      oprot.writeFieldEnd()
    if self.environmentContext is not None:
      oprot.writeFieldBegin('environmentContext', TType.STRUCT, 7)
      self.environmentContext.write(oprot)
      oprot.writeFieldEnd()
    if self.needResult is not None:
      oprot.writeFieldBegin('needResult', TType.BOOL, 8)
      oprot.writeBool(self.needResult)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 9)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.parts is None:
      raise TProtocol.TProtocolException(message='Required field parts is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.parts)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.ifExists)
    value = (value * 31) ^ hash(self.ignoreProtection)
    value = (value * 31) ^ hash(self.environmentContext)
    value = (value * 31) ^ hash(self.needResult)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionValuesRequest:
  """
  Attributes:
   - dbName
   - tblName
   - partitionKeys
   - applyDistinct
   - filter
   - partitionOrder
   - ascending
   - maxParts
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'partitionKeys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 3
    (4, TType.BOOL, 'applyDistinct', None, True, ), # 4
    (5, TType.STRING, 'filter', None, None, ), # 5
    (6, TType.LIST, 'partitionOrder', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 6
    (7, TType.BOOL, 'ascending', None, True, ), # 7
    (8, TType.I64, 'maxParts', None, -1, ), # 8
    (9, TType.STRING, 'catName', None, None, ), # 9
  )

  def __init__(self, dbName=None, tblName=None, partitionKeys=None, applyDistinct=thrift_spec[4][4], filter=None, partitionOrder=None, ascending=thrift_spec[7][4], maxParts=thrift_spec[8][4], catName=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.partitionKeys = partitionKeys
    self.applyDistinct = applyDistinct
    self.filter = filter
    self.partitionOrder = partitionOrder
    self.ascending = ascending
    self.maxParts = maxParts
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.partitionKeys = []
          (_etype456, _size453) = iprot.readListBegin()
          for _i457 in xrange(_size453):
            _elem458 = FieldSchema()
            _elem458.read(iprot)
            self.partitionKeys.append(_elem458)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.applyDistinct = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.partitionOrder = []
          (_etype462, _size459) = iprot.readListBegin()
          for _i463 in xrange(_size459):
            _elem464 = FieldSchema()
            _elem464.read(iprot)
            self.partitionOrder.append(_elem464)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.ascending = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.maxParts = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionValuesRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.partitionKeys is not None:
      oprot.writeFieldBegin('partitionKeys', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionKeys))
      for iter465 in self.partitionKeys:
        iter465.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.applyDistinct is not None:
      oprot.writeFieldBegin('applyDistinct', TType.BOOL, 4)
      oprot.writeBool(self.applyDistinct)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 5)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.partitionOrder is not None:
      oprot.writeFieldBegin('partitionOrder', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionOrder))
      for iter466 in self.partitionOrder:
        iter466.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ascending is not None:
      oprot.writeFieldBegin('ascending', TType.BOOL, 7)
      oprot.writeBool(self.ascending)
      oprot.writeFieldEnd()
    if self.maxParts is not None:
      oprot.writeFieldBegin('maxParts', TType.I64, 8)
      oprot.writeI64(self.maxParts)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 9)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.partitionKeys is None:
      raise TProtocol.TProtocolException(message='Required field partitionKeys is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.partitionKeys)
    value = (value * 31) ^ hash(self.applyDistinct)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.partitionOrder)
    value = (value * 31) ^ hash(self.ascending)
    value = (value * 31) ^ hash(self.maxParts)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionValuesRow:
  """
  Attributes:
   - row
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'row', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, row=None,):
    self.row = row

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.row = []
          (_etype470, _size467) = iprot.readListBegin()
          for _i471 in xrange(_size467):
            _elem472 = iprot.readString()
            self.row.append(_elem472)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionValuesRow')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.row))
      for iter473 in self.row:
        oprot.writeString(iter473)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.row is None:
      raise TProtocol.TProtocolException(message='Required field row is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.row)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionValuesResponse:
  """
  Attributes:
   - partitionValues
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitionValues', (TType.STRUCT,(PartitionValuesRow, PartitionValuesRow.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitionValues=None,):
    self.partitionValues = partitionValues

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitionValues = []
          (_etype477, _size474) = iprot.readListBegin()
          for _i478 in xrange(_size474):
            _elem479 = PartitionValuesRow()
            _elem479.read(iprot)
            self.partitionValues.append(_elem479)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionValuesResponse')
    if self.partitionValues is not None:
      oprot.writeFieldBegin('partitionValues', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionValues))
      for iter480 in self.partitionValues:
        iter480.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partitionValues is None:
      raise TProtocol.TProtocolException(message='Required field partitionValues is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitionValues)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResourceUri:
  """
  Attributes:
   - resourceType
   - uri
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'resourceType', None, None, ), # 1
    (2, TType.STRING, 'uri', None, None, ), # 2
  )

  def __init__(self, resourceType=None, uri=None,):
    self.resourceType = resourceType
    self.uri = uri

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.resourceType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.uri = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResourceUri')
    if self.resourceType is not None:
      oprot.writeFieldBegin('resourceType', TType.I32, 1)
      oprot.writeI32(self.resourceType)
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 2)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourceType)
    value = (value * 31) ^ hash(self.uri)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Function:
  """
  Attributes:
   - functionName
   - dbName
   - className
   - ownerName
   - ownerType
   - createTime
   - functionType
   - resourceUris
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'functionName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'className', None, None, ), # 3
    (4, TType.STRING, 'ownerName', None, None, ), # 4
    (5, TType.I32, 'ownerType', None, None, ), # 5
    (6, TType.I32, 'createTime', None, None, ), # 6
    (7, TType.I32, 'functionType', None, None, ), # 7
    (8, TType.LIST, 'resourceUris', (TType.STRUCT,(ResourceUri, ResourceUri.thrift_spec)), None, ), # 8
    (9, TType.STRING, 'catName', None, None, ), # 9
  )

  def __init__(self, functionName=None, dbName=None, className=None, ownerName=None, ownerType=None, createTime=None, functionType=None, resourceUris=None, catName=None,):
    self.functionName = functionName
    self.dbName = dbName
    self.className = className
    self.ownerName = ownerName
    self.ownerType = ownerType
    self.createTime = createTime
    self.functionType = functionType
    self.resourceUris = resourceUris
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.functionName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.className = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ownerType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.functionType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.resourceUris = []
          (_etype484, _size481) = iprot.readListBegin()
          for _i485 in xrange(_size481):
            _elem486 = ResourceUri()
            _elem486.read(iprot)
            self.resourceUris.append(_elem486)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Function')
    if self.functionName is not None:
      oprot.writeFieldBegin('functionName', TType.STRING, 1)
      oprot.writeString(self.functionName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.className is not None:
      oprot.writeFieldBegin('className', TType.STRING, 3)
      oprot.writeString(self.className)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 4)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    if self.ownerType is not None:
      oprot.writeFieldBegin('ownerType', TType.I32, 5)
      oprot.writeI32(self.ownerType)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 6)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.functionType is not None:
      oprot.writeFieldBegin('functionType', TType.I32, 7)
      oprot.writeI32(self.functionType)
      oprot.writeFieldEnd()
    if self.resourceUris is not None:
      oprot.writeFieldBegin('resourceUris', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.resourceUris))
      for iter487 in self.resourceUris:
        iter487.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 9)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.functionName)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.className)
    value = (value * 31) ^ hash(self.ownerName)
    value = (value * 31) ^ hash(self.ownerType)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.functionType)
    value = (value * 31) ^ hash(self.resourceUris)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TxnInfo:
  """
  Attributes:
   - id
   - state
   - user
   - hostname
   - agentInfo
   - heartbeatCount
   - metaInfo
   - startedTime
   - lastHeartbeatTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I32, 'state', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRING, 'hostname', None, None, ), # 4
    (5, TType.STRING, 'agentInfo', None, "Unknown", ), # 5
    (6, TType.I32, 'heartbeatCount', None, 0, ), # 6
    (7, TType.STRING, 'metaInfo', None, None, ), # 7
    (8, TType.I64, 'startedTime', None, None, ), # 8
    (9, TType.I64, 'lastHeartbeatTime', None, None, ), # 9
  )

  def __init__(self, id=None, state=None, user=None, hostname=None, agentInfo=thrift_spec[5][4], heartbeatCount=thrift_spec[6][4], metaInfo=None, startedTime=None, lastHeartbeatTime=None,):
    self.id = id
    self.state = state
    self.user = user
    self.hostname = hostname
    self.agentInfo = agentInfo
    self.heartbeatCount = heartbeatCount
    self.metaInfo = metaInfo
    self.startedTime = startedTime
    self.lastHeartbeatTime = lastHeartbeatTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.heartbeatCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.metaInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.startedTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.lastHeartbeatTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TxnInfo')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 2)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 4)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 5)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    if self.heartbeatCount is not None:
      oprot.writeFieldBegin('heartbeatCount', TType.I32, 6)
      oprot.writeI32(self.heartbeatCount)
      oprot.writeFieldEnd()
    if self.metaInfo is not None:
      oprot.writeFieldBegin('metaInfo', TType.STRING, 7)
      oprot.writeString(self.metaInfo)
      oprot.writeFieldEnd()
    if self.startedTime is not None:
      oprot.writeFieldBegin('startedTime', TType.I64, 8)
      oprot.writeI64(self.startedTime)
      oprot.writeFieldEnd()
    if self.lastHeartbeatTime is not None:
      oprot.writeFieldBegin('lastHeartbeatTime', TType.I64, 9)
      oprot.writeI64(self.lastHeartbeatTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.agentInfo)
    value = (value * 31) ^ hash(self.heartbeatCount)
    value = (value * 31) ^ hash(self.metaInfo)
    value = (value * 31) ^ hash(self.startedTime)
    value = (value * 31) ^ hash(self.lastHeartbeatTime)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetOpenTxnsInfoResponse:
  """
  Attributes:
   - txn_high_water_mark
   - open_txns
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txn_high_water_mark', None, None, ), # 1
    (2, TType.LIST, 'open_txns', (TType.STRUCT,(TxnInfo, TxnInfo.thrift_spec)), None, ), # 2
  )

  def __init__(self, txn_high_water_mark=None, open_txns=None,):
    self.txn_high_water_mark = txn_high_water_mark
    self.open_txns = open_txns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txn_high_water_mark = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.open_txns = []
          (_etype491, _size488) = iprot.readListBegin()
          for _i492 in xrange(_size488):
            _elem493 = TxnInfo()
            _elem493.read(iprot)
            self.open_txns.append(_elem493)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetOpenTxnsInfoResponse')
    if self.txn_high_water_mark is not None:
      oprot.writeFieldBegin('txn_high_water_mark', TType.I64, 1)
      oprot.writeI64(self.txn_high_water_mark)
      oprot.writeFieldEnd()
    if self.open_txns is not None:
      oprot.writeFieldBegin('open_txns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.open_txns))
      for iter494 in self.open_txns:
        iter494.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_high_water_mark is None:
      raise TProtocol.TProtocolException(message='Required field txn_high_water_mark is unset!')
    if self.open_txns is None:
      raise TProtocol.TProtocolException(message='Required field open_txns is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_high_water_mark)
    value = (value * 31) ^ hash(self.open_txns)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetOpenTxnsResponse:
  """
  Attributes:
   - txn_high_water_mark
   - open_txns
   - min_open_txn
   - abortedBits
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txn_high_water_mark', None, None, ), # 1
    (2, TType.LIST, 'open_txns', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'min_open_txn', None, None, ), # 3
    (4, TType.STRING, 'abortedBits', None, None, ), # 4
  )

  def __init__(self, txn_high_water_mark=None, open_txns=None, min_open_txn=None, abortedBits=None,):
    self.txn_high_water_mark = txn_high_water_mark
    self.open_txns = open_txns
    self.min_open_txn = min_open_txn
    self.abortedBits = abortedBits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txn_high_water_mark = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.open_txns = []
          (_etype498, _size495) = iprot.readListBegin()
          for _i499 in xrange(_size495):
            _elem500 = iprot.readI64()
            self.open_txns.append(_elem500)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.min_open_txn = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.abortedBits = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetOpenTxnsResponse')
    if self.txn_high_water_mark is not None:
      oprot.writeFieldBegin('txn_high_water_mark', TType.I64, 1)
      oprot.writeI64(self.txn_high_water_mark)
      oprot.writeFieldEnd()
    if self.open_txns is not None:
      oprot.writeFieldBegin('open_txns', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.open_txns))
      for iter501 in self.open_txns:
        oprot.writeI64(iter501)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.min_open_txn is not None:
      oprot.writeFieldBegin('min_open_txn', TType.I64, 3)
      oprot.writeI64(self.min_open_txn)
      oprot.writeFieldEnd()
    if self.abortedBits is not None:
      oprot.writeFieldBegin('abortedBits', TType.STRING, 4)
      oprot.writeString(self.abortedBits)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_high_water_mark is None:
      raise TProtocol.TProtocolException(message='Required field txn_high_water_mark is unset!')
    if self.open_txns is None:
      raise TProtocol.TProtocolException(message='Required field open_txns is unset!')
    if self.abortedBits is None:
      raise TProtocol.TProtocolException(message='Required field abortedBits is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_high_water_mark)
    value = (value * 31) ^ hash(self.open_txns)
    value = (value * 31) ^ hash(self.min_open_txn)
    value = (value * 31) ^ hash(self.abortedBits)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class OpenTxnRequest:
  """
  Attributes:
   - num_txns
   - user
   - hostname
   - agentInfo
   - replPolicy
   - replSrcTxnIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'num_txns', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.STRING, 'hostname', None, None, ), # 3
    (4, TType.STRING, 'agentInfo', None, "Unknown", ), # 4
    (5, TType.STRING, 'replPolicy', None, None, ), # 5
    (6, TType.LIST, 'replSrcTxnIds', (TType.I64,None), None, ), # 6
  )

  def __init__(self, num_txns=None, user=None, hostname=None, agentInfo=thrift_spec[4][4], replPolicy=None, replSrcTxnIds=None,):
    self.num_txns = num_txns
    self.user = user
    self.hostname = hostname
    self.agentInfo = agentInfo
    self.replPolicy = replPolicy
    self.replSrcTxnIds = replSrcTxnIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.num_txns = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.replPolicy = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.replSrcTxnIds = []
          (_etype505, _size502) = iprot.readListBegin()
          for _i506 in xrange(_size502):
            _elem507 = iprot.readI64()
            self.replSrcTxnIds.append(_elem507)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('OpenTxnRequest')
    if self.num_txns is not None:
      oprot.writeFieldBegin('num_txns', TType.I32, 1)
      oprot.writeI32(self.num_txns)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 3)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 4)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    if self.replPolicy is not None:
      oprot.writeFieldBegin('replPolicy', TType.STRING, 5)
      oprot.writeString(self.replPolicy)
      oprot.writeFieldEnd()
    if self.replSrcTxnIds is not None:
      oprot.writeFieldBegin('replSrcTxnIds', TType.LIST, 6)
      oprot.writeListBegin(TType.I64, len(self.replSrcTxnIds))
      for iter508 in self.replSrcTxnIds:
        oprot.writeI64(iter508)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.num_txns is None:
      raise TProtocol.TProtocolException(message='Required field num_txns is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.num_txns)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.agentInfo)
    value = (value * 31) ^ hash(self.replPolicy)
    value = (value * 31) ^ hash(self.replSrcTxnIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class OpenTxnsResponse:
  """
  Attributes:
   - txn_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'txn_ids', (TType.I64,None), None, ), # 1
  )

  def __init__(self, txn_ids=None,):
    self.txn_ids = txn_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.txn_ids = []
          (_etype512, _size509) = iprot.readListBegin()
          for _i513 in xrange(_size509):
            _elem514 = iprot.readI64()
            self.txn_ids.append(_elem514)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('OpenTxnsResponse')
    if self.txn_ids is not None:
      oprot.writeFieldBegin('txn_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.txn_ids))
      for iter515 in self.txn_ids:
        oprot.writeI64(iter515)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_ids is None:
      raise TProtocol.TProtocolException(message='Required field txn_ids is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AbortTxnRequest:
  """
  Attributes:
   - txnid
   - replPolicy
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txnid', None, None, ), # 1
    (2, TType.STRING, 'replPolicy', None, None, ), # 2
  )

  def __init__(self, txnid=None, replPolicy=None,):
    self.txnid = txnid
    self.replPolicy = replPolicy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.replPolicy = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AbortTxnRequest')
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 1)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.replPolicy is not None:
      oprot.writeFieldBegin('replPolicy', TType.STRING, 2)
      oprot.writeString(self.replPolicy)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnid is None:
      raise TProtocol.TProtocolException(message='Required field txnid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.replPolicy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AbortTxnsRequest:
  """
  Attributes:
   - txn_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'txn_ids', (TType.I64,None), None, ), # 1
  )

  def __init__(self, txn_ids=None,):
    self.txn_ids = txn_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.txn_ids = []
          (_etype519, _size516) = iprot.readListBegin()
          for _i520 in xrange(_size516):
            _elem521 = iprot.readI64()
            self.txn_ids.append(_elem521)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AbortTxnsRequest')
    if self.txn_ids is not None:
      oprot.writeFieldBegin('txn_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.txn_ids))
      for iter522 in self.txn_ids:
        oprot.writeI64(iter522)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_ids is None:
      raise TProtocol.TProtocolException(message='Required field txn_ids is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CommitTxnRequest:
  """
  Attributes:
   - txnid
   - replPolicy
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txnid', None, None, ), # 1
    (2, TType.STRING, 'replPolicy', None, None, ), # 2
  )

  def __init__(self, txnid=None, replPolicy=None,):
    self.txnid = txnid
    self.replPolicy = replPolicy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.replPolicy = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CommitTxnRequest')
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 1)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.replPolicy is not None:
      oprot.writeFieldBegin('replPolicy', TType.STRING, 2)
      oprot.writeString(self.replPolicy)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnid is None:
      raise TProtocol.TProtocolException(message='Required field txnid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.replPolicy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValidWriteIdsRequest:
  """
  Attributes:
   - fullTableNames
   - validTxnList
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fullTableNames', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'validTxnList', None, None, ), # 2
  )

  def __init__(self, fullTableNames=None, validTxnList=None,):
    self.fullTableNames = fullTableNames
    self.validTxnList = validTxnList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fullTableNames = []
          (_etype526, _size523) = iprot.readListBegin()
          for _i527 in xrange(_size523):
            _elem528 = iprot.readString()
            self.fullTableNames.append(_elem528)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.validTxnList = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValidWriteIdsRequest')
    if self.fullTableNames is not None:
      oprot.writeFieldBegin('fullTableNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.fullTableNames))
      for iter529 in self.fullTableNames:
        oprot.writeString(iter529)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.validTxnList is not None:
      oprot.writeFieldBegin('validTxnList', TType.STRING, 2)
      oprot.writeString(self.validTxnList)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fullTableNames is None:
      raise TProtocol.TProtocolException(message='Required field fullTableNames is unset!')
    if self.validTxnList is None:
      raise TProtocol.TProtocolException(message='Required field validTxnList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fullTableNames)
    value = (value * 31) ^ hash(self.validTxnList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableValidWriteIds:
  """
  Attributes:
   - fullTableName
   - writeIdHighWaterMark
   - invalidWriteIds
   - minOpenWriteId
   - abortedBits
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'fullTableName', None, None, ), # 1
    (2, TType.I64, 'writeIdHighWaterMark', None, None, ), # 2
    (3, TType.LIST, 'invalidWriteIds', (TType.I64,None), None, ), # 3
    (4, TType.I64, 'minOpenWriteId', None, None, ), # 4
    (5, TType.STRING, 'abortedBits', None, None, ), # 5
  )

  def __init__(self, fullTableName=None, writeIdHighWaterMark=None, invalidWriteIds=None, minOpenWriteId=None, abortedBits=None,):
    self.fullTableName = fullTableName
    self.writeIdHighWaterMark = writeIdHighWaterMark
    self.invalidWriteIds = invalidWriteIds
    self.minOpenWriteId = minOpenWriteId
    self.abortedBits = abortedBits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.fullTableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.writeIdHighWaterMark = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.invalidWriteIds = []
          (_etype533, _size530) = iprot.readListBegin()
          for _i534 in xrange(_size530):
            _elem535 = iprot.readI64()
            self.invalidWriteIds.append(_elem535)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.minOpenWriteId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.abortedBits = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableValidWriteIds')
    if self.fullTableName is not None:
      oprot.writeFieldBegin('fullTableName', TType.STRING, 1)
      oprot.writeString(self.fullTableName)
      oprot.writeFieldEnd()
    if self.writeIdHighWaterMark is not None:
      oprot.writeFieldBegin('writeIdHighWaterMark', TType.I64, 2)
      oprot.writeI64(self.writeIdHighWaterMark)
      oprot.writeFieldEnd()
    if self.invalidWriteIds is not None:
      oprot.writeFieldBegin('invalidWriteIds', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.invalidWriteIds))
      for iter536 in self.invalidWriteIds:
        oprot.writeI64(iter536)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.minOpenWriteId is not None:
      oprot.writeFieldBegin('minOpenWriteId', TType.I64, 4)
      oprot.writeI64(self.minOpenWriteId)
      oprot.writeFieldEnd()
    if self.abortedBits is not None:
      oprot.writeFieldBegin('abortedBits', TType.STRING, 5)
      oprot.writeString(self.abortedBits)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fullTableName is None:
      raise TProtocol.TProtocolException(message='Required field fullTableName is unset!')
    if self.writeIdHighWaterMark is None:
      raise TProtocol.TProtocolException(message='Required field writeIdHighWaterMark is unset!')
    if self.invalidWriteIds is None:
      raise TProtocol.TProtocolException(message='Required field invalidWriteIds is unset!')
    if self.abortedBits is None:
      raise TProtocol.TProtocolException(message='Required field abortedBits is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fullTableName)
    value = (value * 31) ^ hash(self.writeIdHighWaterMark)
    value = (value * 31) ^ hash(self.invalidWriteIds)
    value = (value * 31) ^ hash(self.minOpenWriteId)
    value = (value * 31) ^ hash(self.abortedBits)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetValidWriteIdsResponse:
  """
  Attributes:
   - tblValidWriteIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tblValidWriteIds', (TType.STRUCT,(TableValidWriteIds, TableValidWriteIds.thrift_spec)), None, ), # 1
  )

  def __init__(self, tblValidWriteIds=None,):
    self.tblValidWriteIds = tblValidWriteIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tblValidWriteIds = []
          (_etype540, _size537) = iprot.readListBegin()
          for _i541 in xrange(_size537):
            _elem542 = TableValidWriteIds()
            _elem542.read(iprot)
            self.tblValidWriteIds.append(_elem542)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetValidWriteIdsResponse')
    if self.tblValidWriteIds is not None:
      oprot.writeFieldBegin('tblValidWriteIds', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tblValidWriteIds))
      for iter543 in self.tblValidWriteIds:
        iter543.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tblValidWriteIds is None:
      raise TProtocol.TProtocolException(message='Required field tblValidWriteIds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tblValidWriteIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AllocateTableWriteIdsRequest:
  """
  Attributes:
   - dbName
   - tableName
   - txnIds
   - replPolicy
   - srcTxnToWriteIdList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.LIST, 'txnIds', (TType.I64,None), None, ), # 3
    (4, TType.STRING, 'replPolicy', None, None, ), # 4
    (5, TType.LIST, 'srcTxnToWriteIdList', (TType.STRUCT,(TxnToWriteId, TxnToWriteId.thrift_spec)), None, ), # 5
  )

  def __init__(self, dbName=None, tableName=None, txnIds=None, replPolicy=None, srcTxnToWriteIdList=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.txnIds = txnIds
    self.replPolicy = replPolicy
    self.srcTxnToWriteIdList = srcTxnToWriteIdList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.txnIds = []
          (_etype547, _size544) = iprot.readListBegin()
          for _i548 in xrange(_size544):
            _elem549 = iprot.readI64()
            self.txnIds.append(_elem549)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.replPolicy = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.srcTxnToWriteIdList = []
          (_etype553, _size550) = iprot.readListBegin()
          for _i554 in xrange(_size550):
            _elem555 = TxnToWriteId()
            _elem555.read(iprot)
            self.srcTxnToWriteIdList.append(_elem555)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AllocateTableWriteIdsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.txnIds is not None:
      oprot.writeFieldBegin('txnIds', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.txnIds))
      for iter556 in self.txnIds:
        oprot.writeI64(iter556)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.replPolicy is not None:
      oprot.writeFieldBegin('replPolicy', TType.STRING, 4)
      oprot.writeString(self.replPolicy)
      oprot.writeFieldEnd()
    if self.srcTxnToWriteIdList is not None:
      oprot.writeFieldBegin('srcTxnToWriteIdList', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.srcTxnToWriteIdList))
      for iter557 in self.srcTxnToWriteIdList:
        iter557.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.txnIds)
    value = (value * 31) ^ hash(self.replPolicy)
    value = (value * 31) ^ hash(self.srcTxnToWriteIdList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TxnToWriteId:
  """
  Attributes:
   - txnId
   - writeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txnId', None, None, ), # 1
    (2, TType.I64, 'writeId', None, None, ), # 2
  )

  def __init__(self, txnId=None, writeId=None,):
    self.txnId = txnId
    self.writeId = writeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txnId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.writeId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TxnToWriteId')
    if self.txnId is not None:
      oprot.writeFieldBegin('txnId', TType.I64, 1)
      oprot.writeI64(self.txnId)
      oprot.writeFieldEnd()
    if self.writeId is not None:
      oprot.writeFieldBegin('writeId', TType.I64, 2)
      oprot.writeI64(self.writeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnId is None:
      raise TProtocol.TProtocolException(message='Required field txnId is unset!')
    if self.writeId is None:
      raise TProtocol.TProtocolException(message='Required field writeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnId)
    value = (value * 31) ^ hash(self.writeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AllocateTableWriteIdsResponse:
  """
  Attributes:
   - txnToWriteIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'txnToWriteIds', (TType.STRUCT,(TxnToWriteId, TxnToWriteId.thrift_spec)), None, ), # 1
  )

  def __init__(self, txnToWriteIds=None,):
    self.txnToWriteIds = txnToWriteIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.txnToWriteIds = []
          (_etype561, _size558) = iprot.readListBegin()
          for _i562 in xrange(_size558):
            _elem563 = TxnToWriteId()
            _elem563.read(iprot)
            self.txnToWriteIds.append(_elem563)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AllocateTableWriteIdsResponse')
    if self.txnToWriteIds is not None:
      oprot.writeFieldBegin('txnToWriteIds', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.txnToWriteIds))
      for iter564 in self.txnToWriteIds:
        iter564.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnToWriteIds is None:
      raise TProtocol.TProtocolException(message='Required field txnToWriteIds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnToWriteIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LockComponent:
  """
  Attributes:
   - type
   - level
   - dbname
   - tablename
   - partitionname
   - operationType
   - isTransactional
   - isDynamicPartitionWrite
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I32, 'level', None, None, ), # 2
    (3, TType.STRING, 'dbname', None, None, ), # 3
    (4, TType.STRING, 'tablename', None, None, ), # 4
    (5, TType.STRING, 'partitionname', None, None, ), # 5
    (6, TType.I32, 'operationType', None,     5, ), # 6
    (7, TType.BOOL, 'isTransactional', None, False, ), # 7
    (8, TType.BOOL, 'isDynamicPartitionWrite', None, False, ), # 8
  )

  def __init__(self, type=None, level=None, dbname=None, tablename=None, partitionname=None, operationType=thrift_spec[6][4], isTransactional=thrift_spec[7][4], isDynamicPartitionWrite=thrift_spec[8][4],):
    self.type = type
    self.level = level
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname
    self.operationType = operationType
    self.isTransactional = isTransactional
    self.isDynamicPartitionWrite = isDynamicPartitionWrite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.level = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.operationType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.isTransactional = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.isDynamicPartitionWrite = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockComponent')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.level is not None:
      oprot.writeFieldBegin('level', TType.I32, 2)
      oprot.writeI32(self.level)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 3)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 4)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 5)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    if self.operationType is not None:
      oprot.writeFieldBegin('operationType', TType.I32, 6)
      oprot.writeI32(self.operationType)
      oprot.writeFieldEnd()
    if self.isTransactional is not None:
      oprot.writeFieldBegin('isTransactional', TType.BOOL, 7)
      oprot.writeBool(self.isTransactional)
      oprot.writeFieldEnd()
    if self.isDynamicPartitionWrite is not None:
      oprot.writeFieldBegin('isDynamicPartitionWrite', TType.BOOL, 8)
      oprot.writeBool(self.isDynamicPartitionWrite)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.level is None:
      raise TProtocol.TProtocolException(message='Required field level is unset!')
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.level)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    value = (value * 31) ^ hash(self.operationType)
    value = (value * 31) ^ hash(self.isTransactional)
    value = (value * 31) ^ hash(self.isDynamicPartitionWrite)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LockRequest:
  """
  Attributes:
   - component
   - txnid
   - user
   - hostname
   - agentInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'component', (TType.STRUCT,(LockComponent, LockComponent.thrift_spec)), None, ), # 1
    (2, TType.I64, 'txnid', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRING, 'hostname', None, None, ), # 4
    (5, TType.STRING, 'agentInfo', None, "Unknown", ), # 5
  )

  def __init__(self, component=None, txnid=None, user=None, hostname=None, agentInfo=thrift_spec[5][4],):
    self.component = component
    self.txnid = txnid
    self.user = user
    self.hostname = hostname
    self.agentInfo = agentInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.component = []
          (_etype568, _size565) = iprot.readListBegin()
          for _i569 in xrange(_size565):
            _elem570 = LockComponent()
            _elem570.read(iprot)
            self.component.append(_elem570)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockRequest')
    if self.component is not None:
      oprot.writeFieldBegin('component', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.component))
      for iter571 in self.component:
        iter571.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 2)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 4)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 5)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.component is None:
      raise TProtocol.TProtocolException(message='Required field component is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.component)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.agentInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LockResponse:
  """
  Attributes:
   - lockid
   - state
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.I32, 'state', None, None, ), # 2
  )

  def __init__(self, lockid=None, state=None,):
    self.lockid = lockid
    self.state = state

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockResponse')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 2)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.state)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckLockRequest:
  """
  Attributes:
   - lockid
   - txnid
   - elapsed_ms
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.I64, 'txnid', None, None, ), # 2
    (3, TType.I64, 'elapsed_ms', None, None, ), # 3
  )

  def __init__(self, lockid=None, txnid=None, elapsed_ms=None,):
    self.lockid = lockid
    self.txnid = txnid
    self.elapsed_ms = elapsed_ms

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.elapsed_ms = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckLockRequest')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 2)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.elapsed_ms is not None:
      oprot.writeFieldBegin('elapsed_ms', TType.I64, 3)
      oprot.writeI64(self.elapsed_ms)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.elapsed_ms)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnlockRequest:
  """
  Attributes:
   - lockid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
  )

  def __init__(self, lockid=None,):
    self.lockid = lockid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnlockRequest')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowLocksRequest:
  """
  Attributes:
   - dbname
   - tablename
   - partname
   - isExtended
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'partname', None, None, ), # 3
    (4, TType.BOOL, 'isExtended', None, False, ), # 4
  )

  def __init__(self, dbname=None, tablename=None, partname=None, isExtended=thrift_spec[4][4],):
    self.dbname = dbname
    self.tablename = tablename
    self.partname = partname
    self.isExtended = isExtended

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isExtended = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowLocksRequest')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partname is not None:
      oprot.writeFieldBegin('partname', TType.STRING, 3)
      oprot.writeString(self.partname)
      oprot.writeFieldEnd()
    if self.isExtended is not None:
      oprot.writeFieldBegin('isExtended', TType.BOOL, 4)
      oprot.writeBool(self.isExtended)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partname)
    value = (value * 31) ^ hash(self.isExtended)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowLocksResponseElement:
  """
  Attributes:
   - lockid
   - dbname
   - tablename
   - partname
   - state
   - type
   - txnid
   - lastheartbeat
   - acquiredat
   - user
   - hostname
   - heartbeatCount
   - agentInfo
   - blockedByExtId
   - blockedByIntId
   - lockIdInternal
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.STRING, 'dbname', None, None, ), # 2
    (3, TType.STRING, 'tablename', None, None, ), # 3
    (4, TType.STRING, 'partname', None, None, ), # 4
    (5, TType.I32, 'state', None, None, ), # 5
    (6, TType.I32, 'type', None, None, ), # 6
    (7, TType.I64, 'txnid', None, None, ), # 7
    (8, TType.I64, 'lastheartbeat', None, None, ), # 8
    (9, TType.I64, 'acquiredat', None, None, ), # 9
    (10, TType.STRING, 'user', None, None, ), # 10
    (11, TType.STRING, 'hostname', None, None, ), # 11
    (12, TType.I32, 'heartbeatCount', None, 0, ), # 12
    (13, TType.STRING, 'agentInfo', None, None, ), # 13
    (14, TType.I64, 'blockedByExtId', None, None, ), # 14
    (15, TType.I64, 'blockedByIntId', None, None, ), # 15
    (16, TType.I64, 'lockIdInternal', None, None, ), # 16
  )

  def __init__(self, lockid=None, dbname=None, tablename=None, partname=None, state=None, type=None, txnid=None, lastheartbeat=None, acquiredat=None, user=None, hostname=None, heartbeatCount=thrift_spec[12][4], agentInfo=None, blockedByExtId=None, blockedByIntId=None, lockIdInternal=None,):
    self.lockid = lockid
    self.dbname = dbname
    self.tablename = tablename
    self.partname = partname
    self.state = state
    self.type = type
    self.txnid = txnid
    self.lastheartbeat = lastheartbeat
    self.acquiredat = acquiredat
    self.user = user
    self.hostname = hostname
    self.heartbeatCount = heartbeatCount
    self.agentInfo = agentInfo
    self.blockedByExtId = blockedByExtId
    self.blockedByIntId = blockedByIntId
    self.lockIdInternal = lockIdInternal

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.partname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.lastheartbeat = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.acquiredat = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.heartbeatCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I64:
          self.blockedByExtId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.blockedByIntId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I64:
          self.lockIdInternal = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowLocksResponseElement')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 2)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 3)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partname is not None:
      oprot.writeFieldBegin('partname', TType.STRING, 4)
      oprot.writeString(self.partname)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 5)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 6)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 7)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.lastheartbeat is not None:
      oprot.writeFieldBegin('lastheartbeat', TType.I64, 8)
      oprot.writeI64(self.lastheartbeat)
      oprot.writeFieldEnd()
    if self.acquiredat is not None:
      oprot.writeFieldBegin('acquiredat', TType.I64, 9)
      oprot.writeI64(self.acquiredat)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 10)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 11)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.heartbeatCount is not None:
      oprot.writeFieldBegin('heartbeatCount', TType.I32, 12)
      oprot.writeI32(self.heartbeatCount)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 13)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    if self.blockedByExtId is not None:
      oprot.writeFieldBegin('blockedByExtId', TType.I64, 14)
      oprot.writeI64(self.blockedByExtId)
      oprot.writeFieldEnd()
    if self.blockedByIntId is not None:
      oprot.writeFieldBegin('blockedByIntId', TType.I64, 15)
      oprot.writeI64(self.blockedByIntId)
      oprot.writeFieldEnd()
    if self.lockIdInternal is not None:
      oprot.writeFieldBegin('lockIdInternal', TType.I64, 16)
      oprot.writeI64(self.lockIdInternal)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.lastheartbeat is None:
      raise TProtocol.TProtocolException(message='Required field lastheartbeat is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partname)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.lastheartbeat)
    value = (value * 31) ^ hash(self.acquiredat)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.heartbeatCount)
    value = (value * 31) ^ hash(self.agentInfo)
    value = (value * 31) ^ hash(self.blockedByExtId)
    value = (value * 31) ^ hash(self.blockedByIntId)
    value = (value * 31) ^ hash(self.lockIdInternal)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowLocksResponse:
  """
  Attributes:
   - locks
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'locks', (TType.STRUCT,(ShowLocksResponseElement, ShowLocksResponseElement.thrift_spec)), None, ), # 1
  )

  def __init__(self, locks=None,):
    self.locks = locks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.locks = []
          (_etype575, _size572) = iprot.readListBegin()
          for _i576 in xrange(_size572):
            _elem577 = ShowLocksResponseElement()
            _elem577.read(iprot)
            self.locks.append(_elem577)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowLocksResponse')
    if self.locks is not None:
      oprot.writeFieldBegin('locks', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.locks))
      for iter578 in self.locks:
        iter578.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.locks)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HeartbeatRequest:
  """
  Attributes:
   - lockid
   - txnid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.I64, 'txnid', None, None, ), # 2
  )

  def __init__(self, lockid=None, txnid=None,):
    self.lockid = lockid
    self.txnid = txnid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HeartbeatRequest')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 2)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.txnid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HeartbeatTxnRangeRequest:
  """
  Attributes:
   - min
   - max
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'min', None, None, ), # 1
    (2, TType.I64, 'max', None, None, ), # 2
  )

  def __init__(self, min=None, max=None,):
    self.min = min
    self.max = max

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.min = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.max = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HeartbeatTxnRangeRequest')
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I64, 1)
      oprot.writeI64(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I64, 2)
      oprot.writeI64(self.max)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.min is None:
      raise TProtocol.TProtocolException(message='Required field min is unset!')
    if self.max is None:
      raise TProtocol.TProtocolException(message='Required field max is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.min)
    value = (value * 31) ^ hash(self.max)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HeartbeatTxnRangeResponse:
  """
  Attributes:
   - aborted
   - nosuch
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'aborted', (TType.I64,None), None, ), # 1
    (2, TType.SET, 'nosuch', (TType.I64,None), None, ), # 2
  )

  def __init__(self, aborted=None, nosuch=None,):
    self.aborted = aborted
    self.nosuch = nosuch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.aborted = set()
          (_etype582, _size579) = iprot.readSetBegin()
          for _i583 in xrange(_size579):
            _elem584 = iprot.readI64()
            self.aborted.add(_elem584)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.nosuch = set()
          (_etype588, _size585) = iprot.readSetBegin()
          for _i589 in xrange(_size585):
            _elem590 = iprot.readI64()
            self.nosuch.add(_elem590)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HeartbeatTxnRangeResponse')
    if self.aborted is not None:
      oprot.writeFieldBegin('aborted', TType.SET, 1)
      oprot.writeSetBegin(TType.I64, len(self.aborted))
      for iter591 in self.aborted:
        oprot.writeI64(iter591)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.nosuch is not None:
      oprot.writeFieldBegin('nosuch', TType.SET, 2)
      oprot.writeSetBegin(TType.I64, len(self.nosuch))
      for iter592 in self.nosuch:
        oprot.writeI64(iter592)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.aborted is None:
      raise TProtocol.TProtocolException(message='Required field aborted is unset!')
    if self.nosuch is None:
      raise TProtocol.TProtocolException(message='Required field nosuch is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.aborted)
    value = (value * 31) ^ hash(self.nosuch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CompactionRequest:
  """
  Attributes:
   - dbname
   - tablename
   - partitionname
   - type
   - runas
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'partitionname', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
    (5, TType.STRING, 'runas', None, None, ), # 5
    (6, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 6
  )

  def __init__(self, dbname=None, tablename=None, partitionname=None, type=None, runas=None, properties=None,):
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname
    self.type = type
    self.runas = runas
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.runas = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype594, _vtype595, _size593 ) = iprot.readMapBegin()
          for _i597 in xrange(_size593):
            _key598 = iprot.readString()
            _val599 = iprot.readString()
            self.properties[_key598] = _val599
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CompactionRequest')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 3)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.runas is not None:
      oprot.writeFieldBegin('runas', TType.STRING, 5)
      oprot.writeString(self.runas)
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter600,viter601 in self.properties.items():
        oprot.writeString(kiter600)
        oprot.writeString(viter601)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.runas)
    value = (value * 31) ^ hash(self.properties)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CompactionResponse:
  """
  Attributes:
   - id
   - state
   - accepted
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRING, 'state', None, None, ), # 2
    (3, TType.BOOL, 'accepted', None, None, ), # 3
  )

  def __init__(self, id=None, state=None, accepted=None,):
    self.id = id
    self.state = state
    self.accepted = accepted

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.state = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.accepted = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CompactionResponse')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRING, 2)
      oprot.writeString(self.state)
      oprot.writeFieldEnd()
    if self.accepted is not None:
      oprot.writeFieldBegin('accepted', TType.BOOL, 3)
      oprot.writeBool(self.accepted)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    if self.accepted is None:
      raise TProtocol.TProtocolException(message='Required field accepted is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.accepted)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowCompactRequest:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowCompactRequest')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowCompactResponseElement:
  """
  Attributes:
   - dbname
   - tablename
   - partitionname
   - type
   - state
   - workerid
   - start
   - runAs
   - hightestTxnId
   - metaInfo
   - endTime
   - hadoopJobId
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'partitionname', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
    (5, TType.STRING, 'state', None, None, ), # 5
    (6, TType.STRING, 'workerid', None, None, ), # 6
    (7, TType.I64, 'start', None, None, ), # 7
    (8, TType.STRING, 'runAs', None, None, ), # 8
    (9, TType.I64, 'hightestTxnId', None, None, ), # 9
    (10, TType.STRING, 'metaInfo', None, None, ), # 10
    (11, TType.I64, 'endTime', None, None, ), # 11
    (12, TType.STRING, 'hadoopJobId', None, "None", ), # 12
    (13, TType.I64, 'id', None, None, ), # 13
  )

  def __init__(self, dbname=None, tablename=None, partitionname=None, type=None, state=None, workerid=None, start=None, runAs=None, hightestTxnId=None, metaInfo=None, endTime=None, hadoopJobId=thrift_spec[12][4], id=None,):
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname
    self.type = type
    self.state = state
    self.workerid = workerid
    self.start = start
    self.runAs = runAs
    self.hightestTxnId = hightestTxnId
    self.metaInfo = metaInfo
    self.endTime = endTime
    self.hadoopJobId = hadoopJobId
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.state = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.workerid = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.runAs = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.hightestTxnId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.metaInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.endTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.hadoopJobId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowCompactResponseElement')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 3)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRING, 5)
      oprot.writeString(self.state)
      oprot.writeFieldEnd()
    if self.workerid is not None:
      oprot.writeFieldBegin('workerid', TType.STRING, 6)
      oprot.writeString(self.workerid)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 7)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.runAs is not None:
      oprot.writeFieldBegin('runAs', TType.STRING, 8)
      oprot.writeString(self.runAs)
      oprot.writeFieldEnd()
    if self.hightestTxnId is not None:
      oprot.writeFieldBegin('hightestTxnId', TType.I64, 9)
      oprot.writeI64(self.hightestTxnId)
      oprot.writeFieldEnd()
    if self.metaInfo is not None:
      oprot.writeFieldBegin('metaInfo', TType.STRING, 10)
      oprot.writeString(self.metaInfo)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.I64, 11)
      oprot.writeI64(self.endTime)
      oprot.writeFieldEnd()
    if self.hadoopJobId is not None:
      oprot.writeFieldBegin('hadoopJobId', TType.STRING, 12)
      oprot.writeString(self.hadoopJobId)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 13)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.workerid)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.runAs)
    value = (value * 31) ^ hash(self.hightestTxnId)
    value = (value * 31) ^ hash(self.metaInfo)
    value = (value * 31) ^ hash(self.endTime)
    value = (value * 31) ^ hash(self.hadoopJobId)
    value = (value * 31) ^ hash(self.id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowCompactResponse:
  """
  Attributes:
   - compacts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'compacts', (TType.STRUCT,(ShowCompactResponseElement, ShowCompactResponseElement.thrift_spec)), None, ), # 1
  )

  def __init__(self, compacts=None,):
    self.compacts = compacts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.compacts = []
          (_etype605, _size602) = iprot.readListBegin()
          for _i606 in xrange(_size602):
            _elem607 = ShowCompactResponseElement()
            _elem607.read(iprot)
            self.compacts.append(_elem607)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowCompactResponse')
    if self.compacts is not None:
      oprot.writeFieldBegin('compacts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.compacts))
      for iter608 in self.compacts:
        iter608.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.compacts is None:
      raise TProtocol.TProtocolException(message='Required field compacts is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.compacts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddDynamicPartitions:
  """
  Attributes:
   - txnid
   - writeid
   - dbname
   - tablename
   - partitionnames
   - operationType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txnid', None, None, ), # 1
    (2, TType.I64, 'writeid', None, None, ), # 2
    (3, TType.STRING, 'dbname', None, None, ), # 3
    (4, TType.STRING, 'tablename', None, None, ), # 4
    (5, TType.LIST, 'partitionnames', (TType.STRING,None), None, ), # 5
    (6, TType.I32, 'operationType', None,     5, ), # 6
  )

  def __init__(self, txnid=None, writeid=None, dbname=None, tablename=None, partitionnames=None, operationType=thrift_spec[6][4],):
    self.txnid = txnid
    self.writeid = writeid
    self.dbname = dbname
    self.tablename = tablename
    self.partitionnames = partitionnames
    self.operationType = operationType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.writeid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.partitionnames = []
          (_etype612, _size609) = iprot.readListBegin()
          for _i613 in xrange(_size609):
            _elem614 = iprot.readString()
            self.partitionnames.append(_elem614)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.operationType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddDynamicPartitions')
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 1)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.writeid is not None:
      oprot.writeFieldBegin('writeid', TType.I64, 2)
      oprot.writeI64(self.writeid)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 3)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 4)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionnames is not None:
      oprot.writeFieldBegin('partitionnames', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.partitionnames))
      for iter615 in self.partitionnames:
        oprot.writeString(iter615)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.operationType is not None:
      oprot.writeFieldBegin('operationType', TType.I32, 6)
      oprot.writeI32(self.operationType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnid is None:
      raise TProtocol.TProtocolException(message='Required field txnid is unset!')
    if self.writeid is None:
      raise TProtocol.TProtocolException(message='Required field writeid is unset!')
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.partitionnames is None:
      raise TProtocol.TProtocolException(message='Required field partitionnames is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.writeid)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionnames)
    value = (value * 31) ^ hash(self.operationType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BasicTxnInfo:
  """
  Attributes:
   - isnull
   - time
   - txnid
   - dbname
   - tablename
   - partitionname
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isnull', None, None, ), # 1
    (2, TType.I64, 'time', None, None, ), # 2
    (3, TType.I64, 'txnid', None, None, ), # 3
    (4, TType.STRING, 'dbname', None, None, ), # 4
    (5, TType.STRING, 'tablename', None, None, ), # 5
    (6, TType.STRING, 'partitionname', None, None, ), # 6
  )

  def __init__(self, isnull=None, time=None, txnid=None, dbname=None, tablename=None, partitionname=None,):
    self.isnull = isnull
    self.time = time
    self.txnid = txnid
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isnull = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BasicTxnInfo')
    if self.isnull is not None:
      oprot.writeFieldBegin('isnull', TType.BOOL, 1)
      oprot.writeBool(self.isnull)
      oprot.writeFieldEnd()
    if self.time is not None:
      oprot.writeFieldBegin('time', TType.I64, 2)
      oprot.writeI64(self.time)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 3)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 4)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 5)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 6)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isnull is None:
      raise TProtocol.TProtocolException(message='Required field isnull is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isnull)
    value = (value * 31) ^ hash(self.time)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreationMetadata:
  """
  Attributes:
   - catName
   - dbName
   - tblName
   - tablesUsed
   - validTxnList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'catName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tblName', None, None, ), # 3
    (4, TType.SET, 'tablesUsed', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'validTxnList', None, None, ), # 5
  )

  def __init__(self, catName=None, dbName=None, tblName=None, tablesUsed=None, validTxnList=None,):
    self.catName = catName
    self.dbName = dbName
    self.tblName = tblName
    self.tablesUsed = tablesUsed
    self.validTxnList = validTxnList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.tablesUsed = set()
          (_etype619, _size616) = iprot.readSetBegin()
          for _i620 in xrange(_size616):
            _elem621 = iprot.readString()
            self.tablesUsed.add(_elem621)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.validTxnList = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreationMetadata')
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 1)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 3)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.tablesUsed is not None:
      oprot.writeFieldBegin('tablesUsed', TType.SET, 4)
      oprot.writeSetBegin(TType.STRING, len(self.tablesUsed))
      for iter622 in self.tablesUsed:
        oprot.writeString(iter622)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.validTxnList is not None:
      oprot.writeFieldBegin('validTxnList', TType.STRING, 5)
      oprot.writeString(self.validTxnList)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catName is None:
      raise TProtocol.TProtocolException(message='Required field catName is unset!')
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.tablesUsed is None:
      raise TProtocol.TProtocolException(message='Required field tablesUsed is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.tablesUsed)
    value = (value * 31) ^ hash(self.validTxnList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEventRequest:
  """
  Attributes:
   - lastEvent
   - maxEvents
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lastEvent', None, None, ), # 1
    (2, TType.I32, 'maxEvents', None, None, ), # 2
  )

  def __init__(self, lastEvent=None, maxEvents=None,):
    self.lastEvent = lastEvent
    self.maxEvents = maxEvents

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lastEvent = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxEvents = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEventRequest')
    if self.lastEvent is not None:
      oprot.writeFieldBegin('lastEvent', TType.I64, 1)
      oprot.writeI64(self.lastEvent)
      oprot.writeFieldEnd()
    if self.maxEvents is not None:
      oprot.writeFieldBegin('maxEvents', TType.I32, 2)
      oprot.writeI32(self.maxEvents)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lastEvent is None:
      raise TProtocol.TProtocolException(message='Required field lastEvent is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lastEvent)
    value = (value * 31) ^ hash(self.maxEvents)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEvent:
  """
  Attributes:
   - eventId
   - eventTime
   - eventType
   - dbName
   - tableName
   - message
   - messageFormat
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'eventId', None, None, ), # 1
    (2, TType.I32, 'eventTime', None, None, ), # 2
    (3, TType.STRING, 'eventType', None, None, ), # 3
    (4, TType.STRING, 'dbName', None, None, ), # 4
    (5, TType.STRING, 'tableName', None, None, ), # 5
    (6, TType.STRING, 'message', None, None, ), # 6
    (7, TType.STRING, 'messageFormat', None, None, ), # 7
    (8, TType.STRING, 'catName', None, None, ), # 8
  )

  def __init__(self, eventId=None, eventTime=None, eventType=None, dbName=None, tableName=None, message=None, messageFormat=None, catName=None,):
    self.eventId = eventId
    self.eventTime = eventTime
    self.eventType = eventType
    self.dbName = dbName
    self.tableName = tableName
    self.message = message
    self.messageFormat = messageFormat
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.eventId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.eventTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.eventType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.messageFormat = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEvent')
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I64, 1)
      oprot.writeI64(self.eventId)
      oprot.writeFieldEnd()
    if self.eventTime is not None:
      oprot.writeFieldBegin('eventTime', TType.I32, 2)
      oprot.writeI32(self.eventTime)
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.STRING, 3)
      oprot.writeString(self.eventType)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 4)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 5)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 6)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.messageFormat is not None:
      oprot.writeFieldBegin('messageFormat', TType.STRING, 7)
      oprot.writeString(self.messageFormat)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 8)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.eventId is None:
      raise TProtocol.TProtocolException(message='Required field eventId is unset!')
    if self.eventTime is None:
      raise TProtocol.TProtocolException(message='Required field eventTime is unset!')
    if self.eventType is None:
      raise TProtocol.TProtocolException(message='Required field eventType is unset!')
    if self.message is None:
      raise TProtocol.TProtocolException(message='Required field message is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.eventId)
    value = (value * 31) ^ hash(self.eventTime)
    value = (value * 31) ^ hash(self.eventType)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.message)
    value = (value * 31) ^ hash(self.messageFormat)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEventResponse:
  """
  Attributes:
   - events
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'events', (TType.STRUCT,(NotificationEvent, NotificationEvent.thrift_spec)), None, ), # 1
  )

  def __init__(self, events=None,):
    self.events = events

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.events = []
          (_etype626, _size623) = iprot.readListBegin()
          for _i627 in xrange(_size623):
            _elem628 = NotificationEvent()
            _elem628.read(iprot)
            self.events.append(_elem628)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEventResponse')
    if self.events is not None:
      oprot.writeFieldBegin('events', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.events))
      for iter629 in self.events:
        iter629.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.events is None:
      raise TProtocol.TProtocolException(message='Required field events is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.events)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CurrentNotificationEventId:
  """
  Attributes:
   - eventId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'eventId', None, None, ), # 1
  )

  def __init__(self, eventId=None,):
    self.eventId = eventId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.eventId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CurrentNotificationEventId')
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I64, 1)
      oprot.writeI64(self.eventId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.eventId is None:
      raise TProtocol.TProtocolException(message='Required field eventId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.eventId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEventsCountRequest:
  """
  Attributes:
   - fromEventId
   - dbName
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'fromEventId', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'catName', None, None, ), # 3
  )

  def __init__(self, fromEventId=None, dbName=None, catName=None,):
    self.fromEventId = fromEventId
    self.dbName = dbName
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.fromEventId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEventsCountRequest')
    if self.fromEventId is not None:
      oprot.writeFieldBegin('fromEventId', TType.I64, 1)
      oprot.writeI64(self.fromEventId)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 3)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fromEventId is None:
      raise TProtocol.TProtocolException(message='Required field fromEventId is unset!')
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fromEventId)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEventsCountResponse:
  """
  Attributes:
   - eventsCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'eventsCount', None, None, ), # 1
  )

  def __init__(self, eventsCount=None,):
    self.eventsCount = eventsCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.eventsCount = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEventsCountResponse')
    if self.eventsCount is not None:
      oprot.writeFieldBegin('eventsCount', TType.I64, 1)
      oprot.writeI64(self.eventsCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.eventsCount is None:
      raise TProtocol.TProtocolException(message='Required field eventsCount is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.eventsCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InsertEventRequestData:
  """
  Attributes:
   - replace
   - filesAdded
   - filesAddedChecksum
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'replace', None, None, ), # 1
    (2, TType.LIST, 'filesAdded', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'filesAddedChecksum', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, replace=None, filesAdded=None, filesAddedChecksum=None,):
    self.replace = replace
    self.filesAdded = filesAdded
    self.filesAddedChecksum = filesAddedChecksum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.replace = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.filesAdded = []
          (_etype633, _size630) = iprot.readListBegin()
          for _i634 in xrange(_size630):
            _elem635 = iprot.readString()
            self.filesAdded.append(_elem635)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.filesAddedChecksum = []
          (_etype639, _size636) = iprot.readListBegin()
          for _i640 in xrange(_size636):
            _elem641 = iprot.readString()
            self.filesAddedChecksum.append(_elem641)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InsertEventRequestData')
    if self.replace is not None:
      oprot.writeFieldBegin('replace', TType.BOOL, 1)
      oprot.writeBool(self.replace)
      oprot.writeFieldEnd()
    if self.filesAdded is not None:
      oprot.writeFieldBegin('filesAdded', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.filesAdded))
      for iter642 in self.filesAdded:
        oprot.writeString(iter642)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.filesAddedChecksum is not None:
      oprot.writeFieldBegin('filesAddedChecksum', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.filesAddedChecksum))
      for iter643 in self.filesAddedChecksum:
        oprot.writeString(iter643)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.filesAdded is None:
      raise TProtocol.TProtocolException(message='Required field filesAdded is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.replace)
    value = (value * 31) ^ hash(self.filesAdded)
    value = (value * 31) ^ hash(self.filesAddedChecksum)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FireEventRequestData:
  """
  Attributes:
   - insertData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'insertData', (InsertEventRequestData, InsertEventRequestData.thrift_spec), None, ), # 1
  )

  def __init__(self, insertData=None,):
    self.insertData = insertData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.insertData = InsertEventRequestData()
          self.insertData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FireEventRequestData')
    if self.insertData is not None:
      oprot.writeFieldBegin('insertData', TType.STRUCT, 1)
      self.insertData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.insertData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FireEventRequest:
  """
  Attributes:
   - successful
   - data
   - dbName
   - tableName
   - partitionVals
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'successful', None, None, ), # 1
    (2, TType.STRUCT, 'data', (FireEventRequestData, FireEventRequestData.thrift_spec), None, ), # 2
    (3, TType.STRING, 'dbName', None, None, ), # 3
    (4, TType.STRING, 'tableName', None, None, ), # 4
    (5, TType.LIST, 'partitionVals', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'catName', None, None, ), # 6
  )

  def __init__(self, successful=None, data=None, dbName=None, tableName=None, partitionVals=None, catName=None,):
    self.successful = successful
    self.data = data
    self.dbName = dbName
    self.tableName = tableName
    self.partitionVals = partitionVals
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.successful = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data = FireEventRequestData()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.partitionVals = []
          (_etype647, _size644) = iprot.readListBegin()
          for _i648 in xrange(_size644):
            _elem649 = iprot.readString()
            self.partitionVals.append(_elem649)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FireEventRequest')
    if self.successful is not None:
      oprot.writeFieldBegin('successful', TType.BOOL, 1)
      oprot.writeBool(self.successful)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRUCT, 2)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 3)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 4)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partitionVals is not None:
      oprot.writeFieldBegin('partitionVals', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.partitionVals))
      for iter650 in self.partitionVals:
        oprot.writeString(iter650)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 6)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.successful is None:
      raise TProtocol.TProtocolException(message='Required field successful is unset!')
    if self.data is None:
      raise TProtocol.TProtocolException(message='Required field data is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.successful)
    value = (value * 31) ^ hash(self.data)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partitionVals)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FireEventResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FireEventResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetadataPpdResult:
  """
  Attributes:
   - metadata
   - includeBitset
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'metadata', None, None, ), # 1
    (2, TType.STRING, 'includeBitset', None, None, ), # 2
  )

  def __init__(self, metadata=None, includeBitset=None,):
    self.metadata = metadata
    self.includeBitset = includeBitset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.metadata = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.includeBitset = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetadataPpdResult')
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRING, 1)
      oprot.writeString(self.metadata)
      oprot.writeFieldEnd()
    if self.includeBitset is not None:
      oprot.writeFieldBegin('includeBitset', TType.STRING, 2)
      oprot.writeString(self.includeBitset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.includeBitset)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataByExprResult:
  """
  Attributes:
   - metadata
   - isSupported
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metadata', (TType.I64,None,TType.STRUCT,(MetadataPpdResult, MetadataPpdResult.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'isSupported', None, None, ), # 2
  )

  def __init__(self, metadata=None, isSupported=None,):
    self.metadata = metadata
    self.isSupported = isSupported

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metadata = {}
          (_ktype652, _vtype653, _size651 ) = iprot.readMapBegin()
          for _i655 in xrange(_size651):
            _key656 = iprot.readI64()
            _val657 = MetadataPpdResult()
            _val657.read(iprot)
            self.metadata[_key656] = _val657
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isSupported = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataByExprResult')
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.MAP, 1)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.metadata))
      for kiter658,viter659 in self.metadata.items():
        oprot.writeI64(kiter658)
        viter659.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.isSupported is not None:
      oprot.writeFieldBegin('isSupported', TType.BOOL, 2)
      oprot.writeBool(self.isSupported)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.isSupported is None:
      raise TProtocol.TProtocolException(message='Required field isSupported is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.isSupported)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataByExprRequest:
  """
  Attributes:
   - fileIds
   - expr
   - doGetFooters
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'expr', None, None, ), # 2
    (3, TType.BOOL, 'doGetFooters', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
  )

  def __init__(self, fileIds=None, expr=None, doGetFooters=None, type=None,):
    self.fileIds = fileIds
    self.expr = expr
    self.doGetFooters = doGetFooters
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype663, _size660) = iprot.readListBegin()
          for _i664 in xrange(_size660):
            _elem665 = iprot.readI64()
            self.fileIds.append(_elem665)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.doGetFooters = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataByExprRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter666 in self.fileIds:
        oprot.writeI64(iter666)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expr is not None:
      oprot.writeFieldBegin('expr', TType.STRING, 2)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    if self.doGetFooters is not None:
      oprot.writeFieldBegin('doGetFooters', TType.BOOL, 3)
      oprot.writeBool(self.doGetFooters)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    if self.expr is None:
      raise TProtocol.TProtocolException(message='Required field expr is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    value = (value * 31) ^ hash(self.expr)
    value = (value * 31) ^ hash(self.doGetFooters)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataResult:
  """
  Attributes:
   - metadata
   - isSupported
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metadata', (TType.I64,None,TType.STRING,None), None, ), # 1
    (2, TType.BOOL, 'isSupported', None, None, ), # 2
  )

  def __init__(self, metadata=None, isSupported=None,):
    self.metadata = metadata
    self.isSupported = isSupported

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metadata = {}
          (_ktype668, _vtype669, _size667 ) = iprot.readMapBegin()
          for _i671 in xrange(_size667):
            _key672 = iprot.readI64()
            _val673 = iprot.readString()
            self.metadata[_key672] = _val673
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isSupported = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataResult')
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.MAP, 1)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.metadata))
      for kiter674,viter675 in self.metadata.items():
        oprot.writeI64(kiter674)
        oprot.writeString(viter675)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.isSupported is not None:
      oprot.writeFieldBegin('isSupported', TType.BOOL, 2)
      oprot.writeBool(self.isSupported)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.isSupported is None:
      raise TProtocol.TProtocolException(message='Required field isSupported is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.isSupported)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataRequest:
  """
  Attributes:
   - fileIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
  )

  def __init__(self, fileIds=None,):
    self.fileIds = fileIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype679, _size676) = iprot.readListBegin()
          for _i680 in xrange(_size676):
            _elem681 = iprot.readI64()
            self.fileIds.append(_elem681)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter682 in self.fileIds:
        oprot.writeI64(iter682)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutFileMetadataResult:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutFileMetadataResult')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutFileMetadataRequest:
  """
  Attributes:
   - fileIds
   - metadata
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
    (2, TType.LIST, 'metadata', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
  )

  def __init__(self, fileIds=None, metadata=None, type=None,):
    self.fileIds = fileIds
    self.metadata = metadata
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype686, _size683) = iprot.readListBegin()
          for _i687 in xrange(_size683):
            _elem688 = iprot.readI64()
            self.fileIds.append(_elem688)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.metadata = []
          (_etype692, _size689) = iprot.readListBegin()
          for _i693 in xrange(_size689):
            _elem694 = iprot.readString()
            self.metadata.append(_elem694)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutFileMetadataRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter695 in self.fileIds:
        oprot.writeI64(iter695)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.metadata))
      for iter696 in self.metadata:
        oprot.writeString(iter696)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClearFileMetadataResult:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClearFileMetadataResult')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClearFileMetadataRequest:
  """
  Attributes:
   - fileIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
  )

  def __init__(self, fileIds=None,):
    self.fileIds = fileIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype700, _size697) = iprot.readListBegin()
          for _i701 in xrange(_size697):
            _elem702 = iprot.readI64()
            self.fileIds.append(_elem702)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClearFileMetadataRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter703 in self.fileIds:
        oprot.writeI64(iter703)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CacheFileMetadataResult:
  """
  Attributes:
   - isSupported
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isSupported', None, None, ), # 1
  )

  def __init__(self, isSupported=None,):
    self.isSupported = isSupported

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isSupported = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CacheFileMetadataResult')
    if self.isSupported is not None:
      oprot.writeFieldBegin('isSupported', TType.BOOL, 1)
      oprot.writeBool(self.isSupported)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isSupported is None:
      raise TProtocol.TProtocolException(message='Required field isSupported is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isSupported)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CacheFileMetadataRequest:
  """
  Attributes:
   - dbName
   - tblName
   - partName
   - isAllParts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRING, 'partName', None, None, ), # 3
    (4, TType.BOOL, 'isAllParts', None, None, ), # 4
  )

  def __init__(self, dbName=None, tblName=None, partName=None, isAllParts=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.partName = partName
    self.isAllParts = isAllParts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isAllParts = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CacheFileMetadataRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.partName is not None:
      oprot.writeFieldBegin('partName', TType.STRING, 3)
      oprot.writeString(self.partName)
      oprot.writeFieldEnd()
    if self.isAllParts is not None:
      oprot.writeFieldBegin('isAllParts', TType.BOOL, 4)
      oprot.writeBool(self.isAllParts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.partName)
    value = (value * 31) ^ hash(self.isAllParts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllFunctionsResponse:
  """
  Attributes:
   - functions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'functions', (TType.STRUCT,(Function, Function.thrift_spec)), None, ), # 1
  )

  def __init__(self, functions=None,):
    self.functions = functions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.functions = []
          (_etype707, _size704) = iprot.readListBegin()
          for _i708 in xrange(_size704):
            _elem709 = Function()
            _elem709.read(iprot)
            self.functions.append(_elem709)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllFunctionsResponse')
    if self.functions is not None:
      oprot.writeFieldBegin('functions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.functions))
      for iter710 in self.functions:
        iter710.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.functions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClientCapabilities:
  """
  Attributes:
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.I32,None), None, ), # 1
  )

  def __init__(self, values=None,):
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype714, _size711) = iprot.readListBegin()
          for _i715 in xrange(_size711):
            _elem716 = iprot.readI32()
            self.values.append(_elem716)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClientCapabilities')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.values))
      for iter717 in self.values:
        oprot.writeI32(iter717)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.values is None:
      raise TProtocol.TProtocolException(message='Required field values is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTableRequest:
  """
  Attributes:
   - dbName
   - tblName
   - capabilities
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRUCT, 'capabilities', (ClientCapabilities, ClientCapabilities.thrift_spec), None, ), # 3
    (4, TType.STRING, 'catName', None, None, ), # 4
  )

  def __init__(self, dbName=None, tblName=None, capabilities=None, catName=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.capabilities = capabilities
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.capabilities = ClientCapabilities()
          self.capabilities.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTableRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.capabilities is not None:
      oprot.writeFieldBegin('capabilities', TType.STRUCT, 3)
      self.capabilities.write(oprot)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 4)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.capabilities)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTableResult:
  """
  Attributes:
   - table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table', (Table, Table.thrift_spec), None, ), # 1
  )

  def __init__(self, table=None,):
    self.table = table

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table = Table()
          self.table.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTableResult')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRUCT, 1)
      self.table.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTablesRequest:
  """
  Attributes:
   - dbName
   - tblNames
   - capabilities
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.LIST, 'tblNames', (TType.STRING,None), None, ), # 2
    (3, TType.STRUCT, 'capabilities', (ClientCapabilities, ClientCapabilities.thrift_spec), None, ), # 3
    (4, TType.STRING, 'catName', None, None, ), # 4
  )

  def __init__(self, dbName=None, tblNames=None, capabilities=None, catName=None,):
    self.dbName = dbName
    self.tblNames = tblNames
    self.capabilities = capabilities
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tblNames = []
          (_etype721, _size718) = iprot.readListBegin()
          for _i722 in xrange(_size718):
            _elem723 = iprot.readString()
            self.tblNames.append(_elem723)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.capabilities = ClientCapabilities()
          self.capabilities.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTablesRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblNames is not None:
      oprot.writeFieldBegin('tblNames', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.tblNames))
      for iter724 in self.tblNames:
        oprot.writeString(iter724)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.capabilities is not None:
      oprot.writeFieldBegin('capabilities', TType.STRUCT, 3)
      self.capabilities.write(oprot)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 4)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblNames)
    value = (value * 31) ^ hash(self.capabilities)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTablesResult:
  """
  Attributes:
   - tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tables', (TType.STRUCT,(Table, Table.thrift_spec)), None, ), # 1
  )

  def __init__(self, tables=None,):
    self.tables = tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tables = []
          (_etype728, _size725) = iprot.readListBegin()
          for _i729 in xrange(_size725):
            _elem730 = Table()
            _elem730.read(iprot)
            self.tables.append(_elem730)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTablesResult')
    if self.tables is not None:
      oprot.writeFieldBegin('tables', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tables))
      for iter731 in self.tables:
        iter731.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tables is None:
      raise TProtocol.TProtocolException(message='Required field tables is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tables)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CmRecycleRequest:
  """
  Attributes:
   - dataPath
   - purge
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dataPath', None, None, ), # 1
    (2, TType.BOOL, 'purge', None, None, ), # 2
  )

  def __init__(self, dataPath=None, purge=None,):
    self.dataPath = dataPath
    self.purge = purge

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dataPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.purge = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CmRecycleRequest')
    if self.dataPath is not None:
      oprot.writeFieldBegin('dataPath', TType.STRING, 1)
      oprot.writeString(self.dataPath)
      oprot.writeFieldEnd()
    if self.purge is not None:
      oprot.writeFieldBegin('purge', TType.BOOL, 2)
      oprot.writeBool(self.purge)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dataPath is None:
      raise TProtocol.TProtocolException(message='Required field dataPath is unset!')
    if self.purge is None:
      raise TProtocol.TProtocolException(message='Required field purge is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dataPath)
    value = (value * 31) ^ hash(self.purge)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CmRecycleResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CmRecycleResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableMeta:
  """
  Attributes:
   - dbName
   - tableName
   - tableType
   - comments
   - catName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'tableType', None, None, ), # 3
    (4, TType.STRING, 'comments', None, None, ), # 4
    (5, TType.STRING, 'catName', None, None, ), # 5
  )

  def __init__(self, dbName=None, tableName=None, tableType=None, comments=None, catName=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.tableType = tableType
    self.comments = comments
    self.catName = catName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.comments = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableMeta')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.tableType is not None:
      oprot.writeFieldBegin('tableType', TType.STRING, 3)
      oprot.writeString(self.tableType)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 4)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 5)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    if self.tableType is None:
      raise TProtocol.TProtocolException(message='Required field tableType is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.tableType)
    value = (value * 31) ^ hash(self.comments)
    value = (value * 31) ^ hash(self.catName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Materialization:
  """
  Attributes:
   - tablesUsed
   - validTxnList
   - invalidationTime
   - sourceTablesUpdateDeleteModified
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'tablesUsed', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'validTxnList', None, None, ), # 2
    (3, TType.I64, 'invalidationTime', None, None, ), # 3
    (4, TType.BOOL, 'sourceTablesUpdateDeleteModified', None, None, ), # 4
  )

  def __init__(self, tablesUsed=None, validTxnList=None, invalidationTime=None, sourceTablesUpdateDeleteModified=None,):
    self.tablesUsed = tablesUsed
    self.validTxnList = validTxnList
    self.invalidationTime = invalidationTime
    self.sourceTablesUpdateDeleteModified = sourceTablesUpdateDeleteModified

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.tablesUsed = set()
          (_etype735, _size732) = iprot.readSetBegin()
          for _i736 in xrange(_size732):
            _elem737 = iprot.readString()
            self.tablesUsed.add(_elem737)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.validTxnList = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.invalidationTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.sourceTablesUpdateDeleteModified = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Materialization')
    if self.tablesUsed is not None:
      oprot.writeFieldBegin('tablesUsed', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.tablesUsed))
      for iter738 in self.tablesUsed:
        oprot.writeString(iter738)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.validTxnList is not None:
      oprot.writeFieldBegin('validTxnList', TType.STRING, 2)
      oprot.writeString(self.validTxnList)
      oprot.writeFieldEnd()
    if self.invalidationTime is not None:
      oprot.writeFieldBegin('invalidationTime', TType.I64, 3)
      oprot.writeI64(self.invalidationTime)
      oprot.writeFieldEnd()
    if self.sourceTablesUpdateDeleteModified is not None:
      oprot.writeFieldBegin('sourceTablesUpdateDeleteModified', TType.BOOL, 4)
      oprot.writeBool(self.sourceTablesUpdateDeleteModified)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tablesUsed is None:
      raise TProtocol.TProtocolException(message='Required field tablesUsed is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tablesUsed)
    value = (value * 31) ^ hash(self.validTxnList)
    value = (value * 31) ^ hash(self.invalidationTime)
    value = (value * 31) ^ hash(self.sourceTablesUpdateDeleteModified)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMResourcePlan:
  """
  Attributes:
   - name
   - status
   - queryParallelism
   - defaultPoolPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    (3, TType.I32, 'queryParallelism', None, None, ), # 3
    (4, TType.STRING, 'defaultPoolPath', None, None, ), # 4
  )

  def __init__(self, name=None, status=None, queryParallelism=None, defaultPoolPath=None,):
    self.name = name
    self.status = status
    self.queryParallelism = queryParallelism
    self.defaultPoolPath = defaultPoolPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.queryParallelism = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.defaultPoolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMResourcePlan')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.queryParallelism is not None:
      oprot.writeFieldBegin('queryParallelism', TType.I32, 3)
      oprot.writeI32(self.queryParallelism)
      oprot.writeFieldEnd()
    if self.defaultPoolPath is not None:
      oprot.writeFieldBegin('defaultPoolPath', TType.STRING, 4)
      oprot.writeString(self.defaultPoolPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.queryParallelism)
    value = (value * 31) ^ hash(self.defaultPoolPath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMNullableResourcePlan:
  """
  Attributes:
   - name
   - status
   - queryParallelism
   - isSetQueryParallelism
   - defaultPoolPath
   - isSetDefaultPoolPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    None, # 3
    (4, TType.I32, 'queryParallelism', None, None, ), # 4
    (5, TType.BOOL, 'isSetQueryParallelism', None, None, ), # 5
    (6, TType.STRING, 'defaultPoolPath', None, None, ), # 6
    (7, TType.BOOL, 'isSetDefaultPoolPath', None, None, ), # 7
  )

  def __init__(self, name=None, status=None, queryParallelism=None, isSetQueryParallelism=None, defaultPoolPath=None, isSetDefaultPoolPath=None,):
    self.name = name
    self.status = status
    self.queryParallelism = queryParallelism
    self.isSetQueryParallelism = isSetQueryParallelism
    self.defaultPoolPath = defaultPoolPath
    self.isSetDefaultPoolPath = isSetDefaultPoolPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.queryParallelism = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isSetQueryParallelism = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.defaultPoolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.isSetDefaultPoolPath = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMNullableResourcePlan')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.queryParallelism is not None:
      oprot.writeFieldBegin('queryParallelism', TType.I32, 4)
      oprot.writeI32(self.queryParallelism)
      oprot.writeFieldEnd()
    if self.isSetQueryParallelism is not None:
      oprot.writeFieldBegin('isSetQueryParallelism', TType.BOOL, 5)
      oprot.writeBool(self.isSetQueryParallelism)
      oprot.writeFieldEnd()
    if self.defaultPoolPath is not None:
      oprot.writeFieldBegin('defaultPoolPath', TType.STRING, 6)
      oprot.writeString(self.defaultPoolPath)
      oprot.writeFieldEnd()
    if self.isSetDefaultPoolPath is not None:
      oprot.writeFieldBegin('isSetDefaultPoolPath', TType.BOOL, 7)
      oprot.writeBool(self.isSetDefaultPoolPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.queryParallelism)
    value = (value * 31) ^ hash(self.isSetQueryParallelism)
    value = (value * 31) ^ hash(self.defaultPoolPath)
    value = (value * 31) ^ hash(self.isSetDefaultPoolPath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMPool:
  """
  Attributes:
   - resourcePlanName
   - poolPath
   - allocFraction
   - queryParallelism
   - schedulingPolicy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'poolPath', None, None, ), # 2
    (3, TType.DOUBLE, 'allocFraction', None, None, ), # 3
    (4, TType.I32, 'queryParallelism', None, None, ), # 4
    (5, TType.STRING, 'schedulingPolicy', None, None, ), # 5
  )

  def __init__(self, resourcePlanName=None, poolPath=None, allocFraction=None, queryParallelism=None, schedulingPolicy=None,):
    self.resourcePlanName = resourcePlanName
    self.poolPath = poolPath
    self.allocFraction = allocFraction
    self.queryParallelism = queryParallelism
    self.schedulingPolicy = schedulingPolicy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.allocFraction = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.queryParallelism = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.schedulingPolicy = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMPool')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 2)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    if self.allocFraction is not None:
      oprot.writeFieldBegin('allocFraction', TType.DOUBLE, 3)
      oprot.writeDouble(self.allocFraction)
      oprot.writeFieldEnd()
    if self.queryParallelism is not None:
      oprot.writeFieldBegin('queryParallelism', TType.I32, 4)
      oprot.writeI32(self.queryParallelism)
      oprot.writeFieldEnd()
    if self.schedulingPolicy is not None:
      oprot.writeFieldBegin('schedulingPolicy', TType.STRING, 5)
      oprot.writeString(self.schedulingPolicy)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.resourcePlanName is None:
      raise TProtocol.TProtocolException(message='Required field resourcePlanName is unset!')
    if self.poolPath is None:
      raise TProtocol.TProtocolException(message='Required field poolPath is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.poolPath)
    value = (value * 31) ^ hash(self.allocFraction)
    value = (value * 31) ^ hash(self.queryParallelism)
    value = (value * 31) ^ hash(self.schedulingPolicy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMNullablePool:
  """
  Attributes:
   - resourcePlanName
   - poolPath
   - allocFraction
   - queryParallelism
   - schedulingPolicy
   - isSetSchedulingPolicy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'poolPath', None, None, ), # 2
    (3, TType.DOUBLE, 'allocFraction', None, None, ), # 3
    (4, TType.I32, 'queryParallelism', None, None, ), # 4
    (5, TType.STRING, 'schedulingPolicy', None, None, ), # 5
    (6, TType.BOOL, 'isSetSchedulingPolicy', None, None, ), # 6
  )

  def __init__(self, resourcePlanName=None, poolPath=None, allocFraction=None, queryParallelism=None, schedulingPolicy=None, isSetSchedulingPolicy=None,):
    self.resourcePlanName = resourcePlanName
    self.poolPath = poolPath
    self.allocFraction = allocFraction
    self.queryParallelism = queryParallelism
    self.schedulingPolicy = schedulingPolicy
    self.isSetSchedulingPolicy = isSetSchedulingPolicy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.allocFraction = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.queryParallelism = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.schedulingPolicy = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.isSetSchedulingPolicy = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMNullablePool')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 2)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    if self.allocFraction is not None:
      oprot.writeFieldBegin('allocFraction', TType.DOUBLE, 3)
      oprot.writeDouble(self.allocFraction)
      oprot.writeFieldEnd()
    if self.queryParallelism is not None:
      oprot.writeFieldBegin('queryParallelism', TType.I32, 4)
      oprot.writeI32(self.queryParallelism)
      oprot.writeFieldEnd()
    if self.schedulingPolicy is not None:
      oprot.writeFieldBegin('schedulingPolicy', TType.STRING, 5)
      oprot.writeString(self.schedulingPolicy)
      oprot.writeFieldEnd()
    if self.isSetSchedulingPolicy is not None:
      oprot.writeFieldBegin('isSetSchedulingPolicy', TType.BOOL, 6)
      oprot.writeBool(self.isSetSchedulingPolicy)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.resourcePlanName is None:
      raise TProtocol.TProtocolException(message='Required field resourcePlanName is unset!')
    if self.poolPath is None:
      raise TProtocol.TProtocolException(message='Required field poolPath is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.poolPath)
    value = (value * 31) ^ hash(self.allocFraction)
    value = (value * 31) ^ hash(self.queryParallelism)
    value = (value * 31) ^ hash(self.schedulingPolicy)
    value = (value * 31) ^ hash(self.isSetSchedulingPolicy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMTrigger:
  """
  Attributes:
   - resourcePlanName
   - triggerName
   - triggerExpression
   - actionExpression
   - isInUnmanaged
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'triggerName', None, None, ), # 2
    (3, TType.STRING, 'triggerExpression', None, None, ), # 3
    (4, TType.STRING, 'actionExpression', None, None, ), # 4
    (5, TType.BOOL, 'isInUnmanaged', None, None, ), # 5
  )

  def __init__(self, resourcePlanName=None, triggerName=None, triggerExpression=None, actionExpression=None, isInUnmanaged=None,):
    self.resourcePlanName = resourcePlanName
    self.triggerName = triggerName
    self.triggerExpression = triggerExpression
    self.actionExpression = actionExpression
    self.isInUnmanaged = isInUnmanaged

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.triggerName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.triggerExpression = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.actionExpression = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isInUnmanaged = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMTrigger')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.triggerName is not None:
      oprot.writeFieldBegin('triggerName', TType.STRING, 2)
      oprot.writeString(self.triggerName)
      oprot.writeFieldEnd()
    if self.triggerExpression is not None:
      oprot.writeFieldBegin('triggerExpression', TType.STRING, 3)
      oprot.writeString(self.triggerExpression)
      oprot.writeFieldEnd()
    if self.actionExpression is not None:
      oprot.writeFieldBegin('actionExpression', TType.STRING, 4)
      oprot.writeString(self.actionExpression)
      oprot.writeFieldEnd()
    if self.isInUnmanaged is not None:
      oprot.writeFieldBegin('isInUnmanaged', TType.BOOL, 5)
      oprot.writeBool(self.isInUnmanaged)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.resourcePlanName is None:
      raise TProtocol.TProtocolException(message='Required field resourcePlanName is unset!')
    if self.triggerName is None:
      raise TProtocol.TProtocolException(message='Required field triggerName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.triggerName)
    value = (value * 31) ^ hash(self.triggerExpression)
    value = (value * 31) ^ hash(self.actionExpression)
    value = (value * 31) ^ hash(self.isInUnmanaged)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMMapping:
  """
  Attributes:
   - resourcePlanName
   - entityType
   - entityName
   - poolPath
   - ordering
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'entityType', None, None, ), # 2
    (3, TType.STRING, 'entityName', None, None, ), # 3
    (4, TType.STRING, 'poolPath', None, None, ), # 4
    (5, TType.I32, 'ordering', None, None, ), # 5
  )

  def __init__(self, resourcePlanName=None, entityType=None, entityName=None, poolPath=None, ordering=None,):
    self.resourcePlanName = resourcePlanName
    self.entityType = entityType
    self.entityName = entityName
    self.poolPath = poolPath
    self.ordering = ordering

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.entityName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ordering = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMMapping')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.entityType is not None:
      oprot.writeFieldBegin('entityType', TType.STRING, 2)
      oprot.writeString(self.entityType)
      oprot.writeFieldEnd()
    if self.entityName is not None:
      oprot.writeFieldBegin('entityName', TType.STRING, 3)
      oprot.writeString(self.entityName)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 4)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    if self.ordering is not None:
      oprot.writeFieldBegin('ordering', TType.I32, 5)
      oprot.writeI32(self.ordering)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.resourcePlanName is None:
      raise TProtocol.TProtocolException(message='Required field resourcePlanName is unset!')
    if self.entityType is None:
      raise TProtocol.TProtocolException(message='Required field entityType is unset!')
    if self.entityName is None:
      raise TProtocol.TProtocolException(message='Required field entityName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.entityType)
    value = (value * 31) ^ hash(self.entityName)
    value = (value * 31) ^ hash(self.poolPath)
    value = (value * 31) ^ hash(self.ordering)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMPoolTrigger:
  """
  Attributes:
   - pool
   - trigger
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool', None, None, ), # 1
    (2, TType.STRING, 'trigger', None, None, ), # 2
  )

  def __init__(self, pool=None, trigger=None,):
    self.pool = pool
    self.trigger = trigger

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.trigger = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMPoolTrigger')
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.STRING, 1)
      oprot.writeString(self.pool)
      oprot.writeFieldEnd()
    if self.trigger is not None:
      oprot.writeFieldBegin('trigger', TType.STRING, 2)
      oprot.writeString(self.trigger)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pool is None:
      raise TProtocol.TProtocolException(message='Required field pool is unset!')
    if self.trigger is None:
      raise TProtocol.TProtocolException(message='Required field trigger is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.trigger)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMFullResourcePlan:
  """
  Attributes:
   - plan
   - pools
   - mappings
   - triggers
   - poolTriggers
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'plan', (WMResourcePlan, WMResourcePlan.thrift_spec), None, ), # 1
    (2, TType.LIST, 'pools', (TType.STRUCT,(WMPool, WMPool.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'mappings', (TType.STRUCT,(WMMapping, WMMapping.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'triggers', (TType.STRUCT,(WMTrigger, WMTrigger.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'poolTriggers', (TType.STRUCT,(WMPoolTrigger, WMPoolTrigger.thrift_spec)), None, ), # 5
  )

  def __init__(self, plan=None, pools=None, mappings=None, triggers=None, poolTriggers=None,):
    self.plan = plan
    self.pools = pools
    self.mappings = mappings
    self.triggers = triggers
    self.poolTriggers = poolTriggers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.plan = WMResourcePlan()
          self.plan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.pools = []
          (_etype742, _size739) = iprot.readListBegin()
          for _i743 in xrange(_size739):
            _elem744 = WMPool()
            _elem744.read(iprot)
            self.pools.append(_elem744)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mappings = []
          (_etype748, _size745) = iprot.readListBegin()
          for _i749 in xrange(_size745):
            _elem750 = WMMapping()
            _elem750.read(iprot)
            self.mappings.append(_elem750)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.triggers = []
          (_etype754, _size751) = iprot.readListBegin()
          for _i755 in xrange(_size751):
            _elem756 = WMTrigger()
            _elem756.read(iprot)
            self.triggers.append(_elem756)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.poolTriggers = []
          (_etype760, _size757) = iprot.readListBegin()
          for _i761 in xrange(_size757):
            _elem762 = WMPoolTrigger()
            _elem762.read(iprot)
            self.poolTriggers.append(_elem762)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMFullResourcePlan')
    if self.plan is not None:
      oprot.writeFieldBegin('plan', TType.STRUCT, 1)
      self.plan.write(oprot)
      oprot.writeFieldEnd()
    if self.pools is not None:
      oprot.writeFieldBegin('pools', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.pools))
      for iter763 in self.pools:
        iter763.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.mappings is not None:
      oprot.writeFieldBegin('mappings', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.mappings))
      for iter764 in self.mappings:
        iter764.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.triggers is not None:
      oprot.writeFieldBegin('triggers', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.triggers))
      for iter765 in self.triggers:
        iter765.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.poolTriggers is not None:
      oprot.writeFieldBegin('poolTriggers', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.poolTriggers))
      for iter766 in self.poolTriggers:
        iter766.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.plan is None:
      raise TProtocol.TProtocolException(message='Required field plan is unset!')
    if self.pools is None:
      raise TProtocol.TProtocolException(message='Required field pools is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.plan)
    value = (value * 31) ^ hash(self.pools)
    value = (value * 31) ^ hash(self.mappings)
    value = (value * 31) ^ hash(self.triggers)
    value = (value * 31) ^ hash(self.poolTriggers)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateResourcePlanRequest:
  """
  Attributes:
   - resourcePlan
   - copyFrom
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'resourcePlan', (WMResourcePlan, WMResourcePlan.thrift_spec), None, ), # 1
    (2, TType.STRING, 'copyFrom', None, None, ), # 2
  )

  def __init__(self, resourcePlan=None, copyFrom=None,):
    self.resourcePlan = resourcePlan
    self.copyFrom = copyFrom

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.resourcePlan = WMResourcePlan()
          self.resourcePlan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.copyFrom = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateResourcePlanRequest')
    if self.resourcePlan is not None:
      oprot.writeFieldBegin('resourcePlan', TType.STRUCT, 1)
      self.resourcePlan.write(oprot)
      oprot.writeFieldEnd()
    if self.copyFrom is not None:
      oprot.writeFieldBegin('copyFrom', TType.STRING, 2)
      oprot.writeString(self.copyFrom)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlan)
    value = (value * 31) ^ hash(self.copyFrom)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateResourcePlanResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateResourcePlanResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetActiveResourcePlanRequest:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetActiveResourcePlanRequest')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetActiveResourcePlanResponse:
  """
  Attributes:
   - resourcePlan
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'resourcePlan', (WMFullResourcePlan, WMFullResourcePlan.thrift_spec), None, ), # 1
  )

  def __init__(self, resourcePlan=None,):
    self.resourcePlan = resourcePlan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.resourcePlan = WMFullResourcePlan()
          self.resourcePlan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetActiveResourcePlanResponse')
    if self.resourcePlan is not None:
      oprot.writeFieldBegin('resourcePlan', TType.STRUCT, 1)
      self.resourcePlan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetResourcePlanRequest:
  """
  Attributes:
   - resourcePlanName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
  )

  def __init__(self, resourcePlanName=None,):
    self.resourcePlanName = resourcePlanName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetResourcePlanRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetResourcePlanResponse:
  """
  Attributes:
   - resourcePlan
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'resourcePlan', (WMFullResourcePlan, WMFullResourcePlan.thrift_spec), None, ), # 1
  )

  def __init__(self, resourcePlan=None,):
    self.resourcePlan = resourcePlan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.resourcePlan = WMFullResourcePlan()
          self.resourcePlan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetResourcePlanResponse')
    if self.resourcePlan is not None:
      oprot.writeFieldBegin('resourcePlan', TType.STRUCT, 1)
      self.resourcePlan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetAllResourcePlanRequest:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetAllResourcePlanRequest')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetAllResourcePlanResponse:
  """
  Attributes:
   - resourcePlans
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'resourcePlans', (TType.STRUCT,(WMResourcePlan, WMResourcePlan.thrift_spec)), None, ), # 1
  )

  def __init__(self, resourcePlans=None,):
    self.resourcePlans = resourcePlans

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.resourcePlans = []
          (_etype770, _size767) = iprot.readListBegin()
          for _i771 in xrange(_size767):
            _elem772 = WMResourcePlan()
            _elem772.read(iprot)
            self.resourcePlans.append(_elem772)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetAllResourcePlanResponse')
    if self.resourcePlans is not None:
      oprot.writeFieldBegin('resourcePlans', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.resourcePlans))
      for iter773 in self.resourcePlans:
        iter773.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlans)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterResourcePlanRequest:
  """
  Attributes:
   - resourcePlanName
   - resourcePlan
   - isEnableAndActivate
   - isForceDeactivate
   - isReplace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRUCT, 'resourcePlan', (WMNullableResourcePlan, WMNullableResourcePlan.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'isEnableAndActivate', None, None, ), # 3
    (4, TType.BOOL, 'isForceDeactivate', None, None, ), # 4
    (5, TType.BOOL, 'isReplace', None, None, ), # 5
  )

  def __init__(self, resourcePlanName=None, resourcePlan=None, isEnableAndActivate=None, isForceDeactivate=None, isReplace=None,):
    self.resourcePlanName = resourcePlanName
    self.resourcePlan = resourcePlan
    self.isEnableAndActivate = isEnableAndActivate
    self.isForceDeactivate = isForceDeactivate
    self.isReplace = isReplace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.resourcePlan = WMNullableResourcePlan()
          self.resourcePlan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isEnableAndActivate = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isForceDeactivate = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isReplace = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterResourcePlanRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.resourcePlan is not None:
      oprot.writeFieldBegin('resourcePlan', TType.STRUCT, 2)
      self.resourcePlan.write(oprot)
      oprot.writeFieldEnd()
    if self.isEnableAndActivate is not None:
      oprot.writeFieldBegin('isEnableAndActivate', TType.BOOL, 3)
      oprot.writeBool(self.isEnableAndActivate)
      oprot.writeFieldEnd()
    if self.isForceDeactivate is not None:
      oprot.writeFieldBegin('isForceDeactivate', TType.BOOL, 4)
      oprot.writeBool(self.isForceDeactivate)
      oprot.writeFieldEnd()
    if self.isReplace is not None:
      oprot.writeFieldBegin('isReplace', TType.BOOL, 5)
      oprot.writeBool(self.isReplace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.resourcePlan)
    value = (value * 31) ^ hash(self.isEnableAndActivate)
    value = (value * 31) ^ hash(self.isForceDeactivate)
    value = (value * 31) ^ hash(self.isReplace)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterResourcePlanResponse:
  """
  Attributes:
   - fullResourcePlan
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fullResourcePlan', (WMFullResourcePlan, WMFullResourcePlan.thrift_spec), None, ), # 1
  )

  def __init__(self, fullResourcePlan=None,):
    self.fullResourcePlan = fullResourcePlan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fullResourcePlan = WMFullResourcePlan()
          self.fullResourcePlan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterResourcePlanResponse')
    if self.fullResourcePlan is not None:
      oprot.writeFieldBegin('fullResourcePlan', TType.STRUCT, 1)
      self.fullResourcePlan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fullResourcePlan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMValidateResourcePlanRequest:
  """
  Attributes:
   - resourcePlanName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
  )

  def __init__(self, resourcePlanName=None,):
    self.resourcePlanName = resourcePlanName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMValidateResourcePlanRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMValidateResourcePlanResponse:
  """
  Attributes:
   - errors
   - warnings
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'errors', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'warnings', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, errors=None, warnings=None,):
    self.errors = errors
    self.warnings = warnings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.errors = []
          (_etype777, _size774) = iprot.readListBegin()
          for _i778 in xrange(_size774):
            _elem779 = iprot.readString()
            self.errors.append(_elem779)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.warnings = []
          (_etype783, _size780) = iprot.readListBegin()
          for _i784 in xrange(_size780):
            _elem785 = iprot.readString()
            self.warnings.append(_elem785)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMValidateResourcePlanResponse')
    if self.errors is not None:
      oprot.writeFieldBegin('errors', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.errors))
      for iter786 in self.errors:
        oprot.writeString(iter786)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.warnings is not None:
      oprot.writeFieldBegin('warnings', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.warnings))
      for iter787 in self.warnings:
        oprot.writeString(iter787)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.errors)
    value = (value * 31) ^ hash(self.warnings)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropResourcePlanRequest:
  """
  Attributes:
   - resourcePlanName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
  )

  def __init__(self, resourcePlanName=None,):
    self.resourcePlanName = resourcePlanName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropResourcePlanRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropResourcePlanResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropResourcePlanResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateTriggerRequest:
  """
  Attributes:
   - trigger
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'trigger', (WMTrigger, WMTrigger.thrift_spec), None, ), # 1
  )

  def __init__(self, trigger=None,):
    self.trigger = trigger

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.trigger = WMTrigger()
          self.trigger.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateTriggerRequest')
    if self.trigger is not None:
      oprot.writeFieldBegin('trigger', TType.STRUCT, 1)
      self.trigger.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.trigger)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateTriggerResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateTriggerResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterTriggerRequest:
  """
  Attributes:
   - trigger
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'trigger', (WMTrigger, WMTrigger.thrift_spec), None, ), # 1
  )

  def __init__(self, trigger=None,):
    self.trigger = trigger

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.trigger = WMTrigger()
          self.trigger.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterTriggerRequest')
    if self.trigger is not None:
      oprot.writeFieldBegin('trigger', TType.STRUCT, 1)
      self.trigger.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.trigger)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterTriggerResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterTriggerResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropTriggerRequest:
  """
  Attributes:
   - resourcePlanName
   - triggerName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'triggerName', None, None, ), # 2
  )

  def __init__(self, resourcePlanName=None, triggerName=None,):
    self.resourcePlanName = resourcePlanName
    self.triggerName = triggerName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.triggerName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropTriggerRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.triggerName is not None:
      oprot.writeFieldBegin('triggerName', TType.STRING, 2)
      oprot.writeString(self.triggerName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.triggerName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropTriggerResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropTriggerResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetTriggersForResourePlanRequest:
  """
  Attributes:
   - resourcePlanName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
  )

  def __init__(self, resourcePlanName=None,):
    self.resourcePlanName = resourcePlanName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetTriggersForResourePlanRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetTriggersForResourePlanResponse:
  """
  Attributes:
   - triggers
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'triggers', (TType.STRUCT,(WMTrigger, WMTrigger.thrift_spec)), None, ), # 1
  )

  def __init__(self, triggers=None,):
    self.triggers = triggers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.triggers = []
          (_etype791, _size788) = iprot.readListBegin()
          for _i792 in xrange(_size788):
            _elem793 = WMTrigger()
            _elem793.read(iprot)
            self.triggers.append(_elem793)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetTriggersForResourePlanResponse')
    if self.triggers is not None:
      oprot.writeFieldBegin('triggers', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.triggers))
      for iter794 in self.triggers:
        iter794.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.triggers)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreatePoolRequest:
  """
  Attributes:
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pool', (WMPool, WMPool.thrift_spec), None, ), # 1
  )

  def __init__(self, pool=None,):
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pool = WMPool()
          self.pool.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreatePoolRequest')
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.STRUCT, 1)
      self.pool.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreatePoolResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreatePoolResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterPoolRequest:
  """
  Attributes:
   - pool
   - poolPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pool', (WMNullablePool, WMNullablePool.thrift_spec), None, ), # 1
    (2, TType.STRING, 'poolPath', None, None, ), # 2
  )

  def __init__(self, pool=None, poolPath=None,):
    self.pool = pool
    self.poolPath = poolPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pool = WMNullablePool()
          self.pool.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterPoolRequest')
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.STRUCT, 1)
      self.pool.write(oprot)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 2)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.poolPath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterPoolResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterPoolResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropPoolRequest:
  """
  Attributes:
   - resourcePlanName
   - poolPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'poolPath', None, None, ), # 2
  )

  def __init__(self, resourcePlanName=None, poolPath=None,):
    self.resourcePlanName = resourcePlanName
    self.poolPath = poolPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropPoolRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 2)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.poolPath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropPoolResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropPoolResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateOrUpdateMappingRequest:
  """
  Attributes:
   - mapping
   - update
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mapping', (WMMapping, WMMapping.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'update', None, None, ), # 2
  )

  def __init__(self, mapping=None, update=None,):
    self.mapping = mapping
    self.update = update

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mapping = WMMapping()
          self.mapping.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.update = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateOrUpdateMappingRequest')
    if self.mapping is not None:
      oprot.writeFieldBegin('mapping', TType.STRUCT, 1)
      self.mapping.write(oprot)
      oprot.writeFieldEnd()
    if self.update is not None:
      oprot.writeFieldBegin('update', TType.BOOL, 2)
      oprot.writeBool(self.update)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mapping)
    value = (value * 31) ^ hash(self.update)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateOrUpdateMappingResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateOrUpdateMappingResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropMappingRequest:
  """
  Attributes:
   - mapping
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mapping', (WMMapping, WMMapping.thrift_spec), None, ), # 1
  )

  def __init__(self, mapping=None,):
    self.mapping = mapping

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mapping = WMMapping()
          self.mapping.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropMappingRequest')
    if self.mapping is not None:
      oprot.writeFieldBegin('mapping', TType.STRUCT, 1)
      self.mapping.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mapping)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropMappingResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropMappingResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateOrDropTriggerToPoolMappingRequest:
  """
  Attributes:
   - resourcePlanName
   - triggerName
   - poolPath
   - drop
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'triggerName', None, None, ), # 2
    (3, TType.STRING, 'poolPath', None, None, ), # 3
    (4, TType.BOOL, 'drop', None, None, ), # 4
  )

  def __init__(self, resourcePlanName=None, triggerName=None, poolPath=None, drop=None,):
    self.resourcePlanName = resourcePlanName
    self.triggerName = triggerName
    self.poolPath = poolPath
    self.drop = drop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.triggerName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.drop = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateOrDropTriggerToPoolMappingRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.triggerName is not None:
      oprot.writeFieldBegin('triggerName', TType.STRING, 2)
      oprot.writeString(self.triggerName)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 3)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    if self.drop is not None:
      oprot.writeFieldBegin('drop', TType.BOOL, 4)
      oprot.writeBool(self.drop)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.triggerName)
    value = (value * 31) ^ hash(self.poolPath)
    value = (value * 31) ^ hash(self.drop)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateOrDropTriggerToPoolMappingResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateOrDropTriggerToPoolMappingResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ISchema:
  """
  Attributes:
   - schemaType
   - name
   - catName
   - dbName
   - compatibility
   - validationLevel
   - canEvolve
   - schemaGroup
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'schemaType', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'catName', None, None, ), # 3
    (4, TType.STRING, 'dbName', None, None, ), # 4
    (5, TType.I32, 'compatibility', None, None, ), # 5
    (6, TType.I32, 'validationLevel', None, None, ), # 6
    (7, TType.BOOL, 'canEvolve', None, None, ), # 7
    (8, TType.STRING, 'schemaGroup', None, None, ), # 8
    (9, TType.STRING, 'description', None, None, ), # 9
  )

  def __init__(self, schemaType=None, name=None, catName=None, dbName=None, compatibility=None, validationLevel=None, canEvolve=None, schemaGroup=None, description=None,):
    self.schemaType = schemaType
    self.name = name
    self.catName = catName
    self.dbName = dbName
    self.compatibility = compatibility
    self.validationLevel = validationLevel
    self.canEvolve = canEvolve
    self.schemaGroup = schemaGroup
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.schemaType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.compatibility = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.validationLevel = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.canEvolve = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.schemaGroup = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.description = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ISchema')
    if self.schemaType is not None:
      oprot.writeFieldBegin('schemaType', TType.I32, 1)
      oprot.writeI32(self.schemaType)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 3)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 4)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.compatibility is not None:
      oprot.writeFieldBegin('compatibility', TType.I32, 5)
      oprot.writeI32(self.compatibility)
      oprot.writeFieldEnd()
    if self.validationLevel is not None:
      oprot.writeFieldBegin('validationLevel', TType.I32, 6)
      oprot.writeI32(self.validationLevel)
      oprot.writeFieldEnd()
    if self.canEvolve is not None:
      oprot.writeFieldBegin('canEvolve', TType.BOOL, 7)
      oprot.writeBool(self.canEvolve)
      oprot.writeFieldEnd()
    if self.schemaGroup is not None:
      oprot.writeFieldBegin('schemaGroup', TType.STRING, 8)
      oprot.writeString(self.schemaGroup)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 9)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.schemaType)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.compatibility)
    value = (value * 31) ^ hash(self.validationLevel)
    value = (value * 31) ^ hash(self.canEvolve)
    value = (value * 31) ^ hash(self.schemaGroup)
    value = (value * 31) ^ hash(self.description)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ISchemaName:
  """
  Attributes:
   - catName
   - dbName
   - schemaName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'catName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'schemaName', None, None, ), # 3
  )

  def __init__(self, catName=None, dbName=None, schemaName=None,):
    self.catName = catName
    self.dbName = dbName
    self.schemaName = schemaName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.catName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ISchemaName')
    if self.catName is not None:
      oprot.writeFieldBegin('catName', TType.STRING, 1)
      oprot.writeString(self.catName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 3)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.catName)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.schemaName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AlterISchemaRequest:
  """
  Attributes:
   - name
   - newSchema
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'name', (ISchemaName, ISchemaName.thrift_spec), None, ), # 1
    None, # 2
    (3, TType.STRUCT, 'newSchema', (ISchema, ISchema.thrift_spec), None, ), # 3
  )

  def __init__(self, name=None, newSchema=None,):
    self.name = name
    self.newSchema = newSchema

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.name = ISchemaName()
          self.name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.newSchema = ISchema()
          self.newSchema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AlterISchemaRequest')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRUCT, 1)
      self.name.write(oprot)
      oprot.writeFieldEnd()
    if self.newSchema is not None:
      oprot.writeFieldBegin('newSchema', TType.STRUCT, 3)
      self.newSchema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.newSchema)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SchemaVersion:
  """
  Attributes:
   - schema
   - version
   - createdAt
   - cols
   - state
   - description
   - schemaText
   - fingerprint
   - name
   - serDe
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'schema', (ISchemaName, ISchemaName.thrift_spec), None, ), # 1
    (2, TType.I32, 'version', None, None, ), # 2
    (3, TType.I64, 'createdAt', None, None, ), # 3
    (4, TType.LIST, 'cols', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 4
    (5, TType.I32, 'state', None, None, ), # 5
    (6, TType.STRING, 'description', None, None, ), # 6
    (7, TType.STRING, 'schemaText', None, None, ), # 7
    (8, TType.STRING, 'fingerprint', None, None, ), # 8
    (9, TType.STRING, 'name', None, None, ), # 9
    (10, TType.STRUCT, 'serDe', (SerDeInfo, SerDeInfo.thrift_spec), None, ), # 10
  )

  def __init__(self, schema=None, version=None, createdAt=None, cols=None, state=None, description=None, schemaText=None, fingerprint=None, name=None, serDe=None,):
    self.schema = schema
    self.version = version
    self.createdAt = createdAt
    self.cols = cols
    self.state = state
    self.description = description
    self.schemaText = schemaText
    self.fingerprint = fingerprint
    self.name = name
    self.serDe = serDe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.schema = ISchemaName()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.createdAt = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.cols = []
          (_etype798, _size795) = iprot.readListBegin()
          for _i799 in xrange(_size795):
            _elem800 = FieldSchema()
            _elem800.read(iprot)
            self.cols.append(_elem800)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.description = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.schemaText = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.fingerprint = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.serDe = SerDeInfo()
          self.serDe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SchemaVersion')
    if self.schema is not None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 1)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 2)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.createdAt is not None:
      oprot.writeFieldBegin('createdAt', TType.I64, 3)
      oprot.writeI64(self.createdAt)
      oprot.writeFieldEnd()
    if self.cols is not None:
      oprot.writeFieldBegin('cols', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.cols))
      for iter801 in self.cols:
        iter801.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 5)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 6)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.schemaText is not None:
      oprot.writeFieldBegin('schemaText', TType.STRING, 7)
      oprot.writeString(self.schemaText)
      oprot.writeFieldEnd()
    if self.fingerprint is not None:
      oprot.writeFieldBegin('fingerprint', TType.STRING, 8)
      oprot.writeString(self.fingerprint)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 9)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.serDe is not None:
      oprot.writeFieldBegin('serDe', TType.STRUCT, 10)
      self.serDe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.schema)
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.createdAt)
    value = (value * 31) ^ hash(self.cols)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.schemaText)
    value = (value * 31) ^ hash(self.fingerprint)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.serDe)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SchemaVersionDescriptor:
  """
  Attributes:
   - schema
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'schema', (ISchemaName, ISchemaName.thrift_spec), None, ), # 1
    (2, TType.I32, 'version', None, None, ), # 2
  )

  def __init__(self, schema=None, version=None,):
    self.schema = schema
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.schema = ISchemaName()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.version = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SchemaVersionDescriptor')
    if self.schema is not None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 1)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 2)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.schema)
    value = (value * 31) ^ hash(self.version)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FindSchemasByColsRqst:
  """
  Attributes:
   - colName
   - colNamespace
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'colName', None, None, ), # 1
    (2, TType.STRING, 'colNamespace', None, None, ), # 2
    (3, TType.STRING, 'type', None, None, ), # 3
  )

  def __init__(self, colName=None, colNamespace=None, type=None,):
    self.colName = colName
    self.colNamespace = colNamespace
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.colName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colNamespace = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FindSchemasByColsRqst')
    if self.colName is not None:
      oprot.writeFieldBegin('colName', TType.STRING, 1)
      oprot.writeString(self.colName)
      oprot.writeFieldEnd()
    if self.colNamespace is not None:
      oprot.writeFieldBegin('colNamespace', TType.STRING, 2)
      oprot.writeString(self.colNamespace)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 3)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.colName)
    value = (value * 31) ^ hash(self.colNamespace)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FindSchemasByColsResp:
  """
  Attributes:
   - schemaVersions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'schemaVersions', (TType.STRUCT,(SchemaVersionDescriptor, SchemaVersionDescriptor.thrift_spec)), None, ), # 1
  )

  def __init__(self, schemaVersions=None,):
    self.schemaVersions = schemaVersions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.schemaVersions = []
          (_etype805, _size802) = iprot.readListBegin()
          for _i806 in xrange(_size802):
            _elem807 = SchemaVersionDescriptor()
            _elem807.read(iprot)
            self.schemaVersions.append(_elem807)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FindSchemasByColsResp')
    if self.schemaVersions is not None:
      oprot.writeFieldBegin('schemaVersions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.schemaVersions))
      for iter808 in self.schemaVersions:
        iter808.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.schemaVersions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MapSchemaVersionToSerdeRequest:
  """
  Attributes:
   - schemaVersion
   - serdeName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'schemaVersion', (SchemaVersionDescriptor, SchemaVersionDescriptor.thrift_spec), None, ), # 1
    (2, TType.STRING, 'serdeName', None, None, ), # 2
  )

  def __init__(self, schemaVersion=None, serdeName=None,):
    self.schemaVersion = schemaVersion
    self.serdeName = serdeName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.schemaVersion = SchemaVersionDescriptor()
          self.schemaVersion.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serdeName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MapSchemaVersionToSerdeRequest')
    if self.schemaVersion is not None:
      oprot.writeFieldBegin('schemaVersion', TType.STRUCT, 1)
      self.schemaVersion.write(oprot)
      oprot.writeFieldEnd()
    if self.serdeName is not None:
      oprot.writeFieldBegin('serdeName', TType.STRING, 2)
      oprot.writeString(self.serdeName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.schemaVersion)
    value = (value * 31) ^ hash(self.serdeName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSchemaVersionStateRequest:
  """
  Attributes:
   - schemaVersion
   - state
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'schemaVersion', (SchemaVersionDescriptor, SchemaVersionDescriptor.thrift_spec), None, ), # 1
    (2, TType.I32, 'state', None, None, ), # 2
  )

  def __init__(self, schemaVersion=None, state=None,):
    self.schemaVersion = schemaVersion
    self.state = state

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.schemaVersion = SchemaVersionDescriptor()
          self.schemaVersion.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSchemaVersionStateRequest')
    if self.schemaVersion is not None:
      oprot.writeFieldBegin('schemaVersion', TType.STRUCT, 1)
      self.schemaVersion.write(oprot)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 2)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.schemaVersion)
    value = (value * 31) ^ hash(self.state)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSerdeRequest:
  """
  Attributes:
   - serdeName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'serdeName', None, None, ), # 1
  )

  def __init__(self, serdeName=None,):
    self.serdeName = serdeName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.serdeName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSerdeRequest')
    if self.serdeName is not None:
      oprot.writeFieldBegin('serdeName', TType.STRING, 1)
      oprot.writeString(self.serdeName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.serdeName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetaException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetaException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownTableException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownTableException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownDBException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownDBException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AlreadyExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AlreadyExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidPartitionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidPartitionException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownPartitionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownPartitionException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidObjectException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidObjectException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchObjectException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchObjectException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidOperationException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidOperationException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigValSecurityException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigValSecurityException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidInputException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidInputException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchTxnException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchTxnException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TxnAbortedException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TxnAbortedException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TxnOpenException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TxnOpenException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchLockException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchLockException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
