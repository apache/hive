#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
import fb303.FacebookService
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(fb303.FacebookService.Iface):
  """
  This interface is live.
  """
  def create_database(self, name, description):
    """
    Parameters:
     - name
     - description
    """
    pass

  def get_database(self, name):
    """
    Parameters:
     - name
    """
    pass

  def drop_database(self, name):
    """
    Parameters:
     - name
    """
    pass

  def get_databases(self, ):
    pass

  def get_type(self, name):
    """
    Parameters:
     - name
    """
    pass

  def create_type(self, type):
    """
    Parameters:
     - type
    """
    pass

  def drop_type(self, type):
    """
    Parameters:
     - type
    """
    pass

  def get_type_all(self, name):
    """
    Parameters:
     - name
    """
    pass

  def get_fields(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    pass

  def get_schema(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    pass

  def create_table(self, tbl):
    """
    Parameters:
     - tbl
    """
    pass

  def drop_table(self, dbname, name, deleteData):
    """
    Parameters:
     - dbname
     - name
     - deleteData
    """
    pass

  def get_tables(self, db_name, pattern):
    """
    Parameters:
     - db_name
     - pattern
    """
    pass

  def get_table(self, dbname, tbl_name):
    """
    Parameters:
     - dbname
     - tbl_name
    """
    pass

  def alter_table(self, dbname, tbl_name, new_tbl):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
    """
    pass

  def add_partition(self, new_part):
    """
    Parameters:
     - new_part
    """
    pass

  def append_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    pass

  def append_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    pass

  def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """
    pass

  def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """
    pass

  def get_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    pass

  def get_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    pass

  def get_partitions(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partition_names(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    pass

  def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    pass

  def alter_partition(self, db_name, tbl_name, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
    """
    pass

  def get_config_value(self, name, defaultValue):
    """
    Parameters:
     - name
     - defaultValue
    """
    pass

  def partition_name_to_vals(self, part_name):
    """
    Parameters:
     - part_name
    """
    pass

  def partition_name_to_spec(self, part_name):
    """
    Parameters:
     - part_name
    """
    pass

  def add_index(self, new_index, index_table):
    """
    Parameters:
     - new_index
     - index_table
    """
    pass

  def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """
    pass

  def get_index_by_name(self, db_name, tbl_name, index_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
    """
    pass

  def get_indexes(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass

  def get_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass


class Client(fb303.FacebookService.Client, Iface):
  """
  This interface is live.
  """
  def __init__(self, iprot, oprot=None):
    fb303.FacebookService.Client.__init__(self, iprot, oprot)

  def create_database(self, name, description):
    """
    Parameters:
     - name
     - description
    """
    self.send_create_database(name, description)
    return self.recv_create_database()

  def send_create_database(self, name, description):
    self._oprot.writeMessageBegin('create_database', TMessageType.CALL, self._seqid)
    args = create_database_args()
    args.name = name
    args.description = description
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_database failed: unknown result");

  def get_database(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_database(name)
    return self.recv_get_database()

  def send_get_database(self, name):
    self._oprot.writeMessageBegin('get_database', TMessageType.CALL, self._seqid)
    args = get_database_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_database failed: unknown result");

  def drop_database(self, name):
    """
    Parameters:
     - name
    """
    self.send_drop_database(name)
    return self.recv_drop_database()

  def send_drop_database(self, name):
    self._oprot.writeMessageBegin('drop_database', TMessageType.CALL, self._seqid)
    args = drop_database_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_database failed: unknown result");

  def get_databases(self, ):
    self.send_get_databases()
    return self.recv_get_databases()

  def send_get_databases(self, ):
    self._oprot.writeMessageBegin('get_databases', TMessageType.CALL, self._seqid)
    args = get_databases_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_databases(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_databases_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_databases failed: unknown result");

  def get_type(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_type(name)
    return self.recv_get_type()

  def send_get_type(self, name):
    self._oprot.writeMessageBegin('get_type', TMessageType.CALL, self._seqid)
    args = get_type_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type failed: unknown result");

  def create_type(self, type):
    """
    Parameters:
     - type
    """
    self.send_create_type(type)
    return self.recv_create_type()

  def send_create_type(self, type):
    self._oprot.writeMessageBegin('create_type', TMessageType.CALL, self._seqid)
    args = create_type_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    if result.o3 != None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_type failed: unknown result");

  def drop_type(self, type):
    """
    Parameters:
     - type
    """
    self.send_drop_type(type)
    return self.recv_drop_type()

  def send_drop_type(self, type):
    self._oprot.writeMessageBegin('drop_type', TMessageType.CALL, self._seqid)
    args = drop_type_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_type failed: unknown result");

  def get_type_all(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_type_all(name)
    return self.recv_get_type_all()

  def send_get_type_all(self, name):
    self._oprot.writeMessageBegin('get_type_all', TMessageType.CALL, self._seqid)
    args = get_type_all_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_type_all(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_type_all_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type_all failed: unknown result");

  def get_fields(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    self.send_get_fields(db_name, table_name)
    return self.recv_get_fields()

  def send_get_fields(self, db_name, table_name):
    self._oprot.writeMessageBegin('get_fields', TMessageType.CALL, self._seqid)
    args = get_fields_args()
    args.db_name = db_name
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_fields(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_fields_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    if result.o3 != None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields failed: unknown result");

  def get_schema(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    self.send_get_schema(db_name, table_name)
    return self.recv_get_schema()

  def send_get_schema(self, db_name, table_name):
    self._oprot.writeMessageBegin('get_schema', TMessageType.CALL, self._seqid)
    args = get_schema_args()
    args.db_name = db_name
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_schema(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_schema_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    if result.o3 != None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result");

  def create_table(self, tbl):
    """
    Parameters:
     - tbl
    """
    self.send_create_table(tbl)
    self.recv_create_table()

  def send_create_table(self, tbl):
    self._oprot.writeMessageBegin('create_table', TMessageType.CALL, self._seqid)
    args = create_table_args()
    args.tbl = tbl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    if result.o3 != None:
      raise result.o3
    if result.o4 != None:
      raise result.o4
    return

  def drop_table(self, dbname, name, deleteData):
    """
    Parameters:
     - dbname
     - name
     - deleteData
    """
    self.send_drop_table(dbname, name, deleteData)
    self.recv_drop_table()

  def send_drop_table(self, dbname, name, deleteData):
    self._oprot.writeMessageBegin('drop_table', TMessageType.CALL, self._seqid)
    args = drop_table_args()
    args.dbname = dbname
    args.name = name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 != None:
      raise result.o1
    if result.o3 != None:
      raise result.o3
    return

  def get_tables(self, db_name, pattern):
    """
    Parameters:
     - db_name
     - pattern
    """
    self.send_get_tables(db_name, pattern)
    return self.recv_get_tables()

  def send_get_tables(self, db_name, pattern):
    self._oprot.writeMessageBegin('get_tables', TMessageType.CALL, self._seqid)
    args = get_tables_args()
    args.db_name = db_name
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_tables(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_tables_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result");

  def get_table(self, dbname, tbl_name):
    """
    Parameters:
     - dbname
     - tbl_name
    """
    self.send_get_table(dbname, tbl_name)
    return self.recv_get_table()

  def send_get_table(self, dbname, tbl_name):
    self._oprot.writeMessageBegin('get_table', TMessageType.CALL, self._seqid)
    args = get_table_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table failed: unknown result");

  def alter_table(self, dbname, tbl_name, new_tbl):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
    """
    self.send_alter_table(dbname, tbl_name, new_tbl)
    self.recv_alter_table()

  def send_alter_table(self, dbname, tbl_name, new_tbl):
    self._oprot.writeMessageBegin('alter_table', TMessageType.CALL, self._seqid)
    args = alter_table_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.new_tbl = new_tbl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    return

  def add_partition(self, new_part):
    """
    Parameters:
     - new_part
    """
    self.send_add_partition(new_part)
    return self.recv_add_partition()

  def send_add_partition(self, new_part):
    self._oprot.writeMessageBegin('add_partition', TMessageType.CALL, self._seqid)
    args = add_partition_args()
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    if result.o3 != None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition failed: unknown result");

  def append_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    self.send_append_partition(db_name, tbl_name, part_vals)
    return self.recv_append_partition()

  def send_append_partition(self, db_name, tbl_name, part_vals):
    self._oprot.writeMessageBegin('append_partition', TMessageType.CALL, self._seqid)
    args = append_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = append_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    if result.o3 != None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition failed: unknown result");

  def append_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    self.send_append_partition_by_name(db_name, tbl_name, part_name)
    return self.recv_append_partition_by_name()

  def send_append_partition_by_name(self, db_name, tbl_name, part_name):
    self._oprot.writeMessageBegin('append_partition_by_name', TMessageType.CALL, self._seqid)
    args = append_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = append_partition_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    if result.o3 != None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name failed: unknown result");

  def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """
    self.send_drop_partition(db_name, tbl_name, part_vals, deleteData)
    return self.recv_drop_partition()

  def send_drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    self._oprot.writeMessageBegin('drop_partition', TMessageType.CALL, self._seqid)
    args = drop_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition failed: unknown result");

  def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """
    self.send_drop_partition_by_name(db_name, tbl_name, part_name, deleteData)
    return self.recv_drop_partition_by_name()

  def send_drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    self._oprot.writeMessageBegin('drop_partition_by_name', TMessageType.CALL, self._seqid)
    args = drop_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_partition_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name failed: unknown result");

  def get_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    self.send_get_partition(db_name, tbl_name, part_vals)
    return self.recv_get_partition()

  def send_get_partition(self, db_name, tbl_name, part_vals):
    self._oprot.writeMessageBegin('get_partition', TMessageType.CALL, self._seqid)
    args = get_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition failed: unknown result");

  def get_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    self.send_get_partition_by_name(db_name, tbl_name, part_name)
    return self.recv_get_partition_by_name()

  def send_get_partition_by_name(self, db_name, tbl_name, part_name):
    self._oprot.writeMessageBegin('get_partition_by_name', TMessageType.CALL, self._seqid)
    args = get_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_by_name failed: unknown result");

  def get_partitions(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partitions(db_name, tbl_name, max_parts)
    return self.recv_get_partitions()

  def send_get_partitions(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partitions', TMessageType.CALL, self._seqid)
    args = get_partitions_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions failed: unknown result");

  def get_partition_names(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partition_names(db_name, tbl_name, max_parts)
    return self.recv_get_partition_names()

  def send_get_partition_names(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partition_names', TMessageType.CALL, self._seqid)
    args = get_partition_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names failed: unknown result");

  def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    self.send_get_partitions_ps(db_name, tbl_name, part_vals, max_parts)
    return self.recv_get_partitions_ps()

  def send_get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    self._oprot.writeMessageBegin('get_partitions_ps', TMessageType.CALL, self._seqid)
    args = get_partitions_ps_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_ps(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_ps_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps failed: unknown result");

  def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    self.send_get_partition_names_ps(db_name, tbl_name, part_vals, max_parts)
    return self.recv_get_partition_names_ps()

  def send_get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    self._oprot.writeMessageBegin('get_partition_names_ps', TMessageType.CALL, self._seqid)
    args = get_partition_names_ps_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_names_ps(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_names_ps_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_ps failed: unknown result");

  def alter_partition(self, db_name, tbl_name, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
    """
    self.send_alter_partition(db_name, tbl_name, new_part)
    self.recv_alter_partition()

  def send_alter_partition(self, db_name, tbl_name, new_part):
    self._oprot.writeMessageBegin('alter_partition', TMessageType.CALL, self._seqid)
    args = alter_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    return

  def get_config_value(self, name, defaultValue):
    """
    Parameters:
     - name
     - defaultValue
    """
    self.send_get_config_value(name, defaultValue)
    return self.recv_get_config_value()

  def send_get_config_value(self, name, defaultValue):
    self._oprot.writeMessageBegin('get_config_value', TMessageType.CALL, self._seqid)
    args = get_config_value_args()
    args.name = name
    args.defaultValue = defaultValue
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_config_value(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_config_value_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_config_value failed: unknown result");

  def partition_name_to_vals(self, part_name):
    """
    Parameters:
     - part_name
    """
    self.send_partition_name_to_vals(part_name)
    return self.recv_partition_name_to_vals()

  def send_partition_name_to_vals(self, part_name):
    self._oprot.writeMessageBegin('partition_name_to_vals', TMessageType.CALL, self._seqid)
    args = partition_name_to_vals_args()
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_to_vals(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = partition_name_to_vals_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_vals failed: unknown result");

  def partition_name_to_spec(self, part_name):
    """
    Parameters:
     - part_name
    """
    self.send_partition_name_to_spec(part_name)
    return self.recv_partition_name_to_spec()

  def send_partition_name_to_spec(self, part_name):
    self._oprot.writeMessageBegin('partition_name_to_spec', TMessageType.CALL, self._seqid)
    args = partition_name_to_spec_args()
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_to_spec(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = partition_name_to_spec_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_spec failed: unknown result");

  def add_index(self, new_index, index_table):
    """
    Parameters:
     - new_index
     - index_table
    """
    self.send_add_index(new_index, index_table)
    return self.recv_add_index()

  def send_add_index(self, new_index, index_table):
    self._oprot.writeMessageBegin('add_index', TMessageType.CALL, self._seqid)
    args = add_index_args()
    args.new_index = new_index
    args.index_table = index_table
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    if result.o3 != None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_index failed: unknown result");

  def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """
    self.send_drop_index_by_name(db_name, tbl_name, index_name, deleteData)
    return self.recv_drop_index_by_name()

  def send_drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    self._oprot.writeMessageBegin('drop_index_by_name', TMessageType.CALL, self._seqid)
    args = drop_index_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.index_name = index_name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_index_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_index_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_index_by_name failed: unknown result");

  def get_index_by_name(self, db_name, tbl_name, index_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
    """
    self.send_get_index_by_name(db_name, tbl_name, index_name)
    return self.recv_get_index_by_name()

  def send_get_index_by_name(self, db_name, tbl_name, index_name):
    self._oprot.writeMessageBegin('get_index_by_name', TMessageType.CALL, self._seqid)
    args = get_index_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.index_name = index_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_index_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_index_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_by_name failed: unknown result");

  def get_indexes(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_indexes(db_name, tbl_name, max_indexes)
    return self.recv_get_indexes()

  def send_get_indexes(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_indexes', TMessageType.CALL, self._seqid)
    args = get_indexes_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_indexes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_indexes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o1 != None:
      raise result.o1
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_indexes failed: unknown result");

  def get_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_index_names(db_name, tbl_name, max_indexes)
    return self.recv_get_index_names()

  def send_get_index_names(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_index_names', TMessageType.CALL, self._seqid)
    args = get_index_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_index_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_index_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.o2 != None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_names failed: unknown result");


class Processor(fb303.FacebookService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    fb303.FacebookService.Processor.__init__(self, handler)
    self._processMap["create_database"] = Processor.process_create_database
    self._processMap["get_database"] = Processor.process_get_database
    self._processMap["drop_database"] = Processor.process_drop_database
    self._processMap["get_databases"] = Processor.process_get_databases
    self._processMap["get_type"] = Processor.process_get_type
    self._processMap["create_type"] = Processor.process_create_type
    self._processMap["drop_type"] = Processor.process_drop_type
    self._processMap["get_type_all"] = Processor.process_get_type_all
    self._processMap["get_fields"] = Processor.process_get_fields
    self._processMap["get_schema"] = Processor.process_get_schema
    self._processMap["create_table"] = Processor.process_create_table
    self._processMap["drop_table"] = Processor.process_drop_table
    self._processMap["get_tables"] = Processor.process_get_tables
    self._processMap["get_table"] = Processor.process_get_table
    self._processMap["alter_table"] = Processor.process_alter_table
    self._processMap["add_partition"] = Processor.process_add_partition
    self._processMap["append_partition"] = Processor.process_append_partition
    self._processMap["append_partition_by_name"] = Processor.process_append_partition_by_name
    self._processMap["drop_partition"] = Processor.process_drop_partition
    self._processMap["drop_partition_by_name"] = Processor.process_drop_partition_by_name
    self._processMap["get_partition"] = Processor.process_get_partition
    self._processMap["get_partition_by_name"] = Processor.process_get_partition_by_name
    self._processMap["get_partitions"] = Processor.process_get_partitions
    self._processMap["get_partition_names"] = Processor.process_get_partition_names
    self._processMap["get_partitions_ps"] = Processor.process_get_partitions_ps
    self._processMap["get_partition_names_ps"] = Processor.process_get_partition_names_ps
    self._processMap["alter_partition"] = Processor.process_alter_partition
    self._processMap["get_config_value"] = Processor.process_get_config_value
    self._processMap["partition_name_to_vals"] = Processor.process_partition_name_to_vals
    self._processMap["partition_name_to_spec"] = Processor.process_partition_name_to_spec
    self._processMap["add_index"] = Processor.process_add_index
    self._processMap["drop_index_by_name"] = Processor.process_drop_index_by_name
    self._processMap["get_index_by_name"] = Processor.process_get_index_by_name
    self._processMap["get_indexes"] = Processor.process_get_indexes
    self._processMap["get_index_names"] = Processor.process_get_index_names

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_create_database(self, seqid, iprot, oprot):
    args = create_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_database_result()
    try:
      result.success = self._handler.create_database(args.name, args.description)
    except AlreadyExistsException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("create_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_database(self, seqid, iprot, oprot):
    args = get_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_database_result()
    try:
      result.success = self._handler.get_database(args.name)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_database(self, seqid, iprot, oprot):
    args = drop_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_database_result()
    try:
      result.success = self._handler.drop_database(args.name)
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_databases(self, seqid, iprot, oprot):
    args = get_databases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_databases_result()
    try:
      result.success = self._handler.get_databases()
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_databases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_type(self, seqid, iprot, oprot):
    args = get_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_type_result()
    try:
      result.success = self._handler.get_type(args.name)
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_type(self, seqid, iprot, oprot):
    args = create_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_type_result()
    try:
      result.success = self._handler.create_type(args.type)
    except AlreadyExistsException, o1:
      result.o1 = o1
    except InvalidObjectException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("create_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_type(self, seqid, iprot, oprot):
    args = drop_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_type_result()
    try:
      result.success = self._handler.drop_type(args.type)
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_type_all(self, seqid, iprot, oprot):
    args = get_type_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_type_all_result()
    try:
      result.success = self._handler.get_type_all(args.name)
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_type_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_fields(self, seqid, iprot, oprot):
    args = get_fields_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_fields_result()
    try:
      result.success = self._handler.get_fields(args.db_name, args.table_name)
    except MetaException, o1:
      result.o1 = o1
    except UnknownTableException, o2:
      result.o2 = o2
    except UnknownDBException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("get_fields", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_schema(self, seqid, iprot, oprot):
    args = get_schema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_schema_result()
    try:
      result.success = self._handler.get_schema(args.db_name, args.table_name)
    except MetaException, o1:
      result.o1 = o1
    except UnknownTableException, o2:
      result.o2 = o2
    except UnknownDBException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("get_schema", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table(self, seqid, iprot, oprot):
    args = create_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_result()
    try:
      self._handler.create_table(args.tbl)
    except AlreadyExistsException, o1:
      result.o1 = o1
    except InvalidObjectException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    except NoSuchObjectException, o4:
      result.o4 = o4
    oprot.writeMessageBegin("create_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_table(self, seqid, iprot, oprot):
    args = drop_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_table_result()
    try:
      self._handler.drop_table(args.dbname, args.name, args.deleteData)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("drop_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_tables(self, seqid, iprot, oprot):
    args = get_tables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_tables_result()
    try:
      result.success = self._handler.get_tables(args.db_name, args.pattern)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_tables", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table(self, seqid, iprot, oprot):
    args = get_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_result()
    try:
      result.success = self._handler.get_table(args.dbname, args.tbl_name)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table(self, seqid, iprot, oprot):
    args = alter_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_result()
    try:
      self._handler.alter_table(args.dbname, args.tbl_name, args.new_tbl)
    except InvalidOperationException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition(self, seqid, iprot, oprot):
    args = add_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_result()
    try:
      result.success = self._handler.add_partition(args.new_part)
    except InvalidObjectException, o1:
      result.o1 = o1
    except AlreadyExistsException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("add_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition(self, seqid, iprot, oprot):
    args = append_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_result()
    try:
      result.success = self._handler.append_partition(args.db_name, args.tbl_name, args.part_vals)
    except InvalidObjectException, o1:
      result.o1 = o1
    except AlreadyExistsException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("append_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition_by_name(self, seqid, iprot, oprot):
    args = append_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_by_name_result()
    try:
      result.success = self._handler.append_partition_by_name(args.db_name, args.tbl_name, args.part_name)
    except InvalidObjectException, o1:
      result.o1 = o1
    except AlreadyExistsException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("append_partition_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition(self, seqid, iprot, oprot):
    args = drop_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_result()
    try:
      result.success = self._handler.drop_partition(args.db_name, args.tbl_name, args.part_vals, args.deleteData)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_by_name(self, seqid, iprot, oprot):
    args = drop_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_by_name_result()
    try:
      result.success = self._handler.drop_partition_by_name(args.db_name, args.tbl_name, args.part_name, args.deleteData)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_partition_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition(self, seqid, iprot, oprot):
    args = get_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_result()
    try:
      result.success = self._handler.get_partition(args.db_name, args.tbl_name, args.part_vals)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_by_name(self, seqid, iprot, oprot):
    args = get_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_by_name_result()
    try:
      result.success = self._handler.get_partition_by_name(args.db_name, args.tbl_name, args.part_name)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions(self, seqid, iprot, oprot):
    args = get_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_result()
    try:
      result.success = self._handler.get_partitions(args.db_name, args.tbl_name, args.max_parts)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_names(self, seqid, iprot, oprot):
    args = get_partition_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_names_result()
    try:
      result.success = self._handler.get_partition_names(args.db_name, args.tbl_name, args.max_parts)
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_ps(self, seqid, iprot, oprot):
    args = get_partitions_ps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_ps_result()
    try:
      result.success = self._handler.get_partitions_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_partitions_ps", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_names_ps(self, seqid, iprot, oprot):
    args = get_partition_names_ps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_names_ps_result()
    try:
      result.success = self._handler.get_partition_names_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_partition_names_ps", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partition(self, seqid, iprot, oprot):
    args = alter_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partition_result()
    try:
      self._handler.alter_partition(args.db_name, args.tbl_name, args.new_part)
    except InvalidOperationException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_config_value(self, seqid, iprot, oprot):
    args = get_config_value_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_config_value_result()
    try:
      result.success = self._handler.get_config_value(args.name, args.defaultValue)
    except ConfigValSecurityException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_config_value", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_to_vals(self, seqid, iprot, oprot):
    args = partition_name_to_vals_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_to_vals_result()
    try:
      result.success = self._handler.partition_name_to_vals(args.part_name)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("partition_name_to_vals", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_to_spec(self, seqid, iprot, oprot):
    args = partition_name_to_spec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_to_spec_result()
    try:
      result.success = self._handler.partition_name_to_spec(args.part_name)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("partition_name_to_spec", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_index(self, seqid, iprot, oprot):
    args = add_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_index_result()
    try:
      result.success = self._handler.add_index(args.new_index, args.index_table)
    except InvalidObjectException, o1:
      result.o1 = o1
    except AlreadyExistsException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("add_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_index_by_name(self, seqid, iprot, oprot):
    args = drop_index_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_index_by_name_result()
    try:
      result.success = self._handler.drop_index_by_name(args.db_name, args.tbl_name, args.index_name, args.deleteData)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_index_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_index_by_name(self, seqid, iprot, oprot):
    args = get_index_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_index_by_name_result()
    try:
      result.success = self._handler.get_index_by_name(args.db_name, args.tbl_name, args.index_name)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_index_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_indexes(self, seqid, iprot, oprot):
    args = get_indexes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_indexes_result()
    try:
      result.success = self._handler.get_indexes(args.db_name, args.tbl_name, args.max_indexes)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_indexes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_index_names(self, seqid, iprot, oprot):
    args = get_index_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_index_names_result()
    try:
      result.success = self._handler.get_index_names(args.db_name, args.tbl_name, args.max_indexes)
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_index_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class create_database_args:
  """
  Attributes:
   - name
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
  )

  def __init__(self, name=None, description=None,):
    self.name = name
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_database_args')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description != None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_database_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_database_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_database_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_database_args')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_database_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Database, Database.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Database()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_database_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_database_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_database_args')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_database_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    None, # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_database_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_databases_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_databases_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_databases_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype106, _size103) = iprot.readListBegin()
          for _i107 in xrange(_size103):
            _elem108 = iprot.readString();
            self.success.append(_elem108)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_databases_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter109 in self.success:
        oprot.writeString(iter109)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_args')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Type, Type.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Type()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_type_args:
  """
  Attributes:
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'type', (Type, Type.thrift_spec), None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.type = Type()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_type_args')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.STRUCT, 1)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_type_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 != None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_type_args:
  """
  Attributes:
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type', None, None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_type_args')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.STRING, 1)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_type_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_type_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_all_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_all_args')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_all_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Type, Type.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype111, _vtype112, _size110 ) = iprot.readMapBegin() 
          for _i114 in xrange(_size110):
            _key115 = iprot.readString();
            _val116 = Type()
            _val116.read(iprot)
            self.success[_key115] = _val116
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_all_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter117,viter118 in self.success.items():
        oprot.writeString(kiter117)
        viter118.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_args:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype122, _size119) = iprot.readListBegin()
          for _i123 in xrange(_size119):
            _elem124 = FieldSchema()
            _elem124.read(iprot)
            self.success.append(_elem124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter125 in self.success:
        iter125.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 != None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_args:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name != None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype129, _size126) = iprot.readListBegin()
          for _i130 in xrange(_size126):
            _elem131 = FieldSchema()
            _elem131.read(iprot)
            self.success.append(_elem131)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter132 in self.success:
        iter132.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 != None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_args:
  """
  Attributes:
   - tbl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
  )

  def __init__(self, tbl=None,):
    self.tbl = tbl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_args')
    if self.tbl != None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_result')
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 != None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 != None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_args:
  """
  Attributes:
   - dbname
   - name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.BOOL, 'deleteData', None, None, ), # 3
  )

  def __init__(self, dbname=None, name=None, deleteData=None,):
    self.dbname = dbname
    self.name = name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_args')
    if self.dbname != None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData != None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_result:
  """
  Attributes:
   - o1
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o3=None,):
    self.o1 = o1
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_result')
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 != None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 2)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_args:
  """
  Attributes:
   - db_name
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
  )

  def __init__(self, db_name=None, pattern=None,):
    self.db_name = db_name
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.pattern != None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype136, _size133) = iprot.readListBegin()
          for _i137 in xrange(_size133):
            _elem138 = iprot.readString();
            self.success.append(_elem138)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter139 in self.success:
        oprot.writeString(iter139)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_args:
  """
  Attributes:
   - dbname
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, dbname=None, tbl_name=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_args')
    if self.dbname != None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Table, Table.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Table()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - new_tbl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ), # 3
  )

  def __init__(self, dbname=None, tbl_name=None, new_tbl=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.new_tbl = new_tbl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_tbl = Table()
          self.new_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_args')
    if self.dbname != None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_tbl != None:
      oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
      self.new_tbl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_result')
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_args:
  """
  Attributes:
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 1
  )

  def __init__(self, new_part=None,):
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_args')
    if self.new_part != None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 != None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype143, _size140) = iprot.readListBegin()
          for _i144 in xrange(_size140):
            _elem145 = iprot.readString();
            self.part_vals.append(_elem145)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals != None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter146 in self.part_vals:
        oprot.writeString(iter146)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 != None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name != None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 != None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype150, _size147) = iprot.readListBegin()
          for _i151 in xrange(_size147):
            _elem152 = iprot.readString();
            self.part_vals.append(_elem152)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals != None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter153 in self.part_vals:
        oprot.writeString(iter153)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.deleteData != None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name != None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.deleteData != None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype157, _size154) = iprot.readListBegin()
          for _i158 in xrange(_size154):
            _elem159 = iprot.readString();
            self.part_vals.append(_elem159)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals != None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter160 in self.part_vals:
        oprot.writeString(iter160)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_by_name_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name != None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_by_name_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts != None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype164, _size161) = iprot.readListBegin()
          for _i165 in xrange(_size161):
            _elem166 = Partition()
            _elem166.read(iprot)
            self.success.append(_elem166)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter167 in self.success:
        iter167.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts != None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype171, _size168) = iprot.readListBegin()
          for _i172 in xrange(_size168):
            _elem173 = iprot.readString();
            self.success.append(_elem173)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter174 in self.success:
        oprot.writeString(iter174)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype178, _size175) = iprot.readListBegin()
          for _i179 in xrange(_size175):
            _elem180 = iprot.readString();
            self.part_vals.append(_elem180)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals != None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter181 in self.part_vals:
        oprot.writeString(iter181)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts != None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype185, _size182) = iprot.readListBegin()
          for _i186 in xrange(_size182):
            _elem187 = Partition()
            _elem187.read(iprot)
            self.success.append(_elem187)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter188 in self.success:
        iter188.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_ps_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype192, _size189) = iprot.readListBegin()
          for _i193 in xrange(_size189):
            _elem194 = iprot.readString();
            self.part_vals.append(_elem194)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_ps_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals != None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter195 in self.part_vals:
        oprot.writeString(iter195)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts != None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_ps_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype199, _size196) = iprot.readListBegin()
          for _i200 in xrange(_size196):
            _elem201 = iprot.readString();
            self.success.append(_elem201)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_ps_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter202 in self.success:
        oprot.writeString(iter202)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, new_part=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_part != None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_result')
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_config_value_args:
  """
  Attributes:
   - name
   - defaultValue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'defaultValue', None, None, ), # 2
  )

  def __init__(self, name=None, defaultValue=None,):
    self.name = name
    self.defaultValue = defaultValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.defaultValue = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_config_value_args')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.defaultValue != None:
      oprot.writeFieldBegin('defaultValue', TType.STRING, 2)
      oprot.writeString(self.defaultValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_config_value_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (ConfigValSecurityException, ConfigValSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = ConfigValSecurityException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_config_value_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_vals_args:
  """
  Attributes:
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'part_name', None, None, ), # 1
  )

  def __init__(self, part_name=None,):
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_vals_args')
    if self.part_name != None:
      oprot.writeFieldBegin('part_name', TType.STRING, 1)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_vals_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype206, _size203) = iprot.readListBegin()
          for _i207 in xrange(_size203):
            _elem208 = iprot.readString();
            self.success.append(_elem208)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_vals_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter209 in self.success:
        oprot.writeString(iter209)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_spec_args:
  """
  Attributes:
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'part_name', None, None, ), # 1
  )

  def __init__(self, part_name=None,):
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_spec_args')
    if self.part_name != None:
      oprot.writeFieldBegin('part_name', TType.STRING, 1)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_spec_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype211, _vtype212, _size210 ) = iprot.readMapBegin() 
          for _i214 in xrange(_size210):
            _key215 = iprot.readString();
            _val216 = iprot.readString();
            self.success[_key215] = _val216
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_spec_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter217,viter218 in self.success.items():
        oprot.writeString(kiter217)
        oprot.writeString(viter218)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_index_args:
  """
  Attributes:
   - new_index
   - index_table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'index_table', (Table, Table.thrift_spec), None, ), # 2
  )

  def __init__(self, new_index=None, index_table=None,):
    self.new_index = new_index
    self.index_table = index_table

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_index = Index()
          self.new_index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.index_table = Table()
          self.index_table.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_index_args')
    if self.new_index != None:
      oprot.writeFieldBegin('new_index', TType.STRUCT, 1)
      self.new_index.write(oprot)
      oprot.writeFieldEnd()
    if self.index_table != None:
      oprot.writeFieldBegin('index_table', TType.STRUCT, 2)
      self.index_table.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_index_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Index()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_index_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 != None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_index_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - index_name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'index_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, index_name=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.index_name = index_name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_index_by_name_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 3)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.deleteData != None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_index_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_index_by_name_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - index_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'index_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, index_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.index_name = index_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_by_name_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 3)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Index()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_by_name_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_indexes_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_indexes_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes != None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_indexes_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Index, Index.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype222, _size219) = iprot.readListBegin()
          for _i223 in xrange(_size219):
            _elem224 = Index()
            _elem224.read(iprot)
            self.success.append(_elem224)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_indexes_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter225 in self.success:
        iter225.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 != None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_names_args')
    if self.db_name != None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name != None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes != None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_names_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype229, _size226) = iprot.readListBegin()
          for _i230 in xrange(_size226):
            _elem231 = iprot.readString();
            self.success.append(_elem231)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_names_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter232 in self.success:
        oprot.writeString(iter232)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o2 != None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


