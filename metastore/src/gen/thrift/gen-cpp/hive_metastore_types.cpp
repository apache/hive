/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "hive_metastore_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Apache { namespace Hadoop { namespace Hive {

int _kHiveObjectTypeValues[] = {
  HiveObjectType::GLOBAL,
  HiveObjectType::DATABASE,
  HiveObjectType::TABLE,
  HiveObjectType::PARTITION,
  HiveObjectType::COLUMN
};
const char* _kHiveObjectTypeNames[] = {
  "GLOBAL",
  "DATABASE",
  "TABLE",
  "PARTITION",
  "COLUMN"
};
const std::map<int, const char*> _HiveObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kHiveObjectTypeValues, _kHiveObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPrincipalTypeValues[] = {
  PrincipalType::USER,
  PrincipalType::ROLE,
  PrincipalType::GROUP
};
const char* _kPrincipalTypeNames[] = {
  "USER",
  "ROLE",
  "GROUP"
};
const std::map<int, const char*> _PrincipalType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kPrincipalTypeValues, _kPrincipalTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPartitionEventTypeValues[] = {
  PartitionEventType::LOAD_DONE
};
const char* _kPartitionEventTypeNames[] = {
  "LOAD_DONE"
};
const std::map<int, const char*> _PartitionEventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kPartitionEventTypeValues, _kPartitionEventTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTxnStateValues[] = {
  TxnState::COMMITTED,
  TxnState::ABORTED,
  TxnState::OPEN
};
const char* _kTxnStateNames[] = {
  "COMMITTED",
  "ABORTED",
  "OPEN"
};
const std::map<int, const char*> _TxnState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTxnStateValues, _kTxnStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLockLevelValues[] = {
  LockLevel::DB,
  LockLevel::TABLE,
  LockLevel::PARTITION
};
const char* _kLockLevelNames[] = {
  "DB",
  "TABLE",
  "PARTITION"
};
const std::map<int, const char*> _LockLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLockLevelValues, _kLockLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLockStateValues[] = {
  LockState::ACQUIRED,
  LockState::WAITING,
  LockState::ABORT,
  LockState::NOT_ACQUIRED
};
const char* _kLockStateNames[] = {
  "ACQUIRED",
  "WAITING",
  "ABORT",
  "NOT_ACQUIRED"
};
const std::map<int, const char*> _LockState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kLockStateValues, _kLockStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLockTypeValues[] = {
  LockType::SHARED_READ,
  LockType::SHARED_WRITE,
  LockType::EXCLUSIVE
};
const char* _kLockTypeNames[] = {
  "SHARED_READ",
  "SHARED_WRITE",
  "EXCLUSIVE"
};
const std::map<int, const char*> _LockType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLockTypeValues, _kLockTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCompactionTypeValues[] = {
  CompactionType::MINOR,
  CompactionType::MAJOR
};
const char* _kCompactionTypeNames[] = {
  "MINOR",
  "MAJOR"
};
const std::map<int, const char*> _CompactionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCompactionTypeValues, _kCompactionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGrantRevokeTypeValues[] = {
  GrantRevokeType::GRANT,
  GrantRevokeType::REVOKE
};
const char* _kGrantRevokeTypeNames[] = {
  "GRANT",
  "REVOKE"
};
const std::map<int, const char*> _GrantRevokeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGrantRevokeTypeValues, _kGrantRevokeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEventRequestTypeValues[] = {
  EventRequestType::INSERT,
  EventRequestType::UPDATE,
  EventRequestType::DELETE
};
const char* _kEventRequestTypeNames[] = {
  "INSERT",
  "UPDATE",
  "DELETE"
};
const std::map<int, const char*> _EventRequestType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kEventRequestTypeValues, _kEventRequestTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFunctionTypeValues[] = {
  FunctionType::JAVA
};
const char* _kFunctionTypeNames[] = {
  "JAVA"
};
const std::map<int, const char*> _FunctionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kFunctionTypeValues, _kFunctionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kResourceTypeValues[] = {
  ResourceType::JAR,
  ResourceType::FILE,
  ResourceType::ARCHIVE
};
const char* _kResourceTypeNames[] = {
  "JAR",
  "FILE",
  "ARCHIVE"
};
const std::map<int, const char*> _ResourceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kResourceTypeValues, _kResourceTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Version::~Version() throw() {
}


void Version::__set_version(const std::string& val) {
  this->version = val;
}

void Version::__set_comments(const std::string& val) {
  this->comments = val;
}

uint32_t Version::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comments);
          this->__isset.comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Version::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Version");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comments", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->comments);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Version &a, Version &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.comments, b.comments);
  swap(a.__isset, b.__isset);
}

Version::Version(const Version& other0) {
  version = other0.version;
  comments = other0.comments;
  __isset = other0.__isset;
}
Version& Version::operator=(const Version& other1) {
  version = other1.version;
  comments = other1.comments;
  __isset = other1.__isset;
  return *this;
}
void Version::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Version(";
  out << "version=" << to_string(version);
  out << ", " << "comments=" << to_string(comments);
  out << ")";
}


FieldSchema::~FieldSchema() throw() {
}


void FieldSchema::__set_name(const std::string& val) {
  this->name = val;
}

void FieldSchema::__set_type(const std::string& val) {
  this->type = val;
}

void FieldSchema::__set_comment(const std::string& val) {
  this->comment = val;
}

uint32_t FieldSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FieldSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FieldSchema");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FieldSchema &a, FieldSchema &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

FieldSchema::FieldSchema(const FieldSchema& other2) {
  name = other2.name;
  type = other2.type;
  comment = other2.comment;
  __isset = other2.__isset;
}
FieldSchema& FieldSchema::operator=(const FieldSchema& other3) {
  name = other3.name;
  type = other3.type;
  comment = other3.comment;
  __isset = other3.__isset;
  return *this;
}
void FieldSchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FieldSchema(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "comment=" << to_string(comment);
  out << ")";
}


Type::~Type() throw() {
}


void Type::__set_name(const std::string& val) {
  this->name = val;
}

void Type::__set_type1(const std::string& val) {
  this->type1 = val;
__isset.type1 = true;
}

void Type::__set_type2(const std::string& val) {
  this->type2 = val;
__isset.type2 = true;
}

void Type::__set_fields(const std::vector<FieldSchema> & val) {
  this->fields = val;
__isset.fields = true;
}

uint32_t Type::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type1);
          this->__isset.type1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type2);
          this->__isset.type2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->fields.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->fields[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Type::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Type");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type1) {
    xfer += oprot->writeFieldBegin("type1", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->type1);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type2) {
    xfer += oprot->writeFieldBegin("type2", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->type2);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fields) {
    xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
      std::vector<FieldSchema> ::const_iterator _iter9;
      for (_iter9 = this->fields.begin(); _iter9 != this->fields.end(); ++_iter9)
      {
        xfer += (*_iter9).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Type &a, Type &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type1, b.type1);
  swap(a.type2, b.type2);
  swap(a.fields, b.fields);
  swap(a.__isset, b.__isset);
}

Type::Type(const Type& other10) {
  name = other10.name;
  type1 = other10.type1;
  type2 = other10.type2;
  fields = other10.fields;
  __isset = other10.__isset;
}
Type& Type::operator=(const Type& other11) {
  name = other11.name;
  type1 = other11.type1;
  type2 = other11.type2;
  fields = other11.fields;
  __isset = other11.__isset;
  return *this;
}
void Type::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Type(";
  out << "name=" << to_string(name);
  out << ", " << "type1="; (__isset.type1 ? (out << to_string(type1)) : (out << "<null>"));
  out << ", " << "type2="; (__isset.type2 ? (out << to_string(type2)) : (out << "<null>"));
  out << ", " << "fields="; (__isset.fields ? (out << to_string(fields)) : (out << "<null>"));
  out << ")";
}


HiveObjectRef::~HiveObjectRef() throw() {
}


void HiveObjectRef::__set_objectType(const HiveObjectType::type val) {
  this->objectType = val;
}

void HiveObjectRef::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void HiveObjectRef::__set_objectName(const std::string& val) {
  this->objectName = val;
}

void HiveObjectRef::__set_partValues(const std::vector<std::string> & val) {
  this->partValues = val;
}

void HiveObjectRef::__set_columnName(const std::string& val) {
  this->columnName = val;
}

uint32_t HiveObjectRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->objectType = (HiveObjectType::type)ecast12;
          this->__isset.objectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectName);
          this->__isset.objectName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partValues.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->partValues.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += iprot->readString(this->partValues[_i17]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          this->__isset.columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HiveObjectRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HiveObjectRef");

  xfer += oprot->writeFieldBegin("objectType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->objectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->objectName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partValues", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partValues.size()));
    std::vector<std::string> ::const_iterator _iter18;
    for (_iter18 = this->partValues.begin(); _iter18 != this->partValues.end(); ++_iter18)
    {
      xfer += oprot->writeString((*_iter18));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveObjectRef &a, HiveObjectRef &b) {
  using ::std::swap;
  swap(a.objectType, b.objectType);
  swap(a.dbName, b.dbName);
  swap(a.objectName, b.objectName);
  swap(a.partValues, b.partValues);
  swap(a.columnName, b.columnName);
  swap(a.__isset, b.__isset);
}

HiveObjectRef::HiveObjectRef(const HiveObjectRef& other19) {
  objectType = other19.objectType;
  dbName = other19.dbName;
  objectName = other19.objectName;
  partValues = other19.partValues;
  columnName = other19.columnName;
  __isset = other19.__isset;
}
HiveObjectRef& HiveObjectRef::operator=(const HiveObjectRef& other20) {
  objectType = other20.objectType;
  dbName = other20.dbName;
  objectName = other20.objectName;
  partValues = other20.partValues;
  columnName = other20.columnName;
  __isset = other20.__isset;
  return *this;
}
void HiveObjectRef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HiveObjectRef(";
  out << "objectType=" << to_string(objectType);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "objectName=" << to_string(objectName);
  out << ", " << "partValues=" << to_string(partValues);
  out << ", " << "columnName=" << to_string(columnName);
  out << ")";
}


PrivilegeGrantInfo::~PrivilegeGrantInfo() throw() {
}


void PrivilegeGrantInfo::__set_privilege(const std::string& val) {
  this->privilege = val;
}

void PrivilegeGrantInfo::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void PrivilegeGrantInfo::__set_grantor(const std::string& val) {
  this->grantor = val;
}

void PrivilegeGrantInfo::__set_grantorType(const PrincipalType::type val) {
  this->grantorType = val;
}

void PrivilegeGrantInfo::__set_grantOption(const bool val) {
  this->grantOption = val;
}

uint32_t PrivilegeGrantInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->privilege);
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantor);
          this->__isset.grantor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->grantorType = (PrincipalType::type)ecast21;
          this->__isset.grantorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrivilegeGrantInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrivilegeGrantInfo");

  xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->privilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantor", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->grantor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->grantorType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->grantOption);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrivilegeGrantInfo &a, PrivilegeGrantInfo &b) {
  using ::std::swap;
  swap(a.privilege, b.privilege);
  swap(a.createTime, b.createTime);
  swap(a.grantor, b.grantor);
  swap(a.grantorType, b.grantorType);
  swap(a.grantOption, b.grantOption);
  swap(a.__isset, b.__isset);
}

PrivilegeGrantInfo::PrivilegeGrantInfo(const PrivilegeGrantInfo& other22) {
  privilege = other22.privilege;
  createTime = other22.createTime;
  grantor = other22.grantor;
  grantorType = other22.grantorType;
  grantOption = other22.grantOption;
  __isset = other22.__isset;
}
PrivilegeGrantInfo& PrivilegeGrantInfo::operator=(const PrivilegeGrantInfo& other23) {
  privilege = other23.privilege;
  createTime = other23.createTime;
  grantor = other23.grantor;
  grantorType = other23.grantorType;
  grantOption = other23.grantOption;
  __isset = other23.__isset;
  return *this;
}
void PrivilegeGrantInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrivilegeGrantInfo(";
  out << "privilege=" << to_string(privilege);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "grantor=" << to_string(grantor);
  out << ", " << "grantorType=" << to_string(grantorType);
  out << ", " << "grantOption=" << to_string(grantOption);
  out << ")";
}


HiveObjectPrivilege::~HiveObjectPrivilege() throw() {
}


void HiveObjectPrivilege::__set_hiveObject(const HiveObjectRef& val) {
  this->hiveObject = val;
}

void HiveObjectPrivilege::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void HiveObjectPrivilege::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void HiveObjectPrivilege::__set_grantInfo(const PrivilegeGrantInfo& val) {
  this->grantInfo = val;
}

uint32_t HiveObjectPrivilege::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hiveObject.read(iprot);
          this->__isset.hiveObject = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->principalType = (PrincipalType::type)ecast24;
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->grantInfo.read(iprot);
          this->__isset.grantInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HiveObjectPrivilege::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HiveObjectPrivilege");

  xfer += oprot->writeFieldBegin("hiveObject", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->hiveObject.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->principalType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantInfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->grantInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveObjectPrivilege &a, HiveObjectPrivilege &b) {
  using ::std::swap;
  swap(a.hiveObject, b.hiveObject);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantInfo, b.grantInfo);
  swap(a.__isset, b.__isset);
}

HiveObjectPrivilege::HiveObjectPrivilege(const HiveObjectPrivilege& other25) {
  hiveObject = other25.hiveObject;
  principalName = other25.principalName;
  principalType = other25.principalType;
  grantInfo = other25.grantInfo;
  __isset = other25.__isset;
}
HiveObjectPrivilege& HiveObjectPrivilege::operator=(const HiveObjectPrivilege& other26) {
  hiveObject = other26.hiveObject;
  principalName = other26.principalName;
  principalType = other26.principalType;
  grantInfo = other26.grantInfo;
  __isset = other26.__isset;
  return *this;
}
void HiveObjectPrivilege::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HiveObjectPrivilege(";
  out << "hiveObject=" << to_string(hiveObject);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantInfo=" << to_string(grantInfo);
  out << ")";
}


PrivilegeBag::~PrivilegeBag() throw() {
}


void PrivilegeBag::__set_privileges(const std::vector<HiveObjectPrivilege> & val) {
  this->privileges = val;
}

uint32_t PrivilegeBag::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->privileges.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->privileges.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->privileges[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrivilegeBag::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrivilegeBag");

  xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->privileges.size()));
    std::vector<HiveObjectPrivilege> ::const_iterator _iter32;
    for (_iter32 = this->privileges.begin(); _iter32 != this->privileges.end(); ++_iter32)
    {
      xfer += (*_iter32).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrivilegeBag &a, PrivilegeBag &b) {
  using ::std::swap;
  swap(a.privileges, b.privileges);
  swap(a.__isset, b.__isset);
}

PrivilegeBag::PrivilegeBag(const PrivilegeBag& other33) {
  privileges = other33.privileges;
  __isset = other33.__isset;
}
PrivilegeBag& PrivilegeBag::operator=(const PrivilegeBag& other34) {
  privileges = other34.privileges;
  __isset = other34.__isset;
  return *this;
}
void PrivilegeBag::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrivilegeBag(";
  out << "privileges=" << to_string(privileges);
  out << ")";
}


PrincipalPrivilegeSet::~PrincipalPrivilegeSet() throw() {
}


void PrincipalPrivilegeSet::__set_userPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->userPrivileges = val;
}

void PrincipalPrivilegeSet::__set_groupPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->groupPrivileges = val;
}

void PrincipalPrivilegeSet::__set_rolePrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->rolePrivileges = val;
}

uint32_t PrincipalPrivilegeSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->userPrivileges.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _ktype36;
            ::apache::thrift::protocol::TType _vtype37;
            xfer += iprot->readMapBegin(_ktype36, _vtype37, _size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              std::string _key40;
              xfer += iprot->readString(_key40);
              std::vector<PrivilegeGrantInfo> & _val41 = this->userPrivileges[_key40];
              {
                _val41.clear();
                uint32_t _size42;
                ::apache::thrift::protocol::TType _etype45;
                xfer += iprot->readListBegin(_etype45, _size42);
                _val41.resize(_size42);
                uint32_t _i46;
                for (_i46 = 0; _i46 < _size42; ++_i46)
                {
                  xfer += _val41[_i46].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.userPrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->groupPrivileges.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _ktype48;
            ::apache::thrift::protocol::TType _vtype49;
            xfer += iprot->readMapBegin(_ktype48, _vtype49, _size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              std::string _key52;
              xfer += iprot->readString(_key52);
              std::vector<PrivilegeGrantInfo> & _val53 = this->groupPrivileges[_key52];
              {
                _val53.clear();
                uint32_t _size54;
                ::apache::thrift::protocol::TType _etype57;
                xfer += iprot->readListBegin(_etype57, _size54);
                _val53.resize(_size54);
                uint32_t _i58;
                for (_i58 = 0; _i58 < _size54; ++_i58)
                {
                  xfer += _val53[_i58].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.groupPrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->rolePrivileges.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _ktype60;
            ::apache::thrift::protocol::TType _vtype61;
            xfer += iprot->readMapBegin(_ktype60, _vtype61, _size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              std::string _key64;
              xfer += iprot->readString(_key64);
              std::vector<PrivilegeGrantInfo> & _val65 = this->rolePrivileges[_key64];
              {
                _val65.clear();
                uint32_t _size66;
                ::apache::thrift::protocol::TType _etype69;
                xfer += iprot->readListBegin(_etype69, _size66);
                _val65.resize(_size66);
                uint32_t _i70;
                for (_i70 = 0; _i70 < _size66; ++_i70)
                {
                  xfer += _val65[_i70].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.rolePrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrincipalPrivilegeSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrincipalPrivilegeSet");

  xfer += oprot->writeFieldBegin("userPrivileges", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->userPrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter71;
    for (_iter71 = this->userPrivileges.begin(); _iter71 != this->userPrivileges.end(); ++_iter71)
    {
      xfer += oprot->writeString(_iter71->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter71->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter72;
        for (_iter72 = _iter71->second.begin(); _iter72 != _iter71->second.end(); ++_iter72)
        {
          xfer += (*_iter72).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupPrivileges", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->groupPrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter73;
    for (_iter73 = this->groupPrivileges.begin(); _iter73 != this->groupPrivileges.end(); ++_iter73)
    {
      xfer += oprot->writeString(_iter73->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter73->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter74;
        for (_iter74 = _iter73->second.begin(); _iter74 != _iter73->second.end(); ++_iter74)
        {
          xfer += (*_iter74).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rolePrivileges", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->rolePrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter75;
    for (_iter75 = this->rolePrivileges.begin(); _iter75 != this->rolePrivileges.end(); ++_iter75)
    {
      xfer += oprot->writeString(_iter75->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter75->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter76;
        for (_iter76 = _iter75->second.begin(); _iter76 != _iter75->second.end(); ++_iter76)
        {
          xfer += (*_iter76).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrincipalPrivilegeSet &a, PrincipalPrivilegeSet &b) {
  using ::std::swap;
  swap(a.userPrivileges, b.userPrivileges);
  swap(a.groupPrivileges, b.groupPrivileges);
  swap(a.rolePrivileges, b.rolePrivileges);
  swap(a.__isset, b.__isset);
}

PrincipalPrivilegeSet::PrincipalPrivilegeSet(const PrincipalPrivilegeSet& other77) {
  userPrivileges = other77.userPrivileges;
  groupPrivileges = other77.groupPrivileges;
  rolePrivileges = other77.rolePrivileges;
  __isset = other77.__isset;
}
PrincipalPrivilegeSet& PrincipalPrivilegeSet::operator=(const PrincipalPrivilegeSet& other78) {
  userPrivileges = other78.userPrivileges;
  groupPrivileges = other78.groupPrivileges;
  rolePrivileges = other78.rolePrivileges;
  __isset = other78.__isset;
  return *this;
}
void PrincipalPrivilegeSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrincipalPrivilegeSet(";
  out << "userPrivileges=" << to_string(userPrivileges);
  out << ", " << "groupPrivileges=" << to_string(groupPrivileges);
  out << ", " << "rolePrivileges=" << to_string(rolePrivileges);
  out << ")";
}


GrantRevokePrivilegeRequest::~GrantRevokePrivilegeRequest() throw() {
}


void GrantRevokePrivilegeRequest::__set_requestType(const GrantRevokeType::type val) {
  this->requestType = val;
}

void GrantRevokePrivilegeRequest::__set_privileges(const PrivilegeBag& val) {
  this->privileges = val;
}

void GrantRevokePrivilegeRequest::__set_revokeGrantOption(const bool val) {
  this->revokeGrantOption = val;
__isset.revokeGrantOption = true;
}

uint32_t GrantRevokePrivilegeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast79;
          xfer += iprot->readI32(ecast79);
          this->requestType = (GrantRevokeType::type)ecast79;
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->revokeGrantOption);
          this->__isset.revokeGrantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokePrivilegeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokePrivilegeRequest");

  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->requestType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->privileges.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.revokeGrantOption) {
    xfer += oprot->writeFieldBegin("revokeGrantOption", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->revokeGrantOption);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokePrivilegeRequest &a, GrantRevokePrivilegeRequest &b) {
  using ::std::swap;
  swap(a.requestType, b.requestType);
  swap(a.privileges, b.privileges);
  swap(a.revokeGrantOption, b.revokeGrantOption);
  swap(a.__isset, b.__isset);
}

GrantRevokePrivilegeRequest::GrantRevokePrivilegeRequest(const GrantRevokePrivilegeRequest& other80) {
  requestType = other80.requestType;
  privileges = other80.privileges;
  revokeGrantOption = other80.revokeGrantOption;
  __isset = other80.__isset;
}
GrantRevokePrivilegeRequest& GrantRevokePrivilegeRequest::operator=(const GrantRevokePrivilegeRequest& other81) {
  requestType = other81.requestType;
  privileges = other81.privileges;
  revokeGrantOption = other81.revokeGrantOption;
  __isset = other81.__isset;
  return *this;
}
void GrantRevokePrivilegeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokePrivilegeRequest(";
  out << "requestType=" << to_string(requestType);
  out << ", " << "privileges=" << to_string(privileges);
  out << ", " << "revokeGrantOption="; (__isset.revokeGrantOption ? (out << to_string(revokeGrantOption)) : (out << "<null>"));
  out << ")";
}


GrantRevokePrivilegeResponse::~GrantRevokePrivilegeResponse() throw() {
}


void GrantRevokePrivilegeResponse::__set_success(const bool val) {
  this->success = val;
__isset.success = true;
}

uint32_t GrantRevokePrivilegeResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokePrivilegeResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokePrivilegeResponse");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokePrivilegeResponse &a, GrantRevokePrivilegeResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.__isset, b.__isset);
}

GrantRevokePrivilegeResponse::GrantRevokePrivilegeResponse(const GrantRevokePrivilegeResponse& other82) {
  success = other82.success;
  __isset = other82.__isset;
}
GrantRevokePrivilegeResponse& GrantRevokePrivilegeResponse::operator=(const GrantRevokePrivilegeResponse& other83) {
  success = other83.success;
  __isset = other83.__isset;
  return *this;
}
void GrantRevokePrivilegeResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokePrivilegeResponse(";
  out << "success="; (__isset.success ? (out << to_string(success)) : (out << "<null>"));
  out << ")";
}


Role::~Role() throw() {
}


void Role::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void Role::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Role::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

uint32_t Role::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Role::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Role");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Role &a, Role &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
  swap(a.createTime, b.createTime);
  swap(a.ownerName, b.ownerName);
  swap(a.__isset, b.__isset);
}

Role::Role(const Role& other84) {
  roleName = other84.roleName;
  createTime = other84.createTime;
  ownerName = other84.ownerName;
  __isset = other84.__isset;
}
Role& Role::operator=(const Role& other85) {
  roleName = other85.roleName;
  createTime = other85.createTime;
  ownerName = other85.ownerName;
  __isset = other85.__isset;
  return *this;
}
void Role::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Role(";
  out << "roleName=" << to_string(roleName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ")";
}


RolePrincipalGrant::~RolePrincipalGrant() throw() {
}


void RolePrincipalGrant::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void RolePrincipalGrant::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void RolePrincipalGrant::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void RolePrincipalGrant::__set_grantOption(const bool val) {
  this->grantOption = val;
}

void RolePrincipalGrant::__set_grantTime(const int32_t val) {
  this->grantTime = val;
}

void RolePrincipalGrant::__set_grantorName(const std::string& val) {
  this->grantorName = val;
}

void RolePrincipalGrant::__set_grantorPrincipalType(const PrincipalType::type val) {
  this->grantorPrincipalType = val;
}

uint32_t RolePrincipalGrant::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast86;
          xfer += iprot->readI32(ecast86);
          this->principalType = (PrincipalType::type)ecast86;
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->grantTime);
          this->__isset.grantTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantorName);
          this->__isset.grantorName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast87;
          xfer += iprot->readI32(ecast87);
          this->grantorPrincipalType = (PrincipalType::type)ecast87;
          this->__isset.grantorPrincipalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RolePrincipalGrant::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RolePrincipalGrant");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->principalType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->grantOption);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->grantTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorName", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->grantorName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorPrincipalType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->grantorPrincipalType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RolePrincipalGrant &a, RolePrincipalGrant &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantOption, b.grantOption);
  swap(a.grantTime, b.grantTime);
  swap(a.grantorName, b.grantorName);
  swap(a.grantorPrincipalType, b.grantorPrincipalType);
  swap(a.__isset, b.__isset);
}

RolePrincipalGrant::RolePrincipalGrant(const RolePrincipalGrant& other88) {
  roleName = other88.roleName;
  principalName = other88.principalName;
  principalType = other88.principalType;
  grantOption = other88.grantOption;
  grantTime = other88.grantTime;
  grantorName = other88.grantorName;
  grantorPrincipalType = other88.grantorPrincipalType;
  __isset = other88.__isset;
}
RolePrincipalGrant& RolePrincipalGrant::operator=(const RolePrincipalGrant& other89) {
  roleName = other89.roleName;
  principalName = other89.principalName;
  principalType = other89.principalType;
  grantOption = other89.grantOption;
  grantTime = other89.grantTime;
  grantorName = other89.grantorName;
  grantorPrincipalType = other89.grantorPrincipalType;
  __isset = other89.__isset;
  return *this;
}
void RolePrincipalGrant::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RolePrincipalGrant(";
  out << "roleName=" << to_string(roleName);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantOption=" << to_string(grantOption);
  out << ", " << "grantTime=" << to_string(grantTime);
  out << ", " << "grantorName=" << to_string(grantorName);
  out << ", " << "grantorPrincipalType=" << to_string(grantorPrincipalType);
  out << ")";
}


GetRoleGrantsForPrincipalRequest::~GetRoleGrantsForPrincipalRequest() throw() {
}


void GetRoleGrantsForPrincipalRequest::__set_principal_name(const std::string& val) {
  this->principal_name = val;
}

void GetRoleGrantsForPrincipalRequest::__set_principal_type(const PrincipalType::type val) {
  this->principal_type = val;
}

uint32_t GetRoleGrantsForPrincipalRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principal_name = false;
  bool isset_principal_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principal_name);
          isset_principal_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast90;
          xfer += iprot->readI32(ecast90);
          this->principal_type = (PrincipalType::type)ecast90;
          isset_principal_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principal_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_principal_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRoleGrantsForPrincipalRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRoleGrantsForPrincipalRequest");

  xfer += oprot->writeFieldBegin("principal_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->principal_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principal_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->principal_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRoleGrantsForPrincipalRequest &a, GetRoleGrantsForPrincipalRequest &b) {
  using ::std::swap;
  swap(a.principal_name, b.principal_name);
  swap(a.principal_type, b.principal_type);
}

GetRoleGrantsForPrincipalRequest::GetRoleGrantsForPrincipalRequest(const GetRoleGrantsForPrincipalRequest& other91) {
  principal_name = other91.principal_name;
  principal_type = other91.principal_type;
}
GetRoleGrantsForPrincipalRequest& GetRoleGrantsForPrincipalRequest::operator=(const GetRoleGrantsForPrincipalRequest& other92) {
  principal_name = other92.principal_name;
  principal_type = other92.principal_type;
  return *this;
}
void GetRoleGrantsForPrincipalRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRoleGrantsForPrincipalRequest(";
  out << "principal_name=" << to_string(principal_name);
  out << ", " << "principal_type=" << to_string(principal_type);
  out << ")";
}


GetRoleGrantsForPrincipalResponse::~GetRoleGrantsForPrincipalResponse() throw() {
}


void GetRoleGrantsForPrincipalResponse::__set_principalGrants(const std::vector<RolePrincipalGrant> & val) {
  this->principalGrants = val;
}

uint32_t GetRoleGrantsForPrincipalResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principalGrants = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->principalGrants.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->principalGrants.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += this->principalGrants[_i97].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_principalGrants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principalGrants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRoleGrantsForPrincipalResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRoleGrantsForPrincipalResponse");

  xfer += oprot->writeFieldBegin("principalGrants", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->principalGrants.size()));
    std::vector<RolePrincipalGrant> ::const_iterator _iter98;
    for (_iter98 = this->principalGrants.begin(); _iter98 != this->principalGrants.end(); ++_iter98)
    {
      xfer += (*_iter98).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRoleGrantsForPrincipalResponse &a, GetRoleGrantsForPrincipalResponse &b) {
  using ::std::swap;
  swap(a.principalGrants, b.principalGrants);
}

GetRoleGrantsForPrincipalResponse::GetRoleGrantsForPrincipalResponse(const GetRoleGrantsForPrincipalResponse& other99) {
  principalGrants = other99.principalGrants;
}
GetRoleGrantsForPrincipalResponse& GetRoleGrantsForPrincipalResponse::operator=(const GetRoleGrantsForPrincipalResponse& other100) {
  principalGrants = other100.principalGrants;
  return *this;
}
void GetRoleGrantsForPrincipalResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRoleGrantsForPrincipalResponse(";
  out << "principalGrants=" << to_string(principalGrants);
  out << ")";
}


GetPrincipalsInRoleRequest::~GetPrincipalsInRoleRequest() throw() {
}


void GetPrincipalsInRoleRequest::__set_roleName(const std::string& val) {
  this->roleName = val;
}

uint32_t GetPrincipalsInRoleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_roleName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          isset_roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_roleName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPrincipalsInRoleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPrincipalsInRoleRequest");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPrincipalsInRoleRequest &a, GetPrincipalsInRoleRequest &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
}

GetPrincipalsInRoleRequest::GetPrincipalsInRoleRequest(const GetPrincipalsInRoleRequest& other101) {
  roleName = other101.roleName;
}
GetPrincipalsInRoleRequest& GetPrincipalsInRoleRequest::operator=(const GetPrincipalsInRoleRequest& other102) {
  roleName = other102.roleName;
  return *this;
}
void GetPrincipalsInRoleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPrincipalsInRoleRequest(";
  out << "roleName=" << to_string(roleName);
  out << ")";
}


GetPrincipalsInRoleResponse::~GetPrincipalsInRoleResponse() throw() {
}


void GetPrincipalsInRoleResponse::__set_principalGrants(const std::vector<RolePrincipalGrant> & val) {
  this->principalGrants = val;
}

uint32_t GetPrincipalsInRoleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principalGrants = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->principalGrants.clear();
            uint32_t _size103;
            ::apache::thrift::protocol::TType _etype106;
            xfer += iprot->readListBegin(_etype106, _size103);
            this->principalGrants.resize(_size103);
            uint32_t _i107;
            for (_i107 = 0; _i107 < _size103; ++_i107)
            {
              xfer += this->principalGrants[_i107].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_principalGrants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principalGrants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPrincipalsInRoleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPrincipalsInRoleResponse");

  xfer += oprot->writeFieldBegin("principalGrants", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->principalGrants.size()));
    std::vector<RolePrincipalGrant> ::const_iterator _iter108;
    for (_iter108 = this->principalGrants.begin(); _iter108 != this->principalGrants.end(); ++_iter108)
    {
      xfer += (*_iter108).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPrincipalsInRoleResponse &a, GetPrincipalsInRoleResponse &b) {
  using ::std::swap;
  swap(a.principalGrants, b.principalGrants);
}

GetPrincipalsInRoleResponse::GetPrincipalsInRoleResponse(const GetPrincipalsInRoleResponse& other109) {
  principalGrants = other109.principalGrants;
}
GetPrincipalsInRoleResponse& GetPrincipalsInRoleResponse::operator=(const GetPrincipalsInRoleResponse& other110) {
  principalGrants = other110.principalGrants;
  return *this;
}
void GetPrincipalsInRoleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPrincipalsInRoleResponse(";
  out << "principalGrants=" << to_string(principalGrants);
  out << ")";
}


GrantRevokeRoleRequest::~GrantRevokeRoleRequest() throw() {
}


void GrantRevokeRoleRequest::__set_requestType(const GrantRevokeType::type val) {
  this->requestType = val;
}

void GrantRevokeRoleRequest::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void GrantRevokeRoleRequest::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void GrantRevokeRoleRequest::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void GrantRevokeRoleRequest::__set_grantor(const std::string& val) {
  this->grantor = val;
__isset.grantor = true;
}

void GrantRevokeRoleRequest::__set_grantorType(const PrincipalType::type val) {
  this->grantorType = val;
__isset.grantorType = true;
}

void GrantRevokeRoleRequest::__set_grantOption(const bool val) {
  this->grantOption = val;
__isset.grantOption = true;
}

uint32_t GrantRevokeRoleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast111;
          xfer += iprot->readI32(ecast111);
          this->requestType = (GrantRevokeType::type)ecast111;
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast112;
          xfer += iprot->readI32(ecast112);
          this->principalType = (PrincipalType::type)ecast112;
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantor);
          this->__isset.grantor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast113;
          xfer += iprot->readI32(ecast113);
          this->grantorType = (PrincipalType::type)ecast113;
          this->__isset.grantorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokeRoleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokeRoleRequest");

  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->requestType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->principalType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.grantor) {
    xfer += oprot->writeFieldBegin("grantor", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->grantor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grantorType) {
    xfer += oprot->writeFieldBegin("grantorType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->grantorType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grantOption) {
    xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->grantOption);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokeRoleRequest &a, GrantRevokeRoleRequest &b) {
  using ::std::swap;
  swap(a.requestType, b.requestType);
  swap(a.roleName, b.roleName);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantor, b.grantor);
  swap(a.grantorType, b.grantorType);
  swap(a.grantOption, b.grantOption);
  swap(a.__isset, b.__isset);
}

GrantRevokeRoleRequest::GrantRevokeRoleRequest(const GrantRevokeRoleRequest& other114) {
  requestType = other114.requestType;
  roleName = other114.roleName;
  principalName = other114.principalName;
  principalType = other114.principalType;
  grantor = other114.grantor;
  grantorType = other114.grantorType;
  grantOption = other114.grantOption;
  __isset = other114.__isset;
}
GrantRevokeRoleRequest& GrantRevokeRoleRequest::operator=(const GrantRevokeRoleRequest& other115) {
  requestType = other115.requestType;
  roleName = other115.roleName;
  principalName = other115.principalName;
  principalType = other115.principalType;
  grantor = other115.grantor;
  grantorType = other115.grantorType;
  grantOption = other115.grantOption;
  __isset = other115.__isset;
  return *this;
}
void GrantRevokeRoleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokeRoleRequest(";
  out << "requestType=" << to_string(requestType);
  out << ", " << "roleName=" << to_string(roleName);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantor="; (__isset.grantor ? (out << to_string(grantor)) : (out << "<null>"));
  out << ", " << "grantorType="; (__isset.grantorType ? (out << to_string(grantorType)) : (out << "<null>"));
  out << ", " << "grantOption="; (__isset.grantOption ? (out << to_string(grantOption)) : (out << "<null>"));
  out << ")";
}


GrantRevokeRoleResponse::~GrantRevokeRoleResponse() throw() {
}


void GrantRevokeRoleResponse::__set_success(const bool val) {
  this->success = val;
__isset.success = true;
}

uint32_t GrantRevokeRoleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokeRoleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokeRoleResponse");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokeRoleResponse &a, GrantRevokeRoleResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.__isset, b.__isset);
}

GrantRevokeRoleResponse::GrantRevokeRoleResponse(const GrantRevokeRoleResponse& other116) {
  success = other116.success;
  __isset = other116.__isset;
}
GrantRevokeRoleResponse& GrantRevokeRoleResponse::operator=(const GrantRevokeRoleResponse& other117) {
  success = other117.success;
  __isset = other117.__isset;
  return *this;
}
void GrantRevokeRoleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokeRoleResponse(";
  out << "success="; (__isset.success ? (out << to_string(success)) : (out << "<null>"));
  out << ")";
}


Database::~Database() throw() {
}


void Database::__set_name(const std::string& val) {
  this->name = val;
}

void Database::__set_description(const std::string& val) {
  this->description = val;
}

void Database::__set_locationUri(const std::string& val) {
  this->locationUri = val;
}

void Database::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Database::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void Database::__set_ownerName(const std::string& val) {
  this->ownerName = val;
__isset.ownerName = true;
}

void Database::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}

uint32_t Database::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationUri);
          this->__isset.locationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _ktype119;
            ::apache::thrift::protocol::TType _vtype120;
            xfer += iprot->readMapBegin(_ktype119, _vtype120, _size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              std::string _key123;
              xfer += iprot->readString(_key123);
              std::string& _val124 = this->parameters[_key123];
              xfer += iprot->readString(_val124);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast125;
          xfer += iprot->readI32(ecast125);
          this->ownerType = (PrincipalType::type)ecast125;
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Database::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Database");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("locationUri", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->locationUri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter126;
    for (_iter126 = this->parameters.begin(); _iter126 != this->parameters.end(); ++_iter126)
    {
      xfer += oprot->writeString(_iter126->first);
      xfer += oprot->writeString(_iter126->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerName) {
    xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ownerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->ownerType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Database &a, Database &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.locationUri, b.locationUri);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.__isset, b.__isset);
}

Database::Database(const Database& other127) {
  name = other127.name;
  description = other127.description;
  locationUri = other127.locationUri;
  parameters = other127.parameters;
  privileges = other127.privileges;
  ownerName = other127.ownerName;
  ownerType = other127.ownerType;
  __isset = other127.__isset;
}
Database& Database::operator=(const Database& other128) {
  name = other128.name;
  description = other128.description;
  locationUri = other128.locationUri;
  parameters = other128.parameters;
  privileges = other128.privileges;
  ownerName = other128.ownerName;
  ownerType = other128.ownerType;
  __isset = other128.__isset;
  return *this;
}
void Database::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Database(";
  out << "name=" << to_string(name);
  out << ", " << "description=" << to_string(description);
  out << ", " << "locationUri=" << to_string(locationUri);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "ownerName="; (__isset.ownerName ? (out << to_string(ownerName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ")";
}


SerDeInfo::~SerDeInfo() throw() {
}


void SerDeInfo::__set_name(const std::string& val) {
  this->name = val;
}

void SerDeInfo::__set_serializationLib(const std::string& val) {
  this->serializationLib = val;
}

void SerDeInfo::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

uint32_t SerDeInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serializationLib);
          this->__isset.serializationLib = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _ktype130;
            ::apache::thrift::protocol::TType _vtype131;
            xfer += iprot->readMapBegin(_ktype130, _vtype131, _size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              std::string _key134;
              xfer += iprot->readString(_key134);
              std::string& _val135 = this->parameters[_key134];
              xfer += iprot->readString(_val135);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SerDeInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SerDeInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serializationLib", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->serializationLib);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter136;
    for (_iter136 = this->parameters.begin(); _iter136 != this->parameters.end(); ++_iter136)
    {
      xfer += oprot->writeString(_iter136->first);
      xfer += oprot->writeString(_iter136->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SerDeInfo &a, SerDeInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.serializationLib, b.serializationLib);
  swap(a.parameters, b.parameters);
  swap(a.__isset, b.__isset);
}

SerDeInfo::SerDeInfo(const SerDeInfo& other137) {
  name = other137.name;
  serializationLib = other137.serializationLib;
  parameters = other137.parameters;
  __isset = other137.__isset;
}
SerDeInfo& SerDeInfo::operator=(const SerDeInfo& other138) {
  name = other138.name;
  serializationLib = other138.serializationLib;
  parameters = other138.parameters;
  __isset = other138.__isset;
  return *this;
}
void SerDeInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SerDeInfo(";
  out << "name=" << to_string(name);
  out << ", " << "serializationLib=" << to_string(serializationLib);
  out << ", " << "parameters=" << to_string(parameters);
  out << ")";
}


Order::~Order() throw() {
}


void Order::__set_col(const std::string& val) {
  this->col = val;
}

void Order::__set_order(const int32_t val) {
  this->order = val;
}

uint32_t Order::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col);
          this->__isset.col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->order);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Order::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Order");

  xfer += oprot->writeFieldBegin("col", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->order);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Order &a, Order &b) {
  using ::std::swap;
  swap(a.col, b.col);
  swap(a.order, b.order);
  swap(a.__isset, b.__isset);
}

Order::Order(const Order& other139) {
  col = other139.col;
  order = other139.order;
  __isset = other139.__isset;
}
Order& Order::operator=(const Order& other140) {
  col = other140.col;
  order = other140.order;
  __isset = other140.__isset;
  return *this;
}
void Order::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Order(";
  out << "col=" << to_string(col);
  out << ", " << "order=" << to_string(order);
  out << ")";
}


SkewedInfo::~SkewedInfo() throw() {
}


void SkewedInfo::__set_skewedColNames(const std::vector<std::string> & val) {
  this->skewedColNames = val;
}

void SkewedInfo::__set_skewedColValues(const std::vector<std::vector<std::string> > & val) {
  this->skewedColValues = val;
}

void SkewedInfo::__set_skewedColValueLocationMaps(const std::map<std::vector<std::string> , std::string> & val) {
  this->skewedColValueLocationMaps = val;
}

uint32_t SkewedInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->skewedColNames.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _etype144;
            xfer += iprot->readListBegin(_etype144, _size141);
            this->skewedColNames.resize(_size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              xfer += iprot->readString(this->skewedColNames[_i145]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.skewedColNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->skewedColValues.clear();
            uint32_t _size146;
            ::apache::thrift::protocol::TType _etype149;
            xfer += iprot->readListBegin(_etype149, _size146);
            this->skewedColValues.resize(_size146);
            uint32_t _i150;
            for (_i150 = 0; _i150 < _size146; ++_i150)
            {
              {
                this->skewedColValues[_i150].clear();
                uint32_t _size151;
                ::apache::thrift::protocol::TType _etype154;
                xfer += iprot->readListBegin(_etype154, _size151);
                this->skewedColValues[_i150].resize(_size151);
                uint32_t _i155;
                for (_i155 = 0; _i155 < _size151; ++_i155)
                {
                  xfer += iprot->readString(this->skewedColValues[_i150][_i155]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.skewedColValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->skewedColValueLocationMaps.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _ktype157;
            ::apache::thrift::protocol::TType _vtype158;
            xfer += iprot->readMapBegin(_ktype157, _vtype158, _size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              std::vector<std::string>  _key161;
              {
                _key161.clear();
                uint32_t _size163;
                ::apache::thrift::protocol::TType _etype166;
                xfer += iprot->readListBegin(_etype166, _size163);
                _key161.resize(_size163);
                uint32_t _i167;
                for (_i167 = 0; _i167 < _size163; ++_i167)
                {
                  xfer += iprot->readString(_key161[_i167]);
                }
                xfer += iprot->readListEnd();
              }
              std::string& _val162 = this->skewedColValueLocationMaps[_key161];
              xfer += iprot->readString(_val162);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.skewedColValueLocationMaps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SkewedInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SkewedInfo");

  xfer += oprot->writeFieldBegin("skewedColNames", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->skewedColNames.size()));
    std::vector<std::string> ::const_iterator _iter168;
    for (_iter168 = this->skewedColNames.begin(); _iter168 != this->skewedColNames.end(); ++_iter168)
    {
      xfer += oprot->writeString((*_iter168));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skewedColValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->skewedColValues.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter169;
    for (_iter169 = this->skewedColValues.begin(); _iter169 != this->skewedColValues.end(); ++_iter169)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter169).size()));
        std::vector<std::string> ::const_iterator _iter170;
        for (_iter170 = (*_iter169).begin(); _iter170 != (*_iter169).end(); ++_iter170)
        {
          xfer += oprot->writeString((*_iter170));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skewedColValueLocationMaps", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_LIST, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->skewedColValueLocationMaps.size()));
    std::map<std::vector<std::string> , std::string> ::const_iterator _iter171;
    for (_iter171 = this->skewedColValueLocationMaps.begin(); _iter171 != this->skewedColValueLocationMaps.end(); ++_iter171)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter171->first.size()));
        std::vector<std::string> ::const_iterator _iter172;
        for (_iter172 = _iter171->first.begin(); _iter172 != _iter171->first.end(); ++_iter172)
        {
          xfer += oprot->writeString((*_iter172));
        }
        xfer += oprot->writeListEnd();
      }
      xfer += oprot->writeString(_iter171->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SkewedInfo &a, SkewedInfo &b) {
  using ::std::swap;
  swap(a.skewedColNames, b.skewedColNames);
  swap(a.skewedColValues, b.skewedColValues);
  swap(a.skewedColValueLocationMaps, b.skewedColValueLocationMaps);
  swap(a.__isset, b.__isset);
}

SkewedInfo::SkewedInfo(const SkewedInfo& other173) {
  skewedColNames = other173.skewedColNames;
  skewedColValues = other173.skewedColValues;
  skewedColValueLocationMaps = other173.skewedColValueLocationMaps;
  __isset = other173.__isset;
}
SkewedInfo& SkewedInfo::operator=(const SkewedInfo& other174) {
  skewedColNames = other174.skewedColNames;
  skewedColValues = other174.skewedColValues;
  skewedColValueLocationMaps = other174.skewedColValueLocationMaps;
  __isset = other174.__isset;
  return *this;
}
void SkewedInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SkewedInfo(";
  out << "skewedColNames=" << to_string(skewedColNames);
  out << ", " << "skewedColValues=" << to_string(skewedColValues);
  out << ", " << "skewedColValueLocationMaps=" << to_string(skewedColValueLocationMaps);
  out << ")";
}


StorageDescriptor::~StorageDescriptor() throw() {
}


void StorageDescriptor::__set_cols(const std::vector<FieldSchema> & val) {
  this->cols = val;
}

void StorageDescriptor::__set_location(const std::string& val) {
  this->location = val;
}

void StorageDescriptor::__set_inputFormat(const std::string& val) {
  this->inputFormat = val;
}

void StorageDescriptor::__set_outputFormat(const std::string& val) {
  this->outputFormat = val;
}

void StorageDescriptor::__set_compressed(const bool val) {
  this->compressed = val;
}

void StorageDescriptor::__set_numBuckets(const int32_t val) {
  this->numBuckets = val;
}

void StorageDescriptor::__set_serdeInfo(const SerDeInfo& val) {
  this->serdeInfo = val;
}

void StorageDescriptor::__set_bucketCols(const std::vector<std::string> & val) {
  this->bucketCols = val;
}

void StorageDescriptor::__set_sortCols(const std::vector<Order> & val) {
  this->sortCols = val;
}

void StorageDescriptor::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void StorageDescriptor::__set_skewedInfo(const SkewedInfo& val) {
  this->skewedInfo = val;
__isset.skewedInfo = true;
}

void StorageDescriptor::__set_storedAsSubDirectories(const bool val) {
  this->storedAsSubDirectories = val;
__isset.storedAsSubDirectories = true;
}

uint32_t StorageDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size175;
            ::apache::thrift::protocol::TType _etype178;
            xfer += iprot->readListBegin(_etype178, _size175);
            this->cols.resize(_size175);
            uint32_t _i179;
            for (_i179 = 0; _i179 < _size175; ++_i179)
            {
              xfer += this->cols[_i179].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->inputFormat);
          this->__isset.inputFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->outputFormat);
          this->__isset.outputFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numBuckets);
          this->__isset.numBuckets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serdeInfo.read(iprot);
          this->__isset.serdeInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bucketCols.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readListBegin(_etype183, _size180);
            this->bucketCols.resize(_size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              xfer += iprot->readString(this->bucketCols[_i184]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bucketCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sortCols.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->sortCols.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += this->sortCols[_i189].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sortCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size190;
            ::apache::thrift::protocol::TType _ktype191;
            ::apache::thrift::protocol::TType _vtype192;
            xfer += iprot->readMapBegin(_ktype191, _vtype192, _size190);
            uint32_t _i194;
            for (_i194 = 0; _i194 < _size190; ++_i194)
            {
              std::string _key195;
              xfer += iprot->readString(_key195);
              std::string& _val196 = this->parameters[_key195];
              xfer += iprot->readString(_val196);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->skewedInfo.read(iprot);
          this->__isset.skewedInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->storedAsSubDirectories);
          this->__isset.storedAsSubDirectories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StorageDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StorageDescriptor");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<FieldSchema> ::const_iterator _iter197;
    for (_iter197 = this->cols.begin(); _iter197 != this->cols.end(); ++_iter197)
    {
      xfer += (*_iter197).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputFormat", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->inputFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputFormat", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->outputFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->compressed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numBuckets", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->numBuckets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serdeInfo", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->serdeInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucketCols", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->bucketCols.size()));
    std::vector<std::string> ::const_iterator _iter198;
    for (_iter198 = this->bucketCols.begin(); _iter198 != this->bucketCols.end(); ++_iter198)
    {
      xfer += oprot->writeString((*_iter198));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortCols", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sortCols.size()));
    std::vector<Order> ::const_iterator _iter199;
    for (_iter199 = this->sortCols.begin(); _iter199 != this->sortCols.end(); ++_iter199)
    {
      xfer += (*_iter199).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter200;
    for (_iter200 = this->parameters.begin(); _iter200 != this->parameters.end(); ++_iter200)
    {
      xfer += oprot->writeString(_iter200->first);
      xfer += oprot->writeString(_iter200->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.skewedInfo) {
    xfer += oprot->writeFieldBegin("skewedInfo", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->skewedInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storedAsSubDirectories) {
    xfer += oprot->writeFieldBegin("storedAsSubDirectories", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->storedAsSubDirectories);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StorageDescriptor &a, StorageDescriptor &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.location, b.location);
  swap(a.inputFormat, b.inputFormat);
  swap(a.outputFormat, b.outputFormat);
  swap(a.compressed, b.compressed);
  swap(a.numBuckets, b.numBuckets);
  swap(a.serdeInfo, b.serdeInfo);
  swap(a.bucketCols, b.bucketCols);
  swap(a.sortCols, b.sortCols);
  swap(a.parameters, b.parameters);
  swap(a.skewedInfo, b.skewedInfo);
  swap(a.storedAsSubDirectories, b.storedAsSubDirectories);
  swap(a.__isset, b.__isset);
}

StorageDescriptor::StorageDescriptor(const StorageDescriptor& other201) {
  cols = other201.cols;
  location = other201.location;
  inputFormat = other201.inputFormat;
  outputFormat = other201.outputFormat;
  compressed = other201.compressed;
  numBuckets = other201.numBuckets;
  serdeInfo = other201.serdeInfo;
  bucketCols = other201.bucketCols;
  sortCols = other201.sortCols;
  parameters = other201.parameters;
  skewedInfo = other201.skewedInfo;
  storedAsSubDirectories = other201.storedAsSubDirectories;
  __isset = other201.__isset;
}
StorageDescriptor& StorageDescriptor::operator=(const StorageDescriptor& other202) {
  cols = other202.cols;
  location = other202.location;
  inputFormat = other202.inputFormat;
  outputFormat = other202.outputFormat;
  compressed = other202.compressed;
  numBuckets = other202.numBuckets;
  serdeInfo = other202.serdeInfo;
  bucketCols = other202.bucketCols;
  sortCols = other202.sortCols;
  parameters = other202.parameters;
  skewedInfo = other202.skewedInfo;
  storedAsSubDirectories = other202.storedAsSubDirectories;
  __isset = other202.__isset;
  return *this;
}
void StorageDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StorageDescriptor(";
  out << "cols=" << to_string(cols);
  out << ", " << "location=" << to_string(location);
  out << ", " << "inputFormat=" << to_string(inputFormat);
  out << ", " << "outputFormat=" << to_string(outputFormat);
  out << ", " << "compressed=" << to_string(compressed);
  out << ", " << "numBuckets=" << to_string(numBuckets);
  out << ", " << "serdeInfo=" << to_string(serdeInfo);
  out << ", " << "bucketCols=" << to_string(bucketCols);
  out << ", " << "sortCols=" << to_string(sortCols);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "skewedInfo="; (__isset.skewedInfo ? (out << to_string(skewedInfo)) : (out << "<null>"));
  out << ", " << "storedAsSubDirectories="; (__isset.storedAsSubDirectories ? (out << to_string(storedAsSubDirectories)) : (out << "<null>"));
  out << ")";
}


Table::~Table() throw() {
}


void Table::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void Table::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Table::__set_owner(const std::string& val) {
  this->owner = val;
}

void Table::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Table::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void Table::__set_retention(const int32_t val) {
  this->retention = val;
}

void Table::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

void Table::__set_partitionKeys(const std::vector<FieldSchema> & val) {
  this->partitionKeys = val;
}

void Table::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Table::__set_viewOriginalText(const std::string& val) {
  this->viewOriginalText = val;
}

void Table::__set_viewExpandedText(const std::string& val) {
  this->viewExpandedText = val;
}

void Table::__set_tableType(const std::string& val) {
  this->tableType = val;
}

void Table::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void Table::__set_temporary(const bool val) {
  this->temporary = val;
__isset.temporary = true;
}

uint32_t Table::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retention);
          this->__isset.retention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionKeys.clear();
            uint32_t _size203;
            ::apache::thrift::protocol::TType _etype206;
            xfer += iprot->readListBegin(_etype206, _size203);
            this->partitionKeys.resize(_size203);
            uint32_t _i207;
            for (_i207 = 0; _i207 < _size203; ++_i207)
            {
              xfer += this->partitionKeys[_i207].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size208;
            ::apache::thrift::protocol::TType _ktype209;
            ::apache::thrift::protocol::TType _vtype210;
            xfer += iprot->readMapBegin(_ktype209, _vtype210, _size208);
            uint32_t _i212;
            for (_i212 = 0; _i212 < _size208; ++_i212)
            {
              std::string _key213;
              xfer += iprot->readString(_key213);
              std::string& _val214 = this->parameters[_key213];
              xfer += iprot->readString(_val214);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewOriginalText);
          this->__isset.viewOriginalText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewExpandedText);
          this->__isset.viewExpandedText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableType);
          this->__isset.tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->temporary);
          this->__isset.temporary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Table::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Table");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retention", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->retention);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionKeys", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionKeys.size()));
    std::vector<FieldSchema> ::const_iterator _iter215;
    for (_iter215 = this->partitionKeys.begin(); _iter215 != this->partitionKeys.end(); ++_iter215)
    {
      xfer += (*_iter215).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 9);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter216;
    for (_iter216 = this->parameters.begin(); _iter216 != this->parameters.end(); ++_iter216)
    {
      xfer += oprot->writeString(_iter216->first);
      xfer += oprot->writeString(_iter216->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewOriginalText", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->viewOriginalText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewExpandedText", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->viewExpandedText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->tableType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.temporary) {
    xfer += oprot->writeFieldBegin("temporary", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->temporary);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Table &a, Table &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.dbName, b.dbName);
  swap(a.owner, b.owner);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.retention, b.retention);
  swap(a.sd, b.sd);
  swap(a.partitionKeys, b.partitionKeys);
  swap(a.parameters, b.parameters);
  swap(a.viewOriginalText, b.viewOriginalText);
  swap(a.viewExpandedText, b.viewExpandedText);
  swap(a.tableType, b.tableType);
  swap(a.privileges, b.privileges);
  swap(a.temporary, b.temporary);
  swap(a.__isset, b.__isset);
}

Table::Table(const Table& other217) {
  tableName = other217.tableName;
  dbName = other217.dbName;
  owner = other217.owner;
  createTime = other217.createTime;
  lastAccessTime = other217.lastAccessTime;
  retention = other217.retention;
  sd = other217.sd;
  partitionKeys = other217.partitionKeys;
  parameters = other217.parameters;
  viewOriginalText = other217.viewOriginalText;
  viewExpandedText = other217.viewExpandedText;
  tableType = other217.tableType;
  privileges = other217.privileges;
  temporary = other217.temporary;
  __isset = other217.__isset;
}
Table& Table::operator=(const Table& other218) {
  tableName = other218.tableName;
  dbName = other218.dbName;
  owner = other218.owner;
  createTime = other218.createTime;
  lastAccessTime = other218.lastAccessTime;
  retention = other218.retention;
  sd = other218.sd;
  partitionKeys = other218.partitionKeys;
  parameters = other218.parameters;
  viewOriginalText = other218.viewOriginalText;
  viewExpandedText = other218.viewExpandedText;
  tableType = other218.tableType;
  privileges = other218.privileges;
  temporary = other218.temporary;
  __isset = other218.__isset;
  return *this;
}
void Table::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Table(";
  out << "tableName=" << to_string(tableName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "owner=" << to_string(owner);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "retention=" << to_string(retention);
  out << ", " << "sd=" << to_string(sd);
  out << ", " << "partitionKeys=" << to_string(partitionKeys);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "viewOriginalText=" << to_string(viewOriginalText);
  out << ", " << "viewExpandedText=" << to_string(viewExpandedText);
  out << ", " << "tableType=" << to_string(tableType);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "temporary="; (__isset.temporary ? (out << to_string(temporary)) : (out << "<null>"));
  out << ")";
}


Partition::~Partition() throw() {
}


void Partition::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void Partition::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Partition::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void Partition::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Partition::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void Partition::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

void Partition::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Partition::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

uint32_t Partition::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size219;
            ::apache::thrift::protocol::TType _etype222;
            xfer += iprot->readListBegin(_etype222, _size219);
            this->values.resize(_size219);
            uint32_t _i223;
            for (_i223 = 0; _i223 < _size219; ++_i223)
            {
              xfer += iprot->readString(this->values[_i223]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size224;
            ::apache::thrift::protocol::TType _ktype225;
            ::apache::thrift::protocol::TType _vtype226;
            xfer += iprot->readMapBegin(_ktype225, _vtype226, _size224);
            uint32_t _i228;
            for (_i228 = 0; _i228 < _size224; ++_i228)
            {
              std::string _key229;
              xfer += iprot->readString(_key229);
              std::string& _val230 = this->parameters[_key229];
              xfer += iprot->readString(_val230);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Partition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Partition");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter231;
    for (_iter231 = this->values.begin(); _iter231 != this->values.end(); ++_iter231)
    {
      xfer += oprot->writeString((*_iter231));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter232;
    for (_iter232 = this->parameters.begin(); _iter232 != this->parameters.end(); ++_iter232)
    {
      xfer += oprot->writeString(_iter232->first);
      xfer += oprot->writeString(_iter232->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Partition &a, Partition &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.sd, b.sd);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.__isset, b.__isset);
}

Partition::Partition(const Partition& other233) {
  values = other233.values;
  dbName = other233.dbName;
  tableName = other233.tableName;
  createTime = other233.createTime;
  lastAccessTime = other233.lastAccessTime;
  sd = other233.sd;
  parameters = other233.parameters;
  privileges = other233.privileges;
  __isset = other233.__isset;
}
Partition& Partition::operator=(const Partition& other234) {
  values = other234.values;
  dbName = other234.dbName;
  tableName = other234.tableName;
  createTime = other234.createTime;
  lastAccessTime = other234.lastAccessTime;
  sd = other234.sd;
  parameters = other234.parameters;
  privileges = other234.privileges;
  __isset = other234.__isset;
  return *this;
}
void Partition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Partition(";
  out << "values=" << to_string(values);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "sd=" << to_string(sd);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ")";
}


PartitionWithoutSD::~PartitionWithoutSD() throw() {
}


void PartitionWithoutSD::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void PartitionWithoutSD::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void PartitionWithoutSD::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void PartitionWithoutSD::__set_relativePath(const std::string& val) {
  this->relativePath = val;
}

void PartitionWithoutSD::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void PartitionWithoutSD::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

uint32_t PartitionWithoutSD::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size235;
            ::apache::thrift::protocol::TType _etype238;
            xfer += iprot->readListBegin(_etype238, _size235);
            this->values.resize(_size235);
            uint32_t _i239;
            for (_i239 = 0; _i239 < _size235; ++_i239)
            {
              xfer += iprot->readString(this->values[_i239]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->relativePath);
          this->__isset.relativePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size240;
            ::apache::thrift::protocol::TType _ktype241;
            ::apache::thrift::protocol::TType _vtype242;
            xfer += iprot->readMapBegin(_ktype241, _vtype242, _size240);
            uint32_t _i244;
            for (_i244 = 0; _i244 < _size240; ++_i244)
            {
              std::string _key245;
              xfer += iprot->readString(_key245);
              std::string& _val246 = this->parameters[_key245];
              xfer += iprot->readString(_val246);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionWithoutSD::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionWithoutSD");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter247;
    for (_iter247 = this->values.begin(); _iter247 != this->values.end(); ++_iter247)
    {
      xfer += oprot->writeString((*_iter247));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("relativePath", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->relativePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter248;
    for (_iter248 = this->parameters.begin(); _iter248 != this->parameters.end(); ++_iter248)
    {
      xfer += oprot->writeString(_iter248->first);
      xfer += oprot->writeString(_iter248->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionWithoutSD &a, PartitionWithoutSD &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.relativePath, b.relativePath);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.__isset, b.__isset);
}

PartitionWithoutSD::PartitionWithoutSD(const PartitionWithoutSD& other249) {
  values = other249.values;
  createTime = other249.createTime;
  lastAccessTime = other249.lastAccessTime;
  relativePath = other249.relativePath;
  parameters = other249.parameters;
  privileges = other249.privileges;
  __isset = other249.__isset;
}
PartitionWithoutSD& PartitionWithoutSD::operator=(const PartitionWithoutSD& other250) {
  values = other250.values;
  createTime = other250.createTime;
  lastAccessTime = other250.lastAccessTime;
  relativePath = other250.relativePath;
  parameters = other250.parameters;
  privileges = other250.privileges;
  __isset = other250.__isset;
  return *this;
}
void PartitionWithoutSD::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionWithoutSD(";
  out << "values=" << to_string(values);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "relativePath=" << to_string(relativePath);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ")";
}


PartitionSpecWithSharedSD::~PartitionSpecWithSharedSD() throw() {
}


void PartitionSpecWithSharedSD::__set_partitions(const std::vector<PartitionWithoutSD> & val) {
  this->partitions = val;
}

void PartitionSpecWithSharedSD::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

uint32_t PartitionSpecWithSharedSD::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size251;
            ::apache::thrift::protocol::TType _etype254;
            xfer += iprot->readListBegin(_etype254, _size251);
            this->partitions.resize(_size251);
            uint32_t _i255;
            for (_i255 = 0; _i255 < _size251; ++_i255)
            {
              xfer += this->partitions[_i255].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionSpecWithSharedSD::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionSpecWithSharedSD");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<PartitionWithoutSD> ::const_iterator _iter256;
    for (_iter256 = this->partitions.begin(); _iter256 != this->partitions.end(); ++_iter256)
    {
      xfer += (*_iter256).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionSpecWithSharedSD &a, PartitionSpecWithSharedSD &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.sd, b.sd);
  swap(a.__isset, b.__isset);
}

PartitionSpecWithSharedSD::PartitionSpecWithSharedSD(const PartitionSpecWithSharedSD& other257) {
  partitions = other257.partitions;
  sd = other257.sd;
  __isset = other257.__isset;
}
PartitionSpecWithSharedSD& PartitionSpecWithSharedSD::operator=(const PartitionSpecWithSharedSD& other258) {
  partitions = other258.partitions;
  sd = other258.sd;
  __isset = other258.__isset;
  return *this;
}
void PartitionSpecWithSharedSD::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionSpecWithSharedSD(";
  out << "partitions=" << to_string(partitions);
  out << ", " << "sd=" << to_string(sd);
  out << ")";
}


PartitionListComposingSpec::~PartitionListComposingSpec() throw() {
}


void PartitionListComposingSpec::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}

uint32_t PartitionListComposingSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size259;
            ::apache::thrift::protocol::TType _etype262;
            xfer += iprot->readListBegin(_etype262, _size259);
            this->partitions.resize(_size259);
            uint32_t _i263;
            for (_i263 = 0; _i263 < _size259; ++_i263)
            {
              xfer += this->partitions[_i263].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionListComposingSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionListComposingSpec");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter264;
    for (_iter264 = this->partitions.begin(); _iter264 != this->partitions.end(); ++_iter264)
    {
      xfer += (*_iter264).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionListComposingSpec &a, PartitionListComposingSpec &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

PartitionListComposingSpec::PartitionListComposingSpec(const PartitionListComposingSpec& other265) {
  partitions = other265.partitions;
  __isset = other265.__isset;
}
PartitionListComposingSpec& PartitionListComposingSpec::operator=(const PartitionListComposingSpec& other266) {
  partitions = other266.partitions;
  __isset = other266.__isset;
  return *this;
}
void PartitionListComposingSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionListComposingSpec(";
  out << "partitions=" << to_string(partitions);
  out << ")";
}


PartitionSpec::~PartitionSpec() throw() {
}


void PartitionSpec::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionSpec::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void PartitionSpec::__set_rootPath(const std::string& val) {
  this->rootPath = val;
}

void PartitionSpec::__set_sharedSDPartitionSpec(const PartitionSpecWithSharedSD& val) {
  this->sharedSDPartitionSpec = val;
__isset.sharedSDPartitionSpec = true;
}

void PartitionSpec::__set_partitionList(const PartitionListComposingSpec& val) {
  this->partitionList = val;
__isset.partitionList = true;
}

uint32_t PartitionSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rootPath);
          this->__isset.rootPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sharedSDPartitionSpec.read(iprot);
          this->__isset.sharedSDPartitionSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partitionList.read(iprot);
          this->__isset.partitionList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionSpec");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rootPath", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->rootPath);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sharedSDPartitionSpec) {
    xfer += oprot->writeFieldBegin("sharedSDPartitionSpec", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->sharedSDPartitionSpec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionList) {
    xfer += oprot->writeFieldBegin("partitionList", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->partitionList.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionSpec &a, PartitionSpec &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.rootPath, b.rootPath);
  swap(a.sharedSDPartitionSpec, b.sharedSDPartitionSpec);
  swap(a.partitionList, b.partitionList);
  swap(a.__isset, b.__isset);
}

PartitionSpec::PartitionSpec(const PartitionSpec& other267) {
  dbName = other267.dbName;
  tableName = other267.tableName;
  rootPath = other267.rootPath;
  sharedSDPartitionSpec = other267.sharedSDPartitionSpec;
  partitionList = other267.partitionList;
  __isset = other267.__isset;
}
PartitionSpec& PartitionSpec::operator=(const PartitionSpec& other268) {
  dbName = other268.dbName;
  tableName = other268.tableName;
  rootPath = other268.rootPath;
  sharedSDPartitionSpec = other268.sharedSDPartitionSpec;
  partitionList = other268.partitionList;
  __isset = other268.__isset;
  return *this;
}
void PartitionSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionSpec(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "rootPath=" << to_string(rootPath);
  out << ", " << "sharedSDPartitionSpec="; (__isset.sharedSDPartitionSpec ? (out << to_string(sharedSDPartitionSpec)) : (out << "<null>"));
  out << ", " << "partitionList="; (__isset.partitionList ? (out << to_string(partitionList)) : (out << "<null>"));
  out << ")";
}


Index::~Index() throw() {
}


void Index::__set_indexName(const std::string& val) {
  this->indexName = val;
}

void Index::__set_indexHandlerClass(const std::string& val) {
  this->indexHandlerClass = val;
}

void Index::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Index::__set_origTableName(const std::string& val) {
  this->origTableName = val;
}

void Index::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Index::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void Index::__set_indexTableName(const std::string& val) {
  this->indexTableName = val;
}

void Index::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

void Index::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Index::__set_deferredRebuild(const bool val) {
  this->deferredRebuild = val;
}

uint32_t Index::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->indexName);
          this->__isset.indexName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->indexHandlerClass);
          this->__isset.indexHandlerClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origTableName);
          this->__isset.origTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->indexTableName);
          this->__isset.indexTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size269;
            ::apache::thrift::protocol::TType _ktype270;
            ::apache::thrift::protocol::TType _vtype271;
            xfer += iprot->readMapBegin(_ktype270, _vtype271, _size269);
            uint32_t _i273;
            for (_i273 = 0; _i273 < _size269; ++_i273)
            {
              std::string _key274;
              xfer += iprot->readString(_key274);
              std::string& _val275 = this->parameters[_key274];
              xfer += iprot->readString(_val275);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deferredRebuild);
          this->__isset.deferredRebuild = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Index::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Index");

  xfer += oprot->writeFieldBegin("indexName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->indexName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("indexHandlerClass", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->indexHandlerClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origTableName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->origTableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("indexTableName", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->indexTableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 9);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter276;
    for (_iter276 = this->parameters.begin(); _iter276 != this->parameters.end(); ++_iter276)
    {
      xfer += oprot->writeString(_iter276->first);
      xfer += oprot->writeString(_iter276->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deferredRebuild", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->deferredRebuild);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Index &a, Index &b) {
  using ::std::swap;
  swap(a.indexName, b.indexName);
  swap(a.indexHandlerClass, b.indexHandlerClass);
  swap(a.dbName, b.dbName);
  swap(a.origTableName, b.origTableName);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.indexTableName, b.indexTableName);
  swap(a.sd, b.sd);
  swap(a.parameters, b.parameters);
  swap(a.deferredRebuild, b.deferredRebuild);
  swap(a.__isset, b.__isset);
}

Index::Index(const Index& other277) {
  indexName = other277.indexName;
  indexHandlerClass = other277.indexHandlerClass;
  dbName = other277.dbName;
  origTableName = other277.origTableName;
  createTime = other277.createTime;
  lastAccessTime = other277.lastAccessTime;
  indexTableName = other277.indexTableName;
  sd = other277.sd;
  parameters = other277.parameters;
  deferredRebuild = other277.deferredRebuild;
  __isset = other277.__isset;
}
Index& Index::operator=(const Index& other278) {
  indexName = other278.indexName;
  indexHandlerClass = other278.indexHandlerClass;
  dbName = other278.dbName;
  origTableName = other278.origTableName;
  createTime = other278.createTime;
  lastAccessTime = other278.lastAccessTime;
  indexTableName = other278.indexTableName;
  sd = other278.sd;
  parameters = other278.parameters;
  deferredRebuild = other278.deferredRebuild;
  __isset = other278.__isset;
  return *this;
}
void Index::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Index(";
  out << "indexName=" << to_string(indexName);
  out << ", " << "indexHandlerClass=" << to_string(indexHandlerClass);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "origTableName=" << to_string(origTableName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "indexTableName=" << to_string(indexTableName);
  out << ", " << "sd=" << to_string(sd);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "deferredRebuild=" << to_string(deferredRebuild);
  out << ")";
}


BooleanColumnStatsData::~BooleanColumnStatsData() throw() {
}


void BooleanColumnStatsData::__set_numTrues(const int64_t val) {
  this->numTrues = val;
}

void BooleanColumnStatsData::__set_numFalses(const int64_t val) {
  this->numFalses = val;
}

void BooleanColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

uint32_t BooleanColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numTrues = false;
  bool isset_numFalses = false;
  bool isset_numNulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numTrues);
          isset_numTrues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numFalses);
          isset_numFalses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numTrues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numFalses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BooleanColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BooleanColumnStatsData");

  xfer += oprot->writeFieldBegin("numTrues", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->numTrues);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numFalses", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->numFalses);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BooleanColumnStatsData &a, BooleanColumnStatsData &b) {
  using ::std::swap;
  swap(a.numTrues, b.numTrues);
  swap(a.numFalses, b.numFalses);
  swap(a.numNulls, b.numNulls);
}

BooleanColumnStatsData::BooleanColumnStatsData(const BooleanColumnStatsData& other279) {
  numTrues = other279.numTrues;
  numFalses = other279.numFalses;
  numNulls = other279.numNulls;
}
BooleanColumnStatsData& BooleanColumnStatsData::operator=(const BooleanColumnStatsData& other280) {
  numTrues = other280.numTrues;
  numFalses = other280.numFalses;
  numNulls = other280.numNulls;
  return *this;
}
void BooleanColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BooleanColumnStatsData(";
  out << "numTrues=" << to_string(numTrues);
  out << ", " << "numFalses=" << to_string(numFalses);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ")";
}


DoubleColumnStatsData::~DoubleColumnStatsData() throw() {
}


void DoubleColumnStatsData::__set_lowValue(const double val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DoubleColumnStatsData::__set_highValue(const double val) {
  this->highValue = val;
__isset.highValue = true;
}

void DoubleColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DoubleColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

uint32_t DoubleColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->lowValue);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->highValue);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DoubleColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DoubleColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_DOUBLE, 1);
    xfer += oprot->writeDouble(this->lowValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->highValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DoubleColumnStatsData &a, DoubleColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.__isset, b.__isset);
}

DoubleColumnStatsData::DoubleColumnStatsData(const DoubleColumnStatsData& other281) {
  lowValue = other281.lowValue;
  highValue = other281.highValue;
  numNulls = other281.numNulls;
  numDVs = other281.numDVs;
  __isset = other281.__isset;
}
DoubleColumnStatsData& DoubleColumnStatsData::operator=(const DoubleColumnStatsData& other282) {
  lowValue = other282.lowValue;
  highValue = other282.highValue;
  numNulls = other282.numNulls;
  numDVs = other282.numDVs;
  __isset = other282.__isset;
  return *this;
}
void DoubleColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DoubleColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ")";
}


LongColumnStatsData::~LongColumnStatsData() throw() {
}


void LongColumnStatsData::__set_lowValue(const int64_t val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void LongColumnStatsData::__set_highValue(const int64_t val) {
  this->highValue = val;
__isset.highValue = true;
}

void LongColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void LongColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

uint32_t LongColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lowValue);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->highValue);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LongColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LongColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->lowValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->highValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LongColumnStatsData &a, LongColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.__isset, b.__isset);
}

LongColumnStatsData::LongColumnStatsData(const LongColumnStatsData& other283) {
  lowValue = other283.lowValue;
  highValue = other283.highValue;
  numNulls = other283.numNulls;
  numDVs = other283.numDVs;
  __isset = other283.__isset;
}
LongColumnStatsData& LongColumnStatsData::operator=(const LongColumnStatsData& other284) {
  lowValue = other284.lowValue;
  highValue = other284.highValue;
  numNulls = other284.numNulls;
  numDVs = other284.numDVs;
  __isset = other284.__isset;
  return *this;
}
void LongColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LongColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ")";
}


StringColumnStatsData::~StringColumnStatsData() throw() {
}


void StringColumnStatsData::__set_maxColLen(const int64_t val) {
  this->maxColLen = val;
}

void StringColumnStatsData::__set_avgColLen(const double val) {
  this->avgColLen = val;
}

void StringColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void StringColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

uint32_t StringColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxColLen = false;
  bool isset_avgColLen = false;
  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxColLen);
          isset_maxColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avgColLen);
          isset_avgColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_avgColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StringColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringColumnStatsData");

  xfer += oprot->writeFieldBegin("maxColLen", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("avgColLen", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->avgColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringColumnStatsData &a, StringColumnStatsData &b) {
  using ::std::swap;
  swap(a.maxColLen, b.maxColLen);
  swap(a.avgColLen, b.avgColLen);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
}

StringColumnStatsData::StringColumnStatsData(const StringColumnStatsData& other285) {
  maxColLen = other285.maxColLen;
  avgColLen = other285.avgColLen;
  numNulls = other285.numNulls;
  numDVs = other285.numDVs;
}
StringColumnStatsData& StringColumnStatsData::operator=(const StringColumnStatsData& other286) {
  maxColLen = other286.maxColLen;
  avgColLen = other286.avgColLen;
  numNulls = other286.numNulls;
  numDVs = other286.numDVs;
  return *this;
}
void StringColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringColumnStatsData(";
  out << "maxColLen=" << to_string(maxColLen);
  out << ", " << "avgColLen=" << to_string(avgColLen);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ")";
}


BinaryColumnStatsData::~BinaryColumnStatsData() throw() {
}


void BinaryColumnStatsData::__set_maxColLen(const int64_t val) {
  this->maxColLen = val;
}

void BinaryColumnStatsData::__set_avgColLen(const double val) {
  this->avgColLen = val;
}

void BinaryColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

uint32_t BinaryColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxColLen = false;
  bool isset_avgColLen = false;
  bool isset_numNulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxColLen);
          isset_maxColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avgColLen);
          isset_avgColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_avgColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BinaryColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BinaryColumnStatsData");

  xfer += oprot->writeFieldBegin("maxColLen", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("avgColLen", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->avgColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BinaryColumnStatsData &a, BinaryColumnStatsData &b) {
  using ::std::swap;
  swap(a.maxColLen, b.maxColLen);
  swap(a.avgColLen, b.avgColLen);
  swap(a.numNulls, b.numNulls);
}

BinaryColumnStatsData::BinaryColumnStatsData(const BinaryColumnStatsData& other287) {
  maxColLen = other287.maxColLen;
  avgColLen = other287.avgColLen;
  numNulls = other287.numNulls;
}
BinaryColumnStatsData& BinaryColumnStatsData::operator=(const BinaryColumnStatsData& other288) {
  maxColLen = other288.maxColLen;
  avgColLen = other288.avgColLen;
  numNulls = other288.numNulls;
  return *this;
}
void BinaryColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BinaryColumnStatsData(";
  out << "maxColLen=" << to_string(maxColLen);
  out << ", " << "avgColLen=" << to_string(avgColLen);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ")";
}


Decimal::~Decimal() throw() {
}


void Decimal::__set_unscaled(const std::string& val) {
  this->unscaled = val;
}

void Decimal::__set_scale(const int16_t val) {
  this->scale = val;
}

uint32_t Decimal::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_unscaled = false;
  bool isset_scale = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->unscaled);
          isset_unscaled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scale);
          isset_scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_unscaled)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_scale)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Decimal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Decimal");

  xfer += oprot->writeFieldBegin("unscaled", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->unscaled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->scale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Decimal &a, Decimal &b) {
  using ::std::swap;
  swap(a.unscaled, b.unscaled);
  swap(a.scale, b.scale);
}

Decimal::Decimal(const Decimal& other289) {
  unscaled = other289.unscaled;
  scale = other289.scale;
}
Decimal& Decimal::operator=(const Decimal& other290) {
  unscaled = other290.unscaled;
  scale = other290.scale;
  return *this;
}
void Decimal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Decimal(";
  out << "unscaled=" << to_string(unscaled);
  out << ", " << "scale=" << to_string(scale);
  out << ")";
}


DecimalColumnStatsData::~DecimalColumnStatsData() throw() {
}


void DecimalColumnStatsData::__set_lowValue(const Decimal& val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DecimalColumnStatsData::__set_highValue(const Decimal& val) {
  this->highValue = val;
__isset.highValue = true;
}

void DecimalColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DecimalColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

uint32_t DecimalColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lowValue.read(iprot);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->highValue.read(iprot);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DecimalColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DecimalColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lowValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->highValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DecimalColumnStatsData &a, DecimalColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.__isset, b.__isset);
}

DecimalColumnStatsData::DecimalColumnStatsData(const DecimalColumnStatsData& other291) {
  lowValue = other291.lowValue;
  highValue = other291.highValue;
  numNulls = other291.numNulls;
  numDVs = other291.numDVs;
  __isset = other291.__isset;
}
DecimalColumnStatsData& DecimalColumnStatsData::operator=(const DecimalColumnStatsData& other292) {
  lowValue = other292.lowValue;
  highValue = other292.highValue;
  numNulls = other292.numNulls;
  numDVs = other292.numDVs;
  __isset = other292.__isset;
  return *this;
}
void DecimalColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DecimalColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ")";
}


Date::~Date() throw() {
}


void Date::__set_daysSinceEpoch(const int64_t val) {
  this->daysSinceEpoch = val;
}

uint32_t Date::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_daysSinceEpoch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->daysSinceEpoch);
          isset_daysSinceEpoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_daysSinceEpoch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Date::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Date");

  xfer += oprot->writeFieldBegin("daysSinceEpoch", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->daysSinceEpoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Date &a, Date &b) {
  using ::std::swap;
  swap(a.daysSinceEpoch, b.daysSinceEpoch);
}

Date::Date(const Date& other293) {
  daysSinceEpoch = other293.daysSinceEpoch;
}
Date& Date::operator=(const Date& other294) {
  daysSinceEpoch = other294.daysSinceEpoch;
  return *this;
}
void Date::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Date(";
  out << "daysSinceEpoch=" << to_string(daysSinceEpoch);
  out << ")";
}


DateColumnStatsData::~DateColumnStatsData() throw() {
}


void DateColumnStatsData::__set_lowValue(const Date& val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DateColumnStatsData::__set_highValue(const Date& val) {
  this->highValue = val;
__isset.highValue = true;
}

void DateColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DateColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

uint32_t DateColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lowValue.read(iprot);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->highValue.read(iprot);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DateColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DateColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lowValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->highValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DateColumnStatsData &a, DateColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.__isset, b.__isset);
}

DateColumnStatsData::DateColumnStatsData(const DateColumnStatsData& other295) {
  lowValue = other295.lowValue;
  highValue = other295.highValue;
  numNulls = other295.numNulls;
  numDVs = other295.numDVs;
  __isset = other295.__isset;
}
DateColumnStatsData& DateColumnStatsData::operator=(const DateColumnStatsData& other296) {
  lowValue = other296.lowValue;
  highValue = other296.highValue;
  numNulls = other296.numNulls;
  numDVs = other296.numDVs;
  __isset = other296.__isset;
  return *this;
}
void DateColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DateColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ")";
}


ColumnStatisticsData::~ColumnStatisticsData() throw() {
}


void ColumnStatisticsData::__set_booleanStats(const BooleanColumnStatsData& val) {
  this->booleanStats = val;
}

void ColumnStatisticsData::__set_longStats(const LongColumnStatsData& val) {
  this->longStats = val;
}

void ColumnStatisticsData::__set_doubleStats(const DoubleColumnStatsData& val) {
  this->doubleStats = val;
}

void ColumnStatisticsData::__set_stringStats(const StringColumnStatsData& val) {
  this->stringStats = val;
}

void ColumnStatisticsData::__set_binaryStats(const BinaryColumnStatsData& val) {
  this->binaryStats = val;
}

void ColumnStatisticsData::__set_decimalStats(const DecimalColumnStatsData& val) {
  this->decimalStats = val;
}

void ColumnStatisticsData::__set_dateStats(const DateColumnStatsData& val) {
  this->dateStats = val;
}

uint32_t ColumnStatisticsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->booleanStats.read(iprot);
          this->__isset.booleanStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->longStats.read(iprot);
          this->__isset.longStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->doubleStats.read(iprot);
          this->__isset.doubleStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringStats.read(iprot);
          this->__isset.stringStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->binaryStats.read(iprot);
          this->__isset.binaryStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->decimalStats.read(iprot);
          this->__isset.decimalStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dateStats.read(iprot);
          this->__isset.dateStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnStatisticsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsData");

  xfer += oprot->writeFieldBegin("booleanStats", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->booleanStats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("longStats", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->longStats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doubleStats", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->doubleStats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringStats", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->stringStats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binaryStats", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->binaryStats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("decimalStats", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->decimalStats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dateStats", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->dateStats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsData &a, ColumnStatisticsData &b) {
  using ::std::swap;
  swap(a.booleanStats, b.booleanStats);
  swap(a.longStats, b.longStats);
  swap(a.doubleStats, b.doubleStats);
  swap(a.stringStats, b.stringStats);
  swap(a.binaryStats, b.binaryStats);
  swap(a.decimalStats, b.decimalStats);
  swap(a.dateStats, b.dateStats);
  swap(a.__isset, b.__isset);
}

ColumnStatisticsData::ColumnStatisticsData(const ColumnStatisticsData& other297) {
  booleanStats = other297.booleanStats;
  longStats = other297.longStats;
  doubleStats = other297.doubleStats;
  stringStats = other297.stringStats;
  binaryStats = other297.binaryStats;
  decimalStats = other297.decimalStats;
  dateStats = other297.dateStats;
  __isset = other297.__isset;
}
ColumnStatisticsData& ColumnStatisticsData::operator=(const ColumnStatisticsData& other298) {
  booleanStats = other298.booleanStats;
  longStats = other298.longStats;
  doubleStats = other298.doubleStats;
  stringStats = other298.stringStats;
  binaryStats = other298.binaryStats;
  decimalStats = other298.decimalStats;
  dateStats = other298.dateStats;
  __isset = other298.__isset;
  return *this;
}
void ColumnStatisticsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsData(";
  out << "booleanStats=" << to_string(booleanStats);
  out << ", " << "longStats=" << to_string(longStats);
  out << ", " << "doubleStats=" << to_string(doubleStats);
  out << ", " << "stringStats=" << to_string(stringStats);
  out << ", " << "binaryStats=" << to_string(binaryStats);
  out << ", " << "decimalStats=" << to_string(decimalStats);
  out << ", " << "dateStats=" << to_string(dateStats);
  out << ")";
}


ColumnStatisticsObj::~ColumnStatisticsObj() throw() {
}


void ColumnStatisticsObj::__set_colName(const std::string& val) {
  this->colName = val;
}

void ColumnStatisticsObj::__set_colType(const std::string& val) {
  this->colType = val;
}

void ColumnStatisticsObj::__set_statsData(const ColumnStatisticsData& val) {
  this->statsData = val;
}

uint32_t ColumnStatisticsObj::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colName = false;
  bool isset_colType = false;
  bool isset_statsData = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colName);
          isset_colName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colType);
          isset_colType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statsData.read(iprot);
          isset_statsData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statsData)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatisticsObj::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsObj");

  xfer += oprot->writeFieldBegin("colName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->colName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colType", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->colType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statsData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->statsData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsObj &a, ColumnStatisticsObj &b) {
  using ::std::swap;
  swap(a.colName, b.colName);
  swap(a.colType, b.colType);
  swap(a.statsData, b.statsData);
}

ColumnStatisticsObj::ColumnStatisticsObj(const ColumnStatisticsObj& other299) {
  colName = other299.colName;
  colType = other299.colType;
  statsData = other299.statsData;
}
ColumnStatisticsObj& ColumnStatisticsObj::operator=(const ColumnStatisticsObj& other300) {
  colName = other300.colName;
  colType = other300.colType;
  statsData = other300.statsData;
  return *this;
}
void ColumnStatisticsObj::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsObj(";
  out << "colName=" << to_string(colName);
  out << ", " << "colType=" << to_string(colType);
  out << ", " << "statsData=" << to_string(statsData);
  out << ")";
}


ColumnStatisticsDesc::~ColumnStatisticsDesc() throw() {
}


void ColumnStatisticsDesc::__set_isTblLevel(const bool val) {
  this->isTblLevel = val;
}

void ColumnStatisticsDesc::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void ColumnStatisticsDesc::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void ColumnStatisticsDesc::__set_partName(const std::string& val) {
  this->partName = val;
__isset.partName = true;
}

void ColumnStatisticsDesc::__set_lastAnalyzed(const int64_t val) {
  this->lastAnalyzed = val;
__isset.lastAnalyzed = true;
}

uint32_t ColumnStatisticsDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isTblLevel = false;
  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isTblLevel);
          isset_isTblLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partName);
          this->__isset.partName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastAnalyzed);
          this->__isset.lastAnalyzed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isTblLevel)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatisticsDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsDesc");

  xfer += oprot->writeFieldBegin("isTblLevel", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isTblLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partName) {
    xfer += oprot->writeFieldBegin("partName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->partName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastAnalyzed) {
    xfer += oprot->writeFieldBegin("lastAnalyzed", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->lastAnalyzed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsDesc &a, ColumnStatisticsDesc &b) {
  using ::std::swap;
  swap(a.isTblLevel, b.isTblLevel);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partName, b.partName);
  swap(a.lastAnalyzed, b.lastAnalyzed);
  swap(a.__isset, b.__isset);
}

ColumnStatisticsDesc::ColumnStatisticsDesc(const ColumnStatisticsDesc& other301) {
  isTblLevel = other301.isTblLevel;
  dbName = other301.dbName;
  tableName = other301.tableName;
  partName = other301.partName;
  lastAnalyzed = other301.lastAnalyzed;
  __isset = other301.__isset;
}
ColumnStatisticsDesc& ColumnStatisticsDesc::operator=(const ColumnStatisticsDesc& other302) {
  isTblLevel = other302.isTblLevel;
  dbName = other302.dbName;
  tableName = other302.tableName;
  partName = other302.partName;
  lastAnalyzed = other302.lastAnalyzed;
  __isset = other302.__isset;
  return *this;
}
void ColumnStatisticsDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsDesc(";
  out << "isTblLevel=" << to_string(isTblLevel);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partName="; (__isset.partName ? (out << to_string(partName)) : (out << "<null>"));
  out << ", " << "lastAnalyzed="; (__isset.lastAnalyzed ? (out << to_string(lastAnalyzed)) : (out << "<null>"));
  out << ")";
}


ColumnStatistics::~ColumnStatistics() throw() {
}


void ColumnStatistics::__set_statsDesc(const ColumnStatisticsDesc& val) {
  this->statsDesc = val;
}

void ColumnStatistics::__set_statsObj(const std::vector<ColumnStatisticsObj> & val) {
  this->statsObj = val;
}

uint32_t ColumnStatistics::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_statsDesc = false;
  bool isset_statsObj = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statsDesc.read(iprot);
          isset_statsDesc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statsObj.clear();
            uint32_t _size303;
            ::apache::thrift::protocol::TType _etype306;
            xfer += iprot->readListBegin(_etype306, _size303);
            this->statsObj.resize(_size303);
            uint32_t _i307;
            for (_i307 = 0; _i307 < _size303; ++_i307)
            {
              xfer += this->statsObj[_i307].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_statsObj = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_statsDesc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statsObj)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatistics::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatistics");

  xfer += oprot->writeFieldBegin("statsDesc", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->statsDesc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statsObj", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statsObj.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter308;
    for (_iter308 = this->statsObj.begin(); _iter308 != this->statsObj.end(); ++_iter308)
    {
      xfer += (*_iter308).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatistics &a, ColumnStatistics &b) {
  using ::std::swap;
  swap(a.statsDesc, b.statsDesc);
  swap(a.statsObj, b.statsObj);
}

ColumnStatistics::ColumnStatistics(const ColumnStatistics& other309) {
  statsDesc = other309.statsDesc;
  statsObj = other309.statsObj;
}
ColumnStatistics& ColumnStatistics::operator=(const ColumnStatistics& other310) {
  statsDesc = other310.statsDesc;
  statsObj = other310.statsObj;
  return *this;
}
void ColumnStatistics::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatistics(";
  out << "statsDesc=" << to_string(statsDesc);
  out << ", " << "statsObj=" << to_string(statsObj);
  out << ")";
}


AggrStats::~AggrStats() throw() {
}


void AggrStats::__set_colStats(const std::vector<ColumnStatisticsObj> & val) {
  this->colStats = val;
}

void AggrStats::__set_partsFound(const int64_t val) {
  this->partsFound = val;
}

uint32_t AggrStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colStats = false;
  bool isset_partsFound = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colStats.clear();
            uint32_t _size311;
            ::apache::thrift::protocol::TType _etype314;
            xfer += iprot->readListBegin(_etype314, _size311);
            this->colStats.resize(_size311);
            uint32_t _i315;
            for (_i315 = 0; _i315 < _size311; ++_i315)
            {
              xfer += this->colStats[_i315].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->partsFound);
          isset_partsFound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partsFound)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AggrStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AggrStats");

  xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colStats.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter316;
    for (_iter316 = this->colStats.begin(); _iter316 != this->colStats.end(); ++_iter316)
    {
      xfer += (*_iter316).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partsFound", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->partsFound);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AggrStats &a, AggrStats &b) {
  using ::std::swap;
  swap(a.colStats, b.colStats);
  swap(a.partsFound, b.partsFound);
}

AggrStats::AggrStats(const AggrStats& other317) {
  colStats = other317.colStats;
  partsFound = other317.partsFound;
}
AggrStats& AggrStats::operator=(const AggrStats& other318) {
  colStats = other318.colStats;
  partsFound = other318.partsFound;
  return *this;
}
void AggrStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AggrStats(";
  out << "colStats=" << to_string(colStats);
  out << ", " << "partsFound=" << to_string(partsFound);
  out << ")";
}


SetPartitionsStatsRequest::~SetPartitionsStatsRequest() throw() {
}


void SetPartitionsStatsRequest::__set_colStats(const std::vector<ColumnStatistics> & val) {
  this->colStats = val;
}

uint32_t SetPartitionsStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colStats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colStats.clear();
            uint32_t _size319;
            ::apache::thrift::protocol::TType _etype322;
            xfer += iprot->readListBegin(_etype322, _size319);
            this->colStats.resize(_size319);
            uint32_t _i323;
            for (_i323 = 0; _i323 < _size319; ++_i323)
            {
              xfer += this->colStats[_i323].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SetPartitionsStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetPartitionsStatsRequest");

  xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colStats.size()));
    std::vector<ColumnStatistics> ::const_iterator _iter324;
    for (_iter324 = this->colStats.begin(); _iter324 != this->colStats.end(); ++_iter324)
    {
      xfer += (*_iter324).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetPartitionsStatsRequest &a, SetPartitionsStatsRequest &b) {
  using ::std::swap;
  swap(a.colStats, b.colStats);
}

SetPartitionsStatsRequest::SetPartitionsStatsRequest(const SetPartitionsStatsRequest& other325) {
  colStats = other325.colStats;
}
SetPartitionsStatsRequest& SetPartitionsStatsRequest::operator=(const SetPartitionsStatsRequest& other326) {
  colStats = other326.colStats;
  return *this;
}
void SetPartitionsStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetPartitionsStatsRequest(";
  out << "colStats=" << to_string(colStats);
  out << ")";
}


Schema::~Schema() throw() {
}


void Schema::__set_fieldSchemas(const std::vector<FieldSchema> & val) {
  this->fieldSchemas = val;
}

void Schema::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}

uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fieldSchemas.clear();
            uint32_t _size327;
            ::apache::thrift::protocol::TType _etype330;
            xfer += iprot->readListBegin(_etype330, _size327);
            this->fieldSchemas.resize(_size327);
            uint32_t _i331;
            for (_i331 = 0; _i331 < _size327; ++_i331)
            {
              xfer += this->fieldSchemas[_i331].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldSchemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size332;
            ::apache::thrift::protocol::TType _ktype333;
            ::apache::thrift::protocol::TType _vtype334;
            xfer += iprot->readMapBegin(_ktype333, _vtype334, _size332);
            uint32_t _i336;
            for (_i336 = 0; _i336 < _size332; ++_i336)
            {
              std::string _key337;
              xfer += iprot->readString(_key337);
              std::string& _val338 = this->properties[_key337];
              xfer += iprot->readString(_val338);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  xfer += oprot->writeFieldBegin("fieldSchemas", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fieldSchemas.size()));
    std::vector<FieldSchema> ::const_iterator _iter339;
    for (_iter339 = this->fieldSchemas.begin(); _iter339 != this->fieldSchemas.end(); ++_iter339)
    {
      xfer += (*_iter339).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter340;
    for (_iter340 = this->properties.begin(); _iter340 != this->properties.end(); ++_iter340)
    {
      xfer += oprot->writeString(_iter340->first);
      xfer += oprot->writeString(_iter340->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.fieldSchemas, b.fieldSchemas);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other341) {
  fieldSchemas = other341.fieldSchemas;
  properties = other341.properties;
  __isset = other341.__isset;
}
Schema& Schema::operator=(const Schema& other342) {
  fieldSchemas = other342.fieldSchemas;
  properties = other342.properties;
  __isset = other342.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "fieldSchemas=" << to_string(fieldSchemas);
  out << ", " << "properties=" << to_string(properties);
  out << ")";
}


EnvironmentContext::~EnvironmentContext() throw() {
}


void EnvironmentContext::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}

uint32_t EnvironmentContext::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size343;
            ::apache::thrift::protocol::TType _ktype344;
            ::apache::thrift::protocol::TType _vtype345;
            xfer += iprot->readMapBegin(_ktype344, _vtype345, _size343);
            uint32_t _i347;
            for (_i347 = 0; _i347 < _size343; ++_i347)
            {
              std::string _key348;
              xfer += iprot->readString(_key348);
              std::string& _val349 = this->properties[_key348];
              xfer += iprot->readString(_val349);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnvironmentContext::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnvironmentContext");

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter350;
    for (_iter350 = this->properties.begin(); _iter350 != this->properties.end(); ++_iter350)
    {
      xfer += oprot->writeString(_iter350->first);
      xfer += oprot->writeString(_iter350->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnvironmentContext &a, EnvironmentContext &b) {
  using ::std::swap;
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

EnvironmentContext::EnvironmentContext(const EnvironmentContext& other351) {
  properties = other351.properties;
  __isset = other351.__isset;
}
EnvironmentContext& EnvironmentContext::operator=(const EnvironmentContext& other352) {
  properties = other352.properties;
  __isset = other352.__isset;
  return *this;
}
void EnvironmentContext::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnvironmentContext(";
  out << "properties=" << to_string(properties);
  out << ")";
}


PartitionsByExprResult::~PartitionsByExprResult() throw() {
}


void PartitionsByExprResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}

void PartitionsByExprResult::__set_hasUnknownPartitions(const bool val) {
  this->hasUnknownPartitions = val;
}

uint32_t PartitionsByExprResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitions = false;
  bool isset_hasUnknownPartitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size353;
            ::apache::thrift::protocol::TType _etype356;
            xfer += iprot->readListBegin(_etype356, _size353);
            this->partitions.resize(_size353);
            uint32_t _i357;
            for (_i357 = 0; _i357 < _size353; ++_i357)
            {
              xfer += this->partitions[_i357].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasUnknownPartitions);
          isset_hasUnknownPartitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasUnknownPartitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsByExprResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsByExprResult");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter358;
    for (_iter358 = this->partitions.begin(); _iter358 != this->partitions.end(); ++_iter358)
    {
      xfer += (*_iter358).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasUnknownPartitions", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasUnknownPartitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsByExprResult &a, PartitionsByExprResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.hasUnknownPartitions, b.hasUnknownPartitions);
}

PartitionsByExprResult::PartitionsByExprResult(const PartitionsByExprResult& other359) {
  partitions = other359.partitions;
  hasUnknownPartitions = other359.hasUnknownPartitions;
}
PartitionsByExprResult& PartitionsByExprResult::operator=(const PartitionsByExprResult& other360) {
  partitions = other360.partitions;
  hasUnknownPartitions = other360.hasUnknownPartitions;
  return *this;
}
void PartitionsByExprResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsByExprResult(";
  out << "partitions=" << to_string(partitions);
  out << ", " << "hasUnknownPartitions=" << to_string(hasUnknownPartitions);
  out << ")";
}


PartitionsByExprRequest::~PartitionsByExprRequest() throw() {
}


void PartitionsByExprRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionsByExprRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionsByExprRequest::__set_expr(const std::string& val) {
  this->expr = val;
}

void PartitionsByExprRequest::__set_defaultPartitionName(const std::string& val) {
  this->defaultPartitionName = val;
__isset.defaultPartitionName = true;
}

void PartitionsByExprRequest::__set_maxParts(const int16_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

uint32_t PartitionsByExprRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultPartitionName);
          this->__isset.defaultPartitionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsByExprRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsByExprRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.defaultPartitionName) {
    xfer += oprot->writeFieldBegin("defaultPartitionName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->defaultPartitionName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I16, 5);
    xfer += oprot->writeI16(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsByExprRequest &a, PartitionsByExprRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.expr, b.expr);
  swap(a.defaultPartitionName, b.defaultPartitionName);
  swap(a.maxParts, b.maxParts);
  swap(a.__isset, b.__isset);
}

PartitionsByExprRequest::PartitionsByExprRequest(const PartitionsByExprRequest& other361) {
  dbName = other361.dbName;
  tblName = other361.tblName;
  expr = other361.expr;
  defaultPartitionName = other361.defaultPartitionName;
  maxParts = other361.maxParts;
  __isset = other361.__isset;
}
PartitionsByExprRequest& PartitionsByExprRequest::operator=(const PartitionsByExprRequest& other362) {
  dbName = other362.dbName;
  tblName = other362.tblName;
  expr = other362.expr;
  defaultPartitionName = other362.defaultPartitionName;
  maxParts = other362.maxParts;
  __isset = other362.__isset;
  return *this;
}
void PartitionsByExprRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsByExprRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "expr=" << to_string(expr);
  out << ", " << "defaultPartitionName="; (__isset.defaultPartitionName ? (out << to_string(defaultPartitionName)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ")";
}


TableStatsResult::~TableStatsResult() throw() {
}


void TableStatsResult::__set_tableStats(const std::vector<ColumnStatisticsObj> & val) {
  this->tableStats = val;
}

uint32_t TableStatsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableStats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tableStats.clear();
            uint32_t _size363;
            ::apache::thrift::protocol::TType _etype366;
            xfer += iprot->readListBegin(_etype366, _size363);
            this->tableStats.resize(_size363);
            uint32_t _i367;
            for (_i367 = 0; _i367 < _size363; ++_i367)
            {
              xfer += this->tableStats[_i367].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tableStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableStatsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableStatsResult");

  xfer += oprot->writeFieldBegin("tableStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tableStats.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter368;
    for (_iter368 = this->tableStats.begin(); _iter368 != this->tableStats.end(); ++_iter368)
    {
      xfer += (*_iter368).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableStatsResult &a, TableStatsResult &b) {
  using ::std::swap;
  swap(a.tableStats, b.tableStats);
}

TableStatsResult::TableStatsResult(const TableStatsResult& other369) {
  tableStats = other369.tableStats;
}
TableStatsResult& TableStatsResult::operator=(const TableStatsResult& other370) {
  tableStats = other370.tableStats;
  return *this;
}
void TableStatsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableStatsResult(";
  out << "tableStats=" << to_string(tableStats);
  out << ")";
}


PartitionsStatsResult::~PartitionsStatsResult() throw() {
}


void PartitionsStatsResult::__set_partStats(const std::map<std::string, std::vector<ColumnStatisticsObj> > & val) {
  this->partStats = val;
}

uint32_t PartitionsStatsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partStats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->partStats.clear();
            uint32_t _size371;
            ::apache::thrift::protocol::TType _ktype372;
            ::apache::thrift::protocol::TType _vtype373;
            xfer += iprot->readMapBegin(_ktype372, _vtype373, _size371);
            uint32_t _i375;
            for (_i375 = 0; _i375 < _size371; ++_i375)
            {
              std::string _key376;
              xfer += iprot->readString(_key376);
              std::vector<ColumnStatisticsObj> & _val377 = this->partStats[_key376];
              {
                _val377.clear();
                uint32_t _size378;
                ::apache::thrift::protocol::TType _etype381;
                xfer += iprot->readListBegin(_etype381, _size378);
                _val377.resize(_size378);
                uint32_t _i382;
                for (_i382 = 0; _i382 < _size378; ++_i382)
                {
                  xfer += _val377[_i382].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_partStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsStatsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsStatsResult");

  xfer += oprot->writeFieldBegin("partStats", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partStats.size()));
    std::map<std::string, std::vector<ColumnStatisticsObj> > ::const_iterator _iter383;
    for (_iter383 = this->partStats.begin(); _iter383 != this->partStats.end(); ++_iter383)
    {
      xfer += oprot->writeString(_iter383->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter383->second.size()));
        std::vector<ColumnStatisticsObj> ::const_iterator _iter384;
        for (_iter384 = _iter383->second.begin(); _iter384 != _iter383->second.end(); ++_iter384)
        {
          xfer += (*_iter384).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsStatsResult &a, PartitionsStatsResult &b) {
  using ::std::swap;
  swap(a.partStats, b.partStats);
}

PartitionsStatsResult::PartitionsStatsResult(const PartitionsStatsResult& other385) {
  partStats = other385.partStats;
}
PartitionsStatsResult& PartitionsStatsResult::operator=(const PartitionsStatsResult& other386) {
  partStats = other386.partStats;
  return *this;
}
void PartitionsStatsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsStatsResult(";
  out << "partStats=" << to_string(partStats);
  out << ")";
}


TableStatsRequest::~TableStatsRequest() throw() {
}


void TableStatsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void TableStatsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void TableStatsRequest::__set_colNames(const std::vector<std::string> & val) {
  this->colNames = val;
}

uint32_t TableStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_colNames = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colNames.clear();
            uint32_t _size387;
            ::apache::thrift::protocol::TType _etype390;
            xfer += iprot->readListBegin(_etype390, _size387);
            this->colNames.resize(_size387);
            uint32_t _i391;
            for (_i391 = 0; _i391 < _size387; ++_i391)
            {
              xfer += iprot->readString(this->colNames[_i391]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableStatsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colNames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->colNames.size()));
    std::vector<std::string> ::const_iterator _iter392;
    for (_iter392 = this->colNames.begin(); _iter392 != this->colNames.end(); ++_iter392)
    {
      xfer += oprot->writeString((*_iter392));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableStatsRequest &a, TableStatsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.colNames, b.colNames);
}

TableStatsRequest::TableStatsRequest(const TableStatsRequest& other393) {
  dbName = other393.dbName;
  tblName = other393.tblName;
  colNames = other393.colNames;
}
TableStatsRequest& TableStatsRequest::operator=(const TableStatsRequest& other394) {
  dbName = other394.dbName;
  tblName = other394.tblName;
  colNames = other394.colNames;
  return *this;
}
void TableStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableStatsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "colNames=" << to_string(colNames);
  out << ")";
}


PartitionsStatsRequest::~PartitionsStatsRequest() throw() {
}


void PartitionsStatsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionsStatsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionsStatsRequest::__set_colNames(const std::vector<std::string> & val) {
  this->colNames = val;
}

void PartitionsStatsRequest::__set_partNames(const std::vector<std::string> & val) {
  this->partNames = val;
}

uint32_t PartitionsStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_colNames = false;
  bool isset_partNames = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colNames.clear();
            uint32_t _size395;
            ::apache::thrift::protocol::TType _etype398;
            xfer += iprot->readListBegin(_etype398, _size395);
            this->colNames.resize(_size395);
            uint32_t _i399;
            for (_i399 = 0; _i399 < _size395; ++_i399)
            {
              xfer += iprot->readString(this->colNames[_i399]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partNames.clear();
            uint32_t _size400;
            ::apache::thrift::protocol::TType _etype403;
            xfer += iprot->readListBegin(_etype403, _size400);
            this->partNames.resize(_size400);
            uint32_t _i404;
            for (_i404 = 0; _i404 < _size400; ++_i404)
            {
              xfer += iprot->readString(this->partNames[_i404]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsStatsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colNames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->colNames.size()));
    std::vector<std::string> ::const_iterator _iter405;
    for (_iter405 = this->colNames.begin(); _iter405 != this->colNames.end(); ++_iter405)
    {
      xfer += oprot->writeString((*_iter405));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partNames", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partNames.size()));
    std::vector<std::string> ::const_iterator _iter406;
    for (_iter406 = this->partNames.begin(); _iter406 != this->partNames.end(); ++_iter406)
    {
      xfer += oprot->writeString((*_iter406));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsStatsRequest &a, PartitionsStatsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.colNames, b.colNames);
  swap(a.partNames, b.partNames);
}

PartitionsStatsRequest::PartitionsStatsRequest(const PartitionsStatsRequest& other407) {
  dbName = other407.dbName;
  tblName = other407.tblName;
  colNames = other407.colNames;
  partNames = other407.partNames;
}
PartitionsStatsRequest& PartitionsStatsRequest::operator=(const PartitionsStatsRequest& other408) {
  dbName = other408.dbName;
  tblName = other408.tblName;
  colNames = other408.colNames;
  partNames = other408.partNames;
  return *this;
}
void PartitionsStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsStatsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "colNames=" << to_string(colNames);
  out << ", " << "partNames=" << to_string(partNames);
  out << ")";
}


AddPartitionsResult::~AddPartitionsResult() throw() {
}


void AddPartitionsResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
__isset.partitions = true;
}

uint32_t AddPartitionsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size409;
            ::apache::thrift::protocol::TType _etype412;
            xfer += iprot->readListBegin(_etype412, _size409);
            this->partitions.resize(_size409);
            uint32_t _i413;
            for (_i413 = 0; _i413 < _size409; ++_i413)
            {
              xfer += this->partitions[_i413].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddPartitionsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPartitionsResult");

  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::vector<Partition> ::const_iterator _iter414;
      for (_iter414 = this->partitions.begin(); _iter414 != this->partitions.end(); ++_iter414)
      {
        xfer += (*_iter414).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPartitionsResult &a, AddPartitionsResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

AddPartitionsResult::AddPartitionsResult(const AddPartitionsResult& other415) {
  partitions = other415.partitions;
  __isset = other415.__isset;
}
AddPartitionsResult& AddPartitionsResult::operator=(const AddPartitionsResult& other416) {
  partitions = other416.partitions;
  __isset = other416.__isset;
  return *this;
}
void AddPartitionsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPartitionsResult(";
  out << "partitions="; (__isset.partitions ? (out << to_string(partitions)) : (out << "<null>"));
  out << ")";
}


AddPartitionsRequest::~AddPartitionsRequest() throw() {
}


void AddPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AddPartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void AddPartitionsRequest::__set_parts(const std::vector<Partition> & val) {
  this->parts = val;
}

void AddPartitionsRequest::__set_ifNotExists(const bool val) {
  this->ifNotExists = val;
}

void AddPartitionsRequest::__set_needResult(const bool val) {
  this->needResult = val;
__isset.needResult = true;
}

uint32_t AddPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_parts = false;
  bool isset_ifNotExists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->parts.clear();
            uint32_t _size417;
            ::apache::thrift::protocol::TType _etype420;
            xfer += iprot->readListBegin(_etype420, _size417);
            this->parts.resize(_size417);
            uint32_t _i421;
            for (_i421 = 0; _i421 < _size417; ++_i421)
            {
              xfer += this->parts[_i421].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ifNotExists);
          isset_ifNotExists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needResult);
          this->__isset.needResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ifNotExists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPartitionsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parts", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->parts.size()));
    std::vector<Partition> ::const_iterator _iter422;
    for (_iter422 = this->parts.begin(); _iter422 != this->parts.end(); ++_iter422)
    {
      xfer += (*_iter422).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ifNotExists", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->ifNotExists);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.needResult) {
    xfer += oprot->writeFieldBegin("needResult", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->needResult);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPartitionsRequest &a, AddPartitionsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.parts, b.parts);
  swap(a.ifNotExists, b.ifNotExists);
  swap(a.needResult, b.needResult);
  swap(a.__isset, b.__isset);
}

AddPartitionsRequest::AddPartitionsRequest(const AddPartitionsRequest& other423) {
  dbName = other423.dbName;
  tblName = other423.tblName;
  parts = other423.parts;
  ifNotExists = other423.ifNotExists;
  needResult = other423.needResult;
  __isset = other423.__isset;
}
AddPartitionsRequest& AddPartitionsRequest::operator=(const AddPartitionsRequest& other424) {
  dbName = other424.dbName;
  tblName = other424.tblName;
  parts = other424.parts;
  ifNotExists = other424.ifNotExists;
  needResult = other424.needResult;
  __isset = other424.__isset;
  return *this;
}
void AddPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPartitionsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "parts=" << to_string(parts);
  out << ", " << "ifNotExists=" << to_string(ifNotExists);
  out << ", " << "needResult="; (__isset.needResult ? (out << to_string(needResult)) : (out << "<null>"));
  out << ")";
}


DropPartitionsResult::~DropPartitionsResult() throw() {
}


void DropPartitionsResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
__isset.partitions = true;
}

uint32_t DropPartitionsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size425;
            ::apache::thrift::protocol::TType _etype428;
            xfer += iprot->readListBegin(_etype428, _size425);
            this->partitions.resize(_size425);
            uint32_t _i429;
            for (_i429 = 0; _i429 < _size425; ++_i429)
            {
              xfer += this->partitions[_i429].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropPartitionsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsResult");

  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::vector<Partition> ::const_iterator _iter430;
      for (_iter430 = this->partitions.begin(); _iter430 != this->partitions.end(); ++_iter430)
      {
        xfer += (*_iter430).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsResult &a, DropPartitionsResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

DropPartitionsResult::DropPartitionsResult(const DropPartitionsResult& other431) {
  partitions = other431.partitions;
  __isset = other431.__isset;
}
DropPartitionsResult& DropPartitionsResult::operator=(const DropPartitionsResult& other432) {
  partitions = other432.partitions;
  __isset = other432.__isset;
  return *this;
}
void DropPartitionsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsResult(";
  out << "partitions="; (__isset.partitions ? (out << to_string(partitions)) : (out << "<null>"));
  out << ")";
}


DropPartitionsExpr::~DropPartitionsExpr() throw() {
}


void DropPartitionsExpr::__set_expr(const std::string& val) {
  this->expr = val;
}

void DropPartitionsExpr::__set_partArchiveLevel(const int32_t val) {
  this->partArchiveLevel = val;
__isset.partArchiveLevel = true;
}

uint32_t DropPartitionsExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partArchiveLevel);
          this->__isset.partArchiveLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropPartitionsExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsExpr");

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partArchiveLevel) {
    xfer += oprot->writeFieldBegin("partArchiveLevel", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->partArchiveLevel);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsExpr &a, DropPartitionsExpr &b) {
  using ::std::swap;
  swap(a.expr, b.expr);
  swap(a.partArchiveLevel, b.partArchiveLevel);
  swap(a.__isset, b.__isset);
}

DropPartitionsExpr::DropPartitionsExpr(const DropPartitionsExpr& other433) {
  expr = other433.expr;
  partArchiveLevel = other433.partArchiveLevel;
  __isset = other433.__isset;
}
DropPartitionsExpr& DropPartitionsExpr::operator=(const DropPartitionsExpr& other434) {
  expr = other434.expr;
  partArchiveLevel = other434.partArchiveLevel;
  __isset = other434.__isset;
  return *this;
}
void DropPartitionsExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsExpr(";
  out << "expr=" << to_string(expr);
  out << ", " << "partArchiveLevel="; (__isset.partArchiveLevel ? (out << to_string(partArchiveLevel)) : (out << "<null>"));
  out << ")";
}


RequestPartsSpec::~RequestPartsSpec() throw() {
}


void RequestPartsSpec::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}

void RequestPartsSpec::__set_exprs(const std::vector<DropPartitionsExpr> & val) {
  this->exprs = val;
}

uint32_t RequestPartsSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size435;
            ::apache::thrift::protocol::TType _etype438;
            xfer += iprot->readListBegin(_etype438, _size435);
            this->names.resize(_size435);
            uint32_t _i439;
            for (_i439 = 0; _i439 < _size435; ++_i439)
            {
              xfer += iprot->readString(this->names[_i439]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exprs.clear();
            uint32_t _size440;
            ::apache::thrift::protocol::TType _etype443;
            xfer += iprot->readListBegin(_etype443, _size440);
            this->exprs.resize(_size440);
            uint32_t _i444;
            for (_i444 = 0; _i444 < _size440; ++_i444)
            {
              xfer += this->exprs[_i444].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RequestPartsSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RequestPartsSpec");

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter445;
    for (_iter445 = this->names.begin(); _iter445 != this->names.end(); ++_iter445)
    {
      xfer += oprot->writeString((*_iter445));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exprs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exprs.size()));
    std::vector<DropPartitionsExpr> ::const_iterator _iter446;
    for (_iter446 = this->exprs.begin(); _iter446 != this->exprs.end(); ++_iter446)
    {
      xfer += (*_iter446).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RequestPartsSpec &a, RequestPartsSpec &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.exprs, b.exprs);
  swap(a.__isset, b.__isset);
}

RequestPartsSpec::RequestPartsSpec(const RequestPartsSpec& other447) {
  names = other447.names;
  exprs = other447.exprs;
  __isset = other447.__isset;
}
RequestPartsSpec& RequestPartsSpec::operator=(const RequestPartsSpec& other448) {
  names = other448.names;
  exprs = other448.exprs;
  __isset = other448.__isset;
  return *this;
}
void RequestPartsSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RequestPartsSpec(";
  out << "names=" << to_string(names);
  out << ", " << "exprs=" << to_string(exprs);
  out << ")";
}


DropPartitionsRequest::~DropPartitionsRequest() throw() {
}


void DropPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void DropPartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void DropPartitionsRequest::__set_parts(const RequestPartsSpec& val) {
  this->parts = val;
}

void DropPartitionsRequest::__set_deleteData(const bool val) {
  this->deleteData = val;
__isset.deleteData = true;
}

void DropPartitionsRequest::__set_ifExists(const bool val) {
  this->ifExists = val;
__isset.ifExists = true;
}

void DropPartitionsRequest::__set_ignoreProtection(const bool val) {
  this->ignoreProtection = val;
__isset.ignoreProtection = true;
}

void DropPartitionsRequest::__set_environmentContext(const EnvironmentContext& val) {
  this->environmentContext = val;
__isset.environmentContext = true;
}

void DropPartitionsRequest::__set_needResult(const bool val) {
  this->needResult = val;
__isset.needResult = true;
}

uint32_t DropPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_parts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parts.read(iprot);
          isset_parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleteData);
          this->__isset.deleteData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ifExists);
          this->__isset.ifExists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignoreProtection);
          this->__isset.ignoreProtection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->environmentContext.read(iprot);
          this->__isset.environmentContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needResult);
          this->__isset.needResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parts", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->parts.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.deleteData) {
    xfer += oprot->writeFieldBegin("deleteData", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->deleteData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ifExists) {
    xfer += oprot->writeFieldBegin("ifExists", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->ifExists);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ignoreProtection) {
    xfer += oprot->writeFieldBegin("ignoreProtection", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->ignoreProtection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.environmentContext) {
    xfer += oprot->writeFieldBegin("environmentContext", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->environmentContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.needResult) {
    xfer += oprot->writeFieldBegin("needResult", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->needResult);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsRequest &a, DropPartitionsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.parts, b.parts);
  swap(a.deleteData, b.deleteData);
  swap(a.ifExists, b.ifExists);
  swap(a.ignoreProtection, b.ignoreProtection);
  swap(a.environmentContext, b.environmentContext);
  swap(a.needResult, b.needResult);
  swap(a.__isset, b.__isset);
}

DropPartitionsRequest::DropPartitionsRequest(const DropPartitionsRequest& other449) {
  dbName = other449.dbName;
  tblName = other449.tblName;
  parts = other449.parts;
  deleteData = other449.deleteData;
  ifExists = other449.ifExists;
  ignoreProtection = other449.ignoreProtection;
  environmentContext = other449.environmentContext;
  needResult = other449.needResult;
  __isset = other449.__isset;
}
DropPartitionsRequest& DropPartitionsRequest::operator=(const DropPartitionsRequest& other450) {
  dbName = other450.dbName;
  tblName = other450.tblName;
  parts = other450.parts;
  deleteData = other450.deleteData;
  ifExists = other450.ifExists;
  ignoreProtection = other450.ignoreProtection;
  environmentContext = other450.environmentContext;
  needResult = other450.needResult;
  __isset = other450.__isset;
  return *this;
}
void DropPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "parts=" << to_string(parts);
  out << ", " << "deleteData="; (__isset.deleteData ? (out << to_string(deleteData)) : (out << "<null>"));
  out << ", " << "ifExists="; (__isset.ifExists ? (out << to_string(ifExists)) : (out << "<null>"));
  out << ", " << "ignoreProtection="; (__isset.ignoreProtection ? (out << to_string(ignoreProtection)) : (out << "<null>"));
  out << ", " << "environmentContext="; (__isset.environmentContext ? (out << to_string(environmentContext)) : (out << "<null>"));
  out << ", " << "needResult="; (__isset.needResult ? (out << to_string(needResult)) : (out << "<null>"));
  out << ")";
}


ResourceUri::~ResourceUri() throw() {
}


void ResourceUri::__set_resourceType(const ResourceType::type val) {
  this->resourceType = val;
}

void ResourceUri::__set_uri(const std::string& val) {
  this->uri = val;
}

uint32_t ResourceUri::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast451;
          xfer += iprot->readI32(ecast451);
          this->resourceType = (ResourceType::type)ecast451;
          this->__isset.resourceType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResourceUri::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResourceUri");

  xfer += oprot->writeFieldBegin("resourceType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->resourceType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->uri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResourceUri &a, ResourceUri &b) {
  using ::std::swap;
  swap(a.resourceType, b.resourceType);
  swap(a.uri, b.uri);
  swap(a.__isset, b.__isset);
}

ResourceUri::ResourceUri(const ResourceUri& other452) {
  resourceType = other452.resourceType;
  uri = other452.uri;
  __isset = other452.__isset;
}
ResourceUri& ResourceUri::operator=(const ResourceUri& other453) {
  resourceType = other453.resourceType;
  uri = other453.uri;
  __isset = other453.__isset;
  return *this;
}
void ResourceUri::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResourceUri(";
  out << "resourceType=" << to_string(resourceType);
  out << ", " << "uri=" << to_string(uri);
  out << ")";
}


Function::~Function() throw() {
}


void Function::__set_functionName(const std::string& val) {
  this->functionName = val;
}

void Function::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Function::__set_className(const std::string& val) {
  this->className = val;
}

void Function::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

void Function::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
}

void Function::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Function::__set_functionType(const FunctionType::type val) {
  this->functionType = val;
}

void Function::__set_resourceUris(const std::vector<ResourceUri> & val) {
  this->resourceUris = val;
}

uint32_t Function::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->functionName);
          this->__isset.functionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->className);
          this->__isset.className = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast454;
          xfer += iprot->readI32(ecast454);
          this->ownerType = (PrincipalType::type)ecast454;
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast455;
          xfer += iprot->readI32(ecast455);
          this->functionType = (FunctionType::type)ecast455;
          this->__isset.functionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resourceUris.clear();
            uint32_t _size456;
            ::apache::thrift::protocol::TType _etype459;
            xfer += iprot->readListBegin(_etype459, _size456);
            this->resourceUris.resize(_size456);
            uint32_t _i460;
            for (_i460 = 0; _i460 < _size456; ++_i460)
            {
              xfer += this->resourceUris[_i460].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resourceUris = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Function::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Function");

  xfer += oprot->writeFieldBegin("functionName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->functionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->className);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->ownerType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("functionType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->functionType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceUris", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resourceUris.size()));
    std::vector<ResourceUri> ::const_iterator _iter461;
    for (_iter461 = this->resourceUris.begin(); _iter461 != this->resourceUris.end(); ++_iter461)
    {
      xfer += (*_iter461).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Function &a, Function &b) {
  using ::std::swap;
  swap(a.functionName, b.functionName);
  swap(a.dbName, b.dbName);
  swap(a.className, b.className);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.createTime, b.createTime);
  swap(a.functionType, b.functionType);
  swap(a.resourceUris, b.resourceUris);
  swap(a.__isset, b.__isset);
}

Function::Function(const Function& other462) {
  functionName = other462.functionName;
  dbName = other462.dbName;
  className = other462.className;
  ownerName = other462.ownerName;
  ownerType = other462.ownerType;
  createTime = other462.createTime;
  functionType = other462.functionType;
  resourceUris = other462.resourceUris;
  __isset = other462.__isset;
}
Function& Function::operator=(const Function& other463) {
  functionName = other463.functionName;
  dbName = other463.dbName;
  className = other463.className;
  ownerName = other463.ownerName;
  ownerType = other463.ownerType;
  createTime = other463.createTime;
  functionType = other463.functionType;
  resourceUris = other463.resourceUris;
  __isset = other463.__isset;
  return *this;
}
void Function::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Function(";
  out << "functionName=" << to_string(functionName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "className=" << to_string(className);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ", " << "ownerType=" << to_string(ownerType);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "functionType=" << to_string(functionType);
  out << ", " << "resourceUris=" << to_string(resourceUris);
  out << ")";
}


TxnInfo::~TxnInfo() throw() {
}


void TxnInfo::__set_id(const int64_t val) {
  this->id = val;
}

void TxnInfo::__set_state(const TxnState::type val) {
  this->state = val;
}

void TxnInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TxnInfo::__set_hostname(const std::string& val) {
  this->hostname = val;
}

uint32_t TxnInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_state = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast464;
          xfer += iprot->readI32(ecast464);
          this->state = (TxnState::type)ecast464;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TxnInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnInfo &a, TxnInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
}

TxnInfo::TxnInfo(const TxnInfo& other465) {
  id = other465.id;
  state = other465.state;
  user = other465.user;
  hostname = other465.hostname;
}
TxnInfo& TxnInfo::operator=(const TxnInfo& other466) {
  id = other466.id;
  state = other466.state;
  user = other466.user;
  hostname = other466.hostname;
  return *this;
}
void TxnInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnInfo(";
  out << "id=" << to_string(id);
  out << ", " << "state=" << to_string(state);
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ")";
}


GetOpenTxnsInfoResponse::~GetOpenTxnsInfoResponse() throw() {
}


void GetOpenTxnsInfoResponse::__set_txn_high_water_mark(const int64_t val) {
  this->txn_high_water_mark = val;
}

void GetOpenTxnsInfoResponse::__set_open_txns(const std::vector<TxnInfo> & val) {
  this->open_txns = val;
}

uint32_t GetOpenTxnsInfoResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_high_water_mark = false;
  bool isset_open_txns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txn_high_water_mark);
          isset_txn_high_water_mark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->open_txns.clear();
            uint32_t _size467;
            ::apache::thrift::protocol::TType _etype470;
            xfer += iprot->readListBegin(_etype470, _size467);
            this->open_txns.resize(_size467);
            uint32_t _i471;
            for (_i471 = 0; _i471 < _size467; ++_i471)
            {
              xfer += this->open_txns[_i471].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_open_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_high_water_mark)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_open_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetOpenTxnsInfoResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOpenTxnsInfoResponse");

  xfer += oprot->writeFieldBegin("txn_high_water_mark", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txn_high_water_mark);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("open_txns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->open_txns.size()));
    std::vector<TxnInfo> ::const_iterator _iter472;
    for (_iter472 = this->open_txns.begin(); _iter472 != this->open_txns.end(); ++_iter472)
    {
      xfer += (*_iter472).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOpenTxnsInfoResponse &a, GetOpenTxnsInfoResponse &b) {
  using ::std::swap;
  swap(a.txn_high_water_mark, b.txn_high_water_mark);
  swap(a.open_txns, b.open_txns);
}

GetOpenTxnsInfoResponse::GetOpenTxnsInfoResponse(const GetOpenTxnsInfoResponse& other473) {
  txn_high_water_mark = other473.txn_high_water_mark;
  open_txns = other473.open_txns;
}
GetOpenTxnsInfoResponse& GetOpenTxnsInfoResponse::operator=(const GetOpenTxnsInfoResponse& other474) {
  txn_high_water_mark = other474.txn_high_water_mark;
  open_txns = other474.open_txns;
  return *this;
}
void GetOpenTxnsInfoResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOpenTxnsInfoResponse(";
  out << "txn_high_water_mark=" << to_string(txn_high_water_mark);
  out << ", " << "open_txns=" << to_string(open_txns);
  out << ")";
}


GetOpenTxnsResponse::~GetOpenTxnsResponse() throw() {
}


void GetOpenTxnsResponse::__set_txn_high_water_mark(const int64_t val) {
  this->txn_high_water_mark = val;
}

void GetOpenTxnsResponse::__set_open_txns(const std::set<int64_t> & val) {
  this->open_txns = val;
}

uint32_t GetOpenTxnsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_high_water_mark = false;
  bool isset_open_txns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txn_high_water_mark);
          isset_txn_high_water_mark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->open_txns.clear();
            uint32_t _size475;
            ::apache::thrift::protocol::TType _etype478;
            xfer += iprot->readSetBegin(_etype478, _size475);
            uint32_t _i479;
            for (_i479 = 0; _i479 < _size475; ++_i479)
            {
              int64_t _elem480;
              xfer += iprot->readI64(_elem480);
              this->open_txns.insert(_elem480);
            }
            xfer += iprot->readSetEnd();
          }
          isset_open_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_high_water_mark)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_open_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetOpenTxnsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOpenTxnsResponse");

  xfer += oprot->writeFieldBegin("txn_high_water_mark", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txn_high_water_mark);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("open_txns", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->open_txns.size()));
    std::set<int64_t> ::const_iterator _iter481;
    for (_iter481 = this->open_txns.begin(); _iter481 != this->open_txns.end(); ++_iter481)
    {
      xfer += oprot->writeI64((*_iter481));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOpenTxnsResponse &a, GetOpenTxnsResponse &b) {
  using ::std::swap;
  swap(a.txn_high_water_mark, b.txn_high_water_mark);
  swap(a.open_txns, b.open_txns);
}

GetOpenTxnsResponse::GetOpenTxnsResponse(const GetOpenTxnsResponse& other482) {
  txn_high_water_mark = other482.txn_high_water_mark;
  open_txns = other482.open_txns;
}
GetOpenTxnsResponse& GetOpenTxnsResponse::operator=(const GetOpenTxnsResponse& other483) {
  txn_high_water_mark = other483.txn_high_water_mark;
  open_txns = other483.open_txns;
  return *this;
}
void GetOpenTxnsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOpenTxnsResponse(";
  out << "txn_high_water_mark=" << to_string(txn_high_water_mark);
  out << ", " << "open_txns=" << to_string(open_txns);
  out << ")";
}


OpenTxnRequest::~OpenTxnRequest() throw() {
}


void OpenTxnRequest::__set_num_txns(const int32_t val) {
  this->num_txns = val;
}

void OpenTxnRequest::__set_user(const std::string& val) {
  this->user = val;
}

void OpenTxnRequest::__set_hostname(const std::string& val) {
  this->hostname = val;
}

uint32_t OpenTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_txns = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_txns);
          isset_num_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OpenTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OpenTxnRequest");

  xfer += oprot->writeFieldBegin("num_txns", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_txns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenTxnRequest &a, OpenTxnRequest &b) {
  using ::std::swap;
  swap(a.num_txns, b.num_txns);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
}

OpenTxnRequest::OpenTxnRequest(const OpenTxnRequest& other484) {
  num_txns = other484.num_txns;
  user = other484.user;
  hostname = other484.hostname;
}
OpenTxnRequest& OpenTxnRequest::operator=(const OpenTxnRequest& other485) {
  num_txns = other485.num_txns;
  user = other485.user;
  hostname = other485.hostname;
  return *this;
}
void OpenTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OpenTxnRequest(";
  out << "num_txns=" << to_string(num_txns);
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ")";
}


OpenTxnsResponse::~OpenTxnsResponse() throw() {
}


void OpenTxnsResponse::__set_txn_ids(const std::vector<int64_t> & val) {
  this->txn_ids = val;
}

uint32_t OpenTxnsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txn_ids.clear();
            uint32_t _size486;
            ::apache::thrift::protocol::TType _etype489;
            xfer += iprot->readListBegin(_etype489, _size486);
            this->txn_ids.resize(_size486);
            uint32_t _i490;
            for (_i490 = 0; _i490 < _size486; ++_i490)
            {
              xfer += iprot->readI64(this->txn_ids[_i490]);
            }
            xfer += iprot->readListEnd();
          }
          isset_txn_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OpenTxnsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OpenTxnsResponse");

  xfer += oprot->writeFieldBegin("txn_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->txn_ids.size()));
    std::vector<int64_t> ::const_iterator _iter491;
    for (_iter491 = this->txn_ids.begin(); _iter491 != this->txn_ids.end(); ++_iter491)
    {
      xfer += oprot->writeI64((*_iter491));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenTxnsResponse &a, OpenTxnsResponse &b) {
  using ::std::swap;
  swap(a.txn_ids, b.txn_ids);
}

OpenTxnsResponse::OpenTxnsResponse(const OpenTxnsResponse& other492) {
  txn_ids = other492.txn_ids;
}
OpenTxnsResponse& OpenTxnsResponse::operator=(const OpenTxnsResponse& other493) {
  txn_ids = other493.txn_ids;
  return *this;
}
void OpenTxnsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OpenTxnsResponse(";
  out << "txn_ids=" << to_string(txn_ids);
  out << ")";
}


AbortTxnRequest::~AbortTxnRequest() throw() {
}


void AbortTxnRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
}

uint32_t AbortTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AbortTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AbortTxnRequest");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AbortTxnRequest &a, AbortTxnRequest &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
}

AbortTxnRequest::AbortTxnRequest(const AbortTxnRequest& other494) {
  txnid = other494.txnid;
}
AbortTxnRequest& AbortTxnRequest::operator=(const AbortTxnRequest& other495) {
  txnid = other495.txnid;
  return *this;
}
void AbortTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AbortTxnRequest(";
  out << "txnid=" << to_string(txnid);
  out << ")";
}


CommitTxnRequest::~CommitTxnRequest() throw() {
}


void CommitTxnRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
}

uint32_t CommitTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CommitTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommitTxnRequest");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommitTxnRequest &a, CommitTxnRequest &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
}

CommitTxnRequest::CommitTxnRequest(const CommitTxnRequest& other496) {
  txnid = other496.txnid;
}
CommitTxnRequest& CommitTxnRequest::operator=(const CommitTxnRequest& other497) {
  txnid = other497.txnid;
  return *this;
}
void CommitTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommitTxnRequest(";
  out << "txnid=" << to_string(txnid);
  out << ")";
}


LockComponent::~LockComponent() throw() {
}


void LockComponent::__set_type(const LockType::type val) {
  this->type = val;
}

void LockComponent::__set_level(const LockLevel::type val) {
  this->level = val;
}

void LockComponent::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void LockComponent::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void LockComponent::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

uint32_t LockComponent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_level = false;
  bool isset_dbname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast498;
          xfer += iprot->readI32(ecast498);
          this->type = (LockType::type)ecast498;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast499;
          xfer += iprot->readI32(ecast499);
          this->level = (LockLevel::type)ecast499;
          isset_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_level)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockComponent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockComponent");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockComponent &a, LockComponent &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.level, b.level);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.__isset, b.__isset);
}

LockComponent::LockComponent(const LockComponent& other500) {
  type = other500.type;
  level = other500.level;
  dbname = other500.dbname;
  tablename = other500.tablename;
  partitionname = other500.partitionname;
  __isset = other500.__isset;
}
LockComponent& LockComponent::operator=(const LockComponent& other501) {
  type = other501.type;
  level = other501.level;
  dbname = other501.dbname;
  tablename = other501.tablename;
  partitionname = other501.partitionname;
  __isset = other501.__isset;
  return *this;
}
void LockComponent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockComponent(";
  out << "type=" << to_string(type);
  out << ", " << "level=" << to_string(level);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ")";
}


LockRequest::~LockRequest() throw() {
}


void LockRequest::__set_component(const std::vector<LockComponent> & val) {
  this->component = val;
}

void LockRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void LockRequest::__set_user(const std::string& val) {
  this->user = val;
}

void LockRequest::__set_hostname(const std::string& val) {
  this->hostname = val;
}

uint32_t LockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_component = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->component.clear();
            uint32_t _size502;
            ::apache::thrift::protocol::TType _etype505;
            xfer += iprot->readListBegin(_etype505, _size502);
            this->component.resize(_size502);
            uint32_t _i506;
            for (_i506 = 0; _i506 < _size502; ++_i506)
            {
              xfer += this->component[_i506].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_component)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockRequest");

  xfer += oprot->writeFieldBegin("component", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->component.size()));
    std::vector<LockComponent> ::const_iterator _iter507;
    for (_iter507 = this->component.begin(); _iter507 != this->component.end(); ++_iter507)
    {
      xfer += (*_iter507).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockRequest &a, LockRequest &b) {
  using ::std::swap;
  swap(a.component, b.component);
  swap(a.txnid, b.txnid);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.__isset, b.__isset);
}

LockRequest::LockRequest(const LockRequest& other508) {
  component = other508.component;
  txnid = other508.txnid;
  user = other508.user;
  hostname = other508.hostname;
  __isset = other508.__isset;
}
LockRequest& LockRequest::operator=(const LockRequest& other509) {
  component = other509.component;
  txnid = other509.txnid;
  user = other509.user;
  hostname = other509.hostname;
  __isset = other509.__isset;
  return *this;
}
void LockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockRequest(";
  out << "component=" << to_string(component);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ")";
}


LockResponse::~LockResponse() throw() {
}


void LockResponse::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void LockResponse::__set_state(const LockState::type val) {
  this->state = val;
}

uint32_t LockResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast510;
          xfer += iprot->readI32(ecast510);
          this->state = (LockState::type)ecast510;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockResponse");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockResponse &a, LockResponse &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.state, b.state);
}

LockResponse::LockResponse(const LockResponse& other511) {
  lockid = other511.lockid;
  state = other511.state;
}
LockResponse& LockResponse::operator=(const LockResponse& other512) {
  lockid = other512.lockid;
  state = other512.state;
  return *this;
}
void LockResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockResponse(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "state=" << to_string(state);
  out << ")";
}


CheckLockRequest::~CheckLockRequest() throw() {
}


void CheckLockRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
}

uint32_t CheckLockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CheckLockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CheckLockRequest");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CheckLockRequest &a, CheckLockRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
}

CheckLockRequest::CheckLockRequest(const CheckLockRequest& other513) {
  lockid = other513.lockid;
}
CheckLockRequest& CheckLockRequest::operator=(const CheckLockRequest& other514) {
  lockid = other514.lockid;
  return *this;
}
void CheckLockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CheckLockRequest(";
  out << "lockid=" << to_string(lockid);
  out << ")";
}


UnlockRequest::~UnlockRequest() throw() {
}


void UnlockRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
}

uint32_t UnlockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnlockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnlockRequest");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnlockRequest &a, UnlockRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
}

UnlockRequest::UnlockRequest(const UnlockRequest& other515) {
  lockid = other515.lockid;
}
UnlockRequest& UnlockRequest::operator=(const UnlockRequest& other516) {
  lockid = other516.lockid;
  return *this;
}
void UnlockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnlockRequest(";
  out << "lockid=" << to_string(lockid);
  out << ")";
}


ShowLocksRequest::~ShowLocksRequest() throw() {
}


uint32_t ShowLocksRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowLocksRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksRequest");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksRequest &a, ShowLocksRequest &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ShowLocksRequest::ShowLocksRequest(const ShowLocksRequest& other517) {
  (void) other517;
}
ShowLocksRequest& ShowLocksRequest::operator=(const ShowLocksRequest& other518) {
  (void) other518;
  return *this;
}
void ShowLocksRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksRequest(";
  out << ")";
}


ShowLocksResponseElement::~ShowLocksResponseElement() throw() {
}


void ShowLocksResponseElement::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void ShowLocksResponseElement::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void ShowLocksResponseElement::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void ShowLocksResponseElement::__set_partname(const std::string& val) {
  this->partname = val;
__isset.partname = true;
}

void ShowLocksResponseElement::__set_state(const LockState::type val) {
  this->state = val;
}

void ShowLocksResponseElement::__set_type(const LockType::type val) {
  this->type = val;
}

void ShowLocksResponseElement::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void ShowLocksResponseElement::__set_lastheartbeat(const int64_t val) {
  this->lastheartbeat = val;
}

void ShowLocksResponseElement::__set_acquiredat(const int64_t val) {
  this->acquiredat = val;
__isset.acquiredat = true;
}

void ShowLocksResponseElement::__set_user(const std::string& val) {
  this->user = val;
}

void ShowLocksResponseElement::__set_hostname(const std::string& val) {
  this->hostname = val;
}

uint32_t ShowLocksResponseElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;
  bool isset_dbname = false;
  bool isset_state = false;
  bool isset_type = false;
  bool isset_lastheartbeat = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partname);
          this->__isset.partname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast519;
          xfer += iprot->readI32(ecast519);
          this->state = (LockState::type)ecast519;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast520;
          xfer += iprot->readI32(ecast520);
          this->type = (LockType::type)ecast520;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastheartbeat);
          isset_lastheartbeat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acquiredat);
          this->__isset.acquiredat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lastheartbeat)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowLocksResponseElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksResponseElement");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partname) {
    xfer += oprot->writeFieldBegin("partname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->partname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("lastheartbeat", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->lastheartbeat);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.acquiredat) {
    xfer += oprot->writeFieldBegin("acquiredat", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->acquiredat);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksResponseElement &a, ShowLocksResponseElement &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partname, b.partname);
  swap(a.state, b.state);
  swap(a.type, b.type);
  swap(a.txnid, b.txnid);
  swap(a.lastheartbeat, b.lastheartbeat);
  swap(a.acquiredat, b.acquiredat);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.__isset, b.__isset);
}

ShowLocksResponseElement::ShowLocksResponseElement(const ShowLocksResponseElement& other521) {
  lockid = other521.lockid;
  dbname = other521.dbname;
  tablename = other521.tablename;
  partname = other521.partname;
  state = other521.state;
  type = other521.type;
  txnid = other521.txnid;
  lastheartbeat = other521.lastheartbeat;
  acquiredat = other521.acquiredat;
  user = other521.user;
  hostname = other521.hostname;
  __isset = other521.__isset;
}
ShowLocksResponseElement& ShowLocksResponseElement::operator=(const ShowLocksResponseElement& other522) {
  lockid = other522.lockid;
  dbname = other522.dbname;
  tablename = other522.tablename;
  partname = other522.partname;
  state = other522.state;
  type = other522.type;
  txnid = other522.txnid;
  lastheartbeat = other522.lastheartbeat;
  acquiredat = other522.acquiredat;
  user = other522.user;
  hostname = other522.hostname;
  __isset = other522.__isset;
  return *this;
}
void ShowLocksResponseElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksResponseElement(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partname="; (__isset.partname ? (out << to_string(partname)) : (out << "<null>"));
  out << ", " << "state=" << to_string(state);
  out << ", " << "type=" << to_string(type);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "lastheartbeat=" << to_string(lastheartbeat);
  out << ", " << "acquiredat="; (__isset.acquiredat ? (out << to_string(acquiredat)) : (out << "<null>"));
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ")";
}


ShowLocksResponse::~ShowLocksResponse() throw() {
}


void ShowLocksResponse::__set_locks(const std::vector<ShowLocksResponseElement> & val) {
  this->locks = val;
}

uint32_t ShowLocksResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->locks.clear();
            uint32_t _size523;
            ::apache::thrift::protocol::TType _etype526;
            xfer += iprot->readListBegin(_etype526, _size523);
            this->locks.resize(_size523);
            uint32_t _i527;
            for (_i527 = 0; _i527 < _size523; ++_i527)
            {
              xfer += this->locks[_i527].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.locks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowLocksResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksResponse");

  xfer += oprot->writeFieldBegin("locks", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->locks.size()));
    std::vector<ShowLocksResponseElement> ::const_iterator _iter528;
    for (_iter528 = this->locks.begin(); _iter528 != this->locks.end(); ++_iter528)
    {
      xfer += (*_iter528).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksResponse &a, ShowLocksResponse &b) {
  using ::std::swap;
  swap(a.locks, b.locks);
  swap(a.__isset, b.__isset);
}

ShowLocksResponse::ShowLocksResponse(const ShowLocksResponse& other529) {
  locks = other529.locks;
  __isset = other529.__isset;
}
ShowLocksResponse& ShowLocksResponse::operator=(const ShowLocksResponse& other530) {
  locks = other530.locks;
  __isset = other530.__isset;
  return *this;
}
void ShowLocksResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksResponse(";
  out << "locks=" << to_string(locks);
  out << ")";
}


HeartbeatRequest::~HeartbeatRequest() throw() {
}


void HeartbeatRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
__isset.lockid = true;
}

void HeartbeatRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

uint32_t HeartbeatRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          this->__isset.lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HeartbeatRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatRequest");

  if (this->__isset.lockid) {
    xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->lockid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatRequest &a, HeartbeatRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.txnid, b.txnid);
  swap(a.__isset, b.__isset);
}

HeartbeatRequest::HeartbeatRequest(const HeartbeatRequest& other531) {
  lockid = other531.lockid;
  txnid = other531.txnid;
  __isset = other531.__isset;
}
HeartbeatRequest& HeartbeatRequest::operator=(const HeartbeatRequest& other532) {
  lockid = other532.lockid;
  txnid = other532.txnid;
  __isset = other532.__isset;
  return *this;
}
void HeartbeatRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatRequest(";
  out << "lockid="; (__isset.lockid ? (out << to_string(lockid)) : (out << "<null>"));
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ")";
}


HeartbeatTxnRangeRequest::~HeartbeatTxnRangeRequest() throw() {
}


void HeartbeatTxnRangeRequest::__set_min(const int64_t val) {
  this->min = val;
}

void HeartbeatTxnRangeRequest::__set_max(const int64_t val) {
  this->max = val;
}

uint32_t HeartbeatTxnRangeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_min = false;
  bool isset_max = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min);
          isset_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max);
          isset_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_min)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatTxnRangeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatTxnRangeRequest");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatTxnRangeRequest &a, HeartbeatTxnRangeRequest &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
}

HeartbeatTxnRangeRequest::HeartbeatTxnRangeRequest(const HeartbeatTxnRangeRequest& other533) {
  min = other533.min;
  max = other533.max;
}
HeartbeatTxnRangeRequest& HeartbeatTxnRangeRequest::operator=(const HeartbeatTxnRangeRequest& other534) {
  min = other534.min;
  max = other534.max;
  return *this;
}
void HeartbeatTxnRangeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatTxnRangeRequest(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ")";
}


HeartbeatTxnRangeResponse::~HeartbeatTxnRangeResponse() throw() {
}


void HeartbeatTxnRangeResponse::__set_aborted(const std::set<int64_t> & val) {
  this->aborted = val;
}

void HeartbeatTxnRangeResponse::__set_nosuch(const std::set<int64_t> & val) {
  this->nosuch = val;
}

uint32_t HeartbeatTxnRangeResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_aborted = false;
  bool isset_nosuch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->aborted.clear();
            uint32_t _size535;
            ::apache::thrift::protocol::TType _etype538;
            xfer += iprot->readSetBegin(_etype538, _size535);
            uint32_t _i539;
            for (_i539 = 0; _i539 < _size535; ++_i539)
            {
              int64_t _elem540;
              xfer += iprot->readI64(_elem540);
              this->aborted.insert(_elem540);
            }
            xfer += iprot->readSetEnd();
          }
          isset_aborted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->nosuch.clear();
            uint32_t _size541;
            ::apache::thrift::protocol::TType _etype544;
            xfer += iprot->readSetBegin(_etype544, _size541);
            uint32_t _i545;
            for (_i545 = 0; _i545 < _size541; ++_i545)
            {
              int64_t _elem546;
              xfer += iprot->readI64(_elem546);
              this->nosuch.insert(_elem546);
            }
            xfer += iprot->readSetEnd();
          }
          isset_nosuch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_aborted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nosuch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatTxnRangeResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatTxnRangeResponse");

  xfer += oprot->writeFieldBegin("aborted", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->aborted.size()));
    std::set<int64_t> ::const_iterator _iter547;
    for (_iter547 = this->aborted.begin(); _iter547 != this->aborted.end(); ++_iter547)
    {
      xfer += oprot->writeI64((*_iter547));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nosuch", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->nosuch.size()));
    std::set<int64_t> ::const_iterator _iter548;
    for (_iter548 = this->nosuch.begin(); _iter548 != this->nosuch.end(); ++_iter548)
    {
      xfer += oprot->writeI64((*_iter548));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatTxnRangeResponse &a, HeartbeatTxnRangeResponse &b) {
  using ::std::swap;
  swap(a.aborted, b.aborted);
  swap(a.nosuch, b.nosuch);
}

HeartbeatTxnRangeResponse::HeartbeatTxnRangeResponse(const HeartbeatTxnRangeResponse& other549) {
  aborted = other549.aborted;
  nosuch = other549.nosuch;
}
HeartbeatTxnRangeResponse& HeartbeatTxnRangeResponse::operator=(const HeartbeatTxnRangeResponse& other550) {
  aborted = other550.aborted;
  nosuch = other550.nosuch;
  return *this;
}
void HeartbeatTxnRangeResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatTxnRangeResponse(";
  out << "aborted=" << to_string(aborted);
  out << ", " << "nosuch=" << to_string(nosuch);
  out << ")";
}


CompactionRequest::~CompactionRequest() throw() {
}


void CompactionRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void CompactionRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void CompactionRequest::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void CompactionRequest::__set_type(const CompactionType::type val) {
  this->type = val;
}

void CompactionRequest::__set_runas(const std::string& val) {
  this->runas = val;
__isset.runas = true;
}

uint32_t CompactionRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast551;
          xfer += iprot->readI32(ecast551);
          this->type = (CompactionType::type)ecast551;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runas);
          this->__isset.runas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionRequest");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.runas) {
    xfer += oprot->writeFieldBegin("runas", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->runas);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionRequest &a, CompactionRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.runas, b.runas);
  swap(a.__isset, b.__isset);
}

CompactionRequest::CompactionRequest(const CompactionRequest& other552) {
  dbname = other552.dbname;
  tablename = other552.tablename;
  partitionname = other552.partitionname;
  type = other552.type;
  runas = other552.runas;
  __isset = other552.__isset;
}
CompactionRequest& CompactionRequest::operator=(const CompactionRequest& other553) {
  dbname = other553.dbname;
  tablename = other553.tablename;
  partitionname = other553.partitionname;
  type = other553.type;
  runas = other553.runas;
  __isset = other553.__isset;
  return *this;
}
void CompactionRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionRequest(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "runas="; (__isset.runas ? (out << to_string(runas)) : (out << "<null>"));
  out << ")";
}


ShowCompactRequest::~ShowCompactRequest() throw() {
}


uint32_t ShowCompactRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowCompactRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactRequest");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactRequest &a, ShowCompactRequest &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ShowCompactRequest::ShowCompactRequest(const ShowCompactRequest& other554) {
  (void) other554;
}
ShowCompactRequest& ShowCompactRequest::operator=(const ShowCompactRequest& other555) {
  (void) other555;
  return *this;
}
void ShowCompactRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactRequest(";
  out << ")";
}


ShowCompactResponseElement::~ShowCompactResponseElement() throw() {
}


void ShowCompactResponseElement::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void ShowCompactResponseElement::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void ShowCompactResponseElement::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void ShowCompactResponseElement::__set_type(const CompactionType::type val) {
  this->type = val;
}

void ShowCompactResponseElement::__set_state(const std::string& val) {
  this->state = val;
}

void ShowCompactResponseElement::__set_workerid(const std::string& val) {
  this->workerid = val;
__isset.workerid = true;
}

void ShowCompactResponseElement::__set_start(const int64_t val) {
  this->start = val;
__isset.start = true;
}

void ShowCompactResponseElement::__set_runAs(const std::string& val) {
  this->runAs = val;
__isset.runAs = true;
}

uint32_t ShowCompactResponseElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_type = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast556;
          xfer += iprot->readI32(ecast556);
          this->type = (CompactionType::type)ecast556;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workerid);
          this->__isset.workerid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runAs);
          this->__isset.runAs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowCompactResponseElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactResponseElement");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.workerid) {
    xfer += oprot->writeFieldBegin("workerid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->workerid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.runAs) {
    xfer += oprot->writeFieldBegin("runAs", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->runAs);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactResponseElement &a, ShowCompactResponseElement &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.workerid, b.workerid);
  swap(a.start, b.start);
  swap(a.runAs, b.runAs);
  swap(a.__isset, b.__isset);
}

ShowCompactResponseElement::ShowCompactResponseElement(const ShowCompactResponseElement& other557) {
  dbname = other557.dbname;
  tablename = other557.tablename;
  partitionname = other557.partitionname;
  type = other557.type;
  state = other557.state;
  workerid = other557.workerid;
  start = other557.start;
  runAs = other557.runAs;
  __isset = other557.__isset;
}
ShowCompactResponseElement& ShowCompactResponseElement::operator=(const ShowCompactResponseElement& other558) {
  dbname = other558.dbname;
  tablename = other558.tablename;
  partitionname = other558.partitionname;
  type = other558.type;
  state = other558.state;
  workerid = other558.workerid;
  start = other558.start;
  runAs = other558.runAs;
  __isset = other558.__isset;
  return *this;
}
void ShowCompactResponseElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactResponseElement(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "state=" << to_string(state);
  out << ", " << "workerid="; (__isset.workerid ? (out << to_string(workerid)) : (out << "<null>"));
  out << ", " << "start="; (__isset.start ? (out << to_string(start)) : (out << "<null>"));
  out << ", " << "runAs="; (__isset.runAs ? (out << to_string(runAs)) : (out << "<null>"));
  out << ")";
}


ShowCompactResponse::~ShowCompactResponse() throw() {
}


void ShowCompactResponse::__set_compacts(const std::vector<ShowCompactResponseElement> & val) {
  this->compacts = val;
}

uint32_t ShowCompactResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_compacts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compacts.clear();
            uint32_t _size559;
            ::apache::thrift::protocol::TType _etype562;
            xfer += iprot->readListBegin(_etype562, _size559);
            this->compacts.resize(_size559);
            uint32_t _i563;
            for (_i563 = 0; _i563 < _size559; ++_i563)
            {
              xfer += this->compacts[_i563].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_compacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_compacts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowCompactResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactResponse");

  xfer += oprot->writeFieldBegin("compacts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compacts.size()));
    std::vector<ShowCompactResponseElement> ::const_iterator _iter564;
    for (_iter564 = this->compacts.begin(); _iter564 != this->compacts.end(); ++_iter564)
    {
      xfer += (*_iter564).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactResponse &a, ShowCompactResponse &b) {
  using ::std::swap;
  swap(a.compacts, b.compacts);
}

ShowCompactResponse::ShowCompactResponse(const ShowCompactResponse& other565) {
  compacts = other565.compacts;
}
ShowCompactResponse& ShowCompactResponse::operator=(const ShowCompactResponse& other566) {
  compacts = other566.compacts;
  return *this;
}
void ShowCompactResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactResponse(";
  out << "compacts=" << to_string(compacts);
  out << ")";
}


AddDynamicPartitions::~AddDynamicPartitions() throw() {
}


void AddDynamicPartitions::__set_txnid(const int64_t val) {
  this->txnid = val;
}

void AddDynamicPartitions::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void AddDynamicPartitions::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void AddDynamicPartitions::__set_partitionnames(const std::vector<std::string> & val) {
  this->partitionnames = val;
}

uint32_t AddDynamicPartitions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;
  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_partitionnames = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionnames.clear();
            uint32_t _size567;
            ::apache::thrift::protocol::TType _etype570;
            xfer += iprot->readListBegin(_etype570, _size567);
            this->partitionnames.resize(_size567);
            uint32_t _i571;
            for (_i571 = 0; _i571 < _size567; ++_i571)
            {
              xfer += iprot->readString(this->partitionnames[_i571]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionnames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitionnames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddDynamicPartitions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddDynamicPartitions");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionnames", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionnames.size()));
    std::vector<std::string> ::const_iterator _iter572;
    for (_iter572 = this->partitionnames.begin(); _iter572 != this->partitionnames.end(); ++_iter572)
    {
      xfer += oprot->writeString((*_iter572));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddDynamicPartitions &a, AddDynamicPartitions &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionnames, b.partitionnames);
}

AddDynamicPartitions::AddDynamicPartitions(const AddDynamicPartitions& other573) {
  txnid = other573.txnid;
  dbname = other573.dbname;
  tablename = other573.tablename;
  partitionnames = other573.partitionnames;
}
AddDynamicPartitions& AddDynamicPartitions::operator=(const AddDynamicPartitions& other574) {
  txnid = other574.txnid;
  dbname = other574.dbname;
  tablename = other574.tablename;
  partitionnames = other574.partitionnames;
  return *this;
}
void AddDynamicPartitions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddDynamicPartitions(";
  out << "txnid=" << to_string(txnid);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionnames=" << to_string(partitionnames);
  out << ")";
}


NotificationEventRequest::~NotificationEventRequest() throw() {
}


void NotificationEventRequest::__set_lastEvent(const int64_t val) {
  this->lastEvent = val;
}

void NotificationEventRequest::__set_maxEvents(const int32_t val) {
  this->maxEvents = val;
__isset.maxEvents = true;
}

uint32_t NotificationEventRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lastEvent = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastEvent);
          isset_lastEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxEvents);
          this->__isset.maxEvents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lastEvent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventRequest");

  xfer += oprot->writeFieldBegin("lastEvent", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lastEvent);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.maxEvents) {
    xfer += oprot->writeFieldBegin("maxEvents", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->maxEvents);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventRequest &a, NotificationEventRequest &b) {
  using ::std::swap;
  swap(a.lastEvent, b.lastEvent);
  swap(a.maxEvents, b.maxEvents);
  swap(a.__isset, b.__isset);
}

NotificationEventRequest::NotificationEventRequest(const NotificationEventRequest& other575) {
  lastEvent = other575.lastEvent;
  maxEvents = other575.maxEvents;
  __isset = other575.__isset;
}
NotificationEventRequest& NotificationEventRequest::operator=(const NotificationEventRequest& other576) {
  lastEvent = other576.lastEvent;
  maxEvents = other576.maxEvents;
  __isset = other576.__isset;
  return *this;
}
void NotificationEventRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventRequest(";
  out << "lastEvent=" << to_string(lastEvent);
  out << ", " << "maxEvents="; (__isset.maxEvents ? (out << to_string(maxEvents)) : (out << "<null>"));
  out << ")";
}


NotificationEvent::~NotificationEvent() throw() {
}


void NotificationEvent::__set_eventId(const int64_t val) {
  this->eventId = val;
}

void NotificationEvent::__set_eventTime(const int32_t val) {
  this->eventTime = val;
}

void NotificationEvent::__set_eventType(const std::string& val) {
  this->eventType = val;
}

void NotificationEvent::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}

void NotificationEvent::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}

void NotificationEvent::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t NotificationEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventId = false;
  bool isset_eventTime = false;
  bool isset_eventType = false;
  bool isset_message = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventId);
          isset_eventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->eventTime);
          isset_eventTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->eventType);
          isset_eventType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          isset_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eventTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eventType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_message)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEvent");

  xfer += oprot->writeFieldBegin("eventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->eventTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->eventType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEvent &a, NotificationEvent &b) {
  using ::std::swap;
  swap(a.eventId, b.eventId);
  swap(a.eventTime, b.eventTime);
  swap(a.eventType, b.eventType);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NotificationEvent::NotificationEvent(const NotificationEvent& other577) {
  eventId = other577.eventId;
  eventTime = other577.eventTime;
  eventType = other577.eventType;
  dbName = other577.dbName;
  tableName = other577.tableName;
  message = other577.message;
  __isset = other577.__isset;
}
NotificationEvent& NotificationEvent::operator=(const NotificationEvent& other578) {
  eventId = other578.eventId;
  eventTime = other578.eventTime;
  eventType = other578.eventType;
  dbName = other578.dbName;
  tableName = other578.tableName;
  message = other578.message;
  __isset = other578.__isset;
  return *this;
}
void NotificationEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEvent(";
  out << "eventId=" << to_string(eventId);
  out << ", " << "eventTime=" << to_string(eventTime);
  out << ", " << "eventType=" << to_string(eventType);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "message=" << to_string(message);
  out << ")";
}


NotificationEventResponse::~NotificationEventResponse() throw() {
}


void NotificationEventResponse::__set_events(const std::vector<NotificationEvent> & val) {
  this->events = val;
}

uint32_t NotificationEventResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_events = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->events.clear();
            uint32_t _size579;
            ::apache::thrift::protocol::TType _etype582;
            xfer += iprot->readListBegin(_etype582, _size579);
            this->events.resize(_size579);
            uint32_t _i583;
            for (_i583 = 0; _i583 < _size579; ++_i583)
            {
              xfer += this->events[_i583].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_events = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_events)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventResponse");

  xfer += oprot->writeFieldBegin("events", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->events.size()));
    std::vector<NotificationEvent> ::const_iterator _iter584;
    for (_iter584 = this->events.begin(); _iter584 != this->events.end(); ++_iter584)
    {
      xfer += (*_iter584).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventResponse &a, NotificationEventResponse &b) {
  using ::std::swap;
  swap(a.events, b.events);
}

NotificationEventResponse::NotificationEventResponse(const NotificationEventResponse& other585) {
  events = other585.events;
}
NotificationEventResponse& NotificationEventResponse::operator=(const NotificationEventResponse& other586) {
  events = other586.events;
  return *this;
}
void NotificationEventResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventResponse(";
  out << "events=" << to_string(events);
  out << ")";
}


CurrentNotificationEventId::~CurrentNotificationEventId() throw() {
}


void CurrentNotificationEventId::__set_eventId(const int64_t val) {
  this->eventId = val;
}

uint32_t CurrentNotificationEventId::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventId);
          isset_eventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CurrentNotificationEventId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CurrentNotificationEventId");

  xfer += oprot->writeFieldBegin("eventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CurrentNotificationEventId &a, CurrentNotificationEventId &b) {
  using ::std::swap;
  swap(a.eventId, b.eventId);
}

CurrentNotificationEventId::CurrentNotificationEventId(const CurrentNotificationEventId& other587) {
  eventId = other587.eventId;
}
CurrentNotificationEventId& CurrentNotificationEventId::operator=(const CurrentNotificationEventId& other588) {
  eventId = other588.eventId;
  return *this;
}
void CurrentNotificationEventId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CurrentNotificationEventId(";
  out << "eventId=" << to_string(eventId);
  out << ")";
}


InsertEventRequestData::~InsertEventRequestData() throw() {
}


void InsertEventRequestData::__set_filesAdded(const std::vector<std::string> & val) {
  this->filesAdded = val;
}

uint32_t InsertEventRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_filesAdded = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filesAdded.clear();
            uint32_t _size589;
            ::apache::thrift::protocol::TType _etype592;
            xfer += iprot->readListBegin(_etype592, _size589);
            this->filesAdded.resize(_size589);
            uint32_t _i593;
            for (_i593 = 0; _i593 < _size589; ++_i593)
            {
              xfer += iprot->readString(this->filesAdded[_i593]);
            }
            xfer += iprot->readListEnd();
          }
          isset_filesAdded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_filesAdded)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InsertEventRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InsertEventRequestData");

  xfer += oprot->writeFieldBegin("filesAdded", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filesAdded.size()));
    std::vector<std::string> ::const_iterator _iter594;
    for (_iter594 = this->filesAdded.begin(); _iter594 != this->filesAdded.end(); ++_iter594)
    {
      xfer += oprot->writeString((*_iter594));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InsertEventRequestData &a, InsertEventRequestData &b) {
  using ::std::swap;
  swap(a.filesAdded, b.filesAdded);
}

InsertEventRequestData::InsertEventRequestData(const InsertEventRequestData& other595) {
  filesAdded = other595.filesAdded;
}
InsertEventRequestData& InsertEventRequestData::operator=(const InsertEventRequestData& other596) {
  filesAdded = other596.filesAdded;
  return *this;
}
void InsertEventRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InsertEventRequestData(";
  out << "filesAdded=" << to_string(filesAdded);
  out << ")";
}


FireEventRequestData::~FireEventRequestData() throw() {
}


void FireEventRequestData::__set_insertData(const InsertEventRequestData& val) {
  this->insertData = val;
}

uint32_t FireEventRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->insertData.read(iprot);
          this->__isset.insertData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FireEventRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventRequestData");

  xfer += oprot->writeFieldBegin("insertData", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->insertData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventRequestData &a, FireEventRequestData &b) {
  using ::std::swap;
  swap(a.insertData, b.insertData);
  swap(a.__isset, b.__isset);
}

FireEventRequestData::FireEventRequestData(const FireEventRequestData& other597) {
  insertData = other597.insertData;
  __isset = other597.__isset;
}
FireEventRequestData& FireEventRequestData::operator=(const FireEventRequestData& other598) {
  insertData = other598.insertData;
  __isset = other598.__isset;
  return *this;
}
void FireEventRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventRequestData(";
  out << "insertData=" << to_string(insertData);
  out << ")";
}


FireEventRequest::~FireEventRequest() throw() {
}


void FireEventRequest::__set_successful(const bool val) {
  this->successful = val;
}

void FireEventRequest::__set_data(const FireEventRequestData& val) {
  this->data = val;
}

void FireEventRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}

void FireEventRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}

void FireEventRequest::__set_partitionVals(const std::vector<std::string> & val) {
  this->partitionVals = val;
__isset.partitionVals = true;
}

uint32_t FireEventRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_successful = false;
  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->successful);
          isset_successful = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionVals.clear();
            uint32_t _size599;
            ::apache::thrift::protocol::TType _etype602;
            xfer += iprot->readListBegin(_etype602, _size599);
            this->partitionVals.resize(_size599);
            uint32_t _i603;
            for (_i603 = 0; _i603 < _size599; ++_i603)
            {
              xfer += iprot->readString(this->partitionVals[_i603]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_successful)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FireEventRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventRequest");

  xfer += oprot->writeFieldBegin("successful", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->successful);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionVals) {
    xfer += oprot->writeFieldBegin("partitionVals", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionVals.size()));
      std::vector<std::string> ::const_iterator _iter604;
      for (_iter604 = this->partitionVals.begin(); _iter604 != this->partitionVals.end(); ++_iter604)
      {
        xfer += oprot->writeString((*_iter604));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventRequest &a, FireEventRequest &b) {
  using ::std::swap;
  swap(a.successful, b.successful);
  swap(a.data, b.data);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partitionVals, b.partitionVals);
  swap(a.__isset, b.__isset);
}

FireEventRequest::FireEventRequest(const FireEventRequest& other605) {
  successful = other605.successful;
  data = other605.data;
  dbName = other605.dbName;
  tableName = other605.tableName;
  partitionVals = other605.partitionVals;
  __isset = other605.__isset;
}
FireEventRequest& FireEventRequest::operator=(const FireEventRequest& other606) {
  successful = other606.successful;
  data = other606.data;
  dbName = other606.dbName;
  tableName = other606.tableName;
  partitionVals = other606.partitionVals;
  __isset = other606.__isset;
  return *this;
}
void FireEventRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventRequest(";
  out << "successful=" << to_string(successful);
  out << ", " << "data=" << to_string(data);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "partitionVals="; (__isset.partitionVals ? (out << to_string(partitionVals)) : (out << "<null>"));
  out << ")";
}


FireEventResponse::~FireEventResponse() throw() {
}


uint32_t FireEventResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FireEventResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventResponse &a, FireEventResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

FireEventResponse::FireEventResponse(const FireEventResponse& other607) {
  (void) other607;
}
FireEventResponse& FireEventResponse::operator=(const FireEventResponse& other608) {
  (void) other608;
  return *this;
}
void FireEventResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventResponse(";
  out << ")";
}


MetadataPpdResult::~MetadataPpdResult() throw() {
}


void MetadataPpdResult::__set_metadata(const std::string& val) {
  this->metadata = val;
__isset.metadata = true;
}

void MetadataPpdResult::__set_includeBitset(const std::string& val) {
  this->includeBitset = val;
__isset.includeBitset = true;
}

uint32_t MetadataPpdResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->metadata);
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->includeBitset);
          this->__isset.includeBitset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetadataPpdResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetadataPpdResult");

  if (this->__isset.metadata) {
    xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->metadata);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeBitset) {
    xfer += oprot->writeFieldBegin("includeBitset", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->includeBitset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetadataPpdResult &a, MetadataPpdResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.includeBitset, b.includeBitset);
  swap(a.__isset, b.__isset);
}

MetadataPpdResult::MetadataPpdResult(const MetadataPpdResult& other609) {
  metadata = other609.metadata;
  includeBitset = other609.includeBitset;
  __isset = other609.__isset;
}
MetadataPpdResult& MetadataPpdResult::operator=(const MetadataPpdResult& other610) {
  metadata = other610.metadata;
  includeBitset = other610.includeBitset;
  __isset = other610.__isset;
  return *this;
}
void MetadataPpdResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetadataPpdResult(";
  out << "metadata="; (__isset.metadata ? (out << to_string(metadata)) : (out << "<null>"));
  out << ", " << "includeBitset="; (__isset.includeBitset ? (out << to_string(includeBitset)) : (out << "<null>"));
  out << ")";
}


GetFileMetadataByExprResult::~GetFileMetadataByExprResult() throw() {
}


void GetFileMetadataByExprResult::__set_metadata(const std::map<int64_t, MetadataPpdResult> & val) {
  this->metadata = val;
}

void GetFileMetadataByExprResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}

uint32_t GetFileMetadataByExprResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size611;
            ::apache::thrift::protocol::TType _ktype612;
            ::apache::thrift::protocol::TType _vtype613;
            xfer += iprot->readMapBegin(_ktype612, _vtype613, _size611);
            uint32_t _i615;
            for (_i615 = 0; _i615 < _size611; ++_i615)
            {
              int64_t _key616;
              xfer += iprot->readI64(_key616);
              MetadataPpdResult& _val617 = this->metadata[_key616];
              xfer += _val617.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataByExprResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataByExprResult");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->metadata.size()));
    std::map<int64_t, MetadataPpdResult> ::const_iterator _iter618;
    for (_iter618 = this->metadata.begin(); _iter618 != this->metadata.end(); ++_iter618)
    {
      xfer += oprot->writeI64(_iter618->first);
      xfer += _iter618->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataByExprResult &a, GetFileMetadataByExprResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.isSupported, b.isSupported);
}

GetFileMetadataByExprResult::GetFileMetadataByExprResult(const GetFileMetadataByExprResult& other619) {
  metadata = other619.metadata;
  isSupported = other619.isSupported;
}
GetFileMetadataByExprResult& GetFileMetadataByExprResult::operator=(const GetFileMetadataByExprResult& other620) {
  metadata = other620.metadata;
  isSupported = other620.isSupported;
  return *this;
}
void GetFileMetadataByExprResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataByExprResult(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "isSupported=" << to_string(isSupported);
  out << ")";
}


GetFileMetadataByExprRequest::~GetFileMetadataByExprRequest() throw() {
}


void GetFileMetadataByExprRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}

void GetFileMetadataByExprRequest::__set_expr(const std::string& val) {
  this->expr = val;
}

void GetFileMetadataByExprRequest::__set_doGetFooters(const bool val) {
  this->doGetFooters = val;
__isset.doGetFooters = true;
}

uint32_t GetFileMetadataByExprRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;
  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size621;
            ::apache::thrift::protocol::TType _etype624;
            xfer += iprot->readListBegin(_etype624, _size621);
            this->fileIds.resize(_size621);
            uint32_t _i625;
            for (_i625 = 0; _i625 < _size621; ++_i625)
            {
              xfer += iprot->readI64(this->fileIds[_i625]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->doGetFooters);
          this->__isset.doGetFooters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataByExprRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataByExprRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter626;
    for (_iter626 = this->fileIds.begin(); _iter626 != this->fileIds.end(); ++_iter626)
    {
      xfer += oprot->writeI64((*_iter626));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.doGetFooters) {
    xfer += oprot->writeFieldBegin("doGetFooters", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->doGetFooters);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataByExprRequest &a, GetFileMetadataByExprRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
  swap(a.expr, b.expr);
  swap(a.doGetFooters, b.doGetFooters);
  swap(a.__isset, b.__isset);
}

GetFileMetadataByExprRequest::GetFileMetadataByExprRequest(const GetFileMetadataByExprRequest& other627) {
  fileIds = other627.fileIds;
  expr = other627.expr;
  doGetFooters = other627.doGetFooters;
  __isset = other627.__isset;
}
GetFileMetadataByExprRequest& GetFileMetadataByExprRequest::operator=(const GetFileMetadataByExprRequest& other628) {
  fileIds = other628.fileIds;
  expr = other628.expr;
  doGetFooters = other628.doGetFooters;
  __isset = other628.__isset;
  return *this;
}
void GetFileMetadataByExprRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataByExprRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ", " << "expr=" << to_string(expr);
  out << ", " << "doGetFooters="; (__isset.doGetFooters ? (out << to_string(doGetFooters)) : (out << "<null>"));
  out << ")";
}


GetFileMetadataResult::~GetFileMetadataResult() throw() {
}


void GetFileMetadataResult::__set_metadata(const std::map<int64_t, std::string> & val) {
  this->metadata = val;
}

void GetFileMetadataResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}

uint32_t GetFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size629;
            ::apache::thrift::protocol::TType _ktype630;
            ::apache::thrift::protocol::TType _vtype631;
            xfer += iprot->readMapBegin(_ktype630, _vtype631, _size629);
            uint32_t _i633;
            for (_i633 = 0; _i633 < _size629; ++_i633)
            {
              int64_t _key634;
              xfer += iprot->readI64(_key634);
              std::string& _val635 = this->metadata[_key634];
              xfer += iprot->readBinary(_val635);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataResult");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<int64_t, std::string> ::const_iterator _iter636;
    for (_iter636 = this->metadata.begin(); _iter636 != this->metadata.end(); ++_iter636)
    {
      xfer += oprot->writeI64(_iter636->first);
      xfer += oprot->writeBinary(_iter636->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataResult &a, GetFileMetadataResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.isSupported, b.isSupported);
}

GetFileMetadataResult::GetFileMetadataResult(const GetFileMetadataResult& other637) {
  metadata = other637.metadata;
  isSupported = other637.isSupported;
}
GetFileMetadataResult& GetFileMetadataResult::operator=(const GetFileMetadataResult& other638) {
  metadata = other638.metadata;
  isSupported = other638.isSupported;
  return *this;
}
void GetFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataResult(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "isSupported=" << to_string(isSupported);
  out << ")";
}


GetFileMetadataRequest::~GetFileMetadataRequest() throw() {
}


void GetFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}

uint32_t GetFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size639;
            ::apache::thrift::protocol::TType _etype642;
            xfer += iprot->readListBegin(_etype642, _size639);
            this->fileIds.resize(_size639);
            uint32_t _i643;
            for (_i643 = 0; _i643 < _size639; ++_i643)
            {
              xfer += iprot->readI64(this->fileIds[_i643]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter644;
    for (_iter644 = this->fileIds.begin(); _iter644 != this->fileIds.end(); ++_iter644)
    {
      xfer += oprot->writeI64((*_iter644));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataRequest &a, GetFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
}

GetFileMetadataRequest::GetFileMetadataRequest(const GetFileMetadataRequest& other645) {
  fileIds = other645.fileIds;
}
GetFileMetadataRequest& GetFileMetadataRequest::operator=(const GetFileMetadataRequest& other646) {
  fileIds = other646.fileIds;
  return *this;
}
void GetFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ")";
}


PutFileMetadataResult::~PutFileMetadataResult() throw() {
}


uint32_t PutFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PutFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PutFileMetadataResult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PutFileMetadataResult &a, PutFileMetadataResult &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

PutFileMetadataResult::PutFileMetadataResult(const PutFileMetadataResult& other647) {
  (void) other647;
}
PutFileMetadataResult& PutFileMetadataResult::operator=(const PutFileMetadataResult& other648) {
  (void) other648;
  return *this;
}
void PutFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PutFileMetadataResult(";
  out << ")";
}


PutFileMetadataRequest::~PutFileMetadataRequest() throw() {
}


void PutFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}

void PutFileMetadataRequest::__set_metadata(const std::vector<std::string> & val) {
  this->metadata = val;
}

uint32_t PutFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size649;
            ::apache::thrift::protocol::TType _etype652;
            xfer += iprot->readListBegin(_etype652, _size649);
            this->fileIds.resize(_size649);
            uint32_t _i653;
            for (_i653 = 0; _i653 < _size649; ++_i653)
            {
              xfer += iprot->readI64(this->fileIds[_i653]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->metadata.clear();
            uint32_t _size654;
            ::apache::thrift::protocol::TType _etype657;
            xfer += iprot->readListBegin(_etype657, _size654);
            this->metadata.resize(_size654);
            uint32_t _i658;
            for (_i658 = 0; _i658 < _size654; ++_i658)
            {
              xfer += iprot->readBinary(this->metadata[_i658]);
            }
            xfer += iprot->readListEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PutFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PutFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter659;
    for (_iter659 = this->fileIds.begin(); _iter659 != this->fileIds.end(); ++_iter659)
    {
      xfer += oprot->writeI64((*_iter659));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::vector<std::string> ::const_iterator _iter660;
    for (_iter660 = this->metadata.begin(); _iter660 != this->metadata.end(); ++_iter660)
    {
      xfer += oprot->writeBinary((*_iter660));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PutFileMetadataRequest &a, PutFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
  swap(a.metadata, b.metadata);
}

PutFileMetadataRequest::PutFileMetadataRequest(const PutFileMetadataRequest& other661) {
  fileIds = other661.fileIds;
  metadata = other661.metadata;
}
PutFileMetadataRequest& PutFileMetadataRequest::operator=(const PutFileMetadataRequest& other662) {
  fileIds = other662.fileIds;
  metadata = other662.metadata;
  return *this;
}
void PutFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PutFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


ClearFileMetadataResult::~ClearFileMetadataResult() throw() {
}


uint32_t ClearFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClearFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClearFileMetadataResult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClearFileMetadataResult &a, ClearFileMetadataResult &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ClearFileMetadataResult::ClearFileMetadataResult(const ClearFileMetadataResult& other663) {
  (void) other663;
}
ClearFileMetadataResult& ClearFileMetadataResult::operator=(const ClearFileMetadataResult& other664) {
  (void) other664;
  return *this;
}
void ClearFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClearFileMetadataResult(";
  out << ")";
}


ClearFileMetadataRequest::~ClearFileMetadataRequest() throw() {
}


void ClearFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}

uint32_t ClearFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size665;
            ::apache::thrift::protocol::TType _etype668;
            xfer += iprot->readListBegin(_etype668, _size665);
            this->fileIds.resize(_size665);
            uint32_t _i669;
            for (_i669 = 0; _i669 < _size665; ++_i669)
            {
              xfer += iprot->readI64(this->fileIds[_i669]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ClearFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClearFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter670;
    for (_iter670 = this->fileIds.begin(); _iter670 != this->fileIds.end(); ++_iter670)
    {
      xfer += oprot->writeI64((*_iter670));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClearFileMetadataRequest &a, ClearFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
}

ClearFileMetadataRequest::ClearFileMetadataRequest(const ClearFileMetadataRequest& other671) {
  fileIds = other671.fileIds;
}
ClearFileMetadataRequest& ClearFileMetadataRequest::operator=(const ClearFileMetadataRequest& other672) {
  fileIds = other672.fileIds;
  return *this;
}
void ClearFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClearFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ")";
}


GetAllFunctionsResponse::~GetAllFunctionsResponse() throw() {
}


void GetAllFunctionsResponse::__set_functions(const std::vector<Function> & val) {
  this->functions = val;
__isset.functions = true;
}

uint32_t GetAllFunctionsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->functions.clear();
            uint32_t _size673;
            ::apache::thrift::protocol::TType _etype676;
            xfer += iprot->readListBegin(_etype676, _size673);
            this->functions.resize(_size673);
            uint32_t _i677;
            for (_i677 = 0; _i677 < _size673; ++_i677)
            {
              xfer += this->functions[_i677].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetAllFunctionsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllFunctionsResponse");

  if (this->__isset.functions) {
    xfer += oprot->writeFieldBegin("functions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->functions.size()));
      std::vector<Function> ::const_iterator _iter678;
      for (_iter678 = this->functions.begin(); _iter678 != this->functions.end(); ++_iter678)
      {
        xfer += (*_iter678).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllFunctionsResponse &a, GetAllFunctionsResponse &b) {
  using ::std::swap;
  swap(a.functions, b.functions);
  swap(a.__isset, b.__isset);
}

GetAllFunctionsResponse::GetAllFunctionsResponse(const GetAllFunctionsResponse& other679) {
  functions = other679.functions;
  __isset = other679.__isset;
}
GetAllFunctionsResponse& GetAllFunctionsResponse::operator=(const GetAllFunctionsResponse& other680) {
  functions = other680.functions;
  __isset = other680.__isset;
  return *this;
}
void GetAllFunctionsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllFunctionsResponse(";
  out << "functions="; (__isset.functions ? (out << to_string(functions)) : (out << "<null>"));
  out << ")";
}


MetaException::~MetaException() throw() {
}


void MetaException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t MetaException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetaException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetaException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetaException &a, MetaException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

MetaException::MetaException(const MetaException& other681) : TException() {
  message = other681.message;
  __isset = other681.__isset;
}
MetaException& MetaException::operator=(const MetaException& other682) {
  message = other682.message;
  __isset = other682.__isset;
  return *this;
}
void MetaException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetaException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* MetaException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: MetaException";
  }
}


UnknownTableException::~UnknownTableException() throw() {
}


void UnknownTableException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t UnknownTableException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownTableException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownTableException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownTableException &a, UnknownTableException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownTableException::UnknownTableException(const UnknownTableException& other683) : TException() {
  message = other683.message;
  __isset = other683.__isset;
}
UnknownTableException& UnknownTableException::operator=(const UnknownTableException& other684) {
  message = other684.message;
  __isset = other684.__isset;
  return *this;
}
void UnknownTableException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownTableException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownTableException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownTableException";
  }
}


UnknownDBException::~UnknownDBException() throw() {
}


void UnknownDBException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t UnknownDBException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownDBException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownDBException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownDBException &a, UnknownDBException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownDBException::UnknownDBException(const UnknownDBException& other685) : TException() {
  message = other685.message;
  __isset = other685.__isset;
}
UnknownDBException& UnknownDBException::operator=(const UnknownDBException& other686) {
  message = other686.message;
  __isset = other686.__isset;
  return *this;
}
void UnknownDBException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownDBException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownDBException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownDBException";
  }
}


AlreadyExistsException::~AlreadyExistsException() throw() {
}


void AlreadyExistsException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t AlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlreadyExistsException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlreadyExistsException &a, AlreadyExistsException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

AlreadyExistsException::AlreadyExistsException(const AlreadyExistsException& other687) : TException() {
  message = other687.message;
  __isset = other687.__isset;
}
AlreadyExistsException& AlreadyExistsException::operator=(const AlreadyExistsException& other688) {
  message = other688.message;
  __isset = other688.__isset;
  return *this;
}
void AlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlreadyExistsException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* AlreadyExistsException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: AlreadyExistsException";
  }
}


InvalidPartitionException::~InvalidPartitionException() throw() {
}


void InvalidPartitionException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t InvalidPartitionException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidPartitionException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidPartitionException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidPartitionException &a, InvalidPartitionException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidPartitionException::InvalidPartitionException(const InvalidPartitionException& other689) : TException() {
  message = other689.message;
  __isset = other689.__isset;
}
InvalidPartitionException& InvalidPartitionException::operator=(const InvalidPartitionException& other690) {
  message = other690.message;
  __isset = other690.__isset;
  return *this;
}
void InvalidPartitionException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidPartitionException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidPartitionException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidPartitionException";
  }
}


UnknownPartitionException::~UnknownPartitionException() throw() {
}


void UnknownPartitionException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t UnknownPartitionException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownPartitionException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownPartitionException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownPartitionException &a, UnknownPartitionException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownPartitionException::UnknownPartitionException(const UnknownPartitionException& other691) : TException() {
  message = other691.message;
  __isset = other691.__isset;
}
UnknownPartitionException& UnknownPartitionException::operator=(const UnknownPartitionException& other692) {
  message = other692.message;
  __isset = other692.__isset;
  return *this;
}
void UnknownPartitionException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownPartitionException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownPartitionException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownPartitionException";
  }
}


InvalidObjectException::~InvalidObjectException() throw() {
}


void InvalidObjectException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t InvalidObjectException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidObjectException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidObjectException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidObjectException &a, InvalidObjectException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidObjectException::InvalidObjectException(const InvalidObjectException& other693) : TException() {
  message = other693.message;
  __isset = other693.__isset;
}
InvalidObjectException& InvalidObjectException::operator=(const InvalidObjectException& other694) {
  message = other694.message;
  __isset = other694.__isset;
  return *this;
}
void InvalidObjectException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidObjectException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidObjectException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidObjectException";
  }
}


NoSuchObjectException::~NoSuchObjectException() throw() {
}


void NoSuchObjectException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t NoSuchObjectException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchObjectException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchObjectException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchObjectException &a, NoSuchObjectException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchObjectException::NoSuchObjectException(const NoSuchObjectException& other695) : TException() {
  message = other695.message;
  __isset = other695.__isset;
}
NoSuchObjectException& NoSuchObjectException::operator=(const NoSuchObjectException& other696) {
  message = other696.message;
  __isset = other696.__isset;
  return *this;
}
void NoSuchObjectException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchObjectException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchObjectException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchObjectException";
  }
}


IndexAlreadyExistsException::~IndexAlreadyExistsException() throw() {
}


void IndexAlreadyExistsException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t IndexAlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IndexAlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IndexAlreadyExistsException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IndexAlreadyExistsException &a, IndexAlreadyExistsException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

IndexAlreadyExistsException::IndexAlreadyExistsException(const IndexAlreadyExistsException& other697) : TException() {
  message = other697.message;
  __isset = other697.__isset;
}
IndexAlreadyExistsException& IndexAlreadyExistsException::operator=(const IndexAlreadyExistsException& other698) {
  message = other698.message;
  __isset = other698.__isset;
  return *this;
}
void IndexAlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IndexAlreadyExistsException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* IndexAlreadyExistsException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: IndexAlreadyExistsException";
  }
}


InvalidOperationException::~InvalidOperationException() throw() {
}


void InvalidOperationException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t InvalidOperationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidOperationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidOperationException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidOperationException &a, InvalidOperationException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidOperationException::InvalidOperationException(const InvalidOperationException& other699) : TException() {
  message = other699.message;
  __isset = other699.__isset;
}
InvalidOperationException& InvalidOperationException::operator=(const InvalidOperationException& other700) {
  message = other700.message;
  __isset = other700.__isset;
  return *this;
}
void InvalidOperationException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidOperationException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidOperationException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidOperationException";
  }
}


ConfigValSecurityException::~ConfigValSecurityException() throw() {
}


void ConfigValSecurityException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t ConfigValSecurityException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConfigValSecurityException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConfigValSecurityException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConfigValSecurityException &a, ConfigValSecurityException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

ConfigValSecurityException::ConfigValSecurityException(const ConfigValSecurityException& other701) : TException() {
  message = other701.message;
  __isset = other701.__isset;
}
ConfigValSecurityException& ConfigValSecurityException::operator=(const ConfigValSecurityException& other702) {
  message = other702.message;
  __isset = other702.__isset;
  return *this;
}
void ConfigValSecurityException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConfigValSecurityException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* ConfigValSecurityException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ConfigValSecurityException";
  }
}


InvalidInputException::~InvalidInputException() throw() {
}


void InvalidInputException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t InvalidInputException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidInputException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidInputException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidInputException &a, InvalidInputException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidInputException::InvalidInputException(const InvalidInputException& other703) : TException() {
  message = other703.message;
  __isset = other703.__isset;
}
InvalidInputException& InvalidInputException::operator=(const InvalidInputException& other704) {
  message = other704.message;
  __isset = other704.__isset;
  return *this;
}
void InvalidInputException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidInputException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidInputException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidInputException";
  }
}


NoSuchTxnException::~NoSuchTxnException() throw() {
}


void NoSuchTxnException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t NoSuchTxnException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchTxnException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchTxnException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchTxnException &a, NoSuchTxnException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchTxnException::NoSuchTxnException(const NoSuchTxnException& other705) : TException() {
  message = other705.message;
  __isset = other705.__isset;
}
NoSuchTxnException& NoSuchTxnException::operator=(const NoSuchTxnException& other706) {
  message = other706.message;
  __isset = other706.__isset;
  return *this;
}
void NoSuchTxnException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchTxnException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchTxnException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchTxnException";
  }
}


TxnAbortedException::~TxnAbortedException() throw() {
}


void TxnAbortedException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t TxnAbortedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TxnAbortedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnAbortedException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnAbortedException &a, TxnAbortedException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TxnAbortedException::TxnAbortedException(const TxnAbortedException& other707) : TException() {
  message = other707.message;
  __isset = other707.__isset;
}
TxnAbortedException& TxnAbortedException::operator=(const TxnAbortedException& other708) {
  message = other708.message;
  __isset = other708.__isset;
  return *this;
}
void TxnAbortedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnAbortedException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* TxnAbortedException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TxnAbortedException";
  }
}


TxnOpenException::~TxnOpenException() throw() {
}


void TxnOpenException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t TxnOpenException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TxnOpenException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnOpenException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnOpenException &a, TxnOpenException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TxnOpenException::TxnOpenException(const TxnOpenException& other709) : TException() {
  message = other709.message;
  __isset = other709.__isset;
}
TxnOpenException& TxnOpenException::operator=(const TxnOpenException& other710) {
  message = other710.message;
  __isset = other710.__isset;
  return *this;
}
void TxnOpenException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnOpenException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* TxnOpenException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TxnOpenException";
  }
}


NoSuchLockException::~NoSuchLockException() throw() {
}


void NoSuchLockException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t NoSuchLockException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchLockException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchLockException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchLockException &a, NoSuchLockException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchLockException::NoSuchLockException(const NoSuchLockException& other711) : TException() {
  message = other711.message;
  __isset = other711.__isset;
}
NoSuchLockException& NoSuchLockException::operator=(const NoSuchLockException& other712) {
  message = other712.message;
  __isset = other712.__isset;
  return *this;
}
void NoSuchLockException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchLockException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchLockException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchLockException";
  }
}

}}} // namespace
