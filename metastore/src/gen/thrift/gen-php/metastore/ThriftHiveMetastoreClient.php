<?php
namespace metastore;

/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

class ThriftHiveMetastoreClient extends \FacebookServiceClient implements \metastore\ThriftHiveMetastoreIf
{
    public function __construct($input, $output = null)
    {
        parent::__construct($input, $output);
    }


    public function getMetaConf($key)
    {
        $this->send_getMetaConf($key);
        return $this->recv_getMetaConf();
    }

    public function send_getMetaConf($key)
    {
        $args = new \metastore\ThriftHiveMetastore_getMetaConf_args();
        $args->key = $key;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'getMetaConf',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('getMetaConf', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_getMetaConf()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_getMetaConf_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_getMetaConf_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("getMetaConf failed: unknown result");
    }

    public function setMetaConf($key, $value)
    {
        $this->send_setMetaConf($key, $value);
        $this->recv_setMetaConf();
    }

    public function send_setMetaConf($key, $value)
    {
        $args = new \metastore\ThriftHiveMetastore_setMetaConf_args();
        $args->key = $key;
        $args->value = $value;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'setMetaConf',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('setMetaConf', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_setMetaConf()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_setMetaConf_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_setMetaConf_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function create_database(\metastore\Database $database)
    {
        $this->send_create_database($database);
        $this->recv_create_database();
    }

    public function send_create_database(\metastore\Database $database)
    {
        $args = new \metastore\ThriftHiveMetastore_create_database_args();
        $args->database = $database;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_database',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_database', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_database()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_database_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_database_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function get_database($name)
    {
        $this->send_get_database($name);
        return $this->recv_get_database();
    }

    public function send_get_database($name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_database_args();
        $args->name = $name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_database',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_database', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_database()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_database_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_database_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_database failed: unknown result");
    }

    public function drop_database($name, $deleteData, $cascade)
    {
        $this->send_drop_database($name, $deleteData, $cascade);
        $this->recv_drop_database();
    }

    public function send_drop_database($name, $deleteData, $cascade)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_database_args();
        $args->name = $name;
        $args->deleteData = $deleteData;
        $args->cascade = $cascade;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_database',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_database', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_database()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_database_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_database_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function get_databases($pattern)
    {
        $this->send_get_databases($pattern);
        return $this->recv_get_databases();
    }

    public function send_get_databases($pattern)
    {
        $args = new \metastore\ThriftHiveMetastore_get_databases_args();
        $args->pattern = $pattern;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_databases',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_databases', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_databases()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_databases_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_databases_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_databases failed: unknown result");
    }

    public function get_all_databases()
    {
        $this->send_get_all_databases();
        return $this->recv_get_all_databases();
    }

    public function send_get_all_databases()
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_databases_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_databases',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_databases', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_databases()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_databases_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_databases_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_all_databases failed: unknown result");
    }

    public function alter_database($dbname, \metastore\Database $db)
    {
        $this->send_alter_database($dbname, $db);
        $this->recv_alter_database();
    }

    public function send_alter_database($dbname, \metastore\Database $db)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_database_args();
        $args->dbname = $dbname;
        $args->db = $db;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_database',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_database', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_database()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_database_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_database_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_type($name)
    {
        $this->send_get_type($name);
        return $this->recv_get_type();
    }

    public function send_get_type($name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_type_args();
        $args->name = $name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_type',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_type', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_type()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_type_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_type_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_type failed: unknown result");
    }

    public function create_type(\metastore\Type $type)
    {
        $this->send_create_type($type);
        return $this->recv_create_type();
    }

    public function send_create_type(\metastore\Type $type)
    {
        $args = new \metastore\ThriftHiveMetastore_create_type_args();
        $args->type = $type;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_type',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_type', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_type()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_type_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_type_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("create_type failed: unknown result");
    }

    public function drop_type($type)
    {
        $this->send_drop_type($type);
        return $this->recv_drop_type();
    }

    public function send_drop_type($type)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_type_args();
        $args->type = $type;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_type',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_type', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_type()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_type_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_type_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_type failed: unknown result");
    }

    public function get_type_all($name)
    {
        $this->send_get_type_all($name);
        return $this->recv_get_type_all();
    }

    public function send_get_type_all($name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_type_all_args();
        $args->name = $name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_type_all',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_type_all', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_type_all()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_type_all_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_type_all_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_type_all failed: unknown result");
    }

    public function get_fields($db_name, $table_name)
    {
        $this->send_get_fields($db_name, $table_name);
        return $this->recv_get_fields();
    }

    public function send_get_fields($db_name, $table_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_fields_args();
        $args->db_name = $db_name;
        $args->table_name = $table_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_fields',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_fields', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_fields()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_fields_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_fields_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_fields failed: unknown result");
    }

    public function get_fields_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_get_fields_with_environment_context($db_name, $table_name, $environment_context);
        return $this->recv_get_fields_with_environment_context();
    }

    public function send_get_fields_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_get_fields_with_environment_context_args();
        $args->db_name = $db_name;
        $args->table_name = $table_name;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_fields_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_fields_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_fields_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_fields_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_fields_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_fields_with_environment_context failed: unknown result");
    }

    public function get_schema($db_name, $table_name)
    {
        $this->send_get_schema($db_name, $table_name);
        return $this->recv_get_schema();
    }

    public function send_get_schema($db_name, $table_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_schema_args();
        $args->db_name = $db_name;
        $args->table_name = $table_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_schema',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_schema', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_schema()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_schema_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_schema_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_schema failed: unknown result");
    }

    public function get_schema_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_get_schema_with_environment_context($db_name, $table_name, $environment_context);
        return $this->recv_get_schema_with_environment_context();
    }

    public function send_get_schema_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_get_schema_with_environment_context_args();
        $args->db_name = $db_name;
        $args->table_name = $table_name;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_schema_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_schema_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_schema_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_schema_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_schema_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_schema_with_environment_context failed: unknown result");
    }

    public function create_table(\metastore\Table $tbl)
    {
        $this->send_create_table($tbl);
        $this->recv_create_table();
    }

    public function send_create_table(\metastore\Table $tbl)
    {
        $args = new \metastore\ThriftHiveMetastore_create_table_args();
        $args->tbl = $tbl;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_table',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_table', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_table()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_table_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_table_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        return;
    }

    public function create_table_with_environment_context(\metastore\Table $tbl, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_create_table_with_environment_context($tbl, $environment_context);
        $this->recv_create_table_with_environment_context();
    }

    public function send_create_table_with_environment_context(\metastore\Table $tbl, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_create_table_with_environment_context_args();
        $args->tbl = $tbl;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_table_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_table_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_table_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_table_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_table_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        return;
    }

    public function create_table_with_constraints(\metastore\Table $tbl, array $primaryKeys, array $foreignKeys)
    {
        $this->send_create_table_with_constraints($tbl, $primaryKeys, $foreignKeys);
        $this->recv_create_table_with_constraints();
    }

    public function send_create_table_with_constraints(\metastore\Table $tbl, array $primaryKeys, array $foreignKeys)
    {
        $args = new \metastore\ThriftHiveMetastore_create_table_with_constraints_args();
        $args->tbl = $tbl;
        $args->primaryKeys = $primaryKeys;
        $args->foreignKeys = $foreignKeys;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_table_with_constraints',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_table_with_constraints', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_table_with_constraints()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_table_with_constraints_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_table_with_constraints_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        return;
    }

    public function drop_constraint(\metastore\DropConstraintRequest $req)
    {
        $this->send_drop_constraint($req);
        $this->recv_drop_constraint();
    }

    public function send_drop_constraint(\metastore\DropConstraintRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_constraint_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_constraint',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_constraint', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_constraint()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_constraint_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_constraint_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function add_primary_key(\metastore\AddPrimaryKeyRequest $req)
    {
        $this->send_add_primary_key($req);
        $this->recv_add_primary_key();
    }

    public function send_add_primary_key(\metastore\AddPrimaryKeyRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_add_primary_key_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_primary_key',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_primary_key', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_primary_key()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_primary_key_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_primary_key_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function add_foreign_key(\metastore\AddForeignKeyRequest $req)
    {
        $this->send_add_foreign_key($req);
        $this->recv_add_foreign_key();
    }

    public function send_add_foreign_key(\metastore\AddForeignKeyRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_add_foreign_key_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_foreign_key',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_foreign_key', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_foreign_key()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_foreign_key_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_foreign_key_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function drop_table($dbname, $name, $deleteData)
    {
        $this->send_drop_table($dbname, $name, $deleteData);
        $this->recv_drop_table();
    }

    public function send_drop_table($dbname, $name, $deleteData)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_table_args();
        $args->dbname = $dbname;
        $args->name = $name;
        $args->deleteData = $deleteData;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_table',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_table', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_table()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_table_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_table_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function drop_table_with_environment_context($dbname, $name, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_drop_table_with_environment_context($dbname, $name, $deleteData, $environment_context);
        $this->recv_drop_table_with_environment_context();
    }

    public function send_drop_table_with_environment_context($dbname, $name, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_table_with_environment_context_args();
        $args->dbname = $dbname;
        $args->name = $name;
        $args->deleteData = $deleteData;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_table_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_table_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_table_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_table_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_table_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function get_tables($db_name, $pattern)
    {
        $this->send_get_tables($db_name, $pattern);
        return $this->recv_get_tables();
    }

    public function send_get_tables($db_name, $pattern)
    {
        $args = new \metastore\ThriftHiveMetastore_get_tables_args();
        $args->db_name = $db_name;
        $args->pattern = $pattern;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_tables',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_tables', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_tables()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_tables_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_tables_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_tables failed: unknown result");
    }

    public function get_tables_by_type($db_name, $pattern, $tableType)
    {
        $this->send_get_tables_by_type($db_name, $pattern, $tableType);
        return $this->recv_get_tables_by_type();
    }

    public function send_get_tables_by_type($db_name, $pattern, $tableType)
    {
        $args = new \metastore\ThriftHiveMetastore_get_tables_by_type_args();
        $args->db_name = $db_name;
        $args->pattern = $pattern;
        $args->tableType = $tableType;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_tables_by_type',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_tables_by_type', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_tables_by_type()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_tables_by_type_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_tables_by_type_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_tables_by_type failed: unknown result");
    }

    public function get_table_meta($db_patterns, $tbl_patterns, array $tbl_types)
    {
        $this->send_get_table_meta($db_patterns, $tbl_patterns, $tbl_types);
        return $this->recv_get_table_meta();
    }

    public function send_get_table_meta($db_patterns, $tbl_patterns, array $tbl_types)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_meta_args();
        $args->db_patterns = $db_patterns;
        $args->tbl_patterns = $tbl_patterns;
        $args->tbl_types = $tbl_types;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_meta',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_meta', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_meta()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_meta_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_meta_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_table_meta failed: unknown result");
    }

    public function get_all_tables($db_name)
    {
        $this->send_get_all_tables($db_name);
        return $this->recv_get_all_tables();
    }

    public function send_get_all_tables($db_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_tables_args();
        $args->db_name = $db_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_tables',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_tables', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_tables()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_tables_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_tables_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_all_tables failed: unknown result");
    }

    public function get_table($dbname, $tbl_name)
    {
        $this->send_get_table($dbname, $tbl_name);
        return $this->recv_get_table();
    }

    public function send_get_table($dbname, $tbl_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_args();
        $args->dbname = $dbname;
        $args->tbl_name = $tbl_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_table failed: unknown result");
    }

    public function get_table_objects_by_name($dbname, array $tbl_names)
    {
        $this->send_get_table_objects_by_name($dbname, $tbl_names);
        return $this->recv_get_table_objects_by_name();
    }

    public function send_get_table_objects_by_name($dbname, array $tbl_names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_args();
        $args->dbname = $dbname;
        $args->tbl_names = $tbl_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_objects_by_name',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_objects_by_name', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_objects_by_name()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_objects_by_name_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_table_objects_by_name failed: unknown result");
    }

    public function get_table_req(\metastore\GetTableRequest $req)
    {
        $this->send_get_table_req($req);
        return $this->recv_get_table_req();
    }

    public function send_get_table_req(\metastore\GetTableRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_table_req failed: unknown result");
    }

    public function get_table_objects_by_name_req(\metastore\GetTablesRequest $req)
    {
        $this->send_get_table_objects_by_name_req($req);
        return $this->recv_get_table_objects_by_name_req();
    }

    public function send_get_table_objects_by_name_req(\metastore\GetTablesRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_objects_by_name_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_objects_by_name_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_objects_by_name_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_objects_by_name_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_table_objects_by_name_req failed: unknown result");
    }

    public function get_table_names_by_filter($dbname, $filter, $max_tables)
    {
        $this->send_get_table_names_by_filter($dbname, $filter, $max_tables);
        return $this->recv_get_table_names_by_filter();
    }

    public function send_get_table_names_by_filter($dbname, $filter, $max_tables)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_names_by_filter_args();
        $args->dbname = $dbname;
        $args->filter = $filter;
        $args->max_tables = $max_tables;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_names_by_filter',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_names_by_filter', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_names_by_filter()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_names_by_filter_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_names_by_filter_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_table_names_by_filter failed: unknown result");
    }

    public function alter_table($dbname, $tbl_name, \metastore\Table $new_tbl)
    {
        $this->send_alter_table($dbname, $tbl_name, $new_tbl);
        $this->recv_alter_table();
    }

    public function send_alter_table($dbname, $tbl_name, \metastore\Table $new_tbl)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_table_args();
        $args->dbname = $dbname;
        $args->tbl_name = $tbl_name;
        $args->new_tbl = $new_tbl;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_table',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_table', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_table()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_table_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_table_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_table_with_environment_context($dbname, $tbl_name, \metastore\Table $new_tbl, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_alter_table_with_environment_context($dbname, $tbl_name, $new_tbl, $environment_context);
        $this->recv_alter_table_with_environment_context();
    }

    public function send_alter_table_with_environment_context($dbname, $tbl_name, \metastore\Table $new_tbl, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_table_with_environment_context_args();
        $args->dbname = $dbname;
        $args->tbl_name = $tbl_name;
        $args->new_tbl = $new_tbl;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_table_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_table_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_table_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_table_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_table_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_table_with_cascade($dbname, $tbl_name, \metastore\Table $new_tbl, $cascade)
    {
        $this->send_alter_table_with_cascade($dbname, $tbl_name, $new_tbl, $cascade);
        $this->recv_alter_table_with_cascade();
    }

    public function send_alter_table_with_cascade($dbname, $tbl_name, \metastore\Table $new_tbl, $cascade)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_table_with_cascade_args();
        $args->dbname = $dbname;
        $args->tbl_name = $tbl_name;
        $args->new_tbl = $new_tbl;
        $args->cascade = $cascade;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_table_with_cascade',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_table_with_cascade', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_table_with_cascade()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_table_with_cascade_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_table_with_cascade_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function add_partition(\metastore\Partition $new_part)
    {
        $this->send_add_partition($new_part);
        return $this->recv_add_partition();
    }

    public function send_add_partition(\metastore\Partition $new_part)
    {
        $args = new \metastore\ThriftHiveMetastore_add_partition_args();
        $args->new_part = $new_part;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_partition failed: unknown result");
    }

    public function add_partition_with_environment_context(\metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_add_partition_with_environment_context($new_part, $environment_context);
        return $this->recv_add_partition_with_environment_context();
    }

    public function send_add_partition_with_environment_context(\metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_add_partition_with_environment_context_args();
        $args->new_part = $new_part;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_partition_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_partition_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_partition_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_partition_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_partition_with_environment_context failed: unknown result");
    }

    public function add_partitions(array $new_parts)
    {
        $this->send_add_partitions($new_parts);
        return $this->recv_add_partitions();
    }

    public function send_add_partitions(array $new_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_add_partitions_args();
        $args->new_parts = $new_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_partitions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_partitions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_partitions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_partitions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_partitions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_partitions failed: unknown result");
    }

    public function add_partitions_pspec(array $new_parts)
    {
        $this->send_add_partitions_pspec($new_parts);
        return $this->recv_add_partitions_pspec();
    }

    public function send_add_partitions_pspec(array $new_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_add_partitions_pspec_args();
        $args->new_parts = $new_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_partitions_pspec',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_partitions_pspec', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_partitions_pspec()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_partitions_pspec_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_partitions_pspec_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_partitions_pspec failed: unknown result");
    }

    public function append_partition($db_name, $tbl_name, array $part_vals)
    {
        $this->send_append_partition($db_name, $tbl_name, $part_vals);
        return $this->recv_append_partition();
    }

    public function send_append_partition($db_name, $tbl_name, array $part_vals)
    {
        $args = new \metastore\ThriftHiveMetastore_append_partition_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'append_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('append_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_append_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_append_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_append_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("append_partition failed: unknown result");
    }

    public function add_partitions_req(\metastore\AddPartitionsRequest $request)
    {
        $this->send_add_partitions_req($request);
        return $this->recv_add_partitions_req();
    }

    public function send_add_partitions_req(\metastore\AddPartitionsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_add_partitions_req_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_partitions_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_partitions_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_partitions_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_partitions_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_partitions_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_partitions_req failed: unknown result");
    }

    public function append_partition_with_environment_context($db_name, $tbl_name, array $part_vals, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_append_partition_with_environment_context($db_name, $tbl_name, $part_vals, $environment_context);
        return $this->recv_append_partition_with_environment_context();
    }

    public function send_append_partition_with_environment_context($db_name, $tbl_name, array $part_vals, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_append_partition_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'append_partition_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('append_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_append_partition_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_append_partition_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_append_partition_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("append_partition_with_environment_context failed: unknown result");
    }

    public function append_partition_by_name($db_name, $tbl_name, $part_name)
    {
        $this->send_append_partition_by_name($db_name, $tbl_name, $part_name);
        return $this->recv_append_partition_by_name();
    }

    public function send_append_partition_by_name($db_name, $tbl_name, $part_name)
    {
        $args = new \metastore\ThriftHiveMetastore_append_partition_by_name_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'append_partition_by_name',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('append_partition_by_name', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_append_partition_by_name()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_append_partition_by_name_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_append_partition_by_name_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("append_partition_by_name failed: unknown result");
    }

    public function append_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_append_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $environment_context);
        return $this->recv_append_partition_by_name_with_environment_context();
    }

    public function send_append_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_append_partition_by_name_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'append_partition_by_name_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('append_partition_by_name_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_append_partition_by_name_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_append_partition_by_name_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_append_partition_by_name_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("append_partition_by_name_with_environment_context failed: unknown result");
    }

    public function drop_partition($db_name, $tbl_name, array $part_vals, $deleteData)
    {
        $this->send_drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
        return $this->recv_drop_partition();
    }

    public function send_drop_partition($db_name, $tbl_name, array $part_vals, $deleteData)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_partition_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->deleteData = $deleteData;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_partition failed: unknown result");
    }

    public function drop_partition_with_environment_context($db_name, $tbl_name, array $part_vals, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_drop_partition_with_environment_context($db_name, $tbl_name, $part_vals, $deleteData, $environment_context);
        return $this->recv_drop_partition_with_environment_context();
    }

    public function send_drop_partition_with_environment_context($db_name, $tbl_name, array $part_vals, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_partition_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->deleteData = $deleteData;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_partition_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_partition_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_partition_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_partition_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_partition_with_environment_context failed: unknown result");
    }

    public function drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData)
    {
        $this->send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
        return $this->recv_drop_partition_by_name();
    }

    public function send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_partition_by_name_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $args->deleteData = $deleteData;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_partition_by_name',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_partition_by_name', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_partition_by_name()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_partition_by_name_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_partition_by_name_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_partition_by_name failed: unknown result");
    }

    public function drop_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_drop_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $deleteData, $environment_context);
        return $this->recv_drop_partition_by_name_with_environment_context();
    }

    public function send_drop_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_partition_by_name_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $args->deleteData = $deleteData;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_partition_by_name_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_partition_by_name_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_partition_by_name_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_partition_by_name_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_partition_by_name_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_partition_by_name_with_environment_context failed: unknown result");
    }

    public function drop_partitions_req(\metastore\DropPartitionsRequest $req)
    {
        $this->send_drop_partitions_req($req);
        return $this->recv_drop_partitions_req();
    }

    public function send_drop_partitions_req(\metastore\DropPartitionsRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_partitions_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_partitions_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_partitions_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_partitions_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_partitions_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_partitions_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_partitions_req failed: unknown result");
    }

    public function get_partition($db_name, $tbl_name, array $part_vals)
    {
        $this->send_get_partition($db_name, $tbl_name, $part_vals);
        return $this->recv_get_partition();
    }

    public function send_get_partition($db_name, $tbl_name, array $part_vals)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition failed: unknown result");
    }

    public function exchange_partition(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
    {
        $this->send_exchange_partition($partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name);
        return $this->recv_exchange_partition();
    }

    public function send_exchange_partition(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
    {
        $args = new \metastore\ThriftHiveMetastore_exchange_partition_args();
        $args->partitionSpecs = $partitionSpecs;
        $args->source_db = $source_db;
        $args->source_table_name = $source_table_name;
        $args->dest_db = $dest_db;
        $args->dest_table_name = $dest_table_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'exchange_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('exchange_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_exchange_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_exchange_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_exchange_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("exchange_partition failed: unknown result");
    }

    public function exchange_partitions(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
    {
        $this->send_exchange_partitions($partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name);
        return $this->recv_exchange_partitions();
    }

    public function send_exchange_partitions(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
    {
        $args = new \metastore\ThriftHiveMetastore_exchange_partitions_args();
        $args->partitionSpecs = $partitionSpecs;
        $args->source_db = $source_db;
        $args->source_table_name = $source_table_name;
        $args->dest_db = $dest_db;
        $args->dest_table_name = $dest_table_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'exchange_partitions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('exchange_partitions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_exchange_partitions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_exchange_partitions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_exchange_partitions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("exchange_partitions failed: unknown result");
    }

    public function get_partition_with_auth($db_name, $tbl_name, array $part_vals, $user_name, array $group_names)
    {
        $this->send_get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names);
        return $this->recv_get_partition_with_auth();
    }

    public function send_get_partition_with_auth($db_name, $tbl_name, array $part_vals, $user_name, array $group_names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_with_auth_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->user_name = $user_name;
        $args->group_names = $group_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_with_auth',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_with_auth', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_with_auth()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_with_auth_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_with_auth_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_with_auth failed: unknown result");
    }

    public function get_partition_by_name($db_name, $tbl_name, $part_name)
    {
        $this->send_get_partition_by_name($db_name, $tbl_name, $part_name);
        return $this->recv_get_partition_by_name();
    }

    public function send_get_partition_by_name($db_name, $tbl_name, $part_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_by_name_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_by_name',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_by_name', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_by_name()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_by_name_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_by_name_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_by_name failed: unknown result");
    }

    public function get_partitions($db_name, $tbl_name, $max_parts)
    {
        $this->send_get_partitions($db_name, $tbl_name, $max_parts);
        return $this->recv_get_partitions();
    }

    public function send_get_partitions($db_name, $tbl_name, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions failed: unknown result");
    }

    public function get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, array $group_names)
    {
        $this->send_get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names);
        return $this->recv_get_partitions_with_auth();
    }

    public function send_get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, array $group_names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_with_auth_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->max_parts = $max_parts;
        $args->user_name = $user_name;
        $args->group_names = $group_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_with_auth',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_with_auth', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_with_auth()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_with_auth_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_with_auth_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_with_auth failed: unknown result");
    }

    public function get_partitions_pspec($db_name, $tbl_name, $max_parts)
    {
        $this->send_get_partitions_pspec($db_name, $tbl_name, $max_parts);
        return $this->recv_get_partitions_pspec();
    }

    public function send_get_partitions_pspec($db_name, $tbl_name, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_pspec_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_pspec',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_pspec', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_pspec()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_pspec_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_pspec_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_pspec failed: unknown result");
    }

    public function get_partition_names($db_name, $tbl_name, $max_parts)
    {
        $this->send_get_partition_names($db_name, $tbl_name, $max_parts);
        return $this->recv_get_partition_names();
    }

    public function send_get_partition_names($db_name, $tbl_name, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_names_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_names',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_names', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_names()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_names_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_names_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_names failed: unknown result");
    }

    public function get_partition_values(\metastore\PartitionValuesRequest $request)
    {
        $this->send_get_partition_values($request);
        return $this->recv_get_partition_values();
    }

    public function send_get_partition_values(\metastore\PartitionValuesRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_values_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_values',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_values', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_values()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_values_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_values_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_values failed: unknown result");
    }

    public function get_partitions_ps($db_name, $tbl_name, array $part_vals, $max_parts)
    {
        $this->send_get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
        return $this->recv_get_partitions_ps();
    }

    public function send_get_partitions_ps($db_name, $tbl_name, array $part_vals, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_ps_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_ps',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_ps', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_ps()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_ps_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_ps_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_ps failed: unknown result");
    }

    public function get_partitions_ps_with_auth($db_name, $tbl_name, array $part_vals, $max_parts, $user_name, array $group_names)
    {
        $this->send_get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names);
        return $this->recv_get_partitions_ps_with_auth();
    }

    public function send_get_partitions_ps_with_auth($db_name, $tbl_name, array $part_vals, $max_parts, $user_name, array $group_names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->max_parts = $max_parts;
        $args->user_name = $user_name;
        $args->group_names = $group_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_ps_with_auth',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_ps_with_auth', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_ps_with_auth()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_ps_with_auth failed: unknown result");
    }

    public function get_partition_names_ps($db_name, $tbl_name, array $part_vals, $max_parts)
    {
        $this->send_get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
        return $this->recv_get_partition_names_ps();
    }

    public function send_get_partition_names_ps($db_name, $tbl_name, array $part_vals, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_names_ps_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_names_ps',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_names_ps', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_names_ps()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_names_ps_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_names_ps_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_names_ps failed: unknown result");
    }

    public function get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts)
    {
        $this->send_get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts);
        return $this->recv_get_partitions_by_filter();
    }

    public function send_get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_by_filter_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->filter = $filter;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_by_filter',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_by_filter', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_by_filter()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_by_filter_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_by_filter_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_by_filter failed: unknown result");
    }

    public function get_part_specs_by_filter($db_name, $tbl_name, $filter, $max_parts)
    {
        $this->send_get_part_specs_by_filter($db_name, $tbl_name, $filter, $max_parts);
        return $this->recv_get_part_specs_by_filter();
    }

    public function send_get_part_specs_by_filter($db_name, $tbl_name, $filter, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_part_specs_by_filter_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->filter = $filter;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_part_specs_by_filter',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_part_specs_by_filter', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_part_specs_by_filter()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_part_specs_by_filter_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_part_specs_by_filter_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_part_specs_by_filter failed: unknown result");
    }

    public function get_partitions_by_expr(\metastore\PartitionsByExprRequest $req)
    {
        $this->send_get_partitions_by_expr($req);
        return $this->recv_get_partitions_by_expr();
    }

    public function send_get_partitions_by_expr(\metastore\PartitionsByExprRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_by_expr_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_by_expr',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_by_expr', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_by_expr()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_by_expr_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_by_expr_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_by_expr failed: unknown result");
    }

    public function get_num_partitions_by_filter($db_name, $tbl_name, $filter)
    {
        $this->send_get_num_partitions_by_filter($db_name, $tbl_name, $filter);
        return $this->recv_get_num_partitions_by_filter();
    }

    public function send_get_num_partitions_by_filter($db_name, $tbl_name, $filter)
    {
        $args = new \metastore\ThriftHiveMetastore_get_num_partitions_by_filter_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->filter = $filter;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_num_partitions_by_filter',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_num_partitions_by_filter', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_num_partitions_by_filter()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_num_partitions_by_filter_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_num_partitions_by_filter_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_num_partitions_by_filter failed: unknown result");
    }

    public function get_partitions_by_names($db_name, $tbl_name, array $names)
    {
        $this->send_get_partitions_by_names($db_name, $tbl_name, $names);
        return $this->recv_get_partitions_by_names();
    }

    public function send_get_partitions_by_names($db_name, $tbl_name, array $names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_by_names_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->names = $names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_by_names',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_by_names', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_by_names()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_by_names_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_by_names_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_by_names failed: unknown result");
    }

    public function alter_partition($db_name, $tbl_name, \metastore\Partition $new_part)
    {
        $this->send_alter_partition($db_name, $tbl_name, $new_part);
        $this->recv_alter_partition();
    }

    public function send_alter_partition($db_name, $tbl_name, \metastore\Partition $new_part)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_partition_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->new_part = $new_part;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_partitions($db_name, $tbl_name, array $new_parts)
    {
        $this->send_alter_partitions($db_name, $tbl_name, $new_parts);
        $this->recv_alter_partitions();
    }

    public function send_alter_partitions($db_name, $tbl_name, array $new_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_partitions_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->new_parts = $new_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_partitions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_partitions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_partitions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_partitions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_partitions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_partitions_with_environment_context($db_name, $tbl_name, array $new_parts, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_alter_partitions_with_environment_context($db_name, $tbl_name, $new_parts, $environment_context);
        $this->recv_alter_partitions_with_environment_context();
    }

    public function send_alter_partitions_with_environment_context($db_name, $tbl_name, array $new_parts, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_partitions_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->new_parts = $new_parts;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_partitions_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_partitions_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_partitions_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_partitions_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_partitions_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_partition_with_environment_context($db_name, $tbl_name, \metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_alter_partition_with_environment_context($db_name, $tbl_name, $new_part, $environment_context);
        $this->recv_alter_partition_with_environment_context();
    }

    public function send_alter_partition_with_environment_context($db_name, $tbl_name, \metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_partition_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->new_part = $new_part;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_partition_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_partition_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_partition_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_partition_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function rename_partition($db_name, $tbl_name, array $part_vals, \metastore\Partition $new_part)
    {
        $this->send_rename_partition($db_name, $tbl_name, $part_vals, $new_part);
        $this->recv_rename_partition();
    }

    public function send_rename_partition($db_name, $tbl_name, array $part_vals, \metastore\Partition $new_part)
    {
        $args = new \metastore\ThriftHiveMetastore_rename_partition_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->new_part = $new_part;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'rename_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('rename_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_rename_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_rename_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_rename_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function partition_name_has_valid_characters(array $part_vals, $throw_exception)
    {
        $this->send_partition_name_has_valid_characters($part_vals, $throw_exception);
        return $this->recv_partition_name_has_valid_characters();
    }

    public function send_partition_name_has_valid_characters(array $part_vals, $throw_exception)
    {
        $args = new \metastore\ThriftHiveMetastore_partition_name_has_valid_characters_args();
        $args->part_vals = $part_vals;
        $args->throw_exception = $throw_exception;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'partition_name_has_valid_characters',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('partition_name_has_valid_characters', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_partition_name_has_valid_characters()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_partition_name_has_valid_characters_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_partition_name_has_valid_characters_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("partition_name_has_valid_characters failed: unknown result");
    }

    public function get_config_value($name, $defaultValue)
    {
        $this->send_get_config_value($name, $defaultValue);
        return $this->recv_get_config_value();
    }

    public function send_get_config_value($name, $defaultValue)
    {
        $args = new \metastore\ThriftHiveMetastore_get_config_value_args();
        $args->name = $name;
        $args->defaultValue = $defaultValue;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_config_value',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_config_value', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_config_value()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_config_value_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_config_value_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_config_value failed: unknown result");
    }

    public function partition_name_to_vals($part_name)
    {
        $this->send_partition_name_to_vals($part_name);
        return $this->recv_partition_name_to_vals();
    }

    public function send_partition_name_to_vals($part_name)
    {
        $args = new \metastore\ThriftHiveMetastore_partition_name_to_vals_args();
        $args->part_name = $part_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'partition_name_to_vals',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('partition_name_to_vals', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_partition_name_to_vals()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_partition_name_to_vals_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_partition_name_to_vals_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("partition_name_to_vals failed: unknown result");
    }

    public function partition_name_to_spec($part_name)
    {
        $this->send_partition_name_to_spec($part_name);
        return $this->recv_partition_name_to_spec();
    }

    public function send_partition_name_to_spec($part_name)
    {
        $args = new \metastore\ThriftHiveMetastore_partition_name_to_spec_args();
        $args->part_name = $part_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'partition_name_to_spec',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('partition_name_to_spec', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_partition_name_to_spec()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_partition_name_to_spec_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_partition_name_to_spec_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("partition_name_to_spec failed: unknown result");
    }

    public function markPartitionForEvent($db_name, $tbl_name, array $part_vals, $eventType)
    {
        $this->send_markPartitionForEvent($db_name, $tbl_name, $part_vals, $eventType);
        $this->recv_markPartitionForEvent();
    }

    public function send_markPartitionForEvent($db_name, $tbl_name, array $part_vals, $eventType)
    {
        $args = new \metastore\ThriftHiveMetastore_markPartitionForEvent_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->eventType = $eventType;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'markPartitionForEvent',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('markPartitionForEvent', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_markPartitionForEvent()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_markPartitionForEvent_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_markPartitionForEvent_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        if ($result->o5 !== null) {
            throw $result->o5;
        }
        if ($result->o6 !== null) {
            throw $result->o6;
        }
        return;
    }

    public function isPartitionMarkedForEvent($db_name, $tbl_name, array $part_vals, $eventType)
    {
        $this->send_isPartitionMarkedForEvent($db_name, $tbl_name, $part_vals, $eventType);
        return $this->recv_isPartitionMarkedForEvent();
    }

    public function send_isPartitionMarkedForEvent($db_name, $tbl_name, array $part_vals, $eventType)
    {
        $args = new \metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->eventType = $eventType;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'isPartitionMarkedForEvent',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('isPartitionMarkedForEvent', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_isPartitionMarkedForEvent()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        if ($result->o5 !== null) {
            throw $result->o5;
        }
        if ($result->o6 !== null) {
            throw $result->o6;
        }
        throw new \Exception("isPartitionMarkedForEvent failed: unknown result");
    }

    public function add_index(\metastore\Index $new_index, \metastore\Table $index_table)
    {
        $this->send_add_index($new_index, $index_table);
        return $this->recv_add_index();
    }

    public function send_add_index(\metastore\Index $new_index, \metastore\Table $index_table)
    {
        $args = new \metastore\ThriftHiveMetastore_add_index_args();
        $args->new_index = $new_index;
        $args->index_table = $index_table;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_index',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_index', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_index()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_index_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_index_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_index failed: unknown result");
    }

    public function alter_index($dbname, $base_tbl_name, $idx_name, \metastore\Index $new_idx)
    {
        $this->send_alter_index($dbname, $base_tbl_name, $idx_name, $new_idx);
        $this->recv_alter_index();
    }

    public function send_alter_index($dbname, $base_tbl_name, $idx_name, \metastore\Index $new_idx)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_index_args();
        $args->dbname = $dbname;
        $args->base_tbl_name = $base_tbl_name;
        $args->idx_name = $idx_name;
        $args->new_idx = $new_idx;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_index',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_index', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_index()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_index_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_index_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData)
    {
        $this->send_drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData);
        return $this->recv_drop_index_by_name();
    }

    public function send_drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_index_by_name_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->index_name = $index_name;
        $args->deleteData = $deleteData;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_index_by_name',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_index_by_name', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_index_by_name()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_index_by_name_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_index_by_name_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_index_by_name failed: unknown result");
    }

    public function get_index_by_name($db_name, $tbl_name, $index_name)
    {
        $this->send_get_index_by_name($db_name, $tbl_name, $index_name);
        return $this->recv_get_index_by_name();
    }

    public function send_get_index_by_name($db_name, $tbl_name, $index_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_index_by_name_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->index_name = $index_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_index_by_name',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_index_by_name', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_index_by_name()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_index_by_name_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_index_by_name_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_index_by_name failed: unknown result");
    }

    public function get_indexes($db_name, $tbl_name, $max_indexes)
    {
        $this->send_get_indexes($db_name, $tbl_name, $max_indexes);
        return $this->recv_get_indexes();
    }

    public function send_get_indexes($db_name, $tbl_name, $max_indexes)
    {
        $args = new \metastore\ThriftHiveMetastore_get_indexes_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->max_indexes = $max_indexes;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_indexes',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_indexes', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_indexes()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_indexes_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_indexes_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_indexes failed: unknown result");
    }

    public function get_index_names($db_name, $tbl_name, $max_indexes)
    {
        $this->send_get_index_names($db_name, $tbl_name, $max_indexes);
        return $this->recv_get_index_names();
    }

    public function send_get_index_names($db_name, $tbl_name, $max_indexes)
    {
        $args = new \metastore\ThriftHiveMetastore_get_index_names_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->max_indexes = $max_indexes;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_index_names',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_index_names', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_index_names()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_index_names_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_index_names_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_index_names failed: unknown result");
    }

    public function get_primary_keys(\metastore\PrimaryKeysRequest $request)
    {
        $this->send_get_primary_keys($request);
        return $this->recv_get_primary_keys();
    }

    public function send_get_primary_keys(\metastore\PrimaryKeysRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_primary_keys_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_primary_keys',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_primary_keys', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_primary_keys()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_primary_keys_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_primary_keys_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_primary_keys failed: unknown result");
    }

    public function get_foreign_keys(\metastore\ForeignKeysRequest $request)
    {
        $this->send_get_foreign_keys($request);
        return $this->recv_get_foreign_keys();
    }

    public function send_get_foreign_keys(\metastore\ForeignKeysRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_foreign_keys_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_foreign_keys',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_foreign_keys', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_foreign_keys()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_foreign_keys_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_foreign_keys_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_foreign_keys failed: unknown result");
    }

    public function update_table_column_statistics(\metastore\ColumnStatistics $stats_obj)
    {
        $this->send_update_table_column_statistics($stats_obj);
        return $this->recv_update_table_column_statistics();
    }

    public function send_update_table_column_statistics(\metastore\ColumnStatistics $stats_obj)
    {
        $args = new \metastore\ThriftHiveMetastore_update_table_column_statistics_args();
        $args->stats_obj = $stats_obj;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'update_table_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('update_table_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_update_table_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_update_table_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_update_table_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("update_table_column_statistics failed: unknown result");
    }

    public function update_partition_column_statistics(\metastore\ColumnStatistics $stats_obj)
    {
        $this->send_update_partition_column_statistics($stats_obj);
        return $this->recv_update_partition_column_statistics();
    }

    public function send_update_partition_column_statistics(\metastore\ColumnStatistics $stats_obj)
    {
        $args = new \metastore\ThriftHiveMetastore_update_partition_column_statistics_args();
        $args->stats_obj = $stats_obj;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'update_partition_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('update_partition_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_update_partition_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_update_partition_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_update_partition_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("update_partition_column_statistics failed: unknown result");
    }

    public function get_table_column_statistics($db_name, $tbl_name, $col_name)
    {
        $this->send_get_table_column_statistics($db_name, $tbl_name, $col_name);
        return $this->recv_get_table_column_statistics();
    }

    public function send_get_table_column_statistics($db_name, $tbl_name, $col_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_column_statistics_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->col_name = $col_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("get_table_column_statistics failed: unknown result");
    }

    public function get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
    {
        $this->send_get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
        return $this->recv_get_partition_column_statistics();
    }

    public function send_get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_column_statistics_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $args->col_name = $col_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("get_partition_column_statistics failed: unknown result");
    }

    public function get_table_statistics_req(\metastore\TableStatsRequest $request)
    {
        $this->send_get_table_statistics_req($request);
        return $this->recv_get_table_statistics_req();
    }

    public function send_get_table_statistics_req(\metastore\TableStatsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_statistics_req_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_statistics_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_statistics_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_statistics_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_statistics_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_statistics_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_table_statistics_req failed: unknown result");
    }

    public function get_partitions_statistics_req(\metastore\PartitionsStatsRequest $request)
    {
        $this->send_get_partitions_statistics_req($request);
        return $this->recv_get_partitions_statistics_req();
    }

    public function send_get_partitions_statistics_req(\metastore\PartitionsStatsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_statistics_req_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_statistics_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_statistics_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_statistics_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_statistics_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_statistics_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_statistics_req failed: unknown result");
    }

    public function get_aggr_stats_for(\metastore\PartitionsStatsRequest $request)
    {
        $this->send_get_aggr_stats_for($request);
        return $this->recv_get_aggr_stats_for();
    }

    public function send_get_aggr_stats_for(\metastore\PartitionsStatsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_aggr_stats_for_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_aggr_stats_for',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_aggr_stats_for', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_aggr_stats_for()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_aggr_stats_for_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_aggr_stats_for_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_aggr_stats_for failed: unknown result");
    }

    public function set_aggr_stats_for(\metastore\SetPartitionsStatsRequest $request)
    {
        $this->send_set_aggr_stats_for($request);
        return $this->recv_set_aggr_stats_for();
    }

    public function send_set_aggr_stats_for(\metastore\SetPartitionsStatsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_set_aggr_stats_for_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'set_aggr_stats_for',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('set_aggr_stats_for', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_set_aggr_stats_for()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_set_aggr_stats_for_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_set_aggr_stats_for_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("set_aggr_stats_for failed: unknown result");
    }

    public function delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
    {
        $this->send_delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
        return $this->recv_delete_partition_column_statistics();
    }

    public function send_delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
    {
        $args = new \metastore\ThriftHiveMetastore_delete_partition_column_statistics_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $args->col_name = $col_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'delete_partition_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('delete_partition_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_delete_partition_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_delete_partition_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_delete_partition_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("delete_partition_column_statistics failed: unknown result");
    }

    public function delete_table_column_statistics($db_name, $tbl_name, $col_name)
    {
        $this->send_delete_table_column_statistics($db_name, $tbl_name, $col_name);
        return $this->recv_delete_table_column_statistics();
    }

    public function send_delete_table_column_statistics($db_name, $tbl_name, $col_name)
    {
        $args = new \metastore\ThriftHiveMetastore_delete_table_column_statistics_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->col_name = $col_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'delete_table_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('delete_table_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_delete_table_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_delete_table_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_delete_table_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("delete_table_column_statistics failed: unknown result");
    }

    public function create_function(\metastore\Function $func)
    {
        $this->send_create_function($func);
        $this->recv_create_function();
    }

    public function send_create_function(\metastore\Function $func)
    {
        $args = new \metastore\ThriftHiveMetastore_create_function_args();
        $args->func = $func;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_function',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_function', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_function()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_function_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_function_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        return;
    }

    public function drop_function($dbName, $funcName)
    {
        $this->send_drop_function($dbName, $funcName);
        $this->recv_drop_function();
    }

    public function send_drop_function($dbName, $funcName)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_function_args();
        $args->dbName = $dbName;
        $args->funcName = $funcName;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_function',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_function', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_function()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_function_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_function_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function alter_function($dbName, $funcName, \metastore\Function $newFunc)
    {
        $this->send_alter_function($dbName, $funcName, $newFunc);
        $this->recv_alter_function();
    }

    public function send_alter_function($dbName, $funcName, \metastore\Function $newFunc)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_function_args();
        $args->dbName = $dbName;
        $args->funcName = $funcName;
        $args->newFunc = $newFunc;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_function',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_function', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_function()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_function_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_function_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_functions($dbName, $pattern)
    {
        $this->send_get_functions($dbName, $pattern);
        return $this->recv_get_functions();
    }

    public function send_get_functions($dbName, $pattern)
    {
        $args = new \metastore\ThriftHiveMetastore_get_functions_args();
        $args->dbName = $dbName;
        $args->pattern = $pattern;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_functions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_functions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_functions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_functions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_functions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_functions failed: unknown result");
    }

    public function get_function($dbName, $funcName)
    {
        $this->send_get_function($dbName, $funcName);
        return $this->recv_get_function();
    }

    public function send_get_function($dbName, $funcName)
    {
        $args = new \metastore\ThriftHiveMetastore_get_function_args();
        $args->dbName = $dbName;
        $args->funcName = $funcName;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_function',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_function', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_function()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_function_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_function_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_function failed: unknown result");
    }

    public function get_all_functions()
    {
        $this->send_get_all_functions();
        return $this->recv_get_all_functions();
    }

    public function send_get_all_functions()
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_functions_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_functions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_functions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_functions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_functions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_functions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_all_functions failed: unknown result");
    }

    public function create_role(\metastore\Role $role)
    {
        $this->send_create_role($role);
        return $this->recv_create_role();
    }

    public function send_create_role(\metastore\Role $role)
    {
        $args = new \metastore\ThriftHiveMetastore_create_role_args();
        $args->role = $role;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("create_role failed: unknown result");
    }

    public function drop_role($role_name)
    {
        $this->send_drop_role($role_name);
        return $this->recv_drop_role();
    }

    public function send_drop_role($role_name)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_role_args();
        $args->role_name = $role_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("drop_role failed: unknown result");
    }

    public function get_role_names()
    {
        $this->send_get_role_names();
        return $this->recv_get_role_names();
    }

    public function send_get_role_names()
    {
        $args = new \metastore\ThriftHiveMetastore_get_role_names_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_role_names',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_role_names', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_role_names()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_role_names_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_role_names_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_role_names failed: unknown result");
    }

    public function grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option)
    {
        $this->send_grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option);
        return $this->recv_grant_role();
    }

    public function send_grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option)
    {
        $args = new \metastore\ThriftHiveMetastore_grant_role_args();
        $args->role_name = $role_name;
        $args->principal_name = $principal_name;
        $args->principal_type = $principal_type;
        $args->grantor = $grantor;
        $args->grantorType = $grantorType;
        $args->grant_option = $grant_option;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'grant_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('grant_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_grant_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_grant_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_grant_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("grant_role failed: unknown result");
    }

    public function revoke_role($role_name, $principal_name, $principal_type)
    {
        $this->send_revoke_role($role_name, $principal_name, $principal_type);
        return $this->recv_revoke_role();
    }

    public function send_revoke_role($role_name, $principal_name, $principal_type)
    {
        $args = new \metastore\ThriftHiveMetastore_revoke_role_args();
        $args->role_name = $role_name;
        $args->principal_name = $principal_name;
        $args->principal_type = $principal_type;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'revoke_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('revoke_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_revoke_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_revoke_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_revoke_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("revoke_role failed: unknown result");
    }

    public function list_roles($principal_name, $principal_type)
    {
        $this->send_list_roles($principal_name, $principal_type);
        return $this->recv_list_roles();
    }

    public function send_list_roles($principal_name, $principal_type)
    {
        $args = new \metastore\ThriftHiveMetastore_list_roles_args();
        $args->principal_name = $principal_name;
        $args->principal_type = $principal_type;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'list_roles',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('list_roles', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_list_roles()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_list_roles_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_list_roles_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("list_roles failed: unknown result");
    }

    public function grant_revoke_role(\metastore\GrantRevokeRoleRequest $request)
    {
        $this->send_grant_revoke_role($request);
        return $this->recv_grant_revoke_role();
    }

    public function send_grant_revoke_role(\metastore\GrantRevokeRoleRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_grant_revoke_role_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'grant_revoke_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('grant_revoke_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_grant_revoke_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_grant_revoke_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_grant_revoke_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("grant_revoke_role failed: unknown result");
    }

    public function get_principals_in_role(\metastore\GetPrincipalsInRoleRequest $request)
    {
        $this->send_get_principals_in_role($request);
        return $this->recv_get_principals_in_role();
    }

    public function send_get_principals_in_role(\metastore\GetPrincipalsInRoleRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_principals_in_role_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_principals_in_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_principals_in_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_principals_in_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_principals_in_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_principals_in_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_principals_in_role failed: unknown result");
    }

    public function get_role_grants_for_principal(\metastore\GetRoleGrantsForPrincipalRequest $request)
    {
        $this->send_get_role_grants_for_principal($request);
        return $this->recv_get_role_grants_for_principal();
    }

    public function send_get_role_grants_for_principal(\metastore\GetRoleGrantsForPrincipalRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_role_grants_for_principal_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_role_grants_for_principal',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_role_grants_for_principal', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_role_grants_for_principal()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_role_grants_for_principal_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_role_grants_for_principal_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_role_grants_for_principal failed: unknown result");
    }

    public function get_privilege_set(\metastore\HiveObjectRef $hiveObject, $user_name, array $group_names)
    {
        $this->send_get_privilege_set($hiveObject, $user_name, $group_names);
        return $this->recv_get_privilege_set();
    }

    public function send_get_privilege_set(\metastore\HiveObjectRef $hiveObject, $user_name, array $group_names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_privilege_set_args();
        $args->hiveObject = $hiveObject;
        $args->user_name = $user_name;
        $args->group_names = $group_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_privilege_set',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_privilege_set', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_privilege_set()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_privilege_set_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_privilege_set_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_privilege_set failed: unknown result");
    }

    public function list_privileges($principal_name, $principal_type, \metastore\HiveObjectRef $hiveObject)
    {
        $this->send_list_privileges($principal_name, $principal_type, $hiveObject);
        return $this->recv_list_privileges();
    }

    public function send_list_privileges($principal_name, $principal_type, \metastore\HiveObjectRef $hiveObject)
    {
        $args = new \metastore\ThriftHiveMetastore_list_privileges_args();
        $args->principal_name = $principal_name;
        $args->principal_type = $principal_type;
        $args->hiveObject = $hiveObject;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'list_privileges',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('list_privileges', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_list_privileges()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_list_privileges_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_list_privileges_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("list_privileges failed: unknown result");
    }

    public function grant_privileges(\metastore\PrivilegeBag $privileges)
    {
        $this->send_grant_privileges($privileges);
        return $this->recv_grant_privileges();
    }

    public function send_grant_privileges(\metastore\PrivilegeBag $privileges)
    {
        $args = new \metastore\ThriftHiveMetastore_grant_privileges_args();
        $args->privileges = $privileges;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'grant_privileges',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('grant_privileges', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_grant_privileges()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_grant_privileges_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_grant_privileges_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("grant_privileges failed: unknown result");
    }

    public function revoke_privileges(\metastore\PrivilegeBag $privileges)
    {
        $this->send_revoke_privileges($privileges);
        return $this->recv_revoke_privileges();
    }

    public function send_revoke_privileges(\metastore\PrivilegeBag $privileges)
    {
        $args = new \metastore\ThriftHiveMetastore_revoke_privileges_args();
        $args->privileges = $privileges;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'revoke_privileges',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('revoke_privileges', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_revoke_privileges()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_revoke_privileges_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_revoke_privileges_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("revoke_privileges failed: unknown result");
    }

    public function grant_revoke_privileges(\metastore\GrantRevokePrivilegeRequest $request)
    {
        $this->send_grant_revoke_privileges($request);
        return $this->recv_grant_revoke_privileges();
    }

    public function send_grant_revoke_privileges(\metastore\GrantRevokePrivilegeRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_grant_revoke_privileges_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'grant_revoke_privileges',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('grant_revoke_privileges', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_grant_revoke_privileges()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_grant_revoke_privileges_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_grant_revoke_privileges_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("grant_revoke_privileges failed: unknown result");
    }

    public function set_ugi($user_name, array $group_names)
    {
        $this->send_set_ugi($user_name, $group_names);
        return $this->recv_set_ugi();
    }

    public function send_set_ugi($user_name, array $group_names)
    {
        $args = new \metastore\ThriftHiveMetastore_set_ugi_args();
        $args->user_name = $user_name;
        $args->group_names = $group_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'set_ugi',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('set_ugi', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_set_ugi()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_set_ugi_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_set_ugi_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("set_ugi failed: unknown result");
    }

    public function get_delegation_token($token_owner, $renewer_kerberos_principal_name)
    {
        $this->send_get_delegation_token($token_owner, $renewer_kerberos_principal_name);
        return $this->recv_get_delegation_token();
    }

    public function send_get_delegation_token($token_owner, $renewer_kerberos_principal_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_delegation_token_args();
        $args->token_owner = $token_owner;
        $args->renewer_kerberos_principal_name = $renewer_kerberos_principal_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_delegation_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_delegation_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_delegation_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_delegation_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_delegation_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_delegation_token failed: unknown result");
    }

    public function renew_delegation_token($token_str_form)
    {
        $this->send_renew_delegation_token($token_str_form);
        return $this->recv_renew_delegation_token();
    }

    public function send_renew_delegation_token($token_str_form)
    {
        $args = new \metastore\ThriftHiveMetastore_renew_delegation_token_args();
        $args->token_str_form = $token_str_form;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'renew_delegation_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('renew_delegation_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_renew_delegation_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_renew_delegation_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_renew_delegation_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("renew_delegation_token failed: unknown result");
    }

    public function cancel_delegation_token($token_str_form)
    {
        $this->send_cancel_delegation_token($token_str_form);
        $this->recv_cancel_delegation_token();
    }

    public function send_cancel_delegation_token($token_str_form)
    {
        $args = new \metastore\ThriftHiveMetastore_cancel_delegation_token_args();
        $args->token_str_form = $token_str_form;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'cancel_delegation_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('cancel_delegation_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_cancel_delegation_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_cancel_delegation_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_cancel_delegation_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function add_token($token_identifier, $delegation_token)
    {
        $this->send_add_token($token_identifier, $delegation_token);
        return $this->recv_add_token();
    }

    public function send_add_token($token_identifier, $delegation_token)
    {
        $args = new \metastore\ThriftHiveMetastore_add_token_args();
        $args->token_identifier = $token_identifier;
        $args->delegation_token = $delegation_token;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("add_token failed: unknown result");
    }

    public function remove_token($token_identifier)
    {
        $this->send_remove_token($token_identifier);
        return $this->recv_remove_token();
    }

    public function send_remove_token($token_identifier)
    {
        $args = new \metastore\ThriftHiveMetastore_remove_token_args();
        $args->token_identifier = $token_identifier;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'remove_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('remove_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_remove_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_remove_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_remove_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("remove_token failed: unknown result");
    }

    public function get_token($token_identifier)
    {
        $this->send_get_token($token_identifier);
        return $this->recv_get_token();
    }

    public function send_get_token($token_identifier)
    {
        $args = new \metastore\ThriftHiveMetastore_get_token_args();
        $args->token_identifier = $token_identifier;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_token failed: unknown result");
    }

    public function get_all_token_identifiers()
    {
        $this->send_get_all_token_identifiers();
        return $this->recv_get_all_token_identifiers();
    }

    public function send_get_all_token_identifiers()
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_token_identifiers_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_token_identifiers',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_token_identifiers', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_token_identifiers()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_token_identifiers_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_token_identifiers_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_all_token_identifiers failed: unknown result");
    }

    public function add_master_key($key)
    {
        $this->send_add_master_key($key);
        return $this->recv_add_master_key();
    }

    public function send_add_master_key($key)
    {
        $args = new \metastore\ThriftHiveMetastore_add_master_key_args();
        $args->key = $key;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_master_key',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_master_key', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_master_key()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_master_key_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_master_key_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("add_master_key failed: unknown result");
    }

    public function update_master_key($seq_number, $key)
    {
        $this->send_update_master_key($seq_number, $key);
        $this->recv_update_master_key();
    }

    public function send_update_master_key($seq_number, $key)
    {
        $args = new \metastore\ThriftHiveMetastore_update_master_key_args();
        $args->seq_number = $seq_number;
        $args->key = $key;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'update_master_key',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('update_master_key', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_update_master_key()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_update_master_key_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_update_master_key_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function remove_master_key($key_seq)
    {
        $this->send_remove_master_key($key_seq);
        return $this->recv_remove_master_key();
    }

    public function send_remove_master_key($key_seq)
    {
        $args = new \metastore\ThriftHiveMetastore_remove_master_key_args();
        $args->key_seq = $key_seq;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'remove_master_key',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('remove_master_key', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_remove_master_key()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_remove_master_key_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_remove_master_key_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("remove_master_key failed: unknown result");
    }

    public function get_master_keys()
    {
        $this->send_get_master_keys();
        return $this->recv_get_master_keys();
    }

    public function send_get_master_keys()
    {
        $args = new \metastore\ThriftHiveMetastore_get_master_keys_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_master_keys',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_master_keys', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_master_keys()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_master_keys_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_master_keys_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_master_keys failed: unknown result");
    }

    public function get_open_txns()
    {
        $this->send_get_open_txns();
        return $this->recv_get_open_txns();
    }

    public function send_get_open_txns()
    {
        $args = new \metastore\ThriftHiveMetastore_get_open_txns_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_open_txns',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_open_txns', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_open_txns()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_open_txns_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_open_txns_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_open_txns failed: unknown result");
    }

    public function get_open_txns_info()
    {
        $this->send_get_open_txns_info();
        return $this->recv_get_open_txns_info();
    }

    public function send_get_open_txns_info()
    {
        $args = new \metastore\ThriftHiveMetastore_get_open_txns_info_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_open_txns_info',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_open_txns_info', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_open_txns_info()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_open_txns_info_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_open_txns_info_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_open_txns_info failed: unknown result");
    }

    public function open_txns(\metastore\OpenTxnRequest $rqst)
    {
        $this->send_open_txns($rqst);
        return $this->recv_open_txns();
    }

    public function send_open_txns(\metastore\OpenTxnRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_open_txns_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'open_txns',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('open_txns', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_open_txns()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_open_txns_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_open_txns_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("open_txns failed: unknown result");
    }

    public function abort_txn(\metastore\AbortTxnRequest $rqst)
    {
        $this->send_abort_txn($rqst);
        $this->recv_abort_txn();
    }

    public function send_abort_txn(\metastore\AbortTxnRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_abort_txn_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'abort_txn',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('abort_txn', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_abort_txn()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_abort_txn_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_abort_txn_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function abort_txns(\metastore\AbortTxnsRequest $rqst)
    {
        $this->send_abort_txns($rqst);
        $this->recv_abort_txns();
    }

    public function send_abort_txns(\metastore\AbortTxnsRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_abort_txns_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'abort_txns',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('abort_txns', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_abort_txns()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_abort_txns_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_abort_txns_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function commit_txn(\metastore\CommitTxnRequest $rqst)
    {
        $this->send_commit_txn($rqst);
        $this->recv_commit_txn();
    }

    public function send_commit_txn(\metastore\CommitTxnRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_commit_txn_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'commit_txn',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('commit_txn', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_commit_txn()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_commit_txn_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_commit_txn_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function lock(\metastore\LockRequest $rqst)
    {
        $this->send_lock($rqst);
        return $this->recv_lock();
    }

    public function send_lock(\metastore\LockRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_lock_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'lock',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('lock', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_lock()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_lock_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_lock_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("lock failed: unknown result");
    }

    public function check_lock(\metastore\CheckLockRequest $rqst)
    {
        $this->send_check_lock($rqst);
        return $this->recv_check_lock();
    }

    public function send_check_lock(\metastore\CheckLockRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_check_lock_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'check_lock',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('check_lock', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_check_lock()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_check_lock_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_check_lock_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("check_lock failed: unknown result");
    }

    public function unlock(\metastore\UnlockRequest $rqst)
    {
        $this->send_unlock($rqst);
        $this->recv_unlock();
    }

    public function send_unlock(\metastore\UnlockRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_unlock_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'unlock',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('unlock', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_unlock()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_unlock_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_unlock_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function show_locks(\metastore\ShowLocksRequest $rqst)
    {
        $this->send_show_locks($rqst);
        return $this->recv_show_locks();
    }

    public function send_show_locks(\metastore\ShowLocksRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_show_locks_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'show_locks',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('show_locks', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_show_locks()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_show_locks_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_show_locks_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("show_locks failed: unknown result");
    }

    public function heartbeat(\metastore\HeartbeatRequest $ids)
    {
        $this->send_heartbeat($ids);
        $this->recv_heartbeat();
    }

    public function send_heartbeat(\metastore\HeartbeatRequest $ids)
    {
        $args = new \metastore\ThriftHiveMetastore_heartbeat_args();
        $args->ids = $ids;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'heartbeat',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('heartbeat', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_heartbeat()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_heartbeat_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_heartbeat_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function heartbeat_txn_range(\metastore\HeartbeatTxnRangeRequest $txns)
    {
        $this->send_heartbeat_txn_range($txns);
        return $this->recv_heartbeat_txn_range();
    }

    public function send_heartbeat_txn_range(\metastore\HeartbeatTxnRangeRequest $txns)
    {
        $args = new \metastore\ThriftHiveMetastore_heartbeat_txn_range_args();
        $args->txns = $txns;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'heartbeat_txn_range',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('heartbeat_txn_range', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_heartbeat_txn_range()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_heartbeat_txn_range_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_heartbeat_txn_range_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("heartbeat_txn_range failed: unknown result");
    }

    public function compact(\metastore\CompactionRequest $rqst)
    {
        $this->send_compact($rqst);
        $this->recv_compact();
    }

    public function send_compact(\metastore\CompactionRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_compact_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'compact',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('compact', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_compact()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_compact_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_compact_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        return;
    }

    public function compact2(\metastore\CompactionRequest $rqst)
    {
        $this->send_compact2($rqst);
        return $this->recv_compact2();
    }

    public function send_compact2(\metastore\CompactionRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_compact2_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'compact2',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('compact2', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_compact2()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_compact2_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_compact2_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("compact2 failed: unknown result");
    }

    public function show_compact(\metastore\ShowCompactRequest $rqst)
    {
        $this->send_show_compact($rqst);
        return $this->recv_show_compact();
    }

    public function send_show_compact(\metastore\ShowCompactRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_show_compact_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'show_compact',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('show_compact', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_show_compact()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_show_compact_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_show_compact_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("show_compact failed: unknown result");
    }

    public function add_dynamic_partitions(\metastore\AddDynamicPartitions $rqst)
    {
        $this->send_add_dynamic_partitions($rqst);
        $this->recv_add_dynamic_partitions();
    }

    public function send_add_dynamic_partitions(\metastore\AddDynamicPartitions $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_add_dynamic_partitions_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_dynamic_partitions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_dynamic_partitions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_dynamic_partitions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_dynamic_partitions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_dynamic_partitions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_next_notification(\metastore\NotificationEventRequest $rqst)
    {
        $this->send_get_next_notification($rqst);
        return $this->recv_get_next_notification();
    }

    public function send_get_next_notification(\metastore\NotificationEventRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_get_next_notification_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_next_notification',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_next_notification', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_next_notification()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_next_notification_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_next_notification_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_next_notification failed: unknown result");
    }

    public function get_current_notificationEventId()
    {
        $this->send_get_current_notificationEventId();
        return $this->recv_get_current_notificationEventId();
    }

    public function send_get_current_notificationEventId()
    {
        $args = new \metastore\ThriftHiveMetastore_get_current_notificationEventId_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_current_notificationEventId',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_current_notificationEventId', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_current_notificationEventId()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_current_notificationEventId_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_current_notificationEventId_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_current_notificationEventId failed: unknown result");
    }

    public function fire_listener_event(\metastore\FireEventRequest $rqst)
    {
        $this->send_fire_listener_event($rqst);
        return $this->recv_fire_listener_event();
    }

    public function send_fire_listener_event(\metastore\FireEventRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_fire_listener_event_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'fire_listener_event',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('fire_listener_event', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_fire_listener_event()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_fire_listener_event_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_fire_listener_event_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("fire_listener_event failed: unknown result");
    }

    public function flushCache()
    {
        $this->send_flushCache();
        $this->recv_flushCache();
    }

    public function send_flushCache()
    {
        $args = new \metastore\ThriftHiveMetastore_flushCache_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'flushCache',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('flushCache', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_flushCache()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_flushCache_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_flushCache_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        return;
    }

    public function get_file_metadata_by_expr(\metastore\GetFileMetadataByExprRequest $req)
    {
        $this->send_get_file_metadata_by_expr($req);
        return $this->recv_get_file_metadata_by_expr();
    }

    public function send_get_file_metadata_by_expr(\metastore\GetFileMetadataByExprRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_file_metadata_by_expr_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_file_metadata_by_expr',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_file_metadata_by_expr', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_file_metadata_by_expr()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_file_metadata_by_expr_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_file_metadata_by_expr_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_file_metadata_by_expr failed: unknown result");
    }

    public function get_file_metadata(\metastore\GetFileMetadataRequest $req)
    {
        $this->send_get_file_metadata($req);
        return $this->recv_get_file_metadata();
    }

    public function send_get_file_metadata(\metastore\GetFileMetadataRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_file_metadata_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_file_metadata',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_file_metadata', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_file_metadata()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_file_metadata_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_file_metadata_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_file_metadata failed: unknown result");
    }

    public function put_file_metadata(\metastore\PutFileMetadataRequest $req)
    {
        $this->send_put_file_metadata($req);
        return $this->recv_put_file_metadata();
    }

    public function send_put_file_metadata(\metastore\PutFileMetadataRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_put_file_metadata_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'put_file_metadata',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('put_file_metadata', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_put_file_metadata()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_put_file_metadata_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_put_file_metadata_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("put_file_metadata failed: unknown result");
    }

    public function clear_file_metadata(\metastore\ClearFileMetadataRequest $req)
    {
        $this->send_clear_file_metadata($req);
        return $this->recv_clear_file_metadata();
    }

    public function send_clear_file_metadata(\metastore\ClearFileMetadataRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_clear_file_metadata_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'clear_file_metadata',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('clear_file_metadata', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_clear_file_metadata()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_clear_file_metadata_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_clear_file_metadata_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("clear_file_metadata failed: unknown result");
    }

    public function cache_file_metadata(\metastore\CacheFileMetadataRequest $req)
    {
        $this->send_cache_file_metadata($req);
        return $this->recv_cache_file_metadata();
    }

    public function send_cache_file_metadata(\metastore\CacheFileMetadataRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_cache_file_metadata_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'cache_file_metadata',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('cache_file_metadata', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_cache_file_metadata()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_cache_file_metadata_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_cache_file_metadata_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("cache_file_metadata failed: unknown result");
    }
}
