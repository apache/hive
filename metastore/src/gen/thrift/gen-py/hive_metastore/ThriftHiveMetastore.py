#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import fb303.FacebookService
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(fb303.FacebookService.Iface):
  """
  This interface is live.
  """
  def getMetaConf(self, key):
    """
    Parameters:
     - key
    """
    pass

  def setMetaConf(self, key, value):
    """
    Parameters:
     - key
     - value
    """
    pass

  def create_database(self, database):
    """
    Parameters:
     - database
    """
    pass

  def get_database(self, name):
    """
    Parameters:
     - name
    """
    pass

  def drop_database(self, name, deleteData, cascade):
    """
    Parameters:
     - name
     - deleteData
     - cascade
    """
    pass

  def get_databases(self, pattern):
    """
    Parameters:
     - pattern
    """
    pass

  def get_all_databases(self):
    pass

  def alter_database(self, dbname, db):
    """
    Parameters:
     - dbname
     - db
    """
    pass

  def get_type(self, name):
    """
    Parameters:
     - name
    """
    pass

  def create_type(self, type):
    """
    Parameters:
     - type
    """
    pass

  def drop_type(self, type):
    """
    Parameters:
     - type
    """
    pass

  def get_type_all(self, name):
    """
    Parameters:
     - name
    """
    pass

  def get_fields(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    pass

  def get_fields_with_environment_context(self, db_name, table_name, environment_context):
    """
    Parameters:
     - db_name
     - table_name
     - environment_context
    """
    pass

  def get_schema(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    pass

  def get_schema_with_environment_context(self, db_name, table_name, environment_context):
    """
    Parameters:
     - db_name
     - table_name
     - environment_context
    """
    pass

  def create_table(self, tbl):
    """
    Parameters:
     - tbl
    """
    pass

  def create_table_with_environment_context(self, tbl, environment_context):
    """
    Parameters:
     - tbl
     - environment_context
    """
    pass

  def drop_table(self, dbname, name, deleteData):
    """
    Parameters:
     - dbname
     - name
     - deleteData
    """
    pass

  def drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
    """
    Parameters:
     - dbname
     - name
     - deleteData
     - environment_context
    """
    pass

  def get_tables(self, db_name, pattern):
    """
    Parameters:
     - db_name
     - pattern
    """
    pass

  def get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
    """
    Parameters:
     - db_patterns
     - tbl_patterns
     - tbl_types
    """
    pass

  def get_all_tables(self, db_name):
    """
    Parameters:
     - db_name
    """
    pass

  def get_table(self, dbname, tbl_name):
    """
    Parameters:
     - dbname
     - tbl_name
    """
    pass

  def get_table_objects_by_name(self, dbname, tbl_names):
    """
    Parameters:
     - dbname
     - tbl_names
    """
    pass

  def get_table_names_by_filter(self, dbname, filter, max_tables):
    """
    Parameters:
     - dbname
     - filter
     - max_tables
    """
    pass

  def alter_table(self, dbname, tbl_name, new_tbl):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
    """
    pass

  def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
     - environment_context
    """
    pass

  def alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
     - cascade
    """
    pass

  def add_partition(self, new_part):
    """
    Parameters:
     - new_part
    """
    pass

  def add_partition_with_environment_context(self, new_part, environment_context):
    """
    Parameters:
     - new_part
     - environment_context
    """
    pass

  def add_partitions(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    pass

  def add_partitions_pspec(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    pass

  def append_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    pass

  def add_partitions_req(self, request):
    """
    Parameters:
     - request
    """
    pass

  def append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - environment_context
    """
    pass

  def append_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    pass

  def append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - environment_context
    """
    pass

  def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """
    pass

  def drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
     - environment_context
    """
    pass

  def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """
    pass

  def drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
     - environment_context
    """
    pass

  def drop_partitions_req(self, req):
    """
    Parameters:
     - req
    """
    pass

  def get_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    pass

  def exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    """
    Parameters:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name
    """
    pass

  def exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    """
    Parameters:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name
    """
    pass

  def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names
    """
    pass

  def get_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    pass

  def get_partitions(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names
    """
    pass

  def get_partitions_pspec(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partition_names(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    pass

  def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names
    """
    pass

  def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    pass

  def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    pass

  def get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    pass

  def get_partitions_by_expr(self, req):
    """
    Parameters:
     - req
    """
    pass

  def get_partitions_by_names(self, db_name, tbl_name, names):
    """
    Parameters:
     - db_name
     - tbl_name
     - names
    """
    pass

  def alter_partition(self, db_name, tbl_name, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
    """
    pass

  def alter_partitions(self, db_name, tbl_name, new_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_parts
    """
    pass

  def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
     - environment_context
    """
    pass

  def rename_partition(self, db_name, tbl_name, part_vals, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - new_part
    """
    pass

  def partition_name_has_valid_characters(self, part_vals, throw_exception):
    """
    Parameters:
     - part_vals
     - throw_exception
    """
    pass

  def get_config_value(self, name, defaultValue):
    """
    Parameters:
     - name
     - defaultValue
    """
    pass

  def partition_name_to_vals(self, part_name):
    """
    Parameters:
     - part_name
    """
    pass

  def partition_name_to_spec(self, part_name):
    """
    Parameters:
     - part_name
    """
    pass

  def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    pass

  def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    pass

  def add_index(self, new_index, index_table):
    """
    Parameters:
     - new_index
     - index_table
    """
    pass

  def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    """
    Parameters:
     - dbname
     - base_tbl_name
     - idx_name
     - new_idx
    """
    pass

  def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """
    pass

  def get_index_by_name(self, db_name, tbl_name, index_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
    """
    pass

  def get_indexes(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass

  def get_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass

  def update_table_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    pass

  def update_partition_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    pass

  def get_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    pass

  def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    pass

  def get_table_statistics_req(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_partitions_statistics_req(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_aggr_stats_for(self, request):
    """
    Parameters:
     - request
    """
    pass

  def set_aggr_stats_for(self, request):
    """
    Parameters:
     - request
    """
    pass

  def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    pass

  def delete_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    pass

  def create_function(self, func):
    """
    Parameters:
     - func
    """
    pass

  def drop_function(self, dbName, funcName):
    """
    Parameters:
     - dbName
     - funcName
    """
    pass

  def alter_function(self, dbName, funcName, newFunc):
    """
    Parameters:
     - dbName
     - funcName
     - newFunc
    """
    pass

  def get_functions(self, dbName, pattern):
    """
    Parameters:
     - dbName
     - pattern
    """
    pass

  def get_function(self, dbName, funcName):
    """
    Parameters:
     - dbName
     - funcName
    """
    pass

  def get_all_functions(self):
    pass

  def create_role(self, role):
    """
    Parameters:
     - role
    """
    pass

  def drop_role(self, role_name):
    """
    Parameters:
     - role_name
    """
    pass

  def get_role_names(self):
    pass

  def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option
    """
    pass

  def revoke_role(self, role_name, principal_name, principal_type):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
    """
    pass

  def list_roles(self, principal_name, principal_type):
    """
    Parameters:
     - principal_name
     - principal_type
    """
    pass

  def grant_revoke_role(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_principals_in_role(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_role_grants_for_principal(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_privilege_set(self, hiveObject, user_name, group_names):
    """
    Parameters:
     - hiveObject
     - user_name
     - group_names
    """
    pass

  def list_privileges(self, principal_name, principal_type, hiveObject):
    """
    Parameters:
     - principal_name
     - principal_type
     - hiveObject
    """
    pass

  def grant_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    pass

  def revoke_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    pass

  def grant_revoke_privileges(self, request):
    """
    Parameters:
     - request
    """
    pass

  def set_ugi(self, user_name, group_names):
    """
    Parameters:
     - user_name
     - group_names
    """
    pass

  def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    """
    Parameters:
     - token_owner
     - renewer_kerberos_principal_name
    """
    pass

  def renew_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    pass

  def cancel_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    pass

  def get_open_txns(self):
    pass

  def get_open_txns_info(self):
    pass

  def open_txns(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def abort_txn(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def commit_txn(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def lock(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def check_lock(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def unlock(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def show_locks(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def heartbeat(self, ids):
    """
    Parameters:
     - ids
    """
    pass

  def heartbeat_txn_range(self, txns):
    """
    Parameters:
     - txns
    """
    pass

  def compact(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def show_compact(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def add_dynamic_partitions(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def get_next_notification(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def get_current_notificationEventId(self):
    pass

  def fire_listener_event(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def flushCache(self):
    pass

  def get_file_metadata_by_expr(self, req):
    """
    Parameters:
     - req
    """
    pass

  def get_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    pass

  def put_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    pass

  def clear_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    pass


class Client(fb303.FacebookService.Client, Iface):
  """
  This interface is live.
  """
  def __init__(self, iprot, oprot=None):
    fb303.FacebookService.Client.__init__(self, iprot, oprot)

  def getMetaConf(self, key):
    """
    Parameters:
     - key
    """
    self.send_getMetaConf(key)
    return self.recv_getMetaConf()

  def send_getMetaConf(self, key):
    self._oprot.writeMessageBegin('getMetaConf', TMessageType.CALL, self._seqid)
    args = getMetaConf_args()
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMetaConf(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getMetaConf_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMetaConf failed: unknown result")

  def setMetaConf(self, key, value):
    """
    Parameters:
     - key
     - value
    """
    self.send_setMetaConf(key, value)
    self.recv_setMetaConf()

  def send_setMetaConf(self, key, value):
    self._oprot.writeMessageBegin('setMetaConf', TMessageType.CALL, self._seqid)
    args = setMetaConf_args()
    args.key = key
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setMetaConf(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setMetaConf_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def create_database(self, database):
    """
    Parameters:
     - database
    """
    self.send_create_database(database)
    self.recv_create_database()

  def send_create_database(self, database):
    self._oprot.writeMessageBegin('create_database', TMessageType.CALL, self._seqid)
    args = create_database_args()
    args.database = database
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_database(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_database_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def get_database(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_database(name)
    return self.recv_get_database()

  def send_get_database(self, name):
    self._oprot.writeMessageBegin('get_database', TMessageType.CALL, self._seqid)
    args = get_database_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_database(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_database_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_database failed: unknown result")

  def drop_database(self, name, deleteData, cascade):
    """
    Parameters:
     - name
     - deleteData
     - cascade
    """
    self.send_drop_database(name, deleteData, cascade)
    self.recv_drop_database()

  def send_drop_database(self, name, deleteData, cascade):
    self._oprot.writeMessageBegin('drop_database', TMessageType.CALL, self._seqid)
    args = drop_database_args()
    args.name = name
    args.deleteData = deleteData
    args.cascade = cascade
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_database(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_database_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def get_databases(self, pattern):
    """
    Parameters:
     - pattern
    """
    self.send_get_databases(pattern)
    return self.recv_get_databases()

  def send_get_databases(self, pattern):
    self._oprot.writeMessageBegin('get_databases', TMessageType.CALL, self._seqid)
    args = get_databases_args()
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_databases(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_databases_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_databases failed: unknown result")

  def get_all_databases(self):
    self.send_get_all_databases()
    return self.recv_get_all_databases()

  def send_get_all_databases(self):
    self._oprot.writeMessageBegin('get_all_databases', TMessageType.CALL, self._seqid)
    args = get_all_databases_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_databases(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_databases_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_databases failed: unknown result")

  def alter_database(self, dbname, db):
    """
    Parameters:
     - dbname
     - db
    """
    self.send_alter_database(dbname, db)
    self.recv_alter_database()

  def send_alter_database(self, dbname, db):
    self._oprot.writeMessageBegin('alter_database', TMessageType.CALL, self._seqid)
    args = alter_database_args()
    args.dbname = dbname
    args.db = db
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_database(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_database_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def get_type(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_type(name)
    return self.recv_get_type()

  def send_get_type(self, name):
    self._oprot.writeMessageBegin('get_type', TMessageType.CALL, self._seqid)
    args = get_type_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_type(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_type_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type failed: unknown result")

  def create_type(self, type):
    """
    Parameters:
     - type
    """
    self.send_create_type(type)
    return self.recv_create_type()

  def send_create_type(self, type):
    self._oprot.writeMessageBegin('create_type', TMessageType.CALL, self._seqid)
    args = create_type_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_type(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_type_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_type failed: unknown result")

  def drop_type(self, type):
    """
    Parameters:
     - type
    """
    self.send_drop_type(type)
    return self.recv_drop_type()

  def send_drop_type(self, type):
    self._oprot.writeMessageBegin('drop_type', TMessageType.CALL, self._seqid)
    args = drop_type_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_type(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_type_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_type failed: unknown result")

  def get_type_all(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_type_all(name)
    return self.recv_get_type_all()

  def send_get_type_all(self, name):
    self._oprot.writeMessageBegin('get_type_all', TMessageType.CALL, self._seqid)
    args = get_type_all_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_type_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_type_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type_all failed: unknown result")

  def get_fields(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    self.send_get_fields(db_name, table_name)
    return self.recv_get_fields()

  def send_get_fields(self, db_name, table_name):
    self._oprot.writeMessageBegin('get_fields', TMessageType.CALL, self._seqid)
    args = get_fields_args()
    args.db_name = db_name
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_fields(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_fields_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields failed: unknown result")

  def get_fields_with_environment_context(self, db_name, table_name, environment_context):
    """
    Parameters:
     - db_name
     - table_name
     - environment_context
    """
    self.send_get_fields_with_environment_context(db_name, table_name, environment_context)
    return self.recv_get_fields_with_environment_context()

  def send_get_fields_with_environment_context(self, db_name, table_name, environment_context):
    self._oprot.writeMessageBegin('get_fields_with_environment_context', TMessageType.CALL, self._seqid)
    args = get_fields_with_environment_context_args()
    args.db_name = db_name
    args.table_name = table_name
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_fields_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_fields_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields_with_environment_context failed: unknown result")

  def get_schema(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    self.send_get_schema(db_name, table_name)
    return self.recv_get_schema()

  def send_get_schema(self, db_name, table_name):
    self._oprot.writeMessageBegin('get_schema', TMessageType.CALL, self._seqid)
    args = get_schema_args()
    args.db_name = db_name
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_schema(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_schema_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result")

  def get_schema_with_environment_context(self, db_name, table_name, environment_context):
    """
    Parameters:
     - db_name
     - table_name
     - environment_context
    """
    self.send_get_schema_with_environment_context(db_name, table_name, environment_context)
    return self.recv_get_schema_with_environment_context()

  def send_get_schema_with_environment_context(self, db_name, table_name, environment_context):
    self._oprot.writeMessageBegin('get_schema_with_environment_context', TMessageType.CALL, self._seqid)
    args = get_schema_with_environment_context_args()
    args.db_name = db_name
    args.table_name = table_name
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_schema_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_schema_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_with_environment_context failed: unknown result")

  def create_table(self, tbl):
    """
    Parameters:
     - tbl
    """
    self.send_create_table(tbl)
    self.recv_create_table()

  def send_create_table(self, tbl):
    self._oprot.writeMessageBegin('create_table', TMessageType.CALL, self._seqid)
    args = create_table_args()
    args.tbl = tbl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_table_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def create_table_with_environment_context(self, tbl, environment_context):
    """
    Parameters:
     - tbl
     - environment_context
    """
    self.send_create_table_with_environment_context(tbl, environment_context)
    self.recv_create_table_with_environment_context()

  def send_create_table_with_environment_context(self, tbl, environment_context):
    self._oprot.writeMessageBegin('create_table_with_environment_context', TMessageType.CALL, self._seqid)
    args = create_table_with_environment_context_args()
    args.tbl = tbl
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_table_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def drop_table(self, dbname, name, deleteData):
    """
    Parameters:
     - dbname
     - name
     - deleteData
    """
    self.send_drop_table(dbname, name, deleteData)
    self.recv_drop_table()

  def send_drop_table(self, dbname, name, deleteData):
    self._oprot.writeMessageBegin('drop_table', TMessageType.CALL, self._seqid)
    args = drop_table_args()
    args.dbname = dbname
    args.name = name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_table(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_table_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o3 is not None:
      raise result.o3
    return

  def drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
    """
    Parameters:
     - dbname
     - name
     - deleteData
     - environment_context
    """
    self.send_drop_table_with_environment_context(dbname, name, deleteData, environment_context)
    self.recv_drop_table_with_environment_context()

  def send_drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
    self._oprot.writeMessageBegin('drop_table_with_environment_context', TMessageType.CALL, self._seqid)
    args = drop_table_with_environment_context_args()
    args.dbname = dbname
    args.name = name
    args.deleteData = deleteData
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_table_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_table_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o3 is not None:
      raise result.o3
    return

  def get_tables(self, db_name, pattern):
    """
    Parameters:
     - db_name
     - pattern
    """
    self.send_get_tables(db_name, pattern)
    return self.recv_get_tables()

  def send_get_tables(self, db_name, pattern):
    self._oprot.writeMessageBegin('get_tables', TMessageType.CALL, self._seqid)
    args = get_tables_args()
    args.db_name = db_name
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_tables(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_tables_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result")

  def get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
    """
    Parameters:
     - db_patterns
     - tbl_patterns
     - tbl_types
    """
    self.send_get_table_meta(db_patterns, tbl_patterns, tbl_types)
    return self.recv_get_table_meta()

  def send_get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
    self._oprot.writeMessageBegin('get_table_meta', TMessageType.CALL, self._seqid)
    args = get_table_meta_args()
    args.db_patterns = db_patterns
    args.tbl_patterns = tbl_patterns
    args.tbl_types = tbl_types
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_meta(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_meta_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_meta failed: unknown result")

  def get_all_tables(self, db_name):
    """
    Parameters:
     - db_name
    """
    self.send_get_all_tables(db_name)
    return self.recv_get_all_tables()

  def send_get_all_tables(self, db_name):
    self._oprot.writeMessageBegin('get_all_tables', TMessageType.CALL, self._seqid)
    args = get_all_tables_args()
    args.db_name = db_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_tables(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_tables_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_tables failed: unknown result")

  def get_table(self, dbname, tbl_name):
    """
    Parameters:
     - dbname
     - tbl_name
    """
    self.send_get_table(dbname, tbl_name)
    return self.recv_get_table()

  def send_get_table(self, dbname, tbl_name):
    self._oprot.writeMessageBegin('get_table', TMessageType.CALL, self._seqid)
    args = get_table_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table failed: unknown result")

  def get_table_objects_by_name(self, dbname, tbl_names):
    """
    Parameters:
     - dbname
     - tbl_names
    """
    self.send_get_table_objects_by_name(dbname, tbl_names)
    return self.recv_get_table_objects_by_name()

  def send_get_table_objects_by_name(self, dbname, tbl_names):
    self._oprot.writeMessageBegin('get_table_objects_by_name', TMessageType.CALL, self._seqid)
    args = get_table_objects_by_name_args()
    args.dbname = dbname
    args.tbl_names = tbl_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_objects_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_objects_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_objects_by_name failed: unknown result")

  def get_table_names_by_filter(self, dbname, filter, max_tables):
    """
    Parameters:
     - dbname
     - filter
     - max_tables
    """
    self.send_get_table_names_by_filter(dbname, filter, max_tables)
    return self.recv_get_table_names_by_filter()

  def send_get_table_names_by_filter(self, dbname, filter, max_tables):
    self._oprot.writeMessageBegin('get_table_names_by_filter', TMessageType.CALL, self._seqid)
    args = get_table_names_by_filter_args()
    args.dbname = dbname
    args.filter = filter
    args.max_tables = max_tables
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_names_by_filter(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_names_by_filter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_names_by_filter failed: unknown result")

  def alter_table(self, dbname, tbl_name, new_tbl):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
    """
    self.send_alter_table(dbname, tbl_name, new_tbl)
    self.recv_alter_table()

  def send_alter_table(self, dbname, tbl_name, new_tbl):
    self._oprot.writeMessageBegin('alter_table', TMessageType.CALL, self._seqid)
    args = alter_table_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.new_tbl = new_tbl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_table_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
     - environment_context
    """
    self.send_alter_table_with_environment_context(dbname, tbl_name, new_tbl, environment_context)
    self.recv_alter_table_with_environment_context()

  def send_alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
    self._oprot.writeMessageBegin('alter_table_with_environment_context', TMessageType.CALL, self._seqid)
    args = alter_table_with_environment_context_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.new_tbl = new_tbl
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_table_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
     - cascade
    """
    self.send_alter_table_with_cascade(dbname, tbl_name, new_tbl, cascade)
    self.recv_alter_table_with_cascade()

  def send_alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
    self._oprot.writeMessageBegin('alter_table_with_cascade', TMessageType.CALL, self._seqid)
    args = alter_table_with_cascade_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.new_tbl = new_tbl
    args.cascade = cascade
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table_with_cascade(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_table_with_cascade_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def add_partition(self, new_part):
    """
    Parameters:
     - new_part
    """
    self.send_add_partition(new_part)
    return self.recv_add_partition()

  def send_add_partition(self, new_part):
    self._oprot.writeMessageBegin('add_partition', TMessageType.CALL, self._seqid)
    args = add_partition_args()
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition failed: unknown result")

  def add_partition_with_environment_context(self, new_part, environment_context):
    """
    Parameters:
     - new_part
     - environment_context
    """
    self.send_add_partition_with_environment_context(new_part, environment_context)
    return self.recv_add_partition_with_environment_context()

  def send_add_partition_with_environment_context(self, new_part, environment_context):
    self._oprot.writeMessageBegin('add_partition_with_environment_context', TMessageType.CALL, self._seqid)
    args = add_partition_with_environment_context_args()
    args.new_part = new_part
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_partition_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition_with_environment_context failed: unknown result")

  def add_partitions(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    self.send_add_partitions(new_parts)
    return self.recv_add_partitions()

  def send_add_partitions(self, new_parts):
    self._oprot.writeMessageBegin('add_partitions', TMessageType.CALL, self._seqid)
    args = add_partitions_args()
    args.new_parts = new_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partitions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_partitions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions failed: unknown result")

  def add_partitions_pspec(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    self.send_add_partitions_pspec(new_parts)
    return self.recv_add_partitions_pspec()

  def send_add_partitions_pspec(self, new_parts):
    self._oprot.writeMessageBegin('add_partitions_pspec', TMessageType.CALL, self._seqid)
    args = add_partitions_pspec_args()
    args.new_parts = new_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partitions_pspec(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_partitions_pspec_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions_pspec failed: unknown result")

  def append_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    self.send_append_partition(db_name, tbl_name, part_vals)
    return self.recv_append_partition()

  def send_append_partition(self, db_name, tbl_name, part_vals):
    self._oprot.writeMessageBegin('append_partition', TMessageType.CALL, self._seqid)
    args = append_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = append_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition failed: unknown result")

  def add_partitions_req(self, request):
    """
    Parameters:
     - request
    """
    self.send_add_partitions_req(request)
    return self.recv_add_partitions_req()

  def send_add_partitions_req(self, request):
    self._oprot.writeMessageBegin('add_partitions_req', TMessageType.CALL, self._seqid)
    args = add_partitions_req_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partitions_req(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_partitions_req_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions_req failed: unknown result")

  def append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - environment_context
    """
    self.send_append_partition_with_environment_context(db_name, tbl_name, part_vals, environment_context)
    return self.recv_append_partition_with_environment_context()

  def send_append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
    self._oprot.writeMessageBegin('append_partition_with_environment_context', TMessageType.CALL, self._seqid)
    args = append_partition_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = append_partition_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_with_environment_context failed: unknown result")

  def append_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    self.send_append_partition_by_name(db_name, tbl_name, part_name)
    return self.recv_append_partition_by_name()

  def send_append_partition_by_name(self, db_name, tbl_name, part_name):
    self._oprot.writeMessageBegin('append_partition_by_name', TMessageType.CALL, self._seqid)
    args = append_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = append_partition_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name failed: unknown result")

  def append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - environment_context
    """
    self.send_append_partition_by_name_with_environment_context(db_name, tbl_name, part_name, environment_context)
    return self.recv_append_partition_by_name_with_environment_context()

  def send_append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
    self._oprot.writeMessageBegin('append_partition_by_name_with_environment_context', TMessageType.CALL, self._seqid)
    args = append_partition_by_name_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition_by_name_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = append_partition_by_name_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name_with_environment_context failed: unknown result")

  def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """
    self.send_drop_partition(db_name, tbl_name, part_vals, deleteData)
    return self.recv_drop_partition()

  def send_drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    self._oprot.writeMessageBegin('drop_partition', TMessageType.CALL, self._seqid)
    args = drop_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition failed: unknown result")

  def drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
     - environment_context
    """
    self.send_drop_partition_with_environment_context(db_name, tbl_name, part_vals, deleteData, environment_context)
    return self.recv_drop_partition_with_environment_context()

  def send_drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
    self._oprot.writeMessageBegin('drop_partition_with_environment_context', TMessageType.CALL, self._seqid)
    args = drop_partition_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.deleteData = deleteData
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_partition_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_with_environment_context failed: unknown result")

  def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """
    self.send_drop_partition_by_name(db_name, tbl_name, part_name, deleteData)
    return self.recv_drop_partition_by_name()

  def send_drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    self._oprot.writeMessageBegin('drop_partition_by_name', TMessageType.CALL, self._seqid)
    args = drop_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_partition_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name failed: unknown result")

  def drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
     - environment_context
    """
    self.send_drop_partition_by_name_with_environment_context(db_name, tbl_name, part_name, deleteData, environment_context)
    return self.recv_drop_partition_by_name_with_environment_context()

  def send_drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
    self._oprot.writeMessageBegin('drop_partition_by_name_with_environment_context', TMessageType.CALL, self._seqid)
    args = drop_partition_by_name_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.deleteData = deleteData
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_by_name_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_partition_by_name_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name_with_environment_context failed: unknown result")

  def drop_partitions_req(self, req):
    """
    Parameters:
     - req
    """
    self.send_drop_partitions_req(req)
    return self.recv_drop_partitions_req()

  def send_drop_partitions_req(self, req):
    self._oprot.writeMessageBegin('drop_partitions_req', TMessageType.CALL, self._seqid)
    args = drop_partitions_req_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partitions_req(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_partitions_req_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partitions_req failed: unknown result")

  def get_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    self.send_get_partition(db_name, tbl_name, part_vals)
    return self.recv_get_partition()

  def send_get_partition(self, db_name, tbl_name, part_vals):
    self._oprot.writeMessageBegin('get_partition', TMessageType.CALL, self._seqid)
    args = get_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition failed: unknown result")

  def exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    """
    Parameters:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name
    """
    self.send_exchange_partition(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)
    return self.recv_exchange_partition()

  def send_exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    self._oprot.writeMessageBegin('exchange_partition', TMessageType.CALL, self._seqid)
    args = exchange_partition_args()
    args.partitionSpecs = partitionSpecs
    args.source_db = source_db
    args.source_table_name = source_table_name
    args.dest_db = dest_db
    args.dest_table_name = dest_table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_exchange_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = exchange_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "exchange_partition failed: unknown result")

  def exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    """
    Parameters:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name
    """
    self.send_exchange_partitions(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)
    return self.recv_exchange_partitions()

  def send_exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    self._oprot.writeMessageBegin('exchange_partitions', TMessageType.CALL, self._seqid)
    args = exchange_partitions_args()
    args.partitionSpecs = partitionSpecs
    args.source_db = source_db
    args.source_table_name = source_table_name
    args.dest_db = dest_db
    args.dest_table_name = dest_table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_exchange_partitions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = exchange_partitions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "exchange_partitions failed: unknown result")

  def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names
    """
    self.send_get_partition_with_auth(db_name, tbl_name, part_vals, user_name, group_names)
    return self.recv_get_partition_with_auth()

  def send_get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    self._oprot.writeMessageBegin('get_partition_with_auth', TMessageType.CALL, self._seqid)
    args = get_partition_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_with_auth(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_with_auth_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_with_auth failed: unknown result")

  def get_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    self.send_get_partition_by_name(db_name, tbl_name, part_name)
    return self.recv_get_partition_by_name()

  def send_get_partition_by_name(self, db_name, tbl_name, part_name):
    self._oprot.writeMessageBegin('get_partition_by_name', TMessageType.CALL, self._seqid)
    args = get_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_by_name failed: unknown result")

  def get_partitions(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partitions(db_name, tbl_name, max_parts)
    return self.recv_get_partitions()

  def send_get_partitions(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partitions', TMessageType.CALL, self._seqid)
    args = get_partitions_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions failed: unknown result")

  def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names
    """
    self.send_get_partitions_with_auth(db_name, tbl_name, max_parts, user_name, group_names)
    return self.recv_get_partitions_with_auth()

  def send_get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    self._oprot.writeMessageBegin('get_partitions_with_auth', TMessageType.CALL, self._seqid)
    args = get_partitions_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_with_auth(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_with_auth_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_with_auth failed: unknown result")

  def get_partitions_pspec(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partitions_pspec(db_name, tbl_name, max_parts)
    return self.recv_get_partitions_pspec()

  def send_get_partitions_pspec(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partitions_pspec', TMessageType.CALL, self._seqid)
    args = get_partitions_pspec_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_pspec(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_pspec_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_pspec failed: unknown result")

  def get_partition_names(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partition_names(db_name, tbl_name, max_parts)
    return self.recv_get_partition_names()

  def send_get_partition_names(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partition_names', TMessageType.CALL, self._seqid)
    args = get_partition_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_names(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_names_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names failed: unknown result")

  def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    self.send_get_partitions_ps(db_name, tbl_name, part_vals, max_parts)
    return self.recv_get_partitions_ps()

  def send_get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    self._oprot.writeMessageBegin('get_partitions_ps', TMessageType.CALL, self._seqid)
    args = get_partitions_ps_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_ps(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_ps_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps failed: unknown result")

  def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names
    """
    self.send_get_partitions_ps_with_auth(db_name, tbl_name, part_vals, max_parts, user_name, group_names)
    return self.recv_get_partitions_ps_with_auth()

  def send_get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    self._oprot.writeMessageBegin('get_partitions_ps_with_auth', TMessageType.CALL, self._seqid)
    args = get_partitions_ps_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_ps_with_auth(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_ps_with_auth_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps_with_auth failed: unknown result")

  def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    self.send_get_partition_names_ps(db_name, tbl_name, part_vals, max_parts)
    return self.recv_get_partition_names_ps()

  def send_get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    self._oprot.writeMessageBegin('get_partition_names_ps', TMessageType.CALL, self._seqid)
    args = get_partition_names_ps_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_names_ps(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_names_ps_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_ps failed: unknown result")

  def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    self.send_get_partitions_by_filter(db_name, tbl_name, filter, max_parts)
    return self.recv_get_partitions_by_filter()

  def send_get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    self._oprot.writeMessageBegin('get_partitions_by_filter', TMessageType.CALL, self._seqid)
    args = get_partitions_by_filter_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.filter = filter
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_by_filter(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_by_filter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_filter failed: unknown result")

  def get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    self.send_get_part_specs_by_filter(db_name, tbl_name, filter, max_parts)
    return self.recv_get_part_specs_by_filter()

  def send_get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
    self._oprot.writeMessageBegin('get_part_specs_by_filter', TMessageType.CALL, self._seqid)
    args = get_part_specs_by_filter_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.filter = filter
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_part_specs_by_filter(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_part_specs_by_filter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_part_specs_by_filter failed: unknown result")

  def get_partitions_by_expr(self, req):
    """
    Parameters:
     - req
    """
    self.send_get_partitions_by_expr(req)
    return self.recv_get_partitions_by_expr()

  def send_get_partitions_by_expr(self, req):
    self._oprot.writeMessageBegin('get_partitions_by_expr', TMessageType.CALL, self._seqid)
    args = get_partitions_by_expr_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_by_expr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_by_expr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_expr failed: unknown result")

  def get_partitions_by_names(self, db_name, tbl_name, names):
    """
    Parameters:
     - db_name
     - tbl_name
     - names
    """
    self.send_get_partitions_by_names(db_name, tbl_name, names)
    return self.recv_get_partitions_by_names()

  def send_get_partitions_by_names(self, db_name, tbl_name, names):
    self._oprot.writeMessageBegin('get_partitions_by_names', TMessageType.CALL, self._seqid)
    args = get_partitions_by_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.names = names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_by_names(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_by_names_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_names failed: unknown result")

  def alter_partition(self, db_name, tbl_name, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
    """
    self.send_alter_partition(db_name, tbl_name, new_part)
    self.recv_alter_partition()

  def send_alter_partition(self, db_name, tbl_name, new_part):
    self._oprot.writeMessageBegin('alter_partition', TMessageType.CALL, self._seqid)
    args = alter_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_partitions(self, db_name, tbl_name, new_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_parts
    """
    self.send_alter_partitions(db_name, tbl_name, new_parts)
    self.recv_alter_partitions()

  def send_alter_partitions(self, db_name, tbl_name, new_parts):
    self._oprot.writeMessageBegin('alter_partitions', TMessageType.CALL, self._seqid)
    args = alter_partitions_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_parts = new_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partitions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_partitions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
     - environment_context
    """
    self.send_alter_partition_with_environment_context(db_name, tbl_name, new_part, environment_context)
    self.recv_alter_partition_with_environment_context()

  def send_alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
    self._oprot.writeMessageBegin('alter_partition_with_environment_context', TMessageType.CALL, self._seqid)
    args = alter_partition_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_part = new_part
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partition_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_partition_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def rename_partition(self, db_name, tbl_name, part_vals, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - new_part
    """
    self.send_rename_partition(db_name, tbl_name, part_vals, new_part)
    self.recv_rename_partition()

  def send_rename_partition(self, db_name, tbl_name, part_vals, new_part):
    self._oprot.writeMessageBegin('rename_partition', TMessageType.CALL, self._seqid)
    args = rename_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rename_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = rename_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def partition_name_has_valid_characters(self, part_vals, throw_exception):
    """
    Parameters:
     - part_vals
     - throw_exception
    """
    self.send_partition_name_has_valid_characters(part_vals, throw_exception)
    return self.recv_partition_name_has_valid_characters()

  def send_partition_name_has_valid_characters(self, part_vals, throw_exception):
    self._oprot.writeMessageBegin('partition_name_has_valid_characters', TMessageType.CALL, self._seqid)
    args = partition_name_has_valid_characters_args()
    args.part_vals = part_vals
    args.throw_exception = throw_exception
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_has_valid_characters(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = partition_name_has_valid_characters_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_has_valid_characters failed: unknown result")

  def get_config_value(self, name, defaultValue):
    """
    Parameters:
     - name
     - defaultValue
    """
    self.send_get_config_value(name, defaultValue)
    return self.recv_get_config_value()

  def send_get_config_value(self, name, defaultValue):
    self._oprot.writeMessageBegin('get_config_value', TMessageType.CALL, self._seqid)
    args = get_config_value_args()
    args.name = name
    args.defaultValue = defaultValue
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_config_value(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_config_value_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_config_value failed: unknown result")

  def partition_name_to_vals(self, part_name):
    """
    Parameters:
     - part_name
    """
    self.send_partition_name_to_vals(part_name)
    return self.recv_partition_name_to_vals()

  def send_partition_name_to_vals(self, part_name):
    self._oprot.writeMessageBegin('partition_name_to_vals', TMessageType.CALL, self._seqid)
    args = partition_name_to_vals_args()
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_to_vals(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = partition_name_to_vals_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_vals failed: unknown result")

  def partition_name_to_spec(self, part_name):
    """
    Parameters:
     - part_name
    """
    self.send_partition_name_to_spec(part_name)
    return self.recv_partition_name_to_spec()

  def send_partition_name_to_spec(self, part_name):
    self._oprot.writeMessageBegin('partition_name_to_spec', TMessageType.CALL, self._seqid)
    args = partition_name_to_spec_args()
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_to_spec(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = partition_name_to_spec_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_spec failed: unknown result")

  def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    self.send_markPartitionForEvent(db_name, tbl_name, part_vals, eventType)
    self.recv_markPartitionForEvent()

  def send_markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    self._oprot.writeMessageBegin('markPartitionForEvent', TMessageType.CALL, self._seqid)
    args = markPartitionForEvent_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.eventType = eventType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_markPartitionForEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = markPartitionForEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    if result.o5 is not None:
      raise result.o5
    if result.o6 is not None:
      raise result.o6
    return

  def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    self.send_isPartitionMarkedForEvent(db_name, tbl_name, part_vals, eventType)
    return self.recv_isPartitionMarkedForEvent()

  def send_isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    self._oprot.writeMessageBegin('isPartitionMarkedForEvent', TMessageType.CALL, self._seqid)
    args = isPartitionMarkedForEvent_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.eventType = eventType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isPartitionMarkedForEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = isPartitionMarkedForEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    if result.o5 is not None:
      raise result.o5
    if result.o6 is not None:
      raise result.o6
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isPartitionMarkedForEvent failed: unknown result")

  def add_index(self, new_index, index_table):
    """
    Parameters:
     - new_index
     - index_table
    """
    self.send_add_index(new_index, index_table)
    return self.recv_add_index()

  def send_add_index(self, new_index, index_table):
    self._oprot.writeMessageBegin('add_index', TMessageType.CALL, self._seqid)
    args = add_index_args()
    args.new_index = new_index
    args.index_table = index_table
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_index(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_index_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_index failed: unknown result")

  def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    """
    Parameters:
     - dbname
     - base_tbl_name
     - idx_name
     - new_idx
    """
    self.send_alter_index(dbname, base_tbl_name, idx_name, new_idx)
    self.recv_alter_index()

  def send_alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    self._oprot.writeMessageBegin('alter_index', TMessageType.CALL, self._seqid)
    args = alter_index_args()
    args.dbname = dbname
    args.base_tbl_name = base_tbl_name
    args.idx_name = idx_name
    args.new_idx = new_idx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_index(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_index_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """
    self.send_drop_index_by_name(db_name, tbl_name, index_name, deleteData)
    return self.recv_drop_index_by_name()

  def send_drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    self._oprot.writeMessageBegin('drop_index_by_name', TMessageType.CALL, self._seqid)
    args = drop_index_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.index_name = index_name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_index_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_index_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_index_by_name failed: unknown result")

  def get_index_by_name(self, db_name, tbl_name, index_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
    """
    self.send_get_index_by_name(db_name, tbl_name, index_name)
    return self.recv_get_index_by_name()

  def send_get_index_by_name(self, db_name, tbl_name, index_name):
    self._oprot.writeMessageBegin('get_index_by_name', TMessageType.CALL, self._seqid)
    args = get_index_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.index_name = index_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_index_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_index_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_by_name failed: unknown result")

  def get_indexes(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_indexes(db_name, tbl_name, max_indexes)
    return self.recv_get_indexes()

  def send_get_indexes(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_indexes', TMessageType.CALL, self._seqid)
    args = get_indexes_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_indexes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_indexes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_indexes failed: unknown result")

  def get_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_index_names(db_name, tbl_name, max_indexes)
    return self.recv_get_index_names()

  def send_get_index_names(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_index_names', TMessageType.CALL, self._seqid)
    args = get_index_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_index_names(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_index_names_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_names failed: unknown result")

  def update_table_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    self.send_update_table_column_statistics(stats_obj)
    return self.recv_update_table_column_statistics()

  def send_update_table_column_statistics(self, stats_obj):
    self._oprot.writeMessageBegin('update_table_column_statistics', TMessageType.CALL, self._seqid)
    args = update_table_column_statistics_args()
    args.stats_obj = stats_obj
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_table_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_table_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_table_column_statistics failed: unknown result")

  def update_partition_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    self.send_update_partition_column_statistics(stats_obj)
    return self.recv_update_partition_column_statistics()

  def send_update_partition_column_statistics(self, stats_obj):
    self._oprot.writeMessageBegin('update_partition_column_statistics', TMessageType.CALL, self._seqid)
    args = update_partition_column_statistics_args()
    args.stats_obj = stats_obj
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_partition_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_partition_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_partition_column_statistics failed: unknown result")

  def get_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    self.send_get_table_column_statistics(db_name, tbl_name, col_name)
    return self.recv_get_table_column_statistics()

  def send_get_table_column_statistics(self, db_name, tbl_name, col_name):
    self._oprot.writeMessageBegin('get_table_column_statistics', TMessageType.CALL, self._seqid)
    args = get_table_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_column_statistics failed: unknown result")

  def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    self.send_get_partition_column_statistics(db_name, tbl_name, part_name, col_name)
    return self.recv_get_partition_column_statistics()

  def send_get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    self._oprot.writeMessageBegin('get_partition_column_statistics', TMessageType.CALL, self._seqid)
    args = get_partition_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_column_statistics failed: unknown result")

  def get_table_statistics_req(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_table_statistics_req(request)
    return self.recv_get_table_statistics_req()

  def send_get_table_statistics_req(self, request):
    self._oprot.writeMessageBegin('get_table_statistics_req', TMessageType.CALL, self._seqid)
    args = get_table_statistics_req_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_statistics_req(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_statistics_req_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_statistics_req failed: unknown result")

  def get_partitions_statistics_req(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_partitions_statistics_req(request)
    return self.recv_get_partitions_statistics_req()

  def send_get_partitions_statistics_req(self, request):
    self._oprot.writeMessageBegin('get_partitions_statistics_req', TMessageType.CALL, self._seqid)
    args = get_partitions_statistics_req_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_statistics_req(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_statistics_req_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_statistics_req failed: unknown result")

  def get_aggr_stats_for(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_aggr_stats_for(request)
    return self.recv_get_aggr_stats_for()

  def send_get_aggr_stats_for(self, request):
    self._oprot.writeMessageBegin('get_aggr_stats_for', TMessageType.CALL, self._seqid)
    args = get_aggr_stats_for_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_aggr_stats_for(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_aggr_stats_for_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_aggr_stats_for failed: unknown result")

  def set_aggr_stats_for(self, request):
    """
    Parameters:
     - request
    """
    self.send_set_aggr_stats_for(request)
    return self.recv_set_aggr_stats_for()

  def send_set_aggr_stats_for(self, request):
    self._oprot.writeMessageBegin('set_aggr_stats_for', TMessageType.CALL, self._seqid)
    args = set_aggr_stats_for_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_aggr_stats_for(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_aggr_stats_for_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_aggr_stats_for failed: unknown result")

  def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    self.send_delete_partition_column_statistics(db_name, tbl_name, part_name, col_name)
    return self.recv_delete_partition_column_statistics()

  def send_delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    self._oprot.writeMessageBegin('delete_partition_column_statistics', TMessageType.CALL, self._seqid)
    args = delete_partition_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_partition_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_partition_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_partition_column_statistics failed: unknown result")

  def delete_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    self.send_delete_table_column_statistics(db_name, tbl_name, col_name)
    return self.recv_delete_table_column_statistics()

  def send_delete_table_column_statistics(self, db_name, tbl_name, col_name):
    self._oprot.writeMessageBegin('delete_table_column_statistics', TMessageType.CALL, self._seqid)
    args = delete_table_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_table_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_table_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_table_column_statistics failed: unknown result")

  def create_function(self, func):
    """
    Parameters:
     - func
    """
    self.send_create_function(func)
    self.recv_create_function()

  def send_create_function(self, func):
    self._oprot.writeMessageBegin('create_function', TMessageType.CALL, self._seqid)
    args = create_function_args()
    args.func = func
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_function(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_function_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def drop_function(self, dbName, funcName):
    """
    Parameters:
     - dbName
     - funcName
    """
    self.send_drop_function(dbName, funcName)
    self.recv_drop_function()

  def send_drop_function(self, dbName, funcName):
    self._oprot.writeMessageBegin('drop_function', TMessageType.CALL, self._seqid)
    args = drop_function_args()
    args.dbName = dbName
    args.funcName = funcName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_function(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_function_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o3 is not None:
      raise result.o3
    return

  def alter_function(self, dbName, funcName, newFunc):
    """
    Parameters:
     - dbName
     - funcName
     - newFunc
    """
    self.send_alter_function(dbName, funcName, newFunc)
    self.recv_alter_function()

  def send_alter_function(self, dbName, funcName, newFunc):
    self._oprot.writeMessageBegin('alter_function', TMessageType.CALL, self._seqid)
    args = alter_function_args()
    args.dbName = dbName
    args.funcName = funcName
    args.newFunc = newFunc
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_function(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_function_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def get_functions(self, dbName, pattern):
    """
    Parameters:
     - dbName
     - pattern
    """
    self.send_get_functions(dbName, pattern)
    return self.recv_get_functions()

  def send_get_functions(self, dbName, pattern):
    self._oprot.writeMessageBegin('get_functions', TMessageType.CALL, self._seqid)
    args = get_functions_args()
    args.dbName = dbName
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_functions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_functions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_functions failed: unknown result")

  def get_function(self, dbName, funcName):
    """
    Parameters:
     - dbName
     - funcName
    """
    self.send_get_function(dbName, funcName)
    return self.recv_get_function()

  def send_get_function(self, dbName, funcName):
    self._oprot.writeMessageBegin('get_function', TMessageType.CALL, self._seqid)
    args = get_function_args()
    args.dbName = dbName
    args.funcName = funcName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_function(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_function_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function failed: unknown result")

  def get_all_functions(self):
    self.send_get_all_functions()
    return self.recv_get_all_functions()

  def send_get_all_functions(self):
    self._oprot.writeMessageBegin('get_all_functions', TMessageType.CALL, self._seqid)
    args = get_all_functions_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_functions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_functions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_functions failed: unknown result")

  def create_role(self, role):
    """
    Parameters:
     - role
    """
    self.send_create_role(role)
    return self.recv_create_role()

  def send_create_role(self, role):
    self._oprot.writeMessageBegin('create_role', TMessageType.CALL, self._seqid)
    args = create_role_args()
    args.role = role
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_role failed: unknown result")

  def drop_role(self, role_name):
    """
    Parameters:
     - role_name
    """
    self.send_drop_role(role_name)
    return self.recv_drop_role()

  def send_drop_role(self, role_name):
    self._oprot.writeMessageBegin('drop_role', TMessageType.CALL, self._seqid)
    args = drop_role_args()
    args.role_name = role_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_role failed: unknown result")

  def get_role_names(self):
    self.send_get_role_names()
    return self.recv_get_role_names()

  def send_get_role_names(self):
    self._oprot.writeMessageBegin('get_role_names', TMessageType.CALL, self._seqid)
    args = get_role_names_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_role_names(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_role_names_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_names failed: unknown result")

  def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option
    """
    self.send_grant_role(role_name, principal_name, principal_type, grantor, grantorType, grant_option)
    return self.recv_grant_role()

  def send_grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    self._oprot.writeMessageBegin('grant_role', TMessageType.CALL, self._seqid)
    args = grant_role_args()
    args.role_name = role_name
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.grantor = grantor
    args.grantorType = grantorType
    args.grant_option = grant_option
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = grant_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_role failed: unknown result")

  def revoke_role(self, role_name, principal_name, principal_type):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
    """
    self.send_revoke_role(role_name, principal_name, principal_type)
    return self.recv_revoke_role()

  def send_revoke_role(self, role_name, principal_name, principal_type):
    self._oprot.writeMessageBegin('revoke_role', TMessageType.CALL, self._seqid)
    args = revoke_role_args()
    args.role_name = role_name
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revoke_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revoke_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_role failed: unknown result")

  def list_roles(self, principal_name, principal_type):
    """
    Parameters:
     - principal_name
     - principal_type
    """
    self.send_list_roles(principal_name, principal_type)
    return self.recv_list_roles()

  def send_list_roles(self, principal_name, principal_type):
    self._oprot.writeMessageBegin('list_roles', TMessageType.CALL, self._seqid)
    args = list_roles_args()
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_roles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = list_roles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_roles failed: unknown result")

  def grant_revoke_role(self, request):
    """
    Parameters:
     - request
    """
    self.send_grant_revoke_role(request)
    return self.recv_grant_revoke_role()

  def send_grant_revoke_role(self, request):
    self._oprot.writeMessageBegin('grant_revoke_role', TMessageType.CALL, self._seqid)
    args = grant_revoke_role_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_revoke_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = grant_revoke_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_revoke_role failed: unknown result")

  def get_principals_in_role(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_principals_in_role(request)
    return self.recv_get_principals_in_role()

  def send_get_principals_in_role(self, request):
    self._oprot.writeMessageBegin('get_principals_in_role', TMessageType.CALL, self._seqid)
    args = get_principals_in_role_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_principals_in_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_principals_in_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_principals_in_role failed: unknown result")

  def get_role_grants_for_principal(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_role_grants_for_principal(request)
    return self.recv_get_role_grants_for_principal()

  def send_get_role_grants_for_principal(self, request):
    self._oprot.writeMessageBegin('get_role_grants_for_principal', TMessageType.CALL, self._seqid)
    args = get_role_grants_for_principal_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_role_grants_for_principal(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_role_grants_for_principal_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_grants_for_principal failed: unknown result")

  def get_privilege_set(self, hiveObject, user_name, group_names):
    """
    Parameters:
     - hiveObject
     - user_name
     - group_names
    """
    self.send_get_privilege_set(hiveObject, user_name, group_names)
    return self.recv_get_privilege_set()

  def send_get_privilege_set(self, hiveObject, user_name, group_names):
    self._oprot.writeMessageBegin('get_privilege_set', TMessageType.CALL, self._seqid)
    args = get_privilege_set_args()
    args.hiveObject = hiveObject
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_privilege_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_privilege_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_privilege_set failed: unknown result")

  def list_privileges(self, principal_name, principal_type, hiveObject):
    """
    Parameters:
     - principal_name
     - principal_type
     - hiveObject
    """
    self.send_list_privileges(principal_name, principal_type, hiveObject)
    return self.recv_list_privileges()

  def send_list_privileges(self, principal_name, principal_type, hiveObject):
    self._oprot.writeMessageBegin('list_privileges', TMessageType.CALL, self._seqid)
    args = list_privileges_args()
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.hiveObject = hiveObject
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_privileges(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = list_privileges_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_privileges failed: unknown result")

  def grant_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    self.send_grant_privileges(privileges)
    return self.recv_grant_privileges()

  def send_grant_privileges(self, privileges):
    self._oprot.writeMessageBegin('grant_privileges', TMessageType.CALL, self._seqid)
    args = grant_privileges_args()
    args.privileges = privileges
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_privileges(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = grant_privileges_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_privileges failed: unknown result")

  def revoke_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    self.send_revoke_privileges(privileges)
    return self.recv_revoke_privileges()

  def send_revoke_privileges(self, privileges):
    self._oprot.writeMessageBegin('revoke_privileges', TMessageType.CALL, self._seqid)
    args = revoke_privileges_args()
    args.privileges = privileges
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revoke_privileges(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revoke_privileges_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_privileges failed: unknown result")

  def grant_revoke_privileges(self, request):
    """
    Parameters:
     - request
    """
    self.send_grant_revoke_privileges(request)
    return self.recv_grant_revoke_privileges()

  def send_grant_revoke_privileges(self, request):
    self._oprot.writeMessageBegin('grant_revoke_privileges', TMessageType.CALL, self._seqid)
    args = grant_revoke_privileges_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_revoke_privileges(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = grant_revoke_privileges_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_revoke_privileges failed: unknown result")

  def set_ugi(self, user_name, group_names):
    """
    Parameters:
     - user_name
     - group_names
    """
    self.send_set_ugi(user_name, group_names)
    return self.recv_set_ugi()

  def send_set_ugi(self, user_name, group_names):
    self._oprot.writeMessageBegin('set_ugi', TMessageType.CALL, self._seqid)
    args = set_ugi_args()
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_ugi(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_ugi_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_ugi failed: unknown result")

  def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    """
    Parameters:
     - token_owner
     - renewer_kerberos_principal_name
    """
    self.send_get_delegation_token(token_owner, renewer_kerberos_principal_name)
    return self.recv_get_delegation_token()

  def send_get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    self._oprot.writeMessageBegin('get_delegation_token', TMessageType.CALL, self._seqid)
    args = get_delegation_token_args()
    args.token_owner = token_owner
    args.renewer_kerberos_principal_name = renewer_kerberos_principal_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_delegation_token(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_delegation_token_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_delegation_token failed: unknown result")

  def renew_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    self.send_renew_delegation_token(token_str_form)
    return self.recv_renew_delegation_token()

  def send_renew_delegation_token(self, token_str_form):
    self._oprot.writeMessageBegin('renew_delegation_token', TMessageType.CALL, self._seqid)
    args = renew_delegation_token_args()
    args.token_str_form = token_str_form
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_renew_delegation_token(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = renew_delegation_token_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "renew_delegation_token failed: unknown result")

  def cancel_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    self.send_cancel_delegation_token(token_str_form)
    self.recv_cancel_delegation_token()

  def send_cancel_delegation_token(self, token_str_form):
    self._oprot.writeMessageBegin('cancel_delegation_token', TMessageType.CALL, self._seqid)
    args = cancel_delegation_token_args()
    args.token_str_form = token_str_form
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cancel_delegation_token(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cancel_delegation_token_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def get_open_txns(self):
    self.send_get_open_txns()
    return self.recv_get_open_txns()

  def send_get_open_txns(self):
    self._oprot.writeMessageBegin('get_open_txns', TMessageType.CALL, self._seqid)
    args = get_open_txns_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_open_txns(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_open_txns_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns failed: unknown result")

  def get_open_txns_info(self):
    self.send_get_open_txns_info()
    return self.recv_get_open_txns_info()

  def send_get_open_txns_info(self):
    self._oprot.writeMessageBegin('get_open_txns_info', TMessageType.CALL, self._seqid)
    args = get_open_txns_info_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_open_txns_info(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_open_txns_info_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns_info failed: unknown result")

  def open_txns(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_open_txns(rqst)
    return self.recv_open_txns()

  def send_open_txns(self, rqst):
    self._oprot.writeMessageBegin('open_txns', TMessageType.CALL, self._seqid)
    args = open_txns_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_open_txns(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = open_txns_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "open_txns failed: unknown result")

  def abort_txn(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_abort_txn(rqst)
    self.recv_abort_txn()

  def send_abort_txn(self, rqst):
    self._oprot.writeMessageBegin('abort_txn', TMessageType.CALL, self._seqid)
    args = abort_txn_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_abort_txn(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = abort_txn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def commit_txn(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_commit_txn(rqst)
    self.recv_commit_txn()

  def send_commit_txn(self, rqst):
    self._oprot.writeMessageBegin('commit_txn', TMessageType.CALL, self._seqid)
    args = commit_txn_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_commit_txn(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = commit_txn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def lock(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_lock(rqst)
    return self.recv_lock()

  def send_lock(self, rqst):
    self._oprot.writeMessageBegin('lock', TMessageType.CALL, self._seqid)
    args = lock_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_lock(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = lock_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "lock failed: unknown result")

  def check_lock(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_check_lock(rqst)
    return self.recv_check_lock()

  def send_check_lock(self, rqst):
    self._oprot.writeMessageBegin('check_lock', TMessageType.CALL, self._seqid)
    args = check_lock_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_check_lock(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = check_lock_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "check_lock failed: unknown result")

  def unlock(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_unlock(rqst)
    self.recv_unlock()

  def send_unlock(self, rqst):
    self._oprot.writeMessageBegin('unlock', TMessageType.CALL, self._seqid)
    args = unlock_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unlock(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = unlock_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def show_locks(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_show_locks(rqst)
    return self.recv_show_locks()

  def send_show_locks(self, rqst):
    self._oprot.writeMessageBegin('show_locks', TMessageType.CALL, self._seqid)
    args = show_locks_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_show_locks(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = show_locks_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "show_locks failed: unknown result")

  def heartbeat(self, ids):
    """
    Parameters:
     - ids
    """
    self.send_heartbeat(ids)
    self.recv_heartbeat()

  def send_heartbeat(self, ids):
    self._oprot.writeMessageBegin('heartbeat', TMessageType.CALL, self._seqid)
    args = heartbeat_args()
    args.ids = ids
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_heartbeat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = heartbeat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def heartbeat_txn_range(self, txns):
    """
    Parameters:
     - txns
    """
    self.send_heartbeat_txn_range(txns)
    return self.recv_heartbeat_txn_range()

  def send_heartbeat_txn_range(self, txns):
    self._oprot.writeMessageBegin('heartbeat_txn_range', TMessageType.CALL, self._seqid)
    args = heartbeat_txn_range_args()
    args.txns = txns
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_heartbeat_txn_range(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = heartbeat_txn_range_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "heartbeat_txn_range failed: unknown result")

  def compact(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_compact(rqst)
    self.recv_compact()

  def send_compact(self, rqst):
    self._oprot.writeMessageBegin('compact', TMessageType.CALL, self._seqid)
    args = compact_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_compact(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = compact_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return

  def show_compact(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_show_compact(rqst)
    return self.recv_show_compact()

  def send_show_compact(self, rqst):
    self._oprot.writeMessageBegin('show_compact', TMessageType.CALL, self._seqid)
    args = show_compact_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_show_compact(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = show_compact_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "show_compact failed: unknown result")

  def add_dynamic_partitions(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_add_dynamic_partitions(rqst)
    self.recv_add_dynamic_partitions()

  def send_add_dynamic_partitions(self, rqst):
    self._oprot.writeMessageBegin('add_dynamic_partitions', TMessageType.CALL, self._seqid)
    args = add_dynamic_partitions_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_dynamic_partitions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_dynamic_partitions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def get_next_notification(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_get_next_notification(rqst)
    return self.recv_get_next_notification()

  def send_get_next_notification(self, rqst):
    self._oprot.writeMessageBegin('get_next_notification', TMessageType.CALL, self._seqid)
    args = get_next_notification_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_next_notification(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_next_notification_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_next_notification failed: unknown result")

  def get_current_notificationEventId(self):
    self.send_get_current_notificationEventId()
    return self.recv_get_current_notificationEventId()

  def send_get_current_notificationEventId(self):
    self._oprot.writeMessageBegin('get_current_notificationEventId', TMessageType.CALL, self._seqid)
    args = get_current_notificationEventId_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_current_notificationEventId(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_current_notificationEventId_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_current_notificationEventId failed: unknown result")

  def fire_listener_event(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_fire_listener_event(rqst)
    return self.recv_fire_listener_event()

  def send_fire_listener_event(self, rqst):
    self._oprot.writeMessageBegin('fire_listener_event', TMessageType.CALL, self._seqid)
    args = fire_listener_event_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_fire_listener_event(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = fire_listener_event_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "fire_listener_event failed: unknown result")

  def flushCache(self):
    self.send_flushCache()
    self.recv_flushCache()

  def send_flushCache(self):
    self._oprot.writeMessageBegin('flushCache', TMessageType.CALL, self._seqid)
    args = flushCache_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_flushCache(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = flushCache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return

  def get_file_metadata_by_expr(self, req):
    """
    Parameters:
     - req
    """
    self.send_get_file_metadata_by_expr(req)
    return self.recv_get_file_metadata_by_expr()

  def send_get_file_metadata_by_expr(self, req):
    self._oprot.writeMessageBegin('get_file_metadata_by_expr', TMessageType.CALL, self._seqid)
    args = get_file_metadata_by_expr_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_file_metadata_by_expr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_file_metadata_by_expr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_file_metadata_by_expr failed: unknown result")

  def get_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    self.send_get_file_metadata(req)
    return self.recv_get_file_metadata()

  def send_get_file_metadata(self, req):
    self._oprot.writeMessageBegin('get_file_metadata', TMessageType.CALL, self._seqid)
    args = get_file_metadata_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_file_metadata(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_file_metadata_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_file_metadata failed: unknown result")

  def put_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    self.send_put_file_metadata(req)
    return self.recv_put_file_metadata()

  def send_put_file_metadata(self, req):
    self._oprot.writeMessageBegin('put_file_metadata', TMessageType.CALL, self._seqid)
    args = put_file_metadata_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_put_file_metadata(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = put_file_metadata_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "put_file_metadata failed: unknown result")

  def clear_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    self.send_clear_file_metadata(req)
    return self.recv_clear_file_metadata()

  def send_clear_file_metadata(self, req):
    self._oprot.writeMessageBegin('clear_file_metadata', TMessageType.CALL, self._seqid)
    args = clear_file_metadata_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clear_file_metadata(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clear_file_metadata_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "clear_file_metadata failed: unknown result")


class Processor(fb303.FacebookService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    fb303.FacebookService.Processor.__init__(self, handler)
    self._processMap["getMetaConf"] = Processor.process_getMetaConf
    self._processMap["setMetaConf"] = Processor.process_setMetaConf
    self._processMap["create_database"] = Processor.process_create_database
    self._processMap["get_database"] = Processor.process_get_database
    self._processMap["drop_database"] = Processor.process_drop_database
    self._processMap["get_databases"] = Processor.process_get_databases
    self._processMap["get_all_databases"] = Processor.process_get_all_databases
    self._processMap["alter_database"] = Processor.process_alter_database
    self._processMap["get_type"] = Processor.process_get_type
    self._processMap["create_type"] = Processor.process_create_type
    self._processMap["drop_type"] = Processor.process_drop_type
    self._processMap["get_type_all"] = Processor.process_get_type_all
    self._processMap["get_fields"] = Processor.process_get_fields
    self._processMap["get_fields_with_environment_context"] = Processor.process_get_fields_with_environment_context
    self._processMap["get_schema"] = Processor.process_get_schema
    self._processMap["get_schema_with_environment_context"] = Processor.process_get_schema_with_environment_context
    self._processMap["create_table"] = Processor.process_create_table
    self._processMap["create_table_with_environment_context"] = Processor.process_create_table_with_environment_context
    self._processMap["drop_table"] = Processor.process_drop_table
    self._processMap["drop_table_with_environment_context"] = Processor.process_drop_table_with_environment_context
    self._processMap["get_tables"] = Processor.process_get_tables
    self._processMap["get_table_meta"] = Processor.process_get_table_meta
    self._processMap["get_all_tables"] = Processor.process_get_all_tables
    self._processMap["get_table"] = Processor.process_get_table
    self._processMap["get_table_objects_by_name"] = Processor.process_get_table_objects_by_name
    self._processMap["get_table_names_by_filter"] = Processor.process_get_table_names_by_filter
    self._processMap["alter_table"] = Processor.process_alter_table
    self._processMap["alter_table_with_environment_context"] = Processor.process_alter_table_with_environment_context
    self._processMap["alter_table_with_cascade"] = Processor.process_alter_table_with_cascade
    self._processMap["add_partition"] = Processor.process_add_partition
    self._processMap["add_partition_with_environment_context"] = Processor.process_add_partition_with_environment_context
    self._processMap["add_partitions"] = Processor.process_add_partitions
    self._processMap["add_partitions_pspec"] = Processor.process_add_partitions_pspec
    self._processMap["append_partition"] = Processor.process_append_partition
    self._processMap["add_partitions_req"] = Processor.process_add_partitions_req
    self._processMap["append_partition_with_environment_context"] = Processor.process_append_partition_with_environment_context
    self._processMap["append_partition_by_name"] = Processor.process_append_partition_by_name
    self._processMap["append_partition_by_name_with_environment_context"] = Processor.process_append_partition_by_name_with_environment_context
    self._processMap["drop_partition"] = Processor.process_drop_partition
    self._processMap["drop_partition_with_environment_context"] = Processor.process_drop_partition_with_environment_context
    self._processMap["drop_partition_by_name"] = Processor.process_drop_partition_by_name
    self._processMap["drop_partition_by_name_with_environment_context"] = Processor.process_drop_partition_by_name_with_environment_context
    self._processMap["drop_partitions_req"] = Processor.process_drop_partitions_req
    self._processMap["get_partition"] = Processor.process_get_partition
    self._processMap["exchange_partition"] = Processor.process_exchange_partition
    self._processMap["exchange_partitions"] = Processor.process_exchange_partitions
    self._processMap["get_partition_with_auth"] = Processor.process_get_partition_with_auth
    self._processMap["get_partition_by_name"] = Processor.process_get_partition_by_name
    self._processMap["get_partitions"] = Processor.process_get_partitions
    self._processMap["get_partitions_with_auth"] = Processor.process_get_partitions_with_auth
    self._processMap["get_partitions_pspec"] = Processor.process_get_partitions_pspec
    self._processMap["get_partition_names"] = Processor.process_get_partition_names
    self._processMap["get_partitions_ps"] = Processor.process_get_partitions_ps
    self._processMap["get_partitions_ps_with_auth"] = Processor.process_get_partitions_ps_with_auth
    self._processMap["get_partition_names_ps"] = Processor.process_get_partition_names_ps
    self._processMap["get_partitions_by_filter"] = Processor.process_get_partitions_by_filter
    self._processMap["get_part_specs_by_filter"] = Processor.process_get_part_specs_by_filter
    self._processMap["get_partitions_by_expr"] = Processor.process_get_partitions_by_expr
    self._processMap["get_partitions_by_names"] = Processor.process_get_partitions_by_names
    self._processMap["alter_partition"] = Processor.process_alter_partition
    self._processMap["alter_partitions"] = Processor.process_alter_partitions
    self._processMap["alter_partition_with_environment_context"] = Processor.process_alter_partition_with_environment_context
    self._processMap["rename_partition"] = Processor.process_rename_partition
    self._processMap["partition_name_has_valid_characters"] = Processor.process_partition_name_has_valid_characters
    self._processMap["get_config_value"] = Processor.process_get_config_value
    self._processMap["partition_name_to_vals"] = Processor.process_partition_name_to_vals
    self._processMap["partition_name_to_spec"] = Processor.process_partition_name_to_spec
    self._processMap["markPartitionForEvent"] = Processor.process_markPartitionForEvent
    self._processMap["isPartitionMarkedForEvent"] = Processor.process_isPartitionMarkedForEvent
    self._processMap["add_index"] = Processor.process_add_index
    self._processMap["alter_index"] = Processor.process_alter_index
    self._processMap["drop_index_by_name"] = Processor.process_drop_index_by_name
    self._processMap["get_index_by_name"] = Processor.process_get_index_by_name
    self._processMap["get_indexes"] = Processor.process_get_indexes
    self._processMap["get_index_names"] = Processor.process_get_index_names
    self._processMap["update_table_column_statistics"] = Processor.process_update_table_column_statistics
    self._processMap["update_partition_column_statistics"] = Processor.process_update_partition_column_statistics
    self._processMap["get_table_column_statistics"] = Processor.process_get_table_column_statistics
    self._processMap["get_partition_column_statistics"] = Processor.process_get_partition_column_statistics
    self._processMap["get_table_statistics_req"] = Processor.process_get_table_statistics_req
    self._processMap["get_partitions_statistics_req"] = Processor.process_get_partitions_statistics_req
    self._processMap["get_aggr_stats_for"] = Processor.process_get_aggr_stats_for
    self._processMap["set_aggr_stats_for"] = Processor.process_set_aggr_stats_for
    self._processMap["delete_partition_column_statistics"] = Processor.process_delete_partition_column_statistics
    self._processMap["delete_table_column_statistics"] = Processor.process_delete_table_column_statistics
    self._processMap["create_function"] = Processor.process_create_function
    self._processMap["drop_function"] = Processor.process_drop_function
    self._processMap["alter_function"] = Processor.process_alter_function
    self._processMap["get_functions"] = Processor.process_get_functions
    self._processMap["get_function"] = Processor.process_get_function
    self._processMap["get_all_functions"] = Processor.process_get_all_functions
    self._processMap["create_role"] = Processor.process_create_role
    self._processMap["drop_role"] = Processor.process_drop_role
    self._processMap["get_role_names"] = Processor.process_get_role_names
    self._processMap["grant_role"] = Processor.process_grant_role
    self._processMap["revoke_role"] = Processor.process_revoke_role
    self._processMap["list_roles"] = Processor.process_list_roles
    self._processMap["grant_revoke_role"] = Processor.process_grant_revoke_role
    self._processMap["get_principals_in_role"] = Processor.process_get_principals_in_role
    self._processMap["get_role_grants_for_principal"] = Processor.process_get_role_grants_for_principal
    self._processMap["get_privilege_set"] = Processor.process_get_privilege_set
    self._processMap["list_privileges"] = Processor.process_list_privileges
    self._processMap["grant_privileges"] = Processor.process_grant_privileges
    self._processMap["revoke_privileges"] = Processor.process_revoke_privileges
    self._processMap["grant_revoke_privileges"] = Processor.process_grant_revoke_privileges
    self._processMap["set_ugi"] = Processor.process_set_ugi
    self._processMap["get_delegation_token"] = Processor.process_get_delegation_token
    self._processMap["renew_delegation_token"] = Processor.process_renew_delegation_token
    self._processMap["cancel_delegation_token"] = Processor.process_cancel_delegation_token
    self._processMap["get_open_txns"] = Processor.process_get_open_txns
    self._processMap["get_open_txns_info"] = Processor.process_get_open_txns_info
    self._processMap["open_txns"] = Processor.process_open_txns
    self._processMap["abort_txn"] = Processor.process_abort_txn
    self._processMap["commit_txn"] = Processor.process_commit_txn
    self._processMap["lock"] = Processor.process_lock
    self._processMap["check_lock"] = Processor.process_check_lock
    self._processMap["unlock"] = Processor.process_unlock
    self._processMap["show_locks"] = Processor.process_show_locks
    self._processMap["heartbeat"] = Processor.process_heartbeat
    self._processMap["heartbeat_txn_range"] = Processor.process_heartbeat_txn_range
    self._processMap["compact"] = Processor.process_compact
    self._processMap["show_compact"] = Processor.process_show_compact
    self._processMap["add_dynamic_partitions"] = Processor.process_add_dynamic_partitions
    self._processMap["get_next_notification"] = Processor.process_get_next_notification
    self._processMap["get_current_notificationEventId"] = Processor.process_get_current_notificationEventId
    self._processMap["fire_listener_event"] = Processor.process_fire_listener_event
    self._processMap["flushCache"] = Processor.process_flushCache
    self._processMap["get_file_metadata_by_expr"] = Processor.process_get_file_metadata_by_expr
    self._processMap["get_file_metadata"] = Processor.process_get_file_metadata
    self._processMap["put_file_metadata"] = Processor.process_put_file_metadata
    self._processMap["clear_file_metadata"] = Processor.process_clear_file_metadata

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_getMetaConf(self, seqid, iprot, oprot):
    args = getMetaConf_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMetaConf_result()
    try:
      result.success = self._handler.getMetaConf(args.key)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getMetaConf", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setMetaConf(self, seqid, iprot, oprot):
    args = setMetaConf_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setMetaConf_result()
    try:
      self._handler.setMetaConf(args.key, args.value)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setMetaConf", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_database(self, seqid, iprot, oprot):
    args = create_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_database_result()
    try:
      self._handler.create_database(args.database)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_database", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_database(self, seqid, iprot, oprot):
    args = get_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_database_result()
    try:
      result.success = self._handler.get_database(args.name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_database", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_database(self, seqid, iprot, oprot):
    args = drop_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_database_result()
    try:
      self._handler.drop_database(args.name, args.deleteData, args.cascade)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_database", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_databases(self, seqid, iprot, oprot):
    args = get_databases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_databases_result()
    try:
      result.success = self._handler.get_databases(args.pattern)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_databases", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_databases(self, seqid, iprot, oprot):
    args = get_all_databases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_databases_result()
    try:
      result.success = self._handler.get_all_databases()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_all_databases", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_database(self, seqid, iprot, oprot):
    args = alter_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_database_result()
    try:
      self._handler.alter_database(args.dbname, args.db)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_database", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_type(self, seqid, iprot, oprot):
    args = get_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_type_result()
    try:
      result.success = self._handler.get_type(args.name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_type", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_type(self, seqid, iprot, oprot):
    args = create_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_type_result()
    try:
      result.success = self._handler.create_type(args.type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_type", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_type(self, seqid, iprot, oprot):
    args = drop_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_type_result()
    try:
      result.success = self._handler.drop_type(args.type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_type", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_type_all(self, seqid, iprot, oprot):
    args = get_type_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_type_all_result()
    try:
      result.success = self._handler.get_type_all(args.name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_type_all", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_fields(self, seqid, iprot, oprot):
    args = get_fields_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_fields_result()
    try:
      result.success = self._handler.get_fields(args.db_name, args.table_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except UnknownTableException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_fields", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_fields_with_environment_context(self, seqid, iprot, oprot):
    args = get_fields_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_fields_with_environment_context_result()
    try:
      result.success = self._handler.get_fields_with_environment_context(args.db_name, args.table_name, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except UnknownTableException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_fields_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_schema(self, seqid, iprot, oprot):
    args = get_schema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_schema_result()
    try:
      result.success = self._handler.get_schema(args.db_name, args.table_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except UnknownTableException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_schema", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_schema_with_environment_context(self, seqid, iprot, oprot):
    args = get_schema_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_schema_with_environment_context_result()
    try:
      result.success = self._handler.get_schema_with_environment_context(args.db_name, args.table_name, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except UnknownTableException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_schema_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table(self, seqid, iprot, oprot):
    args = create_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_result()
    try:
      self._handler.create_table(args.tbl)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except NoSuchObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_table", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table_with_environment_context(self, seqid, iprot, oprot):
    args = create_table_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_with_environment_context_result()
    try:
      self._handler.create_table_with_environment_context(args.tbl, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except NoSuchObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_table_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_table(self, seqid, iprot, oprot):
    args = drop_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_table_result()
    try:
      self._handler.drop_table(args.dbname, args.name, args.deleteData)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_table", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_table_with_environment_context(self, seqid, iprot, oprot):
    args = drop_table_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_table_with_environment_context_result()
    try:
      self._handler.drop_table_with_environment_context(args.dbname, args.name, args.deleteData, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_table_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_tables(self, seqid, iprot, oprot):
    args = get_tables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_tables_result()
    try:
      result.success = self._handler.get_tables(args.db_name, args.pattern)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_tables", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_meta(self, seqid, iprot, oprot):
    args = get_table_meta_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_meta_result()
    try:
      result.success = self._handler.get_table_meta(args.db_patterns, args.tbl_patterns, args.tbl_types)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_meta", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_tables(self, seqid, iprot, oprot):
    args = get_all_tables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_tables_result()
    try:
      result.success = self._handler.get_all_tables(args.db_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_all_tables", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table(self, seqid, iprot, oprot):
    args = get_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_result()
    try:
      result.success = self._handler.get_table(args.dbname, args.tbl_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_objects_by_name(self, seqid, iprot, oprot):
    args = get_table_objects_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_objects_by_name_result()
    try:
      result.success = self._handler.get_table_objects_by_name(args.dbname, args.tbl_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_objects_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_names_by_filter(self, seqid, iprot, oprot):
    args = get_table_names_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_names_by_filter_result()
    try:
      result.success = self._handler.get_table_names_by_filter(args.dbname, args.filter, args.max_tables)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_names_by_filter", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table(self, seqid, iprot, oprot):
    args = alter_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_result()
    try:
      self._handler.alter_table(args.dbname, args.tbl_name, args.new_tbl)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_table", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table_with_environment_context(self, seqid, iprot, oprot):
    args = alter_table_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_with_environment_context_result()
    try:
      self._handler.alter_table_with_environment_context(args.dbname, args.tbl_name, args.new_tbl, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_table_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table_with_cascade(self, seqid, iprot, oprot):
    args = alter_table_with_cascade_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_with_cascade_result()
    try:
      self._handler.alter_table_with_cascade(args.dbname, args.tbl_name, args.new_tbl, args.cascade)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_table_with_cascade", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition(self, seqid, iprot, oprot):
    args = add_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_result()
    try:
      result.success = self._handler.add_partition(args.new_part)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition_with_environment_context(self, seqid, iprot, oprot):
    args = add_partition_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_with_environment_context_result()
    try:
      result.success = self._handler.add_partition_with_environment_context(args.new_part, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_partition_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partitions(self, seqid, iprot, oprot):
    args = add_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partitions_result()
    try:
      result.success = self._handler.add_partitions(args.new_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_partitions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partitions_pspec(self, seqid, iprot, oprot):
    args = add_partitions_pspec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partitions_pspec_result()
    try:
      result.success = self._handler.add_partitions_pspec(args.new_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_partitions_pspec", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition(self, seqid, iprot, oprot):
    args = append_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_result()
    try:
      result.success = self._handler.append_partition(args.db_name, args.tbl_name, args.part_vals)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("append_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partitions_req(self, seqid, iprot, oprot):
    args = add_partitions_req_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partitions_req_result()
    try:
      result.success = self._handler.add_partitions_req(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_partitions_req", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition_with_environment_context(self, seqid, iprot, oprot):
    args = append_partition_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_with_environment_context_result()
    try:
      result.success = self._handler.append_partition_with_environment_context(args.db_name, args.tbl_name, args.part_vals, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("append_partition_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition_by_name(self, seqid, iprot, oprot):
    args = append_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_by_name_result()
    try:
      result.success = self._handler.append_partition_by_name(args.db_name, args.tbl_name, args.part_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("append_partition_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition_by_name_with_environment_context(self, seqid, iprot, oprot):
    args = append_partition_by_name_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_by_name_with_environment_context_result()
    try:
      result.success = self._handler.append_partition_by_name_with_environment_context(args.db_name, args.tbl_name, args.part_name, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("append_partition_by_name_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition(self, seqid, iprot, oprot):
    args = drop_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_result()
    try:
      result.success = self._handler.drop_partition(args.db_name, args.tbl_name, args.part_vals, args.deleteData)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_with_environment_context(self, seqid, iprot, oprot):
    args = drop_partition_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_with_environment_context_result()
    try:
      result.success = self._handler.drop_partition_with_environment_context(args.db_name, args.tbl_name, args.part_vals, args.deleteData, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_partition_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_by_name(self, seqid, iprot, oprot):
    args = drop_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_by_name_result()
    try:
      result.success = self._handler.drop_partition_by_name(args.db_name, args.tbl_name, args.part_name, args.deleteData)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_partition_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_by_name_with_environment_context(self, seqid, iprot, oprot):
    args = drop_partition_by_name_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_by_name_with_environment_context_result()
    try:
      result.success = self._handler.drop_partition_by_name_with_environment_context(args.db_name, args.tbl_name, args.part_name, args.deleteData, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_partition_by_name_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partitions_req(self, seqid, iprot, oprot):
    args = drop_partitions_req_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partitions_req_result()
    try:
      result.success = self._handler.drop_partitions_req(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_partitions_req", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition(self, seqid, iprot, oprot):
    args = get_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_result()
    try:
      result.success = self._handler.get_partition(args.db_name, args.tbl_name, args.part_vals)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_exchange_partition(self, seqid, iprot, oprot):
    args = exchange_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = exchange_partition_result()
    try:
      result.success = self._handler.exchange_partition(args.partitionSpecs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("exchange_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_exchange_partitions(self, seqid, iprot, oprot):
    args = exchange_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = exchange_partitions_result()
    try:
      result.success = self._handler.exchange_partitions(args.partitionSpecs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("exchange_partitions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_with_auth(self, seqid, iprot, oprot):
    args = get_partition_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_with_auth_result()
    try:
      result.success = self._handler.get_partition_with_auth(args.db_name, args.tbl_name, args.part_vals, args.user_name, args.group_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_with_auth", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_by_name(self, seqid, iprot, oprot):
    args = get_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_by_name_result()
    try:
      result.success = self._handler.get_partition_by_name(args.db_name, args.tbl_name, args.part_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions(self, seqid, iprot, oprot):
    args = get_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_result()
    try:
      result.success = self._handler.get_partitions(args.db_name, args.tbl_name, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_with_auth(self, seqid, iprot, oprot):
    args = get_partitions_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_with_auth_result()
    try:
      result.success = self._handler.get_partitions_with_auth(args.db_name, args.tbl_name, args.max_parts, args.user_name, args.group_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_with_auth", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_pspec(self, seqid, iprot, oprot):
    args = get_partitions_pspec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_pspec_result()
    try:
      result.success = self._handler.get_partitions_pspec(args.db_name, args.tbl_name, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_pspec", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_names(self, seqid, iprot, oprot):
    args = get_partition_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_names_result()
    try:
      result.success = self._handler.get_partition_names(args.db_name, args.tbl_name, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_names", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_ps(self, seqid, iprot, oprot):
    args = get_partitions_ps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_ps_result()
    try:
      result.success = self._handler.get_partitions_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_ps", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_ps_with_auth(self, seqid, iprot, oprot):
    args = get_partitions_ps_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_ps_with_auth_result()
    try:
      result.success = self._handler.get_partitions_ps_with_auth(args.db_name, args.tbl_name, args.part_vals, args.max_parts, args.user_name, args.group_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_ps_with_auth", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_names_ps(self, seqid, iprot, oprot):
    args = get_partition_names_ps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_names_ps_result()
    try:
      result.success = self._handler.get_partition_names_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_names_ps", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_by_filter(self, seqid, iprot, oprot):
    args = get_partitions_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_by_filter_result()
    try:
      result.success = self._handler.get_partitions_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_by_filter", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_part_specs_by_filter(self, seqid, iprot, oprot):
    args = get_part_specs_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_part_specs_by_filter_result()
    try:
      result.success = self._handler.get_part_specs_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_part_specs_by_filter", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_by_expr(self, seqid, iprot, oprot):
    args = get_partitions_by_expr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_by_expr_result()
    try:
      result.success = self._handler.get_partitions_by_expr(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_by_expr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_by_names(self, seqid, iprot, oprot):
    args = get_partitions_by_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_by_names_result()
    try:
      result.success = self._handler.get_partitions_by_names(args.db_name, args.tbl_name, args.names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_by_names", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partition(self, seqid, iprot, oprot):
    args = alter_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partition_result()
    try:
      self._handler.alter_partition(args.db_name, args.tbl_name, args.new_part)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partitions(self, seqid, iprot, oprot):
    args = alter_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partitions_result()
    try:
      self._handler.alter_partitions(args.db_name, args.tbl_name, args.new_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_partitions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partition_with_environment_context(self, seqid, iprot, oprot):
    args = alter_partition_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partition_with_environment_context_result()
    try:
      self._handler.alter_partition_with_environment_context(args.db_name, args.tbl_name, args.new_part, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_partition_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rename_partition(self, seqid, iprot, oprot):
    args = rename_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rename_partition_result()
    try:
      self._handler.rename_partition(args.db_name, args.tbl_name, args.part_vals, args.new_part)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("rename_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_has_valid_characters(self, seqid, iprot, oprot):
    args = partition_name_has_valid_characters_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_has_valid_characters_result()
    try:
      result.success = self._handler.partition_name_has_valid_characters(args.part_vals, args.throw_exception)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("partition_name_has_valid_characters", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_config_value(self, seqid, iprot, oprot):
    args = get_config_value_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_config_value_result()
    try:
      result.success = self._handler.get_config_value(args.name, args.defaultValue)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ConfigValSecurityException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_config_value", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_to_vals(self, seqid, iprot, oprot):
    args = partition_name_to_vals_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_to_vals_result()
    try:
      result.success = self._handler.partition_name_to_vals(args.part_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("partition_name_to_vals", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_to_spec(self, seqid, iprot, oprot):
    args = partition_name_to_spec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_to_spec_result()
    try:
      result.success = self._handler.partition_name_to_spec(args.part_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("partition_name_to_spec", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_markPartitionForEvent(self, seqid, iprot, oprot):
    args = markPartitionForEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = markPartitionForEvent_result()
    try:
      self._handler.markPartitionForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except UnknownTableException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except UnknownPartitionException as o5:
      msg_type = TMessageType.REPLY
      result.o5 = o5
    except InvalidPartitionException as o6:
      msg_type = TMessageType.REPLY
      result.o6 = o6
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("markPartitionForEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isPartitionMarkedForEvent(self, seqid, iprot, oprot):
    args = isPartitionMarkedForEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isPartitionMarkedForEvent_result()
    try:
      result.success = self._handler.isPartitionMarkedForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except UnknownTableException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except UnknownPartitionException as o5:
      msg_type = TMessageType.REPLY
      result.o5 = o5
    except InvalidPartitionException as o6:
      msg_type = TMessageType.REPLY
      result.o6 = o6
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("isPartitionMarkedForEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_index(self, seqid, iprot, oprot):
    args = add_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_index_result()
    try:
      result.success = self._handler.add_index(args.new_index, args.index_table)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_index", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_index(self, seqid, iprot, oprot):
    args = alter_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_index_result()
    try:
      self._handler.alter_index(args.dbname, args.base_tbl_name, args.idx_name, args.new_idx)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_index", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_index_by_name(self, seqid, iprot, oprot):
    args = drop_index_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_index_by_name_result()
    try:
      result.success = self._handler.drop_index_by_name(args.db_name, args.tbl_name, args.index_name, args.deleteData)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_index_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_index_by_name(self, seqid, iprot, oprot):
    args = get_index_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_index_by_name_result()
    try:
      result.success = self._handler.get_index_by_name(args.db_name, args.tbl_name, args.index_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_index_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_indexes(self, seqid, iprot, oprot):
    args = get_indexes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_indexes_result()
    try:
      result.success = self._handler.get_indexes(args.db_name, args.tbl_name, args.max_indexes)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_indexes", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_index_names(self, seqid, iprot, oprot):
    args = get_index_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_index_names_result()
    try:
      result.success = self._handler.get_index_names(args.db_name, args.tbl_name, args.max_indexes)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_index_names", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_table_column_statistics(self, seqid, iprot, oprot):
    args = update_table_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_table_column_statistics_result()
    try:
      result.success = self._handler.update_table_column_statistics(args.stats_obj)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("update_table_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_partition_column_statistics(self, seqid, iprot, oprot):
    args = update_partition_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_partition_column_statistics_result()
    try:
      result.success = self._handler.update_partition_column_statistics(args.stats_obj)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("update_partition_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_column_statistics(self, seqid, iprot, oprot):
    args = get_table_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_column_statistics_result()
    try:
      result.success = self._handler.get_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidInputException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_column_statistics(self, seqid, iprot, oprot):
    args = get_partition_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_column_statistics_result()
    try:
      result.success = self._handler.get_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidInputException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_statistics_req(self, seqid, iprot, oprot):
    args = get_table_statistics_req_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_statistics_req_result()
    try:
      result.success = self._handler.get_table_statistics_req(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_statistics_req", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_statistics_req(self, seqid, iprot, oprot):
    args = get_partitions_statistics_req_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_statistics_req_result()
    try:
      result.success = self._handler.get_partitions_statistics_req(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_statistics_req", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_aggr_stats_for(self, seqid, iprot, oprot):
    args = get_aggr_stats_for_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_aggr_stats_for_result()
    try:
      result.success = self._handler.get_aggr_stats_for(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_aggr_stats_for", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_aggr_stats_for(self, seqid, iprot, oprot):
    args = set_aggr_stats_for_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_aggr_stats_for_result()
    try:
      result.success = self._handler.set_aggr_stats_for(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("set_aggr_stats_for", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_partition_column_statistics(self, seqid, iprot, oprot):
    args = delete_partition_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_partition_column_statistics_result()
    try:
      result.success = self._handler.delete_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("delete_partition_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_table_column_statistics(self, seqid, iprot, oprot):
    args = delete_table_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_table_column_statistics_result()
    try:
      result.success = self._handler.delete_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("delete_table_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_function(self, seqid, iprot, oprot):
    args = create_function_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_function_result()
    try:
      self._handler.create_function(args.func)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except NoSuchObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_function", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_function(self, seqid, iprot, oprot):
    args = drop_function_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_function_result()
    try:
      self._handler.drop_function(args.dbName, args.funcName)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_function", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_function(self, seqid, iprot, oprot):
    args = alter_function_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_function_result()
    try:
      self._handler.alter_function(args.dbName, args.funcName, args.newFunc)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_function", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_functions(self, seqid, iprot, oprot):
    args = get_functions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_functions_result()
    try:
      result.success = self._handler.get_functions(args.dbName, args.pattern)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_functions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_function(self, seqid, iprot, oprot):
    args = get_function_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_function_result()
    try:
      result.success = self._handler.get_function(args.dbName, args.funcName)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_function", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_functions(self, seqid, iprot, oprot):
    args = get_all_functions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_functions_result()
    try:
      result.success = self._handler.get_all_functions()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_all_functions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_role(self, seqid, iprot, oprot):
    args = create_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_role_result()
    try:
      result.success = self._handler.create_role(args.role)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_role(self, seqid, iprot, oprot):
    args = drop_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_role_result()
    try:
      result.success = self._handler.drop_role(args.role_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_role_names(self, seqid, iprot, oprot):
    args = get_role_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_role_names_result()
    try:
      result.success = self._handler.get_role_names()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_role_names", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_role(self, seqid, iprot, oprot):
    args = grant_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_role_result()
    try:
      result.success = self._handler.grant_role(args.role_name, args.principal_name, args.principal_type, args.grantor, args.grantorType, args.grant_option)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("grant_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revoke_role(self, seqid, iprot, oprot):
    args = revoke_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revoke_role_result()
    try:
      result.success = self._handler.revoke_role(args.role_name, args.principal_name, args.principal_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revoke_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_roles(self, seqid, iprot, oprot):
    args = list_roles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_roles_result()
    try:
      result.success = self._handler.list_roles(args.principal_name, args.principal_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("list_roles", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_revoke_role(self, seqid, iprot, oprot):
    args = grant_revoke_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_revoke_role_result()
    try:
      result.success = self._handler.grant_revoke_role(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("grant_revoke_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_principals_in_role(self, seqid, iprot, oprot):
    args = get_principals_in_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_principals_in_role_result()
    try:
      result.success = self._handler.get_principals_in_role(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_principals_in_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_role_grants_for_principal(self, seqid, iprot, oprot):
    args = get_role_grants_for_principal_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_role_grants_for_principal_result()
    try:
      result.success = self._handler.get_role_grants_for_principal(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_role_grants_for_principal", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_privilege_set(self, seqid, iprot, oprot):
    args = get_privilege_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_privilege_set_result()
    try:
      result.success = self._handler.get_privilege_set(args.hiveObject, args.user_name, args.group_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_privilege_set", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_privileges(self, seqid, iprot, oprot):
    args = list_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_privileges_result()
    try:
      result.success = self._handler.list_privileges(args.principal_name, args.principal_type, args.hiveObject)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("list_privileges", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_privileges(self, seqid, iprot, oprot):
    args = grant_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_privileges_result()
    try:
      result.success = self._handler.grant_privileges(args.privileges)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("grant_privileges", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revoke_privileges(self, seqid, iprot, oprot):
    args = revoke_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revoke_privileges_result()
    try:
      result.success = self._handler.revoke_privileges(args.privileges)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revoke_privileges", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_revoke_privileges(self, seqid, iprot, oprot):
    args = grant_revoke_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_revoke_privileges_result()
    try:
      result.success = self._handler.grant_revoke_privileges(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("grant_revoke_privileges", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_ugi(self, seqid, iprot, oprot):
    args = set_ugi_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_ugi_result()
    try:
      result.success = self._handler.set_ugi(args.user_name, args.group_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("set_ugi", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_delegation_token(self, seqid, iprot, oprot):
    args = get_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_delegation_token_result()
    try:
      result.success = self._handler.get_delegation_token(args.token_owner, args.renewer_kerberos_principal_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_delegation_token", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_renew_delegation_token(self, seqid, iprot, oprot):
    args = renew_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = renew_delegation_token_result()
    try:
      result.success = self._handler.renew_delegation_token(args.token_str_form)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("renew_delegation_token", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cancel_delegation_token(self, seqid, iprot, oprot):
    args = cancel_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cancel_delegation_token_result()
    try:
      self._handler.cancel_delegation_token(args.token_str_form)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("cancel_delegation_token", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_open_txns(self, seqid, iprot, oprot):
    args = get_open_txns_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_open_txns_result()
    try:
      result.success = self._handler.get_open_txns()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_open_txns", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_open_txns_info(self, seqid, iprot, oprot):
    args = get_open_txns_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_open_txns_info_result()
    try:
      result.success = self._handler.get_open_txns_info()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_open_txns_info", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_open_txns(self, seqid, iprot, oprot):
    args = open_txns_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = open_txns_result()
    try:
      result.success = self._handler.open_txns(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("open_txns", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_abort_txn(self, seqid, iprot, oprot):
    args = abort_txn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = abort_txn_result()
    try:
      self._handler.abort_txn(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("abort_txn", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_commit_txn(self, seqid, iprot, oprot):
    args = commit_txn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = commit_txn_result()
    try:
      self._handler.commit_txn(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except TxnAbortedException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("commit_txn", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_lock(self, seqid, iprot, oprot):
    args = lock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = lock_result()
    try:
      result.success = self._handler.lock(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except TxnAbortedException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("lock", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_check_lock(self, seqid, iprot, oprot):
    args = check_lock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = check_lock_result()
    try:
      result.success = self._handler.check_lock(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except TxnAbortedException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except NoSuchLockException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("check_lock", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unlock(self, seqid, iprot, oprot):
    args = unlock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unlock_result()
    try:
      self._handler.unlock(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchLockException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except TxnOpenException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("unlock", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_show_locks(self, seqid, iprot, oprot):
    args = show_locks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = show_locks_result()
    try:
      result.success = self._handler.show_locks(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("show_locks", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_heartbeat(self, seqid, iprot, oprot):
    args = heartbeat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = heartbeat_result()
    try:
      self._handler.heartbeat(args.ids)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchLockException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchTxnException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except TxnAbortedException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("heartbeat", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_heartbeat_txn_range(self, seqid, iprot, oprot):
    args = heartbeat_txn_range_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = heartbeat_txn_range_result()
    try:
      result.success = self._handler.heartbeat_txn_range(args.txns)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("heartbeat_txn_range", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_compact(self, seqid, iprot, oprot):
    args = compact_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = compact_result()
    try:
      self._handler.compact(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("compact", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_show_compact(self, seqid, iprot, oprot):
    args = show_compact_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = show_compact_result()
    try:
      result.success = self._handler.show_compact(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("show_compact", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_dynamic_partitions(self, seqid, iprot, oprot):
    args = add_dynamic_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_dynamic_partitions_result()
    try:
      self._handler.add_dynamic_partitions(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except TxnAbortedException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_dynamic_partitions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_next_notification(self, seqid, iprot, oprot):
    args = get_next_notification_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_next_notification_result()
    try:
      result.success = self._handler.get_next_notification(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_next_notification", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_current_notificationEventId(self, seqid, iprot, oprot):
    args = get_current_notificationEventId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_current_notificationEventId_result()
    try:
      result.success = self._handler.get_current_notificationEventId()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_current_notificationEventId", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_fire_listener_event(self, seqid, iprot, oprot):
    args = fire_listener_event_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = fire_listener_event_result()
    try:
      result.success = self._handler.fire_listener_event(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("fire_listener_event", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_flushCache(self, seqid, iprot, oprot):
    args = flushCache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = flushCache_result()
    try:
      self._handler.flushCache()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("flushCache", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_file_metadata_by_expr(self, seqid, iprot, oprot):
    args = get_file_metadata_by_expr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_file_metadata_by_expr_result()
    try:
      result.success = self._handler.get_file_metadata_by_expr(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_file_metadata_by_expr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_file_metadata(self, seqid, iprot, oprot):
    args = get_file_metadata_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_file_metadata_result()
    try:
      result.success = self._handler.get_file_metadata(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_file_metadata", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_put_file_metadata(self, seqid, iprot, oprot):
    args = put_file_metadata_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = put_file_metadata_result()
    try:
      result.success = self._handler.put_file_metadata(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("put_file_metadata", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clear_file_metadata(self, seqid, iprot, oprot):
    args = clear_file_metadata_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clear_file_metadata_result()
    try:
      result.success = self._handler.clear_file_metadata(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clear_file_metadata", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class getMetaConf_args:
  """
  Attributes:
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
  )

  def __init__(self, key=None,):
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMetaConf_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMetaConf_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMetaConf_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setMetaConf_args:
  """
  Attributes:
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, key=None, value=None,):
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setMetaConf_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setMetaConf_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setMetaConf_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_database_args:
  """
  Attributes:
   - database
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'database', (Database, Database.thrift_spec), None, ), # 1
  )

  def __init__(self, database=None,):
    self.database = database

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.database = Database()
          self.database.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_database_args')
    if self.database is not None:
      oprot.writeFieldBegin('database', TType.STRUCT, 1)
      self.database.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.database)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_database_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_database_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_database_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_database_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Database, Database.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Database()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_database_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_database_args:
  """
  Attributes:
   - name
   - deleteData
   - cascade
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.BOOL, 'deleteData', None, None, ), # 2
    (3, TType.BOOL, 'cascade', None, None, ), # 3
  )

  def __init__(self, name=None, deleteData=None, cascade=None,):
    self.name = name
    self.deleteData = deleteData
    self.cascade = cascade

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.cascade = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_database_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 2)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.cascade is not None:
      oprot.writeFieldBegin('cascade', TType.BOOL, 3)
      oprot.writeBool(self.cascade)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.cascade)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_database_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_databases_args:
  """
  Attributes:
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pattern', None, None, ), # 1
  )

  def __init__(self, pattern=None,):
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pattern = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_databases_args')
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 1)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pattern)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_databases_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype525, _size522) = iprot.readListBegin()
          for _i526 in xrange(_size522):
            _elem527 = iprot.readString()
            self.success.append(_elem527)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_databases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter528 in self.success:
        oprot.writeString(iter528)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_databases_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_databases_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_databases_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype532, _size529) = iprot.readListBegin()
          for _i533 in xrange(_size529):
            _elem534 = iprot.readString()
            self.success.append(_elem534)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_databases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter535 in self.success:
        oprot.writeString(iter535)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_database_args:
  """
  Attributes:
   - dbname
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRUCT, 'db', (Database, Database.thrift_spec), None, ), # 2
  )

  def __init__(self, dbname=None, db=None,):
    self.dbname = dbname
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.db = Database()
          self.db.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_database_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRUCT, 2)
      self.db.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.db)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_database_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Type, Type.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Type()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_type_args:
  """
  Attributes:
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'type', (Type, Type.thrift_spec), None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.type = Type()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_type_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRUCT, 1)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_type_args:
  """
  Attributes:
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type', None, None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_type_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 1)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_all_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_all_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_all_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Type, Type.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype537, _vtype538, _size536 ) = iprot.readMapBegin()
          for _i540 in xrange(_size536):
            _key541 = iprot.readString()
            _val542 = Type()
            _val542.read(iprot)
            self.success[_key541] = _val542
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter543,viter544 in self.success.items():
        oprot.writeString(kiter543)
        viter544.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_args:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype548, _size545) = iprot.readListBegin()
          for _i549 in xrange(_size545):
            _elem550 = FieldSchema()
            _elem550.read(iprot)
            self.success.append(_elem550)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter551 in self.success:
        iter551.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_with_environment_context_args:
  """
  Attributes:
   - db_name
   - table_name
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 3
  )

  def __init__(self, db_name=None, table_name=None, environment_context=None,):
    self.db_name = db_name
    self.table_name = table_name
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 3)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype555, _size552) = iprot.readListBegin()
          for _i556 in xrange(_size552):
            _elem557 = FieldSchema()
            _elem557.read(iprot)
            self.success.append(_elem557)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter558 in self.success:
        iter558.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_args:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype562, _size559) = iprot.readListBegin()
          for _i563 in xrange(_size559):
            _elem564 = FieldSchema()
            _elem564.read(iprot)
            self.success.append(_elem564)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter565 in self.success:
        iter565.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_with_environment_context_args:
  """
  Attributes:
   - db_name
   - table_name
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 3
  )

  def __init__(self, db_name=None, table_name=None, environment_context=None,):
    self.db_name = db_name
    self.table_name = table_name
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 3)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype569, _size566) = iprot.readListBegin()
          for _i570 in xrange(_size566):
            _elem571 = FieldSchema()
            _elem571.read(iprot)
            self.success.append(_elem571)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter572 in self.success:
        iter572.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_args:
  """
  Attributes:
   - tbl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
  )

  def __init__(self, tbl=None,):
    self.tbl = tbl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tbl)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_with_environment_context_args:
  """
  Attributes:
   - tbl
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 2
  )

  def __init__(self, tbl=None, environment_context=None,):
    self.tbl = tbl
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_with_environment_context_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 2)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tbl)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_with_environment_context_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_args:
  """
  Attributes:
   - dbname
   - name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.BOOL, 'deleteData', None, None, ), # 3
  )

  def __init__(self, dbname=None, name=None, deleteData=None,):
    self.dbname = dbname
    self.name = name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.deleteData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_result:
  """
  Attributes:
   - o1
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o3=None,):
    self.o1 = o1
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 2)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_with_environment_context_args:
  """
  Attributes:
   - dbname
   - name
   - deleteData
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.BOOL, 'deleteData', None, None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, dbname=None, name=None, deleteData=None, environment_context=None,):
    self.dbname = dbname
    self.name = name
    self.deleteData = deleteData
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_with_environment_context_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_with_environment_context_result:
  """
  Attributes:
   - o1
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o3=None,):
    self.o1 = o1
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 2)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_args:
  """
  Attributes:
   - db_name
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
  )

  def __init__(self, db_name=None, pattern=None,):
    self.db_name = db_name
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.pattern)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype576, _size573) = iprot.readListBegin()
          for _i577 in xrange(_size573):
            _elem578 = iprot.readString()
            self.success.append(_elem578)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter579 in self.success:
        oprot.writeString(iter579)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_meta_args:
  """
  Attributes:
   - db_patterns
   - tbl_patterns
   - tbl_types
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_patterns', None, None, ), # 1
    (2, TType.STRING, 'tbl_patterns', None, None, ), # 2
    (3, TType.LIST, 'tbl_types', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_patterns=None, tbl_patterns=None, tbl_types=None,):
    self.db_patterns = db_patterns
    self.tbl_patterns = tbl_patterns
    self.tbl_types = tbl_types

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_patterns = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_patterns = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tbl_types = []
          (_etype583, _size580) = iprot.readListBegin()
          for _i584 in xrange(_size580):
            _elem585 = iprot.readString()
            self.tbl_types.append(_elem585)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_meta_args')
    if self.db_patterns is not None:
      oprot.writeFieldBegin('db_patterns', TType.STRING, 1)
      oprot.writeString(self.db_patterns)
      oprot.writeFieldEnd()
    if self.tbl_patterns is not None:
      oprot.writeFieldBegin('tbl_patterns', TType.STRING, 2)
      oprot.writeString(self.tbl_patterns)
      oprot.writeFieldEnd()
    if self.tbl_types is not None:
      oprot.writeFieldBegin('tbl_types', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.tbl_types))
      for iter586 in self.tbl_types:
        oprot.writeString(iter586)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_patterns)
    value = (value * 31) ^ hash(self.tbl_patterns)
    value = (value * 31) ^ hash(self.tbl_types)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_meta_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TableMeta, TableMeta.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype590, _size587) = iprot.readListBegin()
          for _i591 in xrange(_size587):
            _elem592 = TableMeta()
            _elem592.read(iprot)
            self.success.append(_elem592)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_meta_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter593 in self.success:
        iter593.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_tables_args:
  """
  Attributes:
   - db_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
  )

  def __init__(self, db_name=None,):
    self.db_name = db_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_tables_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_tables_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype597, _size594) = iprot.readListBegin()
          for _i598 in xrange(_size594):
            _elem599 = iprot.readString()
            self.success.append(_elem599)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_tables_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter600 in self.success:
        oprot.writeString(iter600)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_args:
  """
  Attributes:
   - dbname
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, dbname=None, tbl_name=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Table, Table.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Table()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_objects_by_name_args:
  """
  Attributes:
   - dbname
   - tbl_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.LIST, 'tbl_names', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, dbname=None, tbl_names=None,):
    self.dbname = dbname
    self.tbl_names = tbl_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tbl_names = []
          (_etype604, _size601) = iprot.readListBegin()
          for _i605 in xrange(_size601):
            _elem606 = iprot.readString()
            self.tbl_names.append(_elem606)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_objects_by_name_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_names is not None:
      oprot.writeFieldBegin('tbl_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.tbl_names))
      for iter607 in self.tbl_names:
        oprot.writeString(iter607)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_objects_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Table, Table.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype611, _size608) = iprot.readListBegin()
          for _i612 in xrange(_size608):
            _elem613 = Table()
            _elem613.read(iprot)
            self.success.append(_elem613)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_objects_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter614 in self.success:
        iter614.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_names_by_filter_args:
  """
  Attributes:
   - dbname
   - filter
   - max_tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'filter', None, None, ), # 2
    (3, TType.I16, 'max_tables', None, -1, ), # 3
  )

  def __init__(self, dbname=None, filter=None, max_tables=thrift_spec[3][4],):
    self.dbname = dbname
    self.filter = filter
    self.max_tables = max_tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_tables = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_names_by_filter_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 2)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.max_tables is not None:
      oprot.writeFieldBegin('max_tables', TType.I16, 3)
      oprot.writeI16(self.max_tables)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.max_tables)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_names_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype618, _size615) = iprot.readListBegin()
          for _i619 in xrange(_size615):
            _elem620 = iprot.readString()
            self.success.append(_elem620)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_names_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter621 in self.success:
        oprot.writeString(iter621)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - new_tbl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ), # 3
  )

  def __init__(self, dbname=None, tbl_name=None, new_tbl=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.new_tbl = new_tbl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_tbl = Table()
          self.new_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_tbl is not None:
      oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
      self.new_tbl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_tbl)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_with_environment_context_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - new_tbl
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, dbname=None, tbl_name=None, new_tbl=None, environment_context=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.new_tbl = new_tbl
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_tbl = Table()
          self.new_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_with_environment_context_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_tbl is not None:
      oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
      self.new_tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_tbl)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_with_environment_context_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_with_cascade_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - new_tbl
   - cascade
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'cascade', None, None, ), # 4
  )

  def __init__(self, dbname=None, tbl_name=None, new_tbl=None, cascade=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.new_tbl = new_tbl
    self.cascade = cascade

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_tbl = Table()
          self.new_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.cascade = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_with_cascade_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_tbl is not None:
      oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
      self.new_tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.cascade is not None:
      oprot.writeFieldBegin('cascade', TType.BOOL, 4)
      oprot.writeBool(self.cascade)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_tbl)
    value = (value * 31) ^ hash(self.cascade)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_with_cascade_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_with_cascade_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_args:
  """
  Attributes:
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 1
  )

  def __init__(self, new_part=None,):
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_args')
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.new_part)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_with_environment_context_args:
  """
  Attributes:
   - new_part
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 2
  )

  def __init__(self, new_part=None, environment_context=None,):
    self.new_part = new_part
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_with_environment_context_args')
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 2)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.new_part)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_args:
  """
  Attributes:
   - new_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'new_parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, new_parts=None,):
    self.new_parts = new_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.new_parts = []
          (_etype625, _size622) = iprot.readListBegin()
          for _i626 in xrange(_size622):
            _elem627 = Partition()
            _elem627.read(iprot)
            self.new_parts.append(_elem627)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_args')
    if self.new_parts is not None:
      oprot.writeFieldBegin('new_parts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
      for iter628 in self.new_parts:
        iter628.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.new_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_pspec_args:
  """
  Attributes:
   - new_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'new_parts', (TType.STRUCT,(PartitionSpec, PartitionSpec.thrift_spec)), None, ), # 1
  )

  def __init__(self, new_parts=None,):
    self.new_parts = new_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.new_parts = []
          (_etype632, _size629) = iprot.readListBegin()
          for _i633 in xrange(_size629):
            _elem634 = PartitionSpec()
            _elem634.read(iprot)
            self.new_parts.append(_elem634)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_pspec_args')
    if self.new_parts is not None:
      oprot.writeFieldBegin('new_parts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
      for iter635 in self.new_parts:
        iter635.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.new_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_pspec_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_pspec_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype639, _size636) = iprot.readListBegin()
          for _i640 in xrange(_size636):
            _elem641 = iprot.readString()
            self.part_vals.append(_elem641)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter642 in self.part_vals:
        oprot.writeString(iter642)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_req_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (AddPartitionsRequest, AddPartitionsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = AddPartitionsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_req_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_req_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AddPartitionsResult, AddPartitionsResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AddPartitionsResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_req_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype646, _size643) = iprot.readListBegin()
          for _i647 in xrange(_size643):
            _elem648 = iprot.readString()
            self.part_vals.append(_elem648)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter649 in self.part_vals:
        oprot.writeString(iter649)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype653, _size650) = iprot.readListBegin()
          for _i654 in xrange(_size650):
            _elem655 = iprot.readString()
            self.part_vals.append(_elem655)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter656 in self.part_vals:
        oprot.writeString(iter656)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.deleteData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - deleteData
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
    (5, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.deleteData = deleteData
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype660, _size657) = iprot.readListBegin()
          for _i661 in xrange(_size657):
            _elem662 = iprot.readString()
            self.part_vals.append(_elem662)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter663 in self.part_vals:
        oprot.writeString(iter663)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 5)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    value = (value * 31) ^ hash(self.deleteData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - deleteData
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
    (5, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.deleteData = deleteData
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 5)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partitions_req_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (DropPartitionsRequest, DropPartitionsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = DropPartitionsRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partitions_req_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partitions_req_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DropPartitionsResult, DropPartitionsResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DropPartitionsResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partitions_req_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype667, _size664) = iprot.readListBegin()
          for _i668 in xrange(_size664):
            _elem669 = iprot.readString()
            self.part_vals.append(_elem669)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter670 in self.part_vals:
        oprot.writeString(iter670)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exchange_partition_args:
  """
  Attributes:
   - partitionSpecs
   - source_db
   - source_table_name
   - dest_db
   - dest_table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'partitionSpecs', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'source_db', None, None, ), # 2
    (3, TType.STRING, 'source_table_name', None, None, ), # 3
    (4, TType.STRING, 'dest_db', None, None, ), # 4
    (5, TType.STRING, 'dest_table_name', None, None, ), # 5
  )

  def __init__(self, partitionSpecs=None, source_db=None, source_table_name=None, dest_db=None, dest_table_name=None,):
    self.partitionSpecs = partitionSpecs
    self.source_db = source_db
    self.source_table_name = source_table_name
    self.dest_db = dest_db
    self.dest_table_name = dest_table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.partitionSpecs = {}
          (_ktype672, _vtype673, _size671 ) = iprot.readMapBegin()
          for _i675 in xrange(_size671):
            _key676 = iprot.readString()
            _val677 = iprot.readString()
            self.partitionSpecs[_key676] = _val677
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.source_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.source_table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dest_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.dest_table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exchange_partition_args')
    if self.partitionSpecs is not None:
      oprot.writeFieldBegin('partitionSpecs', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partitionSpecs))
      for kiter678,viter679 in self.partitionSpecs.items():
        oprot.writeString(kiter678)
        oprot.writeString(viter679)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.source_db is not None:
      oprot.writeFieldBegin('source_db', TType.STRING, 2)
      oprot.writeString(self.source_db)
      oprot.writeFieldEnd()
    if self.source_table_name is not None:
      oprot.writeFieldBegin('source_table_name', TType.STRING, 3)
      oprot.writeString(self.source_table_name)
      oprot.writeFieldEnd()
    if self.dest_db is not None:
      oprot.writeFieldBegin('dest_db', TType.STRING, 4)
      oprot.writeString(self.dest_db)
      oprot.writeFieldEnd()
    if self.dest_table_name is not None:
      oprot.writeFieldBegin('dest_table_name', TType.STRING, 5)
      oprot.writeString(self.dest_table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitionSpecs)
    value = (value * 31) ^ hash(self.source_db)
    value = (value * 31) ^ hash(self.source_table_name)
    value = (value * 31) ^ hash(self.dest_db)
    value = (value * 31) ^ hash(self.dest_table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exchange_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exchange_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exchange_partitions_args:
  """
  Attributes:
   - partitionSpecs
   - source_db
   - source_table_name
   - dest_db
   - dest_table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'partitionSpecs', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'source_db', None, None, ), # 2
    (3, TType.STRING, 'source_table_name', None, None, ), # 3
    (4, TType.STRING, 'dest_db', None, None, ), # 4
    (5, TType.STRING, 'dest_table_name', None, None, ), # 5
  )

  def __init__(self, partitionSpecs=None, source_db=None, source_table_name=None, dest_db=None, dest_table_name=None,):
    self.partitionSpecs = partitionSpecs
    self.source_db = source_db
    self.source_table_name = source_table_name
    self.dest_db = dest_db
    self.dest_table_name = dest_table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.partitionSpecs = {}
          (_ktype681, _vtype682, _size680 ) = iprot.readMapBegin()
          for _i684 in xrange(_size680):
            _key685 = iprot.readString()
            _val686 = iprot.readString()
            self.partitionSpecs[_key685] = _val686
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.source_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.source_table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dest_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.dest_table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exchange_partitions_args')
    if self.partitionSpecs is not None:
      oprot.writeFieldBegin('partitionSpecs', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partitionSpecs))
      for kiter687,viter688 in self.partitionSpecs.items():
        oprot.writeString(kiter687)
        oprot.writeString(viter688)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.source_db is not None:
      oprot.writeFieldBegin('source_db', TType.STRING, 2)
      oprot.writeString(self.source_db)
      oprot.writeFieldEnd()
    if self.source_table_name is not None:
      oprot.writeFieldBegin('source_table_name', TType.STRING, 3)
      oprot.writeString(self.source_table_name)
      oprot.writeFieldEnd()
    if self.dest_db is not None:
      oprot.writeFieldBegin('dest_db', TType.STRING, 4)
      oprot.writeString(self.dest_db)
      oprot.writeFieldEnd()
    if self.dest_table_name is not None:
      oprot.writeFieldBegin('dest_table_name', TType.STRING, 5)
      oprot.writeString(self.dest_table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitionSpecs)
    value = (value * 31) ^ hash(self.source_db)
    value = (value * 31) ^ hash(self.source_table_name)
    value = (value * 31) ^ hash(self.dest_db)
    value = (value * 31) ^ hash(self.dest_table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exchange_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype692, _size689) = iprot.readListBegin()
          for _i693 in xrange(_size689):
            _elem694 = Partition()
            _elem694.read(iprot)
            self.success.append(_elem694)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exchange_partitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter695 in self.success:
        iter695.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'user_name', None, None, ), # 4
    (5, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype699, _size696) = iprot.readListBegin()
          for _i700 in xrange(_size696):
            _elem701 = iprot.readString()
            self.part_vals.append(_elem701)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype705, _size702) = iprot.readListBegin()
          for _i706 in xrange(_size702):
            _elem707 = iprot.readString()
            self.group_names.append(_elem707)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter708 in self.part_vals:
        oprot.writeString(iter708)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 4)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter709 in self.group_names:
        oprot.writeString(iter709)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.user_name)
    value = (value * 31) ^ hash(self.group_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype713, _size710) = iprot.readListBegin()
          for _i714 in xrange(_size710):
            _elem715 = Partition()
            _elem715.read(iprot)
            self.success.append(_elem715)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter716 in self.success:
        iter716.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
    (4, TType.STRING, 'user_name', None, None, ), # 4
    (5, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4], user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype720, _size717) = iprot.readListBegin()
          for _i721 in xrange(_size717):
            _elem722 = iprot.readString()
            self.group_names.append(_elem722)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 4)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter723 in self.group_names:
        oprot.writeString(iter723)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_parts)
    value = (value * 31) ^ hash(self.user_name)
    value = (value * 31) ^ hash(self.group_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype727, _size724) = iprot.readListBegin()
          for _i728 in xrange(_size724):
            _elem729 = Partition()
            _elem729.read(iprot)
            self.success.append(_elem729)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter730 in self.success:
        iter730.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_pspec_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I32, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.max_parts = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_pspec_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I32, 3)
      oprot.writeI32(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_pspec_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(PartitionSpec, PartitionSpec.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype734, _size731) = iprot.readListBegin()
          for _i735 in xrange(_size731):
            _elem736 = PartitionSpec()
            _elem736.read(iprot)
            self.success.append(_elem736)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_pspec_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter737 in self.success:
        iter737.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype741, _size738) = iprot.readListBegin()
          for _i742 in xrange(_size738):
            _elem743 = iprot.readString()
            self.success.append(_elem743)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter744 in self.success:
        oprot.writeString(iter744)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype748, _size745) = iprot.readListBegin()
          for _i749 in xrange(_size745):
            _elem750 = iprot.readString()
            self.part_vals.append(_elem750)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter751 in self.part_vals:
        oprot.writeString(iter751)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype755, _size752) = iprot.readListBegin()
          for _i756 in xrange(_size752):
            _elem757 = Partition()
            _elem757.read(iprot)
            self.success.append(_elem757)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter758 in self.success:
        iter758.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
    (5, TType.STRING, 'user_name', None, None, ), # 5
    (6, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 6
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4], user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype762, _size759) = iprot.readListBegin()
          for _i763 in xrange(_size759):
            _elem764 = iprot.readString()
            self.part_vals.append(_elem764)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype768, _size765) = iprot.readListBegin()
          for _i769 in xrange(_size765):
            _elem770 = iprot.readString()
            self.group_names.append(_elem770)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter771 in self.part_vals:
        oprot.writeString(iter771)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 5)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter772 in self.group_names:
        oprot.writeString(iter772)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.max_parts)
    value = (value * 31) ^ hash(self.user_name)
    value = (value * 31) ^ hash(self.group_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype776, _size773) = iprot.readListBegin()
          for _i777 in xrange(_size773):
            _elem778 = Partition()
            _elem778.read(iprot)
            self.success.append(_elem778)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter779 in self.success:
        iter779.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_ps_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype783, _size780) = iprot.readListBegin()
          for _i784 in xrange(_size780):
            _elem785 = iprot.readString()
            self.part_vals.append(_elem785)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_ps_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter786 in self.part_vals:
        oprot.writeString(iter786)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_ps_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype790, _size787) = iprot.readListBegin()
          for _i791 in xrange(_size787):
            _elem792 = iprot.readString()
            self.success.append(_elem792)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_ps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter793 in self.success:
        oprot.writeString(iter793)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_filter_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - filter
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'filter', None, None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, filter=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.filter = filter
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_filter_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 3)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype797, _size794) = iprot.readListBegin()
          for _i798 in xrange(_size794):
            _elem799 = Partition()
            _elem799.read(iprot)
            self.success.append(_elem799)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter800 in self.success:
        iter800.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_part_specs_by_filter_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - filter
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'filter', None, None, ), # 3
    (4, TType.I32, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, filter=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.filter = filter
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.max_parts = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_part_specs_by_filter_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 3)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I32, 4)
      oprot.writeI32(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_part_specs_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(PartitionSpec, PartitionSpec.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype804, _size801) = iprot.readListBegin()
          for _i805 in xrange(_size801):
            _elem806 = PartitionSpec()
            _elem806.read(iprot)
            self.success.append(_elem806)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_part_specs_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter807 in self.success:
        iter807.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_expr_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (PartitionsByExprRequest, PartitionsByExprRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = PartitionsByExprRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_expr_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_expr_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PartitionsByExprResult, PartitionsByExprResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PartitionsByExprResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_expr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'names', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.names = names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.names = []
          (_etype811, _size808) = iprot.readListBegin()
          for _i812 in xrange(_size808):
            _elem813 = iprot.readString()
            self.names.append(_elem813)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.names is not None:
      oprot.writeFieldBegin('names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.names))
      for iter814 in self.names:
        oprot.writeString(iter814)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_names_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype818, _size815) = iprot.readListBegin()
          for _i819 in xrange(_size815):
            _elem820 = Partition()
            _elem820.read(iprot)
            self.success.append(_elem820)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter821 in self.success:
        iter821.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, new_part=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_part)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partitions_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'new_parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, new_parts=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_parts = new_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.new_parts = []
          (_etype825, _size822) = iprot.readListBegin()
          for _i826 in xrange(_size822):
            _elem827 = Partition()
            _elem827.read(iprot)
            self.new_parts.append(_elem827)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partitions_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_parts is not None:
      oprot.writeFieldBegin('new_parts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
      for iter828 in self.new_parts:
        iter828.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partitions_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partitions_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_part
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, new_part=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_part = new_part
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_part)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_with_environment_context_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, new_part=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype832, _size829) = iprot.readListBegin()
          for _i833 in xrange(_size829):
            _elem834 = iprot.readString()
            self.part_vals.append(_elem834)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter835 in self.part_vals:
        oprot.writeString(iter835)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 4)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.new_part)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_partition_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_partition_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_has_valid_characters_args:
  """
  Attributes:
   - part_vals
   - throw_exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 1
    (2, TType.BOOL, 'throw_exception', None, None, ), # 2
  )

  def __init__(self, part_vals=None, throw_exception=None,):
    self.part_vals = part_vals
    self.throw_exception = throw_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype839, _size836) = iprot.readListBegin()
          for _i840 in xrange(_size836):
            _elem841 = iprot.readString()
            self.part_vals.append(_elem841)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.throw_exception = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_has_valid_characters_args')
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter842 in self.part_vals:
        oprot.writeString(iter842)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.throw_exception is not None:
      oprot.writeFieldBegin('throw_exception', TType.BOOL, 2)
      oprot.writeBool(self.throw_exception)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.throw_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_has_valid_characters_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_has_valid_characters_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_config_value_args:
  """
  Attributes:
   - name
   - defaultValue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'defaultValue', None, None, ), # 2
  )

  def __init__(self, name=None, defaultValue=None,):
    self.name = name
    self.defaultValue = defaultValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.defaultValue = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_config_value_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.defaultValue is not None:
      oprot.writeFieldBegin('defaultValue', TType.STRING, 2)
      oprot.writeString(self.defaultValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.defaultValue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_config_value_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (ConfigValSecurityException, ConfigValSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = ConfigValSecurityException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_config_value_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_vals_args:
  """
  Attributes:
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'part_name', None, None, ), # 1
  )

  def __init__(self, part_name=None,):
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_vals_args')
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 1)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.part_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_vals_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype846, _size843) = iprot.readListBegin()
          for _i847 in xrange(_size843):
            _elem848 = iprot.readString()
            self.success.append(_elem848)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_vals_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter849 in self.success:
        oprot.writeString(iter849)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_spec_args:
  """
  Attributes:
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'part_name', None, None, ), # 1
  )

  def __init__(self, part_name=None,):
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_spec_args')
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 1)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.part_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_spec_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype851, _vtype852, _size850 ) = iprot.readMapBegin()
          for _i854 in xrange(_size850):
            _key855 = iprot.readString()
            _val856 = iprot.readString()
            self.success[_key855] = _val856
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_spec_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter857,viter858 in self.success.items():
        oprot.writeString(kiter857)
        oprot.writeString(viter858)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markPartitionForEvent_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - eventType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.MAP, 'part_vals', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.I32, 'eventType', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.eventType = eventType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.part_vals = {}
          (_ktype860, _vtype861, _size859 ) = iprot.readMapBegin()
          for _i863 in xrange(_size859):
            _key864 = iprot.readString()
            _val865 = iprot.readString()
            self.part_vals[_key864] = _val865
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.eventType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markPartitionForEvent_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
      for kiter866,viter867 in self.part_vals.items():
        oprot.writeString(kiter866)
        oprot.writeString(viter867)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 4)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.eventType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markPartitionForEvent_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
   - o5
   - o6
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'o5', (UnknownPartitionException, UnknownPartitionException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'o6', (InvalidPartitionException, InvalidPartitionException.thrift_spec), None, ), # 6
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4
    self.o5 = o5
    self.o6 = o6

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = UnknownTableException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.o5 = UnknownPartitionException()
          self.o5.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.o6 = InvalidPartitionException()
          self.o6.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markPartitionForEvent_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    if self.o5 is not None:
      oprot.writeFieldBegin('o5', TType.STRUCT, 5)
      self.o5.write(oprot)
      oprot.writeFieldEnd()
    if self.o6 is not None:
      oprot.writeFieldBegin('o6', TType.STRUCT, 6)
      self.o6.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    value = (value * 31) ^ hash(self.o5)
    value = (value * 31) ^ hash(self.o6)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPartitionMarkedForEvent_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - eventType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.MAP, 'part_vals', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.I32, 'eventType', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.eventType = eventType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.part_vals = {}
          (_ktype869, _vtype870, _size868 ) = iprot.readMapBegin()
          for _i872 in xrange(_size868):
            _key873 = iprot.readString()
            _val874 = iprot.readString()
            self.part_vals[_key873] = _val874
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.eventType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPartitionMarkedForEvent_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
      for kiter875,viter876 in self.part_vals.items():
        oprot.writeString(kiter875)
        oprot.writeString(viter876)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 4)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.eventType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPartitionMarkedForEvent_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
   - o5
   - o6
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'o5', (UnknownPartitionException, UnknownPartitionException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'o6', (InvalidPartitionException, InvalidPartitionException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4
    self.o5 = o5
    self.o6 = o6

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = UnknownTableException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.o5 = UnknownPartitionException()
          self.o5.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.o6 = InvalidPartitionException()
          self.o6.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPartitionMarkedForEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    if self.o5 is not None:
      oprot.writeFieldBegin('o5', TType.STRUCT, 5)
      self.o5.write(oprot)
      oprot.writeFieldEnd()
    if self.o6 is not None:
      oprot.writeFieldBegin('o6', TType.STRUCT, 6)
      self.o6.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    value = (value * 31) ^ hash(self.o5)
    value = (value * 31) ^ hash(self.o6)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_index_args:
  """
  Attributes:
   - new_index
   - index_table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'index_table', (Table, Table.thrift_spec), None, ), # 2
  )

  def __init__(self, new_index=None, index_table=None,):
    self.new_index = new_index
    self.index_table = index_table

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_index = Index()
          self.new_index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.index_table = Table()
          self.index_table.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_index_args')
    if self.new_index is not None:
      oprot.writeFieldBegin('new_index', TType.STRUCT, 1)
      self.new_index.write(oprot)
      oprot.writeFieldEnd()
    if self.index_table is not None:
      oprot.writeFieldBegin('index_table', TType.STRUCT, 2)
      self.index_table.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.new_index)
    value = (value * 31) ^ hash(self.index_table)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_index_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Index()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_index_args:
  """
  Attributes:
   - dbname
   - base_tbl_name
   - idx_name
   - new_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'base_tbl_name', None, None, ), # 2
    (3, TType.STRING, 'idx_name', None, None, ), # 3
    (4, TType.STRUCT, 'new_idx', (Index, Index.thrift_spec), None, ), # 4
  )

  def __init__(self, dbname=None, base_tbl_name=None, idx_name=None, new_idx=None,):
    self.dbname = dbname
    self.base_tbl_name = base_tbl_name
    self.idx_name = idx_name
    self.new_idx = new_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.base_tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.idx_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.new_idx = Index()
          self.new_idx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_index_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.base_tbl_name is not None:
      oprot.writeFieldBegin('base_tbl_name', TType.STRING, 2)
      oprot.writeString(self.base_tbl_name)
      oprot.writeFieldEnd()
    if self.idx_name is not None:
      oprot.writeFieldBegin('idx_name', TType.STRING, 3)
      oprot.writeString(self.idx_name)
      oprot.writeFieldEnd()
    if self.new_idx is not None:
      oprot.writeFieldBegin('new_idx', TType.STRUCT, 4)
      self.new_idx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.base_tbl_name)
    value = (value * 31) ^ hash(self.idx_name)
    value = (value * 31) ^ hash(self.new_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_index_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_index_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_index_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - index_name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'index_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, index_name=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.index_name = index_name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_index_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.index_name is not None:
      oprot.writeFieldBegin('index_name', TType.STRING, 3)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.index_name)
    value = (value * 31) ^ hash(self.deleteData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_index_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_index_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - index_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'index_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, index_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.index_name = index_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.index_name is not None:
      oprot.writeFieldBegin('index_name', TType.STRING, 3)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.index_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Index()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_indexes_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_indexes_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes is not None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_indexes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_indexes_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Index, Index.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype880, _size877) = iprot.readListBegin()
          for _i881 in xrange(_size877):
            _elem882 = Index()
            _elem882.read(iprot)
            self.success.append(_elem882)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_indexes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter883 in self.success:
        iter883.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes is not None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_indexes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_names_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype887, _size884) = iprot.readListBegin()
          for _i888 in xrange(_size884):
            _elem889 = iprot.readString()
            self.success.append(_elem889)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter890 in self.success:
        oprot.writeString(iter890)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_table_column_statistics_args:
  """
  Attributes:
   - stats_obj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'stats_obj', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 1
  )

  def __init__(self, stats_obj=None,):
    self.stats_obj = stats_obj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.stats_obj = ColumnStatistics()
          self.stats_obj.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_table_column_statistics_args')
    if self.stats_obj is not None:
      oprot.writeFieldBegin('stats_obj', TType.STRUCT, 1)
      self.stats_obj.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stats_obj)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_table_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_table_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_partition_column_statistics_args:
  """
  Attributes:
   - stats_obj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'stats_obj', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 1
  )

  def __init__(self, stats_obj=None,):
    self.stats_obj = stats_obj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.stats_obj = ColumnStatistics()
          self.stats_obj.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_partition_column_statistics_args')
    if self.stats_obj is not None:
      oprot.writeFieldBegin('stats_obj', TType.STRUCT, 1)
      self.stats_obj.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stats_obj)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_partition_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_partition_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'col_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.col_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 3)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.col_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ColumnStatistics()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidInputException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.STRING, 'col_name', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.col_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 4)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    value = (value * 31) ^ hash(self.col_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ColumnStatistics()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidInputException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_statistics_req_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (TableStatsRequest, TableStatsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = TableStatsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_statistics_req_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_statistics_req_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TableStatsResult, TableStatsResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TableStatsResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_statistics_req_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_statistics_req_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (PartitionsStatsRequest, PartitionsStatsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = PartitionsStatsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_statistics_req_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_statistics_req_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PartitionsStatsResult, PartitionsStatsResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PartitionsStatsResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_statistics_req_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_aggr_stats_for_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (PartitionsStatsRequest, PartitionsStatsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = PartitionsStatsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_aggr_stats_for_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_aggr_stats_for_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AggrStats, AggrStats.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AggrStats()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_aggr_stats_for_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_aggr_stats_for_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (SetPartitionsStatsRequest, SetPartitionsStatsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = SetPartitionsStatsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_aggr_stats_for_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_aggr_stats_for_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_aggr_stats_for_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_partition_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.STRING, 'col_name', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.col_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_partition_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 4)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    value = (value * 31) ^ hash(self.col_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_partition_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_partition_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_table_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'col_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.col_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_table_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 3)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.col_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_table_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_table_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_function_args:
  """
  Attributes:
   - func
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'func', (Function, Function.thrift_spec), None, ), # 1
  )

  def __init__(self, func=None,):
    self.func = func

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.func = Function()
          self.func.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_function_args')
    if self.func is not None:
      oprot.writeFieldBegin('func', TType.STRUCT, 1)
      self.func.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.func)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_function_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_function_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_function_args:
  """
  Attributes:
   - dbName
   - funcName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'funcName', None, None, ), # 2
  )

  def __init__(self, dbName=None, funcName=None,):
    self.dbName = dbName
    self.funcName = funcName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.funcName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_function_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.funcName is not None:
      oprot.writeFieldBegin('funcName', TType.STRING, 2)
      oprot.writeString(self.funcName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.funcName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_function_result:
  """
  Attributes:
   - o1
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o3=None,):
    self.o1 = o1
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_function_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 2)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_function_args:
  """
  Attributes:
   - dbName
   - funcName
   - newFunc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'funcName', None, None, ), # 2
    (3, TType.STRUCT, 'newFunc', (Function, Function.thrift_spec), None, ), # 3
  )

  def __init__(self, dbName=None, funcName=None, newFunc=None,):
    self.dbName = dbName
    self.funcName = funcName
    self.newFunc = newFunc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.funcName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.newFunc = Function()
          self.newFunc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_function_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.funcName is not None:
      oprot.writeFieldBegin('funcName', TType.STRING, 2)
      oprot.writeString(self.funcName)
      oprot.writeFieldEnd()
    if self.newFunc is not None:
      oprot.writeFieldBegin('newFunc', TType.STRUCT, 3)
      self.newFunc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.funcName)
    value = (value * 31) ^ hash(self.newFunc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_function_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_function_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_functions_args:
  """
  Attributes:
   - dbName
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
  )

  def __init__(self, dbName=None, pattern=None,):
    self.dbName = dbName
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_functions_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.pattern)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_functions_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype894, _size891) = iprot.readListBegin()
          for _i895 in xrange(_size891):
            _elem896 = iprot.readString()
            self.success.append(_elem896)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_functions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter897 in self.success:
        oprot.writeString(iter897)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_function_args:
  """
  Attributes:
   - dbName
   - funcName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'funcName', None, None, ), # 2
  )

  def __init__(self, dbName=None, funcName=None,):
    self.dbName = dbName
    self.funcName = funcName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.funcName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_function_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.funcName is not None:
      oprot.writeFieldBegin('funcName', TType.STRING, 2)
      oprot.writeString(self.funcName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.funcName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_function_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Function, Function.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Function()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_function_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_functions_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_functions_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_functions_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetAllFunctionsResponse, GetAllFunctionsResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetAllFunctionsResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_functions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_role_args:
  """
  Attributes:
   - role
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'role', (Role, Role.thrift_spec), None, ), # 1
  )

  def __init__(self, role=None,):
    self.role = role

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.role = Role()
          self.role.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_role_args')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRUCT, 1)
      self.role.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_role_args:
  """
  Attributes:
   - role_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
  )

  def __init__(self, role_name=None,):
    self.role_name = role_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_names_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_names_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_names_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype901, _size898) = iprot.readListBegin()
          for _i902 in xrange(_size898):
            _elem903 = iprot.readString()
            self.success.append(_elem903)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter904 in self.success:
        oprot.writeString(iter904)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_role_args:
  """
  Attributes:
   - role_name
   - principal_name
   - principal_type
   - grantor
   - grantorType
   - grant_option
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
    (2, TType.STRING, 'principal_name', None, None, ), # 2
    (3, TType.I32, 'principal_type', None, None, ), # 3
    (4, TType.STRING, 'grantor', None, None, ), # 4
    (5, TType.I32, 'grantorType', None, None, ), # 5
    (6, TType.BOOL, 'grant_option', None, None, ), # 6
  )

  def __init__(self, role_name=None, principal_name=None, principal_type=None, grantor=None, grantorType=None, grant_option=None,):
    self.role_name = role_name
    self.principal_name = principal_name
    self.principal_type = principal_type
    self.grantor = grantor
    self.grantorType = grantorType
    self.grant_option = grant_option

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.grantor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.grant_option = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 2)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 3)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 4)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 5)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grant_option is not None:
      oprot.writeFieldBegin('grant_option', TType.BOOL, 6)
      oprot.writeBool(self.grant_option)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role_name)
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    value = (value * 31) ^ hash(self.grantor)
    value = (value * 31) ^ hash(self.grantorType)
    value = (value * 31) ^ hash(self.grant_option)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_role_args:
  """
  Attributes:
   - role_name
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
    (2, TType.STRING, 'principal_name', None, None, ), # 2
    (3, TType.I32, 'principal_type', None, None, ), # 3
  )

  def __init__(self, role_name=None, principal_name=None, principal_type=None,):
    self.role_name = role_name
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 2)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 3)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role_name)
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_roles_args:
  """
  Attributes:
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
  )

  def __init__(self, principal_name=None, principal_type=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_roles_args')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_roles_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Role, Role.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype908, _size905) = iprot.readListBegin()
          for _i909 in xrange(_size905):
            _elem910 = Role()
            _elem910.read(iprot)
            self.success.append(_elem910)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_roles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter911 in self.success:
        iter911.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_revoke_role_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (GrantRevokeRoleRequest, GrantRevokeRoleRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = GrantRevokeRoleRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_revoke_role_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_revoke_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GrantRevokeRoleResponse, GrantRevokeRoleResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GrantRevokeRoleResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_revoke_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_principals_in_role_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (GetPrincipalsInRoleRequest, GetPrincipalsInRoleRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = GetPrincipalsInRoleRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_principals_in_role_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_principals_in_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetPrincipalsInRoleResponse, GetPrincipalsInRoleResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetPrincipalsInRoleResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_principals_in_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_grants_for_principal_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (GetRoleGrantsForPrincipalRequest, GetRoleGrantsForPrincipalRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = GetRoleGrantsForPrincipalRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_grants_for_principal_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_grants_for_principal_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetRoleGrantsForPrincipalResponse, GetRoleGrantsForPrincipalResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetRoleGrantsForPrincipalResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_grants_for_principal_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_privilege_set_args:
  """
  Attributes:
   - hiveObject
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 1
    (2, TType.STRING, 'user_name', None, None, ), # 2
    (3, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, hiveObject=None, user_name=None, group_names=None,):
    self.hiveObject = hiveObject
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype915, _size912) = iprot.readListBegin()
          for _i916 in xrange(_size912):
            _elem917 = iprot.readString()
            self.group_names.append(_elem917)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_privilege_set_args')
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 2)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter918 in self.group_names:
        oprot.writeString(iter918)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hiveObject)
    value = (value * 31) ^ hash(self.user_name)
    value = (value * 31) ^ hash(self.group_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_privilege_set_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PrincipalPrivilegeSet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_privilege_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_privileges_args:
  """
  Attributes:
   - principal_name
   - principal_type
   - hiveObject
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
    (3, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 3
  )

  def __init__(self, principal_name=None, principal_type=None, hiveObject=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type
    self.hiveObject = hiveObject

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_privileges_args')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 3)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    value = (value * 31) ^ hash(self.hiveObject)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(HiveObjectPrivilege, HiveObjectPrivilege.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype922, _size919) = iprot.readListBegin()
          for _i923 in xrange(_size919):
            _elem924 = HiveObjectPrivilege()
            _elem924.read(iprot)
            self.success.append(_elem924)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter925 in self.success:
        iter925.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_privileges_args:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_privileges_args')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_privileges_args:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_privileges_args')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_revoke_privileges_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (GrantRevokePrivilegeRequest, GrantRevokePrivilegeRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = GrantRevokePrivilegeRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_revoke_privileges_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_revoke_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GrantRevokePrivilegeResponse, GrantRevokePrivilegeResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GrantRevokePrivilegeResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_revoke_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_ugi_args:
  """
  Attributes:
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user_name', None, None, ), # 1
    (2, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, user_name=None, group_names=None,):
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype929, _size926) = iprot.readListBegin()
          for _i930 in xrange(_size926):
            _elem931 = iprot.readString()
            self.group_names.append(_elem931)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_ugi_args')
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 1)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter932 in self.group_names:
        oprot.writeString(iter932)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.user_name)
    value = (value * 31) ^ hash(self.group_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_ugi_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype936, _size933) = iprot.readListBegin()
          for _i937 in xrange(_size933):
            _elem938 = iprot.readString()
            self.success.append(_elem938)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_ugi_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter939 in self.success:
        oprot.writeString(iter939)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_delegation_token_args:
  """
  Attributes:
   - token_owner
   - renewer_kerberos_principal_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_owner', None, None, ), # 1
    (2, TType.STRING, 'renewer_kerberos_principal_name', None, None, ), # 2
  )

  def __init__(self, token_owner=None, renewer_kerberos_principal_name=None,):
    self.token_owner = token_owner
    self.renewer_kerberos_principal_name = renewer_kerberos_principal_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_owner = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.renewer_kerberos_principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_delegation_token_args')
    if self.token_owner is not None:
      oprot.writeFieldBegin('token_owner', TType.STRING, 1)
      oprot.writeString(self.token_owner)
      oprot.writeFieldEnd()
    if self.renewer_kerberos_principal_name is not None:
      oprot.writeFieldBegin('renewer_kerberos_principal_name', TType.STRING, 2)
      oprot.writeString(self.renewer_kerberos_principal_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token_owner)
    value = (value * 31) ^ hash(self.renewer_kerberos_principal_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_delegation_token_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_delegation_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renew_delegation_token_args:
  """
  Attributes:
   - token_str_form
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_str_form', None, None, ), # 1
  )

  def __init__(self, token_str_form=None,):
    self.token_str_form = token_str_form

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_str_form = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renew_delegation_token_args')
    if self.token_str_form is not None:
      oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
      oprot.writeString(self.token_str_form)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token_str_form)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renew_delegation_token_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renew_delegation_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancel_delegation_token_args:
  """
  Attributes:
   - token_str_form
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_str_form', None, None, ), # 1
  )

  def __init__(self, token_str_form=None,):
    self.token_str_form = token_str_form

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_str_form = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancel_delegation_token_args')
    if self.token_str_form is not None:
      oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
      oprot.writeString(self.token_str_form)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token_str_form)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancel_delegation_token_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancel_delegation_token_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_open_txns_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_open_txns_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_open_txns_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetOpenTxnsResponse, GetOpenTxnsResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetOpenTxnsResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_open_txns_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_open_txns_info_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_open_txns_info_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_open_txns_info_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetOpenTxnsInfoResponse, GetOpenTxnsInfoResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetOpenTxnsInfoResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_open_txns_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class open_txns_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (OpenTxnRequest, OpenTxnRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = OpenTxnRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('open_txns_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class open_txns_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (OpenTxnsResponse, OpenTxnsResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = OpenTxnsResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('open_txns_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_txn_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (AbortTxnRequest, AbortTxnRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = AbortTxnRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_txn_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_txn_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_txn_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_txn_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (CommitTxnRequest, CommitTxnRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = CommitTxnRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_txn_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_txn_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = TxnAbortedException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_txn_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class lock_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (LockRequest, LockRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = LockRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('lock_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class lock_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (LockResponse, LockResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = LockResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = TxnAbortedException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('lock_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_lock_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (CheckLockRequest, CheckLockRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = CheckLockRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_lock_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_lock_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (LockResponse, LockResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (NoSuchLockException, NoSuchLockException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = LockResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = TxnAbortedException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = NoSuchLockException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_lock_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unlock_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (UnlockRequest, UnlockRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = UnlockRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unlock_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unlock_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchLockException, NoSuchLockException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (TxnOpenException, TxnOpenException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchLockException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = TxnOpenException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unlock_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class show_locks_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (ShowLocksRequest, ShowLocksRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = ShowLocksRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('show_locks_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class show_locks_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ShowLocksResponse, ShowLocksResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ShowLocksResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('show_locks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class heartbeat_args:
  """
  Attributes:
   - ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ids', (HeartbeatRequest, HeartbeatRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, ids=None,):
    self.ids = ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ids = HeartbeatRequest()
          self.ids.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('heartbeat_args')
    if self.ids is not None:
      oprot.writeFieldBegin('ids', TType.STRUCT, 1)
      self.ids.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class heartbeat_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchLockException, NoSuchLockException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchLockException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchTxnException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = TxnAbortedException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('heartbeat_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class heartbeat_txn_range_args:
  """
  Attributes:
   - txns
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'txns', (HeartbeatTxnRangeRequest, HeartbeatTxnRangeRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, txns=None,):
    self.txns = txns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.txns = HeartbeatTxnRangeRequest()
          self.txns.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('heartbeat_txn_range_args')
    if self.txns is not None:
      oprot.writeFieldBegin('txns', TType.STRUCT, 1)
      self.txns.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txns)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class heartbeat_txn_range_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (HeartbeatTxnRangeResponse, HeartbeatTxnRangeResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = HeartbeatTxnRangeResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('heartbeat_txn_range_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compact_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (CompactionRequest, CompactionRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = CompactionRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compact_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compact_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compact_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class show_compact_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (ShowCompactRequest, ShowCompactRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = ShowCompactRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('show_compact_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class show_compact_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ShowCompactResponse, ShowCompactResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ShowCompactResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('show_compact_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_dynamic_partitions_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (AddDynamicPartitions, AddDynamicPartitions.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = AddDynamicPartitions()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_dynamic_partitions_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_dynamic_partitions_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = TxnAbortedException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_dynamic_partitions_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_next_notification_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (NotificationEventRequest, NotificationEventRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = NotificationEventRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_next_notification_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_next_notification_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (NotificationEventResponse, NotificationEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = NotificationEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_next_notification_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_current_notificationEventId_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_current_notificationEventId_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_current_notificationEventId_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CurrentNotificationEventId, CurrentNotificationEventId.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CurrentNotificationEventId()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_current_notificationEventId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fire_listener_event_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (FireEventRequest, FireEventRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = FireEventRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fire_listener_event_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fire_listener_event_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (FireEventResponse, FireEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = FireEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fire_listener_event_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class flushCache_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('flushCache_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class flushCache_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('flushCache_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_metadata_by_expr_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (GetFileMetadataByExprRequest, GetFileMetadataByExprRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = GetFileMetadataByExprRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_metadata_by_expr_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_metadata_by_expr_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetFileMetadataByExprResult, GetFileMetadataByExprResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetFileMetadataByExprResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_metadata_by_expr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_metadata_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (GetFileMetadataRequest, GetFileMetadataRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = GetFileMetadataRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_metadata_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_metadata_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetFileMetadataResult, GetFileMetadataResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetFileMetadataResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_metadata_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class put_file_metadata_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (PutFileMetadataRequest, PutFileMetadataRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = PutFileMetadataRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('put_file_metadata_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class put_file_metadata_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PutFileMetadataResult, PutFileMetadataResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PutFileMetadataResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('put_file_metadata_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clear_file_metadata_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (ClearFileMetadataRequest, ClearFileMetadataRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = ClearFileMetadataRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clear_file_metadata_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clear_file_metadata_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ClearFileMetadataResult, ClearFileMetadataResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ClearFileMetadataResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clear_file_metadata_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
