#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import fb303.FacebookService
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(fb303.FacebookService.Iface):
    """
    This interface is live.

    """
    def getMetaConf(self, key):
        """
        Parameters:
         - key

        """
        pass

    def setMetaConf(self, key, value):
        """
        Parameters:
         - key
         - value

        """
        pass

    def create_database(self, database):
        """
        Parameters:
         - database

        """
        pass

    def get_database(self, name):
        """
        Parameters:
         - name

        """
        pass

    def drop_database(self, name, deleteData, cascade):
        """
        Parameters:
         - name
         - deleteData
         - cascade

        """
        pass

    def get_databases(self, pattern):
        """
        Parameters:
         - pattern

        """
        pass

    def get_all_databases(self):
        pass

    def alter_database(self, dbname, db):
        """
        Parameters:
         - dbname
         - db

        """
        pass

    def get_type(self, name):
        """
        Parameters:
         - name

        """
        pass

    def create_type(self, type):
        """
        Parameters:
         - type

        """
        pass

    def drop_type(self, type):
        """
        Parameters:
         - type

        """
        pass

    def get_type_all(self, name):
        """
        Parameters:
         - name

        """
        pass

    def get_fields(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name

        """
        pass

    def get_fields_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context

        """
        pass

    def get_schema(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name

        """
        pass

    def get_schema_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context

        """
        pass

    def create_table(self, tbl):
        """
        Parameters:
         - tbl

        """
        pass

    def create_table_with_environment_context(self, tbl, environment_context):
        """
        Parameters:
         - tbl
         - environment_context

        """
        pass

    def create_table_with_constraints(self, tbl, primaryKeys, foreignKeys):
        """
        Parameters:
         - tbl
         - primaryKeys
         - foreignKeys

        """
        pass

    def drop_constraint(self, req):
        """
        Parameters:
         - req

        """
        pass

    def add_primary_key(self, req):
        """
        Parameters:
         - req

        """
        pass

    def add_foreign_key(self, req):
        """
        Parameters:
         - req

        """
        pass

    def drop_table(self, dbname, name, deleteData):
        """
        Parameters:
         - dbname
         - name
         - deleteData

        """
        pass

    def drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
        """
        Parameters:
         - dbname
         - name
         - deleteData
         - environment_context

        """
        pass

    def get_tables(self, db_name, pattern):
        """
        Parameters:
         - db_name
         - pattern

        """
        pass

    def get_tables_by_type(self, db_name, pattern, tableType):
        """
        Parameters:
         - db_name
         - pattern
         - tableType

        """
        pass

    def get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
        """
        Parameters:
         - db_patterns
         - tbl_patterns
         - tbl_types

        """
        pass

    def get_all_tables(self, db_name):
        """
        Parameters:
         - db_name

        """
        pass

    def get_table(self, dbname, tbl_name):
        """
        Parameters:
         - dbname
         - tbl_name

        """
        pass

    def get_table_objects_by_name(self, dbname, tbl_names):
        """
        Parameters:
         - dbname
         - tbl_names

        """
        pass

    def get_table_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_table_objects_by_name_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_table_names_by_filter(self, dbname, filter, max_tables):
        """
        Parameters:
         - dbname
         - filter
         - max_tables

        """
        pass

    def alter_table(self, dbname, tbl_name, new_tbl):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl

        """
        pass

    def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - environment_context

        """
        pass

    def alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - cascade

        """
        pass

    def add_partition(self, new_part):
        """
        Parameters:
         - new_part

        """
        pass

    def add_partition_with_environment_context(self, new_part, environment_context):
        """
        Parameters:
         - new_part
         - environment_context

        """
        pass

    def add_partitions(self, new_parts):
        """
        Parameters:
         - new_parts

        """
        pass

    def add_partitions_pspec(self, new_parts):
        """
        Parameters:
         - new_parts

        """
        pass

    def append_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals

        """
        pass

    def add_partitions_req(self, request):
        """
        Parameters:
         - request

        """
        pass

    def append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - environment_context

        """
        pass

    def append_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name

        """
        pass

    def append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - environment_context

        """
        pass

    def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData

        """
        pass

    def drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData
         - environment_context

        """
        pass

    def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData

        """
        pass

    def drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData
         - environment_context

        """
        pass

    def drop_partitions_req(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals

        """
        pass

    def exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name

        """
        pass

    def exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name

        """
        pass

    def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - user_name
         - group_names

        """
        pass

    def get_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name

        """
        pass

    def get_partitions(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        pass

    def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
         - user_name
         - group_names

        """
        pass

    def get_partitions_pspec(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        pass

    def get_partition_names(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        pass

    def get_partition_values(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts

        """
        pass

    def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts
         - user_name
         - group_names

        """
        pass

    def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts

        """
        pass

    def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts

        """
        pass

    def get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts

        """
        pass

    def get_partitions_by_expr(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_num_partitions_by_filter(self, db_name, tbl_name, filter):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter

        """
        pass

    def get_partitions_by_names(self, db_name, tbl_name, names):
        """
        Parameters:
         - db_name
         - tbl_name
         - names

        """
        pass

    def alter_partition(self, db_name, tbl_name, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part

        """
        pass

    def alter_partitions(self, db_name, tbl_name, new_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_parts

        """
        pass

    def alter_partitions_with_environment_context(self, db_name, tbl_name, new_parts, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_parts
         - environment_context

        """
        pass

    def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part
         - environment_context

        """
        pass

    def rename_partition(self, db_name, tbl_name, part_vals, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - new_part

        """
        pass

    def partition_name_has_valid_characters(self, part_vals, throw_exception):
        """
        Parameters:
         - part_vals
         - throw_exception

        """
        pass

    def get_config_value(self, name, defaultValue):
        """
        Parameters:
         - name
         - defaultValue

        """
        pass

    def partition_name_to_vals(self, part_name):
        """
        Parameters:
         - part_name

        """
        pass

    def partition_name_to_spec(self, part_name):
        """
        Parameters:
         - part_name

        """
        pass

    def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType

        """
        pass

    def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType

        """
        pass

    def add_index(self, new_index, index_table):
        """
        Parameters:
         - new_index
         - index_table

        """
        pass

    def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
        """
        Parameters:
         - dbname
         - base_tbl_name
         - idx_name
         - new_idx

        """
        pass

    def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - index_name
         - deleteData

        """
        pass

    def get_index_by_name(self, db_name, tbl_name, index_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - index_name

        """
        pass

    def get_indexes(self, db_name, tbl_name, max_indexes):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_indexes

        """
        pass

    def get_index_names(self, db_name, tbl_name, max_indexes):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_indexes

        """
        pass

    def get_primary_keys(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_foreign_keys(self, request):
        """
        Parameters:
         - request

        """
        pass

    def update_table_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj

        """
        pass

    def update_partition_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj

        """
        pass

    def get_table_column_statistics(self, db_name, tbl_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name

        """
        pass

    def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name

        """
        pass

    def get_table_statistics_req(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_partitions_statistics_req(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_aggr_stats_for(self, request):
        """
        Parameters:
         - request

        """
        pass

    def set_aggr_stats_for(self, request):
        """
        Parameters:
         - request

        """
        pass

    def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name

        """
        pass

    def delete_table_column_statistics(self, db_name, tbl_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name

        """
        pass

    def create_function(self, func):
        """
        Parameters:
         - func

        """
        pass

    def drop_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName

        """
        pass

    def alter_function(self, dbName, funcName, newFunc):
        """
        Parameters:
         - dbName
         - funcName
         - newFunc

        """
        pass

    def get_functions(self, dbName, pattern):
        """
        Parameters:
         - dbName
         - pattern

        """
        pass

    def get_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName

        """
        pass

    def get_all_functions(self):
        pass

    def create_role(self, role):
        """
        Parameters:
         - role

        """
        pass

    def drop_role(self, role_name):
        """
        Parameters:
         - role_name

        """
        pass

    def get_role_names(self):
        pass

    def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type
         - grantor
         - grantorType
         - grant_option

        """
        pass

    def revoke_role(self, role_name, principal_name, principal_type):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type

        """
        pass

    def list_roles(self, principal_name, principal_type):
        """
        Parameters:
         - principal_name
         - principal_type

        """
        pass

    def grant_revoke_role(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_principals_in_role(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_role_grants_for_principal(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_privilege_set(self, hiveObject, user_name, group_names):
        """
        Parameters:
         - hiveObject
         - user_name
         - group_names

        """
        pass

    def list_privileges(self, principal_name, principal_type, hiveObject):
        """
        Parameters:
         - principal_name
         - principal_type
         - hiveObject

        """
        pass

    def grant_privileges(self, privileges):
        """
        Parameters:
         - privileges

        """
        pass

    def revoke_privileges(self, privileges):
        """
        Parameters:
         - privileges

        """
        pass

    def grant_revoke_privileges(self, request):
        """
        Parameters:
         - request

        """
        pass

    def set_ugi(self, user_name, group_names):
        """
        Parameters:
         - user_name
         - group_names

        """
        pass

    def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
        """
        Parameters:
         - token_owner
         - renewer_kerberos_principal_name

        """
        pass

    def renew_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form

        """
        pass

    def cancel_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form

        """
        pass

    def add_token(self, token_identifier, delegation_token):
        """
        Parameters:
         - token_identifier
         - delegation_token

        """
        pass

    def remove_token(self, token_identifier):
        """
        Parameters:
         - token_identifier

        """
        pass

    def get_token(self, token_identifier):
        """
        Parameters:
         - token_identifier

        """
        pass

    def get_all_token_identifiers(self):
        pass

    def add_master_key(self, key):
        """
        Parameters:
         - key

        """
        pass

    def update_master_key(self, seq_number, key):
        """
        Parameters:
         - seq_number
         - key

        """
        pass

    def remove_master_key(self, key_seq):
        """
        Parameters:
         - key_seq

        """
        pass

    def get_master_keys(self):
        pass

    def get_open_txns(self):
        pass

    def get_open_txns_info(self):
        pass

    def open_txns(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def abort_txn(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def abort_txns(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def commit_txn(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def lock(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def check_lock(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def unlock(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def show_locks(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def heartbeat(self, ids):
        """
        Parameters:
         - ids

        """
        pass

    def heartbeat_txn_range(self, txns):
        """
        Parameters:
         - txns

        """
        pass

    def compact(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def compact2(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def show_compact(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def add_dynamic_partitions(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_next_notification(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def get_current_notificationEventId(self):
        pass

    def fire_listener_event(self, rqst):
        """
        Parameters:
         - rqst

        """
        pass

    def flushCache(self):
        pass

    def get_file_metadata_by_expr(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        pass

    def put_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        pass

    def clear_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        pass

    def cache_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        pass


class Client(fb303.FacebookService.Client, Iface):
    """
    This interface is live.

    """
    def __init__(self, iprot, oprot=None):
        fb303.FacebookService.Client.__init__(self, iprot, oprot)

    def getMetaConf(self, key):
        """
        Parameters:
         - key

        """
        self.send_getMetaConf(key)
        return self.recv_getMetaConf()

    def send_getMetaConf(self, key):
        self._oprot.writeMessageBegin('getMetaConf', TMessageType.CALL, self._seqid)
        args = getMetaConf_args()
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMetaConf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMetaConf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMetaConf failed: unknown result")

    def setMetaConf(self, key, value):
        """
        Parameters:
         - key
         - value

        """
        self.send_setMetaConf(key, value)
        self.recv_setMetaConf()

    def send_setMetaConf(self, key, value):
        self._oprot.writeMessageBegin('setMetaConf', TMessageType.CALL, self._seqid)
        args = setMetaConf_args()
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setMetaConf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setMetaConf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def create_database(self, database):
        """
        Parameters:
         - database

        """
        self.send_create_database(database)
        self.recv_create_database()

    def send_create_database(self, database):
        self._oprot.writeMessageBegin('create_database', TMessageType.CALL, self._seqid)
        args = create_database_args()
        args.database = database
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_database(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_database(name)
        return self.recv_get_database()

    def send_get_database(self, name):
        self._oprot.writeMessageBegin('get_database', TMessageType.CALL, self._seqid)
        args = get_database_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_database failed: unknown result")

    def drop_database(self, name, deleteData, cascade):
        """
        Parameters:
         - name
         - deleteData
         - cascade

        """
        self.send_drop_database(name, deleteData, cascade)
        self.recv_drop_database()

    def send_drop_database(self, name, deleteData, cascade):
        self._oprot.writeMessageBegin('drop_database', TMessageType.CALL, self._seqid)
        args = drop_database_args()
        args.name = name
        args.deleteData = deleteData
        args.cascade = cascade
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_databases(self, pattern):
        """
        Parameters:
         - pattern

        """
        self.send_get_databases(pattern)
        return self.recv_get_databases()

    def send_get_databases(self, pattern):
        self._oprot.writeMessageBegin('get_databases', TMessageType.CALL, self._seqid)
        args = get_databases_args()
        args.pattern = pattern
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_databases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_databases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_databases failed: unknown result")

    def get_all_databases(self):
        self.send_get_all_databases()
        return self.recv_get_all_databases()

    def send_get_all_databases(self):
        self._oprot.writeMessageBegin('get_all_databases', TMessageType.CALL, self._seqid)
        args = get_all_databases_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_databases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_databases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_databases failed: unknown result")

    def alter_database(self, dbname, db):
        """
        Parameters:
         - dbname
         - db

        """
        self.send_alter_database(dbname, db)
        self.recv_alter_database()

    def send_alter_database(self, dbname, db):
        self._oprot.writeMessageBegin('alter_database', TMessageType.CALL, self._seqid)
        args = alter_database_args()
        args.dbname = dbname
        args.db = db
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_type(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_type(name)
        return self.recv_get_type()

    def send_get_type(self, name):
        self._oprot.writeMessageBegin('get_type', TMessageType.CALL, self._seqid)
        args = get_type_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type failed: unknown result")

    def create_type(self, type):
        """
        Parameters:
         - type

        """
        self.send_create_type(type)
        return self.recv_create_type()

    def send_create_type(self, type):
        self._oprot.writeMessageBegin('create_type', TMessageType.CALL, self._seqid)
        args = create_type_args()
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_type failed: unknown result")

    def drop_type(self, type):
        """
        Parameters:
         - type

        """
        self.send_drop_type(type)
        return self.recv_drop_type()

    def send_drop_type(self, type):
        self._oprot.writeMessageBegin('drop_type', TMessageType.CALL, self._seqid)
        args = drop_type_args()
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_type failed: unknown result")

    def get_type_all(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_type_all(name)
        return self.recv_get_type_all()

    def send_get_type_all(self, name):
        self._oprot.writeMessageBegin('get_type_all', TMessageType.CALL, self._seqid)
        args = get_type_all_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_type_all(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_type_all_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type_all failed: unknown result")

    def get_fields(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name

        """
        self.send_get_fields(db_name, table_name)
        return self.recv_get_fields()

    def send_get_fields(self, db_name, table_name):
        self._oprot.writeMessageBegin('get_fields', TMessageType.CALL, self._seqid)
        args = get_fields_args()
        args.db_name = db_name
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fields(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fields_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields failed: unknown result")

    def get_fields_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context

        """
        self.send_get_fields_with_environment_context(db_name, table_name, environment_context)
        return self.recv_get_fields_with_environment_context()

    def send_get_fields_with_environment_context(self, db_name, table_name, environment_context):
        self._oprot.writeMessageBegin('get_fields_with_environment_context', TMessageType.CALL, self._seqid)
        args = get_fields_with_environment_context_args()
        args.db_name = db_name
        args.table_name = table_name
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fields_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fields_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields_with_environment_context failed: unknown result")

    def get_schema(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name

        """
        self.send_get_schema(db_name, table_name)
        return self.recv_get_schema()

    def send_get_schema(self, db_name, table_name):
        self._oprot.writeMessageBegin('get_schema', TMessageType.CALL, self._seqid)
        args = get_schema_args()
        args.db_name = db_name
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result")

    def get_schema_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context

        """
        self.send_get_schema_with_environment_context(db_name, table_name, environment_context)
        return self.recv_get_schema_with_environment_context()

    def send_get_schema_with_environment_context(self, db_name, table_name, environment_context):
        self._oprot.writeMessageBegin('get_schema_with_environment_context', TMessageType.CALL, self._seqid)
        args = get_schema_with_environment_context_args()
        args.db_name = db_name
        args.table_name = table_name
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_with_environment_context failed: unknown result")

    def create_table(self, tbl):
        """
        Parameters:
         - tbl

        """
        self.send_create_table(tbl)
        self.recv_create_table()

    def send_create_table(self, tbl):
        self._oprot.writeMessageBegin('create_table', TMessageType.CALL, self._seqid)
        args = create_table_args()
        args.tbl = tbl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def create_table_with_environment_context(self, tbl, environment_context):
        """
        Parameters:
         - tbl
         - environment_context

        """
        self.send_create_table_with_environment_context(tbl, environment_context)
        self.recv_create_table_with_environment_context()

    def send_create_table_with_environment_context(self, tbl, environment_context):
        self._oprot.writeMessageBegin('create_table_with_environment_context', TMessageType.CALL, self._seqid)
        args = create_table_with_environment_context_args()
        args.tbl = tbl
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_table_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_table_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def create_table_with_constraints(self, tbl, primaryKeys, foreignKeys):
        """
        Parameters:
         - tbl
         - primaryKeys
         - foreignKeys

        """
        self.send_create_table_with_constraints(tbl, primaryKeys, foreignKeys)
        self.recv_create_table_with_constraints()

    def send_create_table_with_constraints(self, tbl, primaryKeys, foreignKeys):
        self._oprot.writeMessageBegin('create_table_with_constraints', TMessageType.CALL, self._seqid)
        args = create_table_with_constraints_args()
        args.tbl = tbl
        args.primaryKeys = primaryKeys
        args.foreignKeys = foreignKeys
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_table_with_constraints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_table_with_constraints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def drop_constraint(self, req):
        """
        Parameters:
         - req

        """
        self.send_drop_constraint(req)
        self.recv_drop_constraint()

    def send_drop_constraint(self, req):
        self._oprot.writeMessageBegin('drop_constraint', TMessageType.CALL, self._seqid)
        args = drop_constraint_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_constraint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_constraint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def add_primary_key(self, req):
        """
        Parameters:
         - req

        """
        self.send_add_primary_key(req)
        self.recv_add_primary_key()

    def send_add_primary_key(self, req):
        self._oprot.writeMessageBegin('add_primary_key', TMessageType.CALL, self._seqid)
        args = add_primary_key_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_primary_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_primary_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def add_foreign_key(self, req):
        """
        Parameters:
         - req

        """
        self.send_add_foreign_key(req)
        self.recv_add_foreign_key()

    def send_add_foreign_key(self, req):
        self._oprot.writeMessageBegin('add_foreign_key', TMessageType.CALL, self._seqid)
        args = add_foreign_key_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_foreign_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_foreign_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def drop_table(self, dbname, name, deleteData):
        """
        Parameters:
         - dbname
         - name
         - deleteData

        """
        self.send_drop_table(dbname, name, deleteData)
        self.recv_drop_table()

    def send_drop_table(self, dbname, name, deleteData):
        self._oprot.writeMessageBegin('drop_table', TMessageType.CALL, self._seqid)
        args = drop_table_args()
        args.dbname = dbname
        args.name = name
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
        """
        Parameters:
         - dbname
         - name
         - deleteData
         - environment_context

        """
        self.send_drop_table_with_environment_context(dbname, name, deleteData, environment_context)
        self.recv_drop_table_with_environment_context()

    def send_drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
        self._oprot.writeMessageBegin('drop_table_with_environment_context', TMessageType.CALL, self._seqid)
        args = drop_table_with_environment_context_args()
        args.dbname = dbname
        args.name = name
        args.deleteData = deleteData
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_table_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_table_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def get_tables(self, db_name, pattern):
        """
        Parameters:
         - db_name
         - pattern

        """
        self.send_get_tables(db_name, pattern)
        return self.recv_get_tables()

    def send_get_tables(self, db_name, pattern):
        self._oprot.writeMessageBegin('get_tables', TMessageType.CALL, self._seqid)
        args = get_tables_args()
        args.db_name = db_name
        args.pattern = pattern
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result")

    def get_tables_by_type(self, db_name, pattern, tableType):
        """
        Parameters:
         - db_name
         - pattern
         - tableType

        """
        self.send_get_tables_by_type(db_name, pattern, tableType)
        return self.recv_get_tables_by_type()

    def send_get_tables_by_type(self, db_name, pattern, tableType):
        self._oprot.writeMessageBegin('get_tables_by_type', TMessageType.CALL, self._seqid)
        args = get_tables_by_type_args()
        args.db_name = db_name
        args.pattern = pattern
        args.tableType = tableType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tables_by_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tables_by_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables_by_type failed: unknown result")

    def get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
        """
        Parameters:
         - db_patterns
         - tbl_patterns
         - tbl_types

        """
        self.send_get_table_meta(db_patterns, tbl_patterns, tbl_types)
        return self.recv_get_table_meta()

    def send_get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
        self._oprot.writeMessageBegin('get_table_meta', TMessageType.CALL, self._seqid)
        args = get_table_meta_args()
        args.db_patterns = db_patterns
        args.tbl_patterns = tbl_patterns
        args.tbl_types = tbl_types
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_meta(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_meta_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_meta failed: unknown result")

    def get_all_tables(self, db_name):
        """
        Parameters:
         - db_name

        """
        self.send_get_all_tables(db_name)
        return self.recv_get_all_tables()

    def send_get_all_tables(self, db_name):
        self._oprot.writeMessageBegin('get_all_tables', TMessageType.CALL, self._seqid)
        args = get_all_tables_args()
        args.db_name = db_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_tables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_tables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_tables failed: unknown result")

    def get_table(self, dbname, tbl_name):
        """
        Parameters:
         - dbname
         - tbl_name

        """
        self.send_get_table(dbname, tbl_name)
        return self.recv_get_table()

    def send_get_table(self, dbname, tbl_name):
        self._oprot.writeMessageBegin('get_table', TMessageType.CALL, self._seqid)
        args = get_table_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table failed: unknown result")

    def get_table_objects_by_name(self, dbname, tbl_names):
        """
        Parameters:
         - dbname
         - tbl_names

        """
        self.send_get_table_objects_by_name(dbname, tbl_names)
        return self.recv_get_table_objects_by_name()

    def send_get_table_objects_by_name(self, dbname, tbl_names):
        self._oprot.writeMessageBegin('get_table_objects_by_name', TMessageType.CALL, self._seqid)
        args = get_table_objects_by_name_args()
        args.dbname = dbname
        args.tbl_names = tbl_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_objects_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_objects_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_objects_by_name failed: unknown result")

    def get_table_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_table_req(req)
        return self.recv_get_table_req()

    def send_get_table_req(self, req):
        self._oprot.writeMessageBegin('get_table_req', TMessageType.CALL, self._seqid)
        args = get_table_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_req failed: unknown result")

    def get_table_objects_by_name_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_table_objects_by_name_req(req)
        return self.recv_get_table_objects_by_name_req()

    def send_get_table_objects_by_name_req(self, req):
        self._oprot.writeMessageBegin('get_table_objects_by_name_req', TMessageType.CALL, self._seqid)
        args = get_table_objects_by_name_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_objects_by_name_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_objects_by_name_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_objects_by_name_req failed: unknown result")

    def get_table_names_by_filter(self, dbname, filter, max_tables):
        """
        Parameters:
         - dbname
         - filter
         - max_tables

        """
        self.send_get_table_names_by_filter(dbname, filter, max_tables)
        return self.recv_get_table_names_by_filter()

    def send_get_table_names_by_filter(self, dbname, filter, max_tables):
        self._oprot.writeMessageBegin('get_table_names_by_filter', TMessageType.CALL, self._seqid)
        args = get_table_names_by_filter_args()
        args.dbname = dbname
        args.filter = filter
        args.max_tables = max_tables
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_names_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_names_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_names_by_filter failed: unknown result")

    def alter_table(self, dbname, tbl_name, new_tbl):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl

        """
        self.send_alter_table(dbname, tbl_name, new_tbl)
        self.recv_alter_table()

    def send_alter_table(self, dbname, tbl_name, new_tbl):
        self._oprot.writeMessageBegin('alter_table', TMessageType.CALL, self._seqid)
        args = alter_table_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.new_tbl = new_tbl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - environment_context

        """
        self.send_alter_table_with_environment_context(dbname, tbl_name, new_tbl, environment_context)
        self.recv_alter_table_with_environment_context()

    def send_alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
        self._oprot.writeMessageBegin('alter_table_with_environment_context', TMessageType.CALL, self._seqid)
        args = alter_table_with_environment_context_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.new_tbl = new_tbl
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_table_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_table_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - cascade

        """
        self.send_alter_table_with_cascade(dbname, tbl_name, new_tbl, cascade)
        self.recv_alter_table_with_cascade()

    def send_alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
        self._oprot.writeMessageBegin('alter_table_with_cascade', TMessageType.CALL, self._seqid)
        args = alter_table_with_cascade_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.new_tbl = new_tbl
        args.cascade = cascade
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_table_with_cascade(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_table_with_cascade_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def add_partition(self, new_part):
        """
        Parameters:
         - new_part

        """
        self.send_add_partition(new_part)
        return self.recv_add_partition()

    def send_add_partition(self, new_part):
        self._oprot.writeMessageBegin('add_partition', TMessageType.CALL, self._seqid)
        args = add_partition_args()
        args.new_part = new_part
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition failed: unknown result")

    def add_partition_with_environment_context(self, new_part, environment_context):
        """
        Parameters:
         - new_part
         - environment_context

        """
        self.send_add_partition_with_environment_context(new_part, environment_context)
        return self.recv_add_partition_with_environment_context()

    def send_add_partition_with_environment_context(self, new_part, environment_context):
        self._oprot.writeMessageBegin('add_partition_with_environment_context', TMessageType.CALL, self._seqid)
        args = add_partition_with_environment_context_args()
        args.new_part = new_part
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition_with_environment_context failed: unknown result")

    def add_partitions(self, new_parts):
        """
        Parameters:
         - new_parts

        """
        self.send_add_partitions(new_parts)
        return self.recv_add_partitions()

    def send_add_partitions(self, new_parts):
        self._oprot.writeMessageBegin('add_partitions', TMessageType.CALL, self._seqid)
        args = add_partitions_args()
        args.new_parts = new_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions failed: unknown result")

    def add_partitions_pspec(self, new_parts):
        """
        Parameters:
         - new_parts

        """
        self.send_add_partitions_pspec(new_parts)
        return self.recv_add_partitions_pspec()

    def send_add_partitions_pspec(self, new_parts):
        self._oprot.writeMessageBegin('add_partitions_pspec', TMessageType.CALL, self._seqid)
        args = add_partitions_pspec_args()
        args.new_parts = new_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partitions_pspec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partitions_pspec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions_pspec failed: unknown result")

    def append_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals

        """
        self.send_append_partition(db_name, tbl_name, part_vals)
        return self.recv_append_partition()

    def send_append_partition(self, db_name, tbl_name, part_vals):
        self._oprot.writeMessageBegin('append_partition', TMessageType.CALL, self._seqid)
        args = append_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition failed: unknown result")

    def add_partitions_req(self, request):
        """
        Parameters:
         - request

        """
        self.send_add_partitions_req(request)
        return self.recv_add_partitions_req()

    def send_add_partitions_req(self, request):
        self._oprot.writeMessageBegin('add_partitions_req', TMessageType.CALL, self._seqid)
        args = add_partitions_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partitions_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partitions_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions_req failed: unknown result")

    def append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - environment_context

        """
        self.send_append_partition_with_environment_context(db_name, tbl_name, part_vals, environment_context)
        return self.recv_append_partition_with_environment_context()

    def send_append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
        self._oprot.writeMessageBegin('append_partition_with_environment_context', TMessageType.CALL, self._seqid)
        args = append_partition_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_with_environment_context failed: unknown result")

    def append_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name

        """
        self.send_append_partition_by_name(db_name, tbl_name, part_name)
        return self.recv_append_partition_by_name()

    def send_append_partition_by_name(self, db_name, tbl_name, part_name):
        self._oprot.writeMessageBegin('append_partition_by_name', TMessageType.CALL, self._seqid)
        args = append_partition_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name failed: unknown result")

    def append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - environment_context

        """
        self.send_append_partition_by_name_with_environment_context(db_name, tbl_name, part_name, environment_context)
        return self.recv_append_partition_by_name_with_environment_context()

    def send_append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
        self._oprot.writeMessageBegin('append_partition_by_name_with_environment_context', TMessageType.CALL, self._seqid)
        args = append_partition_by_name_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition_by_name_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_by_name_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name_with_environment_context failed: unknown result")

    def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData

        """
        self.send_drop_partition(db_name, tbl_name, part_vals, deleteData)
        return self.recv_drop_partition()

    def send_drop_partition(self, db_name, tbl_name, part_vals, deleteData):
        self._oprot.writeMessageBegin('drop_partition', TMessageType.CALL, self._seqid)
        args = drop_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition failed: unknown result")

    def drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData
         - environment_context

        """
        self.send_drop_partition_with_environment_context(db_name, tbl_name, part_vals, deleteData, environment_context)
        return self.recv_drop_partition_with_environment_context()

    def send_drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
        self._oprot.writeMessageBegin('drop_partition_with_environment_context', TMessageType.CALL, self._seqid)
        args = drop_partition_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.deleteData = deleteData
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_with_environment_context failed: unknown result")

    def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData

        """
        self.send_drop_partition_by_name(db_name, tbl_name, part_name, deleteData)
        return self.recv_drop_partition_by_name()

    def send_drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
        self._oprot.writeMessageBegin('drop_partition_by_name', TMessageType.CALL, self._seqid)
        args = drop_partition_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name failed: unknown result")

    def drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData
         - environment_context

        """
        self.send_drop_partition_by_name_with_environment_context(db_name, tbl_name, part_name, deleteData, environment_context)
        return self.recv_drop_partition_by_name_with_environment_context()

    def send_drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
        self._oprot.writeMessageBegin('drop_partition_by_name_with_environment_context', TMessageType.CALL, self._seqid)
        args = drop_partition_by_name_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.deleteData = deleteData
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition_by_name_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_by_name_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name_with_environment_context failed: unknown result")

    def drop_partitions_req(self, req):
        """
        Parameters:
         - req

        """
        self.send_drop_partitions_req(req)
        return self.recv_drop_partitions_req()

    def send_drop_partitions_req(self, req):
        self._oprot.writeMessageBegin('drop_partitions_req', TMessageType.CALL, self._seqid)
        args = drop_partitions_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partitions_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partitions_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partitions_req failed: unknown result")

    def get_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals

        """
        self.send_get_partition(db_name, tbl_name, part_vals)
        return self.recv_get_partition()

    def send_get_partition(self, db_name, tbl_name, part_vals):
        self._oprot.writeMessageBegin('get_partition', TMessageType.CALL, self._seqid)
        args = get_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition failed: unknown result")

    def exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name

        """
        self.send_exchange_partition(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)
        return self.recv_exchange_partition()

    def send_exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        self._oprot.writeMessageBegin('exchange_partition', TMessageType.CALL, self._seqid)
        args = exchange_partition_args()
        args.partitionSpecs = partitionSpecs
        args.source_db = source_db
        args.source_table_name = source_table_name
        args.dest_db = dest_db
        args.dest_table_name = dest_table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exchange_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exchange_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exchange_partition failed: unknown result")

    def exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name

        """
        self.send_exchange_partitions(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)
        return self.recv_exchange_partitions()

    def send_exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        self._oprot.writeMessageBegin('exchange_partitions', TMessageType.CALL, self._seqid)
        args = exchange_partitions_args()
        args.partitionSpecs = partitionSpecs
        args.source_db = source_db
        args.source_table_name = source_table_name
        args.dest_db = dest_db
        args.dest_table_name = dest_table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exchange_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exchange_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exchange_partitions failed: unknown result")

    def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - user_name
         - group_names

        """
        self.send_get_partition_with_auth(db_name, tbl_name, part_vals, user_name, group_names)
        return self.recv_get_partition_with_auth()

    def send_get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
        self._oprot.writeMessageBegin('get_partition_with_auth', TMessageType.CALL, self._seqid)
        args = get_partition_with_auth_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_with_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_with_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_with_auth failed: unknown result")

    def get_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name

        """
        self.send_get_partition_by_name(db_name, tbl_name, part_name)
        return self.recv_get_partition_by_name()

    def send_get_partition_by_name(self, db_name, tbl_name, part_name):
        self._oprot.writeMessageBegin('get_partition_by_name', TMessageType.CALL, self._seqid)
        args = get_partition_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_by_name failed: unknown result")

    def get_partitions(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        self.send_get_partitions(db_name, tbl_name, max_parts)
        return self.recv_get_partitions()

    def send_get_partitions(self, db_name, tbl_name, max_parts):
        self._oprot.writeMessageBegin('get_partitions', TMessageType.CALL, self._seqid)
        args = get_partitions_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions failed: unknown result")

    def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
         - user_name
         - group_names

        """
        self.send_get_partitions_with_auth(db_name, tbl_name, max_parts, user_name, group_names)
        return self.recv_get_partitions_with_auth()

    def send_get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
        self._oprot.writeMessageBegin('get_partitions_with_auth', TMessageType.CALL, self._seqid)
        args = get_partitions_with_auth_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_with_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_with_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_with_auth failed: unknown result")

    def get_partitions_pspec(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        self.send_get_partitions_pspec(db_name, tbl_name, max_parts)
        return self.recv_get_partitions_pspec()

    def send_get_partitions_pspec(self, db_name, tbl_name, max_parts):
        self._oprot.writeMessageBegin('get_partitions_pspec', TMessageType.CALL, self._seqid)
        args = get_partitions_pspec_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_pspec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_pspec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_pspec failed: unknown result")

    def get_partition_names(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts

        """
        self.send_get_partition_names(db_name, tbl_name, max_parts)
        return self.recv_get_partition_names()

    def send_get_partition_names(self, db_name, tbl_name, max_parts):
        self._oprot.writeMessageBegin('get_partition_names', TMessageType.CALL, self._seqid)
        args = get_partition_names_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names failed: unknown result")

    def get_partition_values(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_partition_values(request)
        return self.recv_get_partition_values()

    def send_get_partition_values(self, request):
        self._oprot.writeMessageBegin('get_partition_values', TMessageType.CALL, self._seqid)
        args = get_partition_values_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_values(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_values_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_values failed: unknown result")

    def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts

        """
        self.send_get_partitions_ps(db_name, tbl_name, part_vals, max_parts)
        return self.recv_get_partitions_ps()

    def send_get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
        self._oprot.writeMessageBegin('get_partitions_ps', TMessageType.CALL, self._seqid)
        args = get_partitions_ps_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_ps(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_ps_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps failed: unknown result")

    def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts
         - user_name
         - group_names

        """
        self.send_get_partitions_ps_with_auth(db_name, tbl_name, part_vals, max_parts, user_name, group_names)
        return self.recv_get_partitions_ps_with_auth()

    def send_get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
        self._oprot.writeMessageBegin('get_partitions_ps_with_auth', TMessageType.CALL, self._seqid)
        args = get_partitions_ps_with_auth_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.max_parts = max_parts
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_ps_with_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_ps_with_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps_with_auth failed: unknown result")

    def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts

        """
        self.send_get_partition_names_ps(db_name, tbl_name, part_vals, max_parts)
        return self.recv_get_partition_names_ps()

    def send_get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
        self._oprot.writeMessageBegin('get_partition_names_ps', TMessageType.CALL, self._seqid)
        args = get_partition_names_ps_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_names_ps(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_names_ps_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_ps failed: unknown result")

    def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts

        """
        self.send_get_partitions_by_filter(db_name, tbl_name, filter, max_parts)
        return self.recv_get_partitions_by_filter()

    def send_get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
        self._oprot.writeMessageBegin('get_partitions_by_filter', TMessageType.CALL, self._seqid)
        args = get_partitions_by_filter_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.filter = filter
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_filter failed: unknown result")

    def get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts

        """
        self.send_get_part_specs_by_filter(db_name, tbl_name, filter, max_parts)
        return self.recv_get_part_specs_by_filter()

    def send_get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
        self._oprot.writeMessageBegin('get_part_specs_by_filter', TMessageType.CALL, self._seqid)
        args = get_part_specs_by_filter_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.filter = filter
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_part_specs_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_part_specs_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_part_specs_by_filter failed: unknown result")

    def get_partitions_by_expr(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_partitions_by_expr(req)
        return self.recv_get_partitions_by_expr()

    def send_get_partitions_by_expr(self, req):
        self._oprot.writeMessageBegin('get_partitions_by_expr', TMessageType.CALL, self._seqid)
        args = get_partitions_by_expr_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_by_expr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_by_expr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_expr failed: unknown result")

    def get_num_partitions_by_filter(self, db_name, tbl_name, filter):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter

        """
        self.send_get_num_partitions_by_filter(db_name, tbl_name, filter)
        return self.recv_get_num_partitions_by_filter()

    def send_get_num_partitions_by_filter(self, db_name, tbl_name, filter):
        self._oprot.writeMessageBegin('get_num_partitions_by_filter', TMessageType.CALL, self._seqid)
        args = get_num_partitions_by_filter_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.filter = filter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_num_partitions_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_num_partitions_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_num_partitions_by_filter failed: unknown result")

    def get_partitions_by_names(self, db_name, tbl_name, names):
        """
        Parameters:
         - db_name
         - tbl_name
         - names

        """
        self.send_get_partitions_by_names(db_name, tbl_name, names)
        return self.recv_get_partitions_by_names()

    def send_get_partitions_by_names(self, db_name, tbl_name, names):
        self._oprot.writeMessageBegin('get_partitions_by_names', TMessageType.CALL, self._seqid)
        args = get_partitions_by_names_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.names = names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_by_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_by_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_names failed: unknown result")

    def alter_partition(self, db_name, tbl_name, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part

        """
        self.send_alter_partition(db_name, tbl_name, new_part)
        self.recv_alter_partition()

    def send_alter_partition(self, db_name, tbl_name, new_part):
        self._oprot.writeMessageBegin('alter_partition', TMessageType.CALL, self._seqid)
        args = alter_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_part = new_part
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_partitions(self, db_name, tbl_name, new_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_parts

        """
        self.send_alter_partitions(db_name, tbl_name, new_parts)
        self.recv_alter_partitions()

    def send_alter_partitions(self, db_name, tbl_name, new_parts):
        self._oprot.writeMessageBegin('alter_partitions', TMessageType.CALL, self._seqid)
        args = alter_partitions_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_parts = new_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_partitions_with_environment_context(self, db_name, tbl_name, new_parts, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_parts
         - environment_context

        """
        self.send_alter_partitions_with_environment_context(db_name, tbl_name, new_parts, environment_context)
        self.recv_alter_partitions_with_environment_context()

    def send_alter_partitions_with_environment_context(self, db_name, tbl_name, new_parts, environment_context):
        self._oprot.writeMessageBegin('alter_partitions_with_environment_context', TMessageType.CALL, self._seqid)
        args = alter_partitions_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_parts = new_parts
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partitions_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partitions_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part
         - environment_context

        """
        self.send_alter_partition_with_environment_context(db_name, tbl_name, new_part, environment_context)
        self.recv_alter_partition_with_environment_context()

    def send_alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
        self._oprot.writeMessageBegin('alter_partition_with_environment_context', TMessageType.CALL, self._seqid)
        args = alter_partition_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_part = new_part
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def rename_partition(self, db_name, tbl_name, part_vals, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - new_part

        """
        self.send_rename_partition(db_name, tbl_name, part_vals, new_part)
        self.recv_rename_partition()

    def send_rename_partition(self, db_name, tbl_name, part_vals, new_part):
        self._oprot.writeMessageBegin('rename_partition', TMessageType.CALL, self._seqid)
        args = rename_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.new_part = new_part
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rename_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rename_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def partition_name_has_valid_characters(self, part_vals, throw_exception):
        """
        Parameters:
         - part_vals
         - throw_exception

        """
        self.send_partition_name_has_valid_characters(part_vals, throw_exception)
        return self.recv_partition_name_has_valid_characters()

    def send_partition_name_has_valid_characters(self, part_vals, throw_exception):
        self._oprot.writeMessageBegin('partition_name_has_valid_characters', TMessageType.CALL, self._seqid)
        args = partition_name_has_valid_characters_args()
        args.part_vals = part_vals
        args.throw_exception = throw_exception
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_partition_name_has_valid_characters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = partition_name_has_valid_characters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_has_valid_characters failed: unknown result")

    def get_config_value(self, name, defaultValue):
        """
        Parameters:
         - name
         - defaultValue

        """
        self.send_get_config_value(name, defaultValue)
        return self.recv_get_config_value()

    def send_get_config_value(self, name, defaultValue):
        self._oprot.writeMessageBegin('get_config_value', TMessageType.CALL, self._seqid)
        args = get_config_value_args()
        args.name = name
        args.defaultValue = defaultValue
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_config_value(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_config_value_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_config_value failed: unknown result")

    def partition_name_to_vals(self, part_name):
        """
        Parameters:
         - part_name

        """
        self.send_partition_name_to_vals(part_name)
        return self.recv_partition_name_to_vals()

    def send_partition_name_to_vals(self, part_name):
        self._oprot.writeMessageBegin('partition_name_to_vals', TMessageType.CALL, self._seqid)
        args = partition_name_to_vals_args()
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_partition_name_to_vals(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = partition_name_to_vals_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_vals failed: unknown result")

    def partition_name_to_spec(self, part_name):
        """
        Parameters:
         - part_name

        """
        self.send_partition_name_to_spec(part_name)
        return self.recv_partition_name_to_spec()

    def send_partition_name_to_spec(self, part_name):
        self._oprot.writeMessageBegin('partition_name_to_spec', TMessageType.CALL, self._seqid)
        args = partition_name_to_spec_args()
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_partition_name_to_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = partition_name_to_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_spec failed: unknown result")

    def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType

        """
        self.send_markPartitionForEvent(db_name, tbl_name, part_vals, eventType)
        self.recv_markPartitionForEvent()

    def send_markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
        self._oprot.writeMessageBegin('markPartitionForEvent', TMessageType.CALL, self._seqid)
        args = markPartitionForEvent_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.eventType = eventType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_markPartitionForEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = markPartitionForEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        if result.o5 is not None:
            raise result.o5
        if result.o6 is not None:
            raise result.o6
        return

    def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType

        """
        self.send_isPartitionMarkedForEvent(db_name, tbl_name, part_vals, eventType)
        return self.recv_isPartitionMarkedForEvent()

    def send_isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
        self._oprot.writeMessageBegin('isPartitionMarkedForEvent', TMessageType.CALL, self._seqid)
        args = isPartitionMarkedForEvent_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.eventType = eventType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isPartitionMarkedForEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isPartitionMarkedForEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        if result.o5 is not None:
            raise result.o5
        if result.o6 is not None:
            raise result.o6
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isPartitionMarkedForEvent failed: unknown result")

    def add_index(self, new_index, index_table):
        """
        Parameters:
         - new_index
         - index_table

        """
        self.send_add_index(new_index, index_table)
        return self.recv_add_index()

    def send_add_index(self, new_index, index_table):
        self._oprot.writeMessageBegin('add_index', TMessageType.CALL, self._seqid)
        args = add_index_args()
        args.new_index = new_index
        args.index_table = index_table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_index(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_index_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_index failed: unknown result")

    def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
        """
        Parameters:
         - dbname
         - base_tbl_name
         - idx_name
         - new_idx

        """
        self.send_alter_index(dbname, base_tbl_name, idx_name, new_idx)
        self.recv_alter_index()

    def send_alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
        self._oprot.writeMessageBegin('alter_index', TMessageType.CALL, self._seqid)
        args = alter_index_args()
        args.dbname = dbname
        args.base_tbl_name = base_tbl_name
        args.idx_name = idx_name
        args.new_idx = new_idx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_index(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_index_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - index_name
         - deleteData

        """
        self.send_drop_index_by_name(db_name, tbl_name, index_name, deleteData)
        return self.recv_drop_index_by_name()

    def send_drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
        self._oprot.writeMessageBegin('drop_index_by_name', TMessageType.CALL, self._seqid)
        args = drop_index_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.index_name = index_name
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_index_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_index_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_index_by_name failed: unknown result")

    def get_index_by_name(self, db_name, tbl_name, index_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - index_name

        """
        self.send_get_index_by_name(db_name, tbl_name, index_name)
        return self.recv_get_index_by_name()

    def send_get_index_by_name(self, db_name, tbl_name, index_name):
        self._oprot.writeMessageBegin('get_index_by_name', TMessageType.CALL, self._seqid)
        args = get_index_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.index_name = index_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_index_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_index_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_by_name failed: unknown result")

    def get_indexes(self, db_name, tbl_name, max_indexes):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_indexes

        """
        self.send_get_indexes(db_name, tbl_name, max_indexes)
        return self.recv_get_indexes()

    def send_get_indexes(self, db_name, tbl_name, max_indexes):
        self._oprot.writeMessageBegin('get_indexes', TMessageType.CALL, self._seqid)
        args = get_indexes_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_indexes = max_indexes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_indexes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_indexes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_indexes failed: unknown result")

    def get_index_names(self, db_name, tbl_name, max_indexes):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_indexes

        """
        self.send_get_index_names(db_name, tbl_name, max_indexes)
        return self.recv_get_index_names()

    def send_get_index_names(self, db_name, tbl_name, max_indexes):
        self._oprot.writeMessageBegin('get_index_names', TMessageType.CALL, self._seqid)
        args = get_index_names_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_indexes = max_indexes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_index_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_index_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_names failed: unknown result")

    def get_primary_keys(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_primary_keys(request)
        return self.recv_get_primary_keys()

    def send_get_primary_keys(self, request):
        self._oprot.writeMessageBegin('get_primary_keys', TMessageType.CALL, self._seqid)
        args = get_primary_keys_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_primary_keys(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_primary_keys_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_primary_keys failed: unknown result")

    def get_foreign_keys(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_foreign_keys(request)
        return self.recv_get_foreign_keys()

    def send_get_foreign_keys(self, request):
        self._oprot.writeMessageBegin('get_foreign_keys', TMessageType.CALL, self._seqid)
        args = get_foreign_keys_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_foreign_keys(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_foreign_keys_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_foreign_keys failed: unknown result")

    def update_table_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj

        """
        self.send_update_table_column_statistics(stats_obj)
        return self.recv_update_table_column_statistics()

    def send_update_table_column_statistics(self, stats_obj):
        self._oprot.writeMessageBegin('update_table_column_statistics', TMessageType.CALL, self._seqid)
        args = update_table_column_statistics_args()
        args.stats_obj = stats_obj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_table_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_table_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "update_table_column_statistics failed: unknown result")

    def update_partition_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj

        """
        self.send_update_partition_column_statistics(stats_obj)
        return self.recv_update_partition_column_statistics()

    def send_update_partition_column_statistics(self, stats_obj):
        self._oprot.writeMessageBegin('update_partition_column_statistics', TMessageType.CALL, self._seqid)
        args = update_partition_column_statistics_args()
        args.stats_obj = stats_obj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_partition_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_partition_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "update_partition_column_statistics failed: unknown result")

    def get_table_column_statistics(self, db_name, tbl_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name

        """
        self.send_get_table_column_statistics(db_name, tbl_name, col_name)
        return self.recv_get_table_column_statistics()

    def send_get_table_column_statistics(self, db_name, tbl_name, col_name):
        self._oprot.writeMessageBegin('get_table_column_statistics', TMessageType.CALL, self._seqid)
        args = get_table_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.col_name = col_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_column_statistics failed: unknown result")

    def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name

        """
        self.send_get_partition_column_statistics(db_name, tbl_name, part_name, col_name)
        return self.recv_get_partition_column_statistics()

    def send_get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        self._oprot.writeMessageBegin('get_partition_column_statistics', TMessageType.CALL, self._seqid)
        args = get_partition_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.col_name = col_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_column_statistics failed: unknown result")

    def get_table_statistics_req(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_table_statistics_req(request)
        return self.recv_get_table_statistics_req()

    def send_get_table_statistics_req(self, request):
        self._oprot.writeMessageBegin('get_table_statistics_req', TMessageType.CALL, self._seqid)
        args = get_table_statistics_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_statistics_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_statistics_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_statistics_req failed: unknown result")

    def get_partitions_statistics_req(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_partitions_statistics_req(request)
        return self.recv_get_partitions_statistics_req()

    def send_get_partitions_statistics_req(self, request):
        self._oprot.writeMessageBegin('get_partitions_statistics_req', TMessageType.CALL, self._seqid)
        args = get_partitions_statistics_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_statistics_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_statistics_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_statistics_req failed: unknown result")

    def get_aggr_stats_for(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_aggr_stats_for(request)
        return self.recv_get_aggr_stats_for()

    def send_get_aggr_stats_for(self, request):
        self._oprot.writeMessageBegin('get_aggr_stats_for', TMessageType.CALL, self._seqid)
        args = get_aggr_stats_for_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_aggr_stats_for(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_aggr_stats_for_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_aggr_stats_for failed: unknown result")

    def set_aggr_stats_for(self, request):
        """
        Parameters:
         - request

        """
        self.send_set_aggr_stats_for(request)
        return self.recv_set_aggr_stats_for()

    def send_set_aggr_stats_for(self, request):
        self._oprot.writeMessageBegin('set_aggr_stats_for', TMessageType.CALL, self._seqid)
        args = set_aggr_stats_for_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_aggr_stats_for(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_aggr_stats_for_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_aggr_stats_for failed: unknown result")

    def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name

        """
        self.send_delete_partition_column_statistics(db_name, tbl_name, part_name, col_name)
        return self.recv_delete_partition_column_statistics()

    def send_delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        self._oprot.writeMessageBegin('delete_partition_column_statistics', TMessageType.CALL, self._seqid)
        args = delete_partition_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.col_name = col_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_partition_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_partition_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_partition_column_statistics failed: unknown result")

    def delete_table_column_statistics(self, db_name, tbl_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name

        """
        self.send_delete_table_column_statistics(db_name, tbl_name, col_name)
        return self.recv_delete_table_column_statistics()

    def send_delete_table_column_statistics(self, db_name, tbl_name, col_name):
        self._oprot.writeMessageBegin('delete_table_column_statistics', TMessageType.CALL, self._seqid)
        args = delete_table_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.col_name = col_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_table_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_table_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_table_column_statistics failed: unknown result")

    def create_function(self, func):
        """
        Parameters:
         - func

        """
        self.send_create_function(func)
        self.recv_create_function()

    def send_create_function(self, func):
        self._oprot.writeMessageBegin('create_function', TMessageType.CALL, self._seqid)
        args = create_function_args()
        args.func = func
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def drop_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName

        """
        self.send_drop_function(dbName, funcName)
        self.recv_drop_function()

    def send_drop_function(self, dbName, funcName):
        self._oprot.writeMessageBegin('drop_function', TMessageType.CALL, self._seqid)
        args = drop_function_args()
        args.dbName = dbName
        args.funcName = funcName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def alter_function(self, dbName, funcName, newFunc):
        """
        Parameters:
         - dbName
         - funcName
         - newFunc

        """
        self.send_alter_function(dbName, funcName, newFunc)
        self.recv_alter_function()

    def send_alter_function(self, dbName, funcName, newFunc):
        self._oprot.writeMessageBegin('alter_function', TMessageType.CALL, self._seqid)
        args = alter_function_args()
        args.dbName = dbName
        args.funcName = funcName
        args.newFunc = newFunc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_functions(self, dbName, pattern):
        """
        Parameters:
         - dbName
         - pattern

        """
        self.send_get_functions(dbName, pattern)
        return self.recv_get_functions()

    def send_get_functions(self, dbName, pattern):
        self._oprot.writeMessageBegin('get_functions', TMessageType.CALL, self._seqid)
        args = get_functions_args()
        args.dbName = dbName
        args.pattern = pattern
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_functions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_functions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_functions failed: unknown result")

    def get_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName

        """
        self.send_get_function(dbName, funcName)
        return self.recv_get_function()

    def send_get_function(self, dbName, funcName):
        self._oprot.writeMessageBegin('get_function', TMessageType.CALL, self._seqid)
        args = get_function_args()
        args.dbName = dbName
        args.funcName = funcName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function failed: unknown result")

    def get_all_functions(self):
        self.send_get_all_functions()
        return self.recv_get_all_functions()

    def send_get_all_functions(self):
        self._oprot.writeMessageBegin('get_all_functions', TMessageType.CALL, self._seqid)
        args = get_all_functions_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_functions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_functions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_functions failed: unknown result")

    def create_role(self, role):
        """
        Parameters:
         - role

        """
        self.send_create_role(role)
        return self.recv_create_role()

    def send_create_role(self, role):
        self._oprot.writeMessageBegin('create_role', TMessageType.CALL, self._seqid)
        args = create_role_args()
        args.role = role
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_role failed: unknown result")

    def drop_role(self, role_name):
        """
        Parameters:
         - role_name

        """
        self.send_drop_role(role_name)
        return self.recv_drop_role()

    def send_drop_role(self, role_name):
        self._oprot.writeMessageBegin('drop_role', TMessageType.CALL, self._seqid)
        args = drop_role_args()
        args.role_name = role_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_role failed: unknown result")

    def get_role_names(self):
        self.send_get_role_names()
        return self.recv_get_role_names()

    def send_get_role_names(self):
        self._oprot.writeMessageBegin('get_role_names', TMessageType.CALL, self._seqid)
        args = get_role_names_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_role_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_role_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_names failed: unknown result")

    def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type
         - grantor
         - grantorType
         - grant_option

        """
        self.send_grant_role(role_name, principal_name, principal_type, grantor, grantorType, grant_option)
        return self.recv_grant_role()

    def send_grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
        self._oprot.writeMessageBegin('grant_role', TMessageType.CALL, self._seqid)
        args = grant_role_args()
        args.role_name = role_name
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.grantor = grantor
        args.grantorType = grantorType
        args.grant_option = grant_option
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_role failed: unknown result")

    def revoke_role(self, role_name, principal_name, principal_type):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type

        """
        self.send_revoke_role(role_name, principal_name, principal_type)
        return self.recv_revoke_role()

    def send_revoke_role(self, role_name, principal_name, principal_type):
        self._oprot.writeMessageBegin('revoke_role', TMessageType.CALL, self._seqid)
        args = revoke_role_args()
        args.role_name = role_name
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revoke_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revoke_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_role failed: unknown result")

    def list_roles(self, principal_name, principal_type):
        """
        Parameters:
         - principal_name
         - principal_type

        """
        self.send_list_roles(principal_name, principal_type)
        return self.recv_list_roles()

    def send_list_roles(self, principal_name, principal_type):
        self._oprot.writeMessageBegin('list_roles', TMessageType.CALL, self._seqid)
        args = list_roles_args()
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_list_roles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = list_roles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "list_roles failed: unknown result")

    def grant_revoke_role(self, request):
        """
        Parameters:
         - request

        """
        self.send_grant_revoke_role(request)
        return self.recv_grant_revoke_role()

    def send_grant_revoke_role(self, request):
        self._oprot.writeMessageBegin('grant_revoke_role', TMessageType.CALL, self._seqid)
        args = grant_revoke_role_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_revoke_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_revoke_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_revoke_role failed: unknown result")

    def get_principals_in_role(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_principals_in_role(request)
        return self.recv_get_principals_in_role()

    def send_get_principals_in_role(self, request):
        self._oprot.writeMessageBegin('get_principals_in_role', TMessageType.CALL, self._seqid)
        args = get_principals_in_role_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_principals_in_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_principals_in_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_principals_in_role failed: unknown result")

    def get_role_grants_for_principal(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_role_grants_for_principal(request)
        return self.recv_get_role_grants_for_principal()

    def send_get_role_grants_for_principal(self, request):
        self._oprot.writeMessageBegin('get_role_grants_for_principal', TMessageType.CALL, self._seqid)
        args = get_role_grants_for_principal_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_role_grants_for_principal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_role_grants_for_principal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_grants_for_principal failed: unknown result")

    def get_privilege_set(self, hiveObject, user_name, group_names):
        """
        Parameters:
         - hiveObject
         - user_name
         - group_names

        """
        self.send_get_privilege_set(hiveObject, user_name, group_names)
        return self.recv_get_privilege_set()

    def send_get_privilege_set(self, hiveObject, user_name, group_names):
        self._oprot.writeMessageBegin('get_privilege_set', TMessageType.CALL, self._seqid)
        args = get_privilege_set_args()
        args.hiveObject = hiveObject
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_privilege_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_privilege_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_privilege_set failed: unknown result")

    def list_privileges(self, principal_name, principal_type, hiveObject):
        """
        Parameters:
         - principal_name
         - principal_type
         - hiveObject

        """
        self.send_list_privileges(principal_name, principal_type, hiveObject)
        return self.recv_list_privileges()

    def send_list_privileges(self, principal_name, principal_type, hiveObject):
        self._oprot.writeMessageBegin('list_privileges', TMessageType.CALL, self._seqid)
        args = list_privileges_args()
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.hiveObject = hiveObject
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_list_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = list_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "list_privileges failed: unknown result")

    def grant_privileges(self, privileges):
        """
        Parameters:
         - privileges

        """
        self.send_grant_privileges(privileges)
        return self.recv_grant_privileges()

    def send_grant_privileges(self, privileges):
        self._oprot.writeMessageBegin('grant_privileges', TMessageType.CALL, self._seqid)
        args = grant_privileges_args()
        args.privileges = privileges
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_privileges failed: unknown result")

    def revoke_privileges(self, privileges):
        """
        Parameters:
         - privileges

        """
        self.send_revoke_privileges(privileges)
        return self.recv_revoke_privileges()

    def send_revoke_privileges(self, privileges):
        self._oprot.writeMessageBegin('revoke_privileges', TMessageType.CALL, self._seqid)
        args = revoke_privileges_args()
        args.privileges = privileges
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revoke_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revoke_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_privileges failed: unknown result")

    def grant_revoke_privileges(self, request):
        """
        Parameters:
         - request

        """
        self.send_grant_revoke_privileges(request)
        return self.recv_grant_revoke_privileges()

    def send_grant_revoke_privileges(self, request):
        self._oprot.writeMessageBegin('grant_revoke_privileges', TMessageType.CALL, self._seqid)
        args = grant_revoke_privileges_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_revoke_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_revoke_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_revoke_privileges failed: unknown result")

    def set_ugi(self, user_name, group_names):
        """
        Parameters:
         - user_name
         - group_names

        """
        self.send_set_ugi(user_name, group_names)
        return self.recv_set_ugi()

    def send_set_ugi(self, user_name, group_names):
        self._oprot.writeMessageBegin('set_ugi', TMessageType.CALL, self._seqid)
        args = set_ugi_args()
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_ugi(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_ugi_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_ugi failed: unknown result")

    def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
        """
        Parameters:
         - token_owner
         - renewer_kerberos_principal_name

        """
        self.send_get_delegation_token(token_owner, renewer_kerberos_principal_name)
        return self.recv_get_delegation_token()

    def send_get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
        self._oprot.writeMessageBegin('get_delegation_token', TMessageType.CALL, self._seqid)
        args = get_delegation_token_args()
        args.token_owner = token_owner
        args.renewer_kerberos_principal_name = renewer_kerberos_principal_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_delegation_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_delegation_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_delegation_token failed: unknown result")

    def renew_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form

        """
        self.send_renew_delegation_token(token_str_form)
        return self.recv_renew_delegation_token()

    def send_renew_delegation_token(self, token_str_form):
        self._oprot.writeMessageBegin('renew_delegation_token', TMessageType.CALL, self._seqid)
        args = renew_delegation_token_args()
        args.token_str_form = token_str_form
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_renew_delegation_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = renew_delegation_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "renew_delegation_token failed: unknown result")

    def cancel_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form

        """
        self.send_cancel_delegation_token(token_str_form)
        self.recv_cancel_delegation_token()

    def send_cancel_delegation_token(self, token_str_form):
        self._oprot.writeMessageBegin('cancel_delegation_token', TMessageType.CALL, self._seqid)
        args = cancel_delegation_token_args()
        args.token_str_form = token_str_form
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancel_delegation_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancel_delegation_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def add_token(self, token_identifier, delegation_token):
        """
        Parameters:
         - token_identifier
         - delegation_token

        """
        self.send_add_token(token_identifier, delegation_token)
        return self.recv_add_token()

    def send_add_token(self, token_identifier, delegation_token):
        self._oprot.writeMessageBegin('add_token', TMessageType.CALL, self._seqid)
        args = add_token_args()
        args.token_identifier = token_identifier
        args.delegation_token = delegation_token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_token failed: unknown result")

    def remove_token(self, token_identifier):
        """
        Parameters:
         - token_identifier

        """
        self.send_remove_token(token_identifier)
        return self.recv_remove_token()

    def send_remove_token(self, token_identifier):
        self._oprot.writeMessageBegin('remove_token', TMessageType.CALL, self._seqid)
        args = remove_token_args()
        args.token_identifier = token_identifier
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_token failed: unknown result")

    def get_token(self, token_identifier):
        """
        Parameters:
         - token_identifier

        """
        self.send_get_token(token_identifier)
        return self.recv_get_token()

    def send_get_token(self, token_identifier):
        self._oprot.writeMessageBegin('get_token', TMessageType.CALL, self._seqid)
        args = get_token_args()
        args.token_identifier = token_identifier
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_token failed: unknown result")

    def get_all_token_identifiers(self):
        self.send_get_all_token_identifiers()
        return self.recv_get_all_token_identifiers()

    def send_get_all_token_identifiers(self):
        self._oprot.writeMessageBegin('get_all_token_identifiers', TMessageType.CALL, self._seqid)
        args = get_all_token_identifiers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_token_identifiers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_token_identifiers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_token_identifiers failed: unknown result")

    def add_master_key(self, key):
        """
        Parameters:
         - key

        """
        self.send_add_master_key(key)
        return self.recv_add_master_key()

    def send_add_master_key(self, key):
        self._oprot.writeMessageBegin('add_master_key', TMessageType.CALL, self._seqid)
        args = add_master_key_args()
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_master_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_master_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_master_key failed: unknown result")

    def update_master_key(self, seq_number, key):
        """
        Parameters:
         - seq_number
         - key

        """
        self.send_update_master_key(seq_number, key)
        self.recv_update_master_key()

    def send_update_master_key(self, seq_number, key):
        self._oprot.writeMessageBegin('update_master_key', TMessageType.CALL, self._seqid)
        args = update_master_key_args()
        args.seq_number = seq_number
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_master_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_master_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def remove_master_key(self, key_seq):
        """
        Parameters:
         - key_seq

        """
        self.send_remove_master_key(key_seq)
        return self.recv_remove_master_key()

    def send_remove_master_key(self, key_seq):
        self._oprot.writeMessageBegin('remove_master_key', TMessageType.CALL, self._seqid)
        args = remove_master_key_args()
        args.key_seq = key_seq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_master_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_master_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_master_key failed: unknown result")

    def get_master_keys(self):
        self.send_get_master_keys()
        return self.recv_get_master_keys()

    def send_get_master_keys(self):
        self._oprot.writeMessageBegin('get_master_keys', TMessageType.CALL, self._seqid)
        args = get_master_keys_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_master_keys(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_master_keys_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_master_keys failed: unknown result")

    def get_open_txns(self):
        self.send_get_open_txns()
        return self.recv_get_open_txns()

    def send_get_open_txns(self):
        self._oprot.writeMessageBegin('get_open_txns', TMessageType.CALL, self._seqid)
        args = get_open_txns_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_open_txns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_open_txns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns failed: unknown result")

    def get_open_txns_info(self):
        self.send_get_open_txns_info()
        return self.recv_get_open_txns_info()

    def send_get_open_txns_info(self):
        self._oprot.writeMessageBegin('get_open_txns_info', TMessageType.CALL, self._seqid)
        args = get_open_txns_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_open_txns_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_open_txns_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns_info failed: unknown result")

    def open_txns(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_open_txns(rqst)
        return self.recv_open_txns()

    def send_open_txns(self, rqst):
        self._oprot.writeMessageBegin('open_txns', TMessageType.CALL, self._seqid)
        args = open_txns_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open_txns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_txns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "open_txns failed: unknown result")

    def abort_txn(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_abort_txn(rqst)
        self.recv_abort_txn()

    def send_abort_txn(self, rqst):
        self._oprot.writeMessageBegin('abort_txn', TMessageType.CALL, self._seqid)
        args = abort_txn_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abort_txn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abort_txn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def abort_txns(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_abort_txns(rqst)
        self.recv_abort_txns()

    def send_abort_txns(self, rqst):
        self._oprot.writeMessageBegin('abort_txns', TMessageType.CALL, self._seqid)
        args = abort_txns_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abort_txns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abort_txns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def commit_txn(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_commit_txn(rqst)
        self.recv_commit_txn()

    def send_commit_txn(self, rqst):
        self._oprot.writeMessageBegin('commit_txn', TMessageType.CALL, self._seqid)
        args = commit_txn_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commit_txn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commit_txn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def lock(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_lock(rqst)
        return self.recv_lock()

    def send_lock(self, rqst):
        self._oprot.writeMessageBegin('lock', TMessageType.CALL, self._seqid)
        args = lock_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_lock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = lock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "lock failed: unknown result")

    def check_lock(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_check_lock(rqst)
        return self.recv_check_lock()

    def send_check_lock(self, rqst):
        self._oprot.writeMessageBegin('check_lock', TMessageType.CALL, self._seqid)
        args = check_lock_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_lock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_lock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_lock failed: unknown result")

    def unlock(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_unlock(rqst)
        self.recv_unlock()

    def send_unlock(self, rqst):
        self._oprot.writeMessageBegin('unlock', TMessageType.CALL, self._seqid)
        args = unlock_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unlock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unlock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def show_locks(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_show_locks(rqst)
        return self.recv_show_locks()

    def send_show_locks(self, rqst):
        self._oprot.writeMessageBegin('show_locks', TMessageType.CALL, self._seqid)
        args = show_locks_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_show_locks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = show_locks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "show_locks failed: unknown result")

    def heartbeat(self, ids):
        """
        Parameters:
         - ids

        """
        self.send_heartbeat(ids)
        self.recv_heartbeat()

    def send_heartbeat(self, ids):
        self._oprot.writeMessageBegin('heartbeat', TMessageType.CALL, self._seqid)
        args = heartbeat_args()
        args.ids = ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_heartbeat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = heartbeat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def heartbeat_txn_range(self, txns):
        """
        Parameters:
         - txns

        """
        self.send_heartbeat_txn_range(txns)
        return self.recv_heartbeat_txn_range()

    def send_heartbeat_txn_range(self, txns):
        self._oprot.writeMessageBegin('heartbeat_txn_range', TMessageType.CALL, self._seqid)
        args = heartbeat_txn_range_args()
        args.txns = txns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_heartbeat_txn_range(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = heartbeat_txn_range_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "heartbeat_txn_range failed: unknown result")

    def compact(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_compact(rqst)
        self.recv_compact()

    def send_compact(self, rqst):
        self._oprot.writeMessageBegin('compact', TMessageType.CALL, self._seqid)
        args = compact_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compact(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compact_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def compact2(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_compact2(rqst)
        return self.recv_compact2()

    def send_compact2(self, rqst):
        self._oprot.writeMessageBegin('compact2', TMessageType.CALL, self._seqid)
        args = compact2_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compact2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compact2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "compact2 failed: unknown result")

    def show_compact(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_show_compact(rqst)
        return self.recv_show_compact()

    def send_show_compact(self, rqst):
        self._oprot.writeMessageBegin('show_compact', TMessageType.CALL, self._seqid)
        args = show_compact_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_show_compact(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = show_compact_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "show_compact failed: unknown result")

    def add_dynamic_partitions(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_add_dynamic_partitions(rqst)
        self.recv_add_dynamic_partitions()

    def send_add_dynamic_partitions(self, rqst):
        self._oprot.writeMessageBegin('add_dynamic_partitions', TMessageType.CALL, self._seqid)
        args = add_dynamic_partitions_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_dynamic_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_dynamic_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_next_notification(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_get_next_notification(rqst)
        return self.recv_get_next_notification()

    def send_get_next_notification(self, rqst):
        self._oprot.writeMessageBegin('get_next_notification', TMessageType.CALL, self._seqid)
        args = get_next_notification_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_next_notification(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_next_notification_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_next_notification failed: unknown result")

    def get_current_notificationEventId(self):
        self.send_get_current_notificationEventId()
        return self.recv_get_current_notificationEventId()

    def send_get_current_notificationEventId(self):
        self._oprot.writeMessageBegin('get_current_notificationEventId', TMessageType.CALL, self._seqid)
        args = get_current_notificationEventId_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_current_notificationEventId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_current_notificationEventId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_current_notificationEventId failed: unknown result")

    def fire_listener_event(self, rqst):
        """
        Parameters:
         - rqst

        """
        self.send_fire_listener_event(rqst)
        return self.recv_fire_listener_event()

    def send_fire_listener_event(self, rqst):
        self._oprot.writeMessageBegin('fire_listener_event', TMessageType.CALL, self._seqid)
        args = fire_listener_event_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fire_listener_event(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fire_listener_event_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fire_listener_event failed: unknown result")

    def flushCache(self):
        self.send_flushCache()
        self.recv_flushCache()

    def send_flushCache(self):
        self._oprot.writeMessageBegin('flushCache', TMessageType.CALL, self._seqid)
        args = flushCache_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_flushCache(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = flushCache_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def get_file_metadata_by_expr(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_file_metadata_by_expr(req)
        return self.recv_get_file_metadata_by_expr()

    def send_get_file_metadata_by_expr(self, req):
        self._oprot.writeMessageBegin('get_file_metadata_by_expr', TMessageType.CALL, self._seqid)
        args = get_file_metadata_by_expr_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_file_metadata_by_expr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_file_metadata_by_expr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_file_metadata_by_expr failed: unknown result")

    def get_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_file_metadata(req)
        return self.recv_get_file_metadata()

    def send_get_file_metadata(self, req):
        self._oprot.writeMessageBegin('get_file_metadata', TMessageType.CALL, self._seqid)
        args = get_file_metadata_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_file_metadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_file_metadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_file_metadata failed: unknown result")

    def put_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        self.send_put_file_metadata(req)
        return self.recv_put_file_metadata()

    def send_put_file_metadata(self, req):
        self._oprot.writeMessageBegin('put_file_metadata', TMessageType.CALL, self._seqid)
        args = put_file_metadata_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_put_file_metadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = put_file_metadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "put_file_metadata failed: unknown result")

    def clear_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        self.send_clear_file_metadata(req)
        return self.recv_clear_file_metadata()

    def send_clear_file_metadata(self, req):
        self._oprot.writeMessageBegin('clear_file_metadata', TMessageType.CALL, self._seqid)
        args = clear_file_metadata_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clear_file_metadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clear_file_metadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "clear_file_metadata failed: unknown result")

    def cache_file_metadata(self, req):
        """
        Parameters:
         - req

        """
        self.send_cache_file_metadata(req)
        return self.recv_cache_file_metadata()

    def send_cache_file_metadata(self, req):
        self._oprot.writeMessageBegin('cache_file_metadata', TMessageType.CALL, self._seqid)
        args = cache_file_metadata_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cache_file_metadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cache_file_metadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "cache_file_metadata failed: unknown result")


class Processor(fb303.FacebookService.Processor, Iface, TProcessor):
    def __init__(self, handler):
        fb303.FacebookService.Processor.__init__(self, handler)
        self._processMap["getMetaConf"] = Processor.process_getMetaConf
        self._processMap["setMetaConf"] = Processor.process_setMetaConf
        self._processMap["create_database"] = Processor.process_create_database
        self._processMap["get_database"] = Processor.process_get_database
        self._processMap["drop_database"] = Processor.process_drop_database
        self._processMap["get_databases"] = Processor.process_get_databases
        self._processMap["get_all_databases"] = Processor.process_get_all_databases
        self._processMap["alter_database"] = Processor.process_alter_database
        self._processMap["get_type"] = Processor.process_get_type
        self._processMap["create_type"] = Processor.process_create_type
        self._processMap["drop_type"] = Processor.process_drop_type
        self._processMap["get_type_all"] = Processor.process_get_type_all
        self._processMap["get_fields"] = Processor.process_get_fields
        self._processMap["get_fields_with_environment_context"] = Processor.process_get_fields_with_environment_context
        self._processMap["get_schema"] = Processor.process_get_schema
        self._processMap["get_schema_with_environment_context"] = Processor.process_get_schema_with_environment_context
        self._processMap["create_table"] = Processor.process_create_table
        self._processMap["create_table_with_environment_context"] = Processor.process_create_table_with_environment_context
        self._processMap["create_table_with_constraints"] = Processor.process_create_table_with_constraints
        self._processMap["drop_constraint"] = Processor.process_drop_constraint
        self._processMap["add_primary_key"] = Processor.process_add_primary_key
        self._processMap["add_foreign_key"] = Processor.process_add_foreign_key
        self._processMap["drop_table"] = Processor.process_drop_table
        self._processMap["drop_table_with_environment_context"] = Processor.process_drop_table_with_environment_context
        self._processMap["get_tables"] = Processor.process_get_tables
        self._processMap["get_tables_by_type"] = Processor.process_get_tables_by_type
        self._processMap["get_table_meta"] = Processor.process_get_table_meta
        self._processMap["get_all_tables"] = Processor.process_get_all_tables
        self._processMap["get_table"] = Processor.process_get_table
        self._processMap["get_table_objects_by_name"] = Processor.process_get_table_objects_by_name
        self._processMap["get_table_req"] = Processor.process_get_table_req
        self._processMap["get_table_objects_by_name_req"] = Processor.process_get_table_objects_by_name_req
        self._processMap["get_table_names_by_filter"] = Processor.process_get_table_names_by_filter
        self._processMap["alter_table"] = Processor.process_alter_table
        self._processMap["alter_table_with_environment_context"] = Processor.process_alter_table_with_environment_context
        self._processMap["alter_table_with_cascade"] = Processor.process_alter_table_with_cascade
        self._processMap["add_partition"] = Processor.process_add_partition
        self._processMap["add_partition_with_environment_context"] = Processor.process_add_partition_with_environment_context
        self._processMap["add_partitions"] = Processor.process_add_partitions
        self._processMap["add_partitions_pspec"] = Processor.process_add_partitions_pspec
        self._processMap["append_partition"] = Processor.process_append_partition
        self._processMap["add_partitions_req"] = Processor.process_add_partitions_req
        self._processMap["append_partition_with_environment_context"] = Processor.process_append_partition_with_environment_context
        self._processMap["append_partition_by_name"] = Processor.process_append_partition_by_name
        self._processMap["append_partition_by_name_with_environment_context"] = Processor.process_append_partition_by_name_with_environment_context
        self._processMap["drop_partition"] = Processor.process_drop_partition
        self._processMap["drop_partition_with_environment_context"] = Processor.process_drop_partition_with_environment_context
        self._processMap["drop_partition_by_name"] = Processor.process_drop_partition_by_name
        self._processMap["drop_partition_by_name_with_environment_context"] = Processor.process_drop_partition_by_name_with_environment_context
        self._processMap["drop_partitions_req"] = Processor.process_drop_partitions_req
        self._processMap["get_partition"] = Processor.process_get_partition
        self._processMap["exchange_partition"] = Processor.process_exchange_partition
        self._processMap["exchange_partitions"] = Processor.process_exchange_partitions
        self._processMap["get_partition_with_auth"] = Processor.process_get_partition_with_auth
        self._processMap["get_partition_by_name"] = Processor.process_get_partition_by_name
        self._processMap["get_partitions"] = Processor.process_get_partitions
        self._processMap["get_partitions_with_auth"] = Processor.process_get_partitions_with_auth
        self._processMap["get_partitions_pspec"] = Processor.process_get_partitions_pspec
        self._processMap["get_partition_names"] = Processor.process_get_partition_names
        self._processMap["get_partition_values"] = Processor.process_get_partition_values
        self._processMap["get_partitions_ps"] = Processor.process_get_partitions_ps
        self._processMap["get_partitions_ps_with_auth"] = Processor.process_get_partitions_ps_with_auth
        self._processMap["get_partition_names_ps"] = Processor.process_get_partition_names_ps
        self._processMap["get_partitions_by_filter"] = Processor.process_get_partitions_by_filter
        self._processMap["get_part_specs_by_filter"] = Processor.process_get_part_specs_by_filter
        self._processMap["get_partitions_by_expr"] = Processor.process_get_partitions_by_expr
        self._processMap["get_num_partitions_by_filter"] = Processor.process_get_num_partitions_by_filter
        self._processMap["get_partitions_by_names"] = Processor.process_get_partitions_by_names
        self._processMap["alter_partition"] = Processor.process_alter_partition
        self._processMap["alter_partitions"] = Processor.process_alter_partitions
        self._processMap["alter_partitions_with_environment_context"] = Processor.process_alter_partitions_with_environment_context
        self._processMap["alter_partition_with_environment_context"] = Processor.process_alter_partition_with_environment_context
        self._processMap["rename_partition"] = Processor.process_rename_partition
        self._processMap["partition_name_has_valid_characters"] = Processor.process_partition_name_has_valid_characters
        self._processMap["get_config_value"] = Processor.process_get_config_value
        self._processMap["partition_name_to_vals"] = Processor.process_partition_name_to_vals
        self._processMap["partition_name_to_spec"] = Processor.process_partition_name_to_spec
        self._processMap["markPartitionForEvent"] = Processor.process_markPartitionForEvent
        self._processMap["isPartitionMarkedForEvent"] = Processor.process_isPartitionMarkedForEvent
        self._processMap["add_index"] = Processor.process_add_index
        self._processMap["alter_index"] = Processor.process_alter_index
        self._processMap["drop_index_by_name"] = Processor.process_drop_index_by_name
        self._processMap["get_index_by_name"] = Processor.process_get_index_by_name
        self._processMap["get_indexes"] = Processor.process_get_indexes
        self._processMap["get_index_names"] = Processor.process_get_index_names
        self._processMap["get_primary_keys"] = Processor.process_get_primary_keys
        self._processMap["get_foreign_keys"] = Processor.process_get_foreign_keys
        self._processMap["update_table_column_statistics"] = Processor.process_update_table_column_statistics
        self._processMap["update_partition_column_statistics"] = Processor.process_update_partition_column_statistics
        self._processMap["get_table_column_statistics"] = Processor.process_get_table_column_statistics
        self._processMap["get_partition_column_statistics"] = Processor.process_get_partition_column_statistics
        self._processMap["get_table_statistics_req"] = Processor.process_get_table_statistics_req
        self._processMap["get_partitions_statistics_req"] = Processor.process_get_partitions_statistics_req
        self._processMap["get_aggr_stats_for"] = Processor.process_get_aggr_stats_for
        self._processMap["set_aggr_stats_for"] = Processor.process_set_aggr_stats_for
        self._processMap["delete_partition_column_statistics"] = Processor.process_delete_partition_column_statistics
        self._processMap["delete_table_column_statistics"] = Processor.process_delete_table_column_statistics
        self._processMap["create_function"] = Processor.process_create_function
        self._processMap["drop_function"] = Processor.process_drop_function
        self._processMap["alter_function"] = Processor.process_alter_function
        self._processMap["get_functions"] = Processor.process_get_functions
        self._processMap["get_function"] = Processor.process_get_function
        self._processMap["get_all_functions"] = Processor.process_get_all_functions
        self._processMap["create_role"] = Processor.process_create_role
        self._processMap["drop_role"] = Processor.process_drop_role
        self._processMap["get_role_names"] = Processor.process_get_role_names
        self._processMap["grant_role"] = Processor.process_grant_role
        self._processMap["revoke_role"] = Processor.process_revoke_role
        self._processMap["list_roles"] = Processor.process_list_roles
        self._processMap["grant_revoke_role"] = Processor.process_grant_revoke_role
        self._processMap["get_principals_in_role"] = Processor.process_get_principals_in_role
        self._processMap["get_role_grants_for_principal"] = Processor.process_get_role_grants_for_principal
        self._processMap["get_privilege_set"] = Processor.process_get_privilege_set
        self._processMap["list_privileges"] = Processor.process_list_privileges
        self._processMap["grant_privileges"] = Processor.process_grant_privileges
        self._processMap["revoke_privileges"] = Processor.process_revoke_privileges
        self._processMap["grant_revoke_privileges"] = Processor.process_grant_revoke_privileges
        self._processMap["set_ugi"] = Processor.process_set_ugi
        self._processMap["get_delegation_token"] = Processor.process_get_delegation_token
        self._processMap["renew_delegation_token"] = Processor.process_renew_delegation_token
        self._processMap["cancel_delegation_token"] = Processor.process_cancel_delegation_token
        self._processMap["add_token"] = Processor.process_add_token
        self._processMap["remove_token"] = Processor.process_remove_token
        self._processMap["get_token"] = Processor.process_get_token
        self._processMap["get_all_token_identifiers"] = Processor.process_get_all_token_identifiers
        self._processMap["add_master_key"] = Processor.process_add_master_key
        self._processMap["update_master_key"] = Processor.process_update_master_key
        self._processMap["remove_master_key"] = Processor.process_remove_master_key
        self._processMap["get_master_keys"] = Processor.process_get_master_keys
        self._processMap["get_open_txns"] = Processor.process_get_open_txns
        self._processMap["get_open_txns_info"] = Processor.process_get_open_txns_info
        self._processMap["open_txns"] = Processor.process_open_txns
        self._processMap["abort_txn"] = Processor.process_abort_txn
        self._processMap["abort_txns"] = Processor.process_abort_txns
        self._processMap["commit_txn"] = Processor.process_commit_txn
        self._processMap["lock"] = Processor.process_lock
        self._processMap["check_lock"] = Processor.process_check_lock
        self._processMap["unlock"] = Processor.process_unlock
        self._processMap["show_locks"] = Processor.process_show_locks
        self._processMap["heartbeat"] = Processor.process_heartbeat
        self._processMap["heartbeat_txn_range"] = Processor.process_heartbeat_txn_range
        self._processMap["compact"] = Processor.process_compact
        self._processMap["compact2"] = Processor.process_compact2
        self._processMap["show_compact"] = Processor.process_show_compact
        self._processMap["add_dynamic_partitions"] = Processor.process_add_dynamic_partitions
        self._processMap["get_next_notification"] = Processor.process_get_next_notification
        self._processMap["get_current_notificationEventId"] = Processor.process_get_current_notificationEventId
        self._processMap["fire_listener_event"] = Processor.process_fire_listener_event
        self._processMap["flushCache"] = Processor.process_flushCache
        self._processMap["get_file_metadata_by_expr"] = Processor.process_get_file_metadata_by_expr
        self._processMap["get_file_metadata"] = Processor.process_get_file_metadata
        self._processMap["put_file_metadata"] = Processor.process_put_file_metadata
        self._processMap["clear_file_metadata"] = Processor.process_clear_file_metadata
        self._processMap["cache_file_metadata"] = Processor.process_cache_file_metadata
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getMetaConf(self, seqid, iprot, oprot):
        args = getMetaConf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMetaConf_result()
        try:
            result.success = self._handler.getMetaConf(args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMetaConf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setMetaConf(self, seqid, iprot, oprot):
        args = setMetaConf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setMetaConf_result()
        try:
            self._handler.setMetaConf(args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setMetaConf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_database(self, seqid, iprot, oprot):
        args = create_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_database_result()
        try:
            self._handler.create_database(args.database)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_database(self, seqid, iprot, oprot):
        args = get_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_database_result()
        try:
            result.success = self._handler.get_database(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_database(self, seqid, iprot, oprot):
        args = drop_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_database_result()
        try:
            self._handler.drop_database(args.name, args.deleteData, args.cascade)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_databases(self, seqid, iprot, oprot):
        args = get_databases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_databases_result()
        try:
            result.success = self._handler.get_databases(args.pattern)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_databases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_databases(self, seqid, iprot, oprot):
        args = get_all_databases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_databases_result()
        try:
            result.success = self._handler.get_all_databases()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_databases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_database(self, seqid, iprot, oprot):
        args = alter_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_database_result()
        try:
            self._handler.alter_database(args.dbname, args.db)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_type(self, seqid, iprot, oprot):
        args = get_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_type_result()
        try:
            result.success = self._handler.get_type(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_type(self, seqid, iprot, oprot):
        args = create_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_type_result()
        try:
            result.success = self._handler.create_type(args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_type(self, seqid, iprot, oprot):
        args = drop_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_type_result()
        try:
            result.success = self._handler.drop_type(args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_type_all(self, seqid, iprot, oprot):
        args = get_type_all_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_type_all_result()
        try:
            result.success = self._handler.get_type_all(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_type_all", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fields(self, seqid, iprot, oprot):
        args = get_fields_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fields_result()
        try:
            result.success = self._handler.get_fields(args.db_name, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fields", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fields_with_environment_context(self, seqid, iprot, oprot):
        args = get_fields_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fields_with_environment_context_result()
        try:
            result.success = self._handler.get_fields_with_environment_context(args.db_name, args.table_name, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fields_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema(self, seqid, iprot, oprot):
        args = get_schema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_result()
        try:
            result.success = self._handler.get_schema(args.db_name, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema_with_environment_context(self, seqid, iprot, oprot):
        args = get_schema_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_with_environment_context_result()
        try:
            result.success = self._handler.get_schema_with_environment_context(args.db_name, args.table_name, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schema_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_table(self, seqid, iprot, oprot):
        args = create_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_table_result()
        try:
            self._handler.create_table(args.tbl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_table_with_environment_context(self, seqid, iprot, oprot):
        args = create_table_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_table_with_environment_context_result()
        try:
            self._handler.create_table_with_environment_context(args.tbl, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_table_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_table_with_constraints(self, seqid, iprot, oprot):
        args = create_table_with_constraints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_table_with_constraints_result()
        try:
            self._handler.create_table_with_constraints(args.tbl, args.primaryKeys, args.foreignKeys)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_table_with_constraints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_constraint(self, seqid, iprot, oprot):
        args = drop_constraint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_constraint_result()
        try:
            self._handler.drop_constraint(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_constraint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_primary_key(self, seqid, iprot, oprot):
        args = add_primary_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_primary_key_result()
        try:
            self._handler.add_primary_key(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_primary_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_foreign_key(self, seqid, iprot, oprot):
        args = add_foreign_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_foreign_key_result()
        try:
            self._handler.add_foreign_key(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_foreign_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_table(self, seqid, iprot, oprot):
        args = drop_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_table_result()
        try:
            self._handler.drop_table(args.dbname, args.name, args.deleteData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_table_with_environment_context(self, seqid, iprot, oprot):
        args = drop_table_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_table_with_environment_context_result()
        try:
            self._handler.drop_table_with_environment_context(args.dbname, args.name, args.deleteData, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_table_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tables(self, seqid, iprot, oprot):
        args = get_tables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tables_result()
        try:
            result.success = self._handler.get_tables(args.db_name, args.pattern)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tables_by_type(self, seqid, iprot, oprot):
        args = get_tables_by_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tables_by_type_result()
        try:
            result.success = self._handler.get_tables_by_type(args.db_name, args.pattern, args.tableType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tables_by_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_meta(self, seqid, iprot, oprot):
        args = get_table_meta_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_meta_result()
        try:
            result.success = self._handler.get_table_meta(args.db_patterns, args.tbl_patterns, args.tbl_types)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_meta", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_tables(self, seqid, iprot, oprot):
        args = get_all_tables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_tables_result()
        try:
            result.success = self._handler.get_all_tables(args.db_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_tables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table(self, seqid, iprot, oprot):
        args = get_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_result()
        try:
            result.success = self._handler.get_table(args.dbname, args.tbl_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_objects_by_name(self, seqid, iprot, oprot):
        args = get_table_objects_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_objects_by_name_result()
        try:
            result.success = self._handler.get_table_objects_by_name(args.dbname, args.tbl_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_objects_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_req(self, seqid, iprot, oprot):
        args = get_table_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_req_result()
        try:
            result.success = self._handler.get_table_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_objects_by_name_req(self, seqid, iprot, oprot):
        args = get_table_objects_by_name_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_objects_by_name_req_result()
        try:
            result.success = self._handler.get_table_objects_by_name_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_objects_by_name_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_names_by_filter(self, seqid, iprot, oprot):
        args = get_table_names_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_names_by_filter_result()
        try:
            result.success = self._handler.get_table_names_by_filter(args.dbname, args.filter, args.max_tables)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_names_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_table(self, seqid, iprot, oprot):
        args = alter_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_table_result()
        try:
            self._handler.alter_table(args.dbname, args.tbl_name, args.new_tbl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_table_with_environment_context(self, seqid, iprot, oprot):
        args = alter_table_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_table_with_environment_context_result()
        try:
            self._handler.alter_table_with_environment_context(args.dbname, args.tbl_name, args.new_tbl, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_table_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_table_with_cascade(self, seqid, iprot, oprot):
        args = alter_table_with_cascade_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_table_with_cascade_result()
        try:
            self._handler.alter_table_with_cascade(args.dbname, args.tbl_name, args.new_tbl, args.cascade)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_table_with_cascade", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partition(self, seqid, iprot, oprot):
        args = add_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partition_result()
        try:
            result.success = self._handler.add_partition(args.new_part)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partition_with_environment_context(self, seqid, iprot, oprot):
        args = add_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partition_with_environment_context_result()
        try:
            result.success = self._handler.add_partition_with_environment_context(args.new_part, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partitions(self, seqid, iprot, oprot):
        args = add_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partitions_result()
        try:
            result.success = self._handler.add_partitions(args.new_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partitions_pspec(self, seqid, iprot, oprot):
        args = add_partitions_pspec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partitions_pspec_result()
        try:
            result.success = self._handler.add_partitions_pspec(args.new_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_partitions_pspec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition(self, seqid, iprot, oprot):
        args = append_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_result()
        try:
            result.success = self._handler.append_partition(args.db_name, args.tbl_name, args.part_vals)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partitions_req(self, seqid, iprot, oprot):
        args = add_partitions_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partitions_req_result()
        try:
            result.success = self._handler.add_partitions_req(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_partitions_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition_with_environment_context(self, seqid, iprot, oprot):
        args = append_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_with_environment_context_result()
        try:
            result.success = self._handler.append_partition_with_environment_context(args.db_name, args.tbl_name, args.part_vals, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition_by_name(self, seqid, iprot, oprot):
        args = append_partition_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_by_name_result()
        try:
            result.success = self._handler.append_partition_by_name(args.db_name, args.tbl_name, args.part_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append_partition_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition_by_name_with_environment_context(self, seqid, iprot, oprot):
        args = append_partition_by_name_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_by_name_with_environment_context_result()
        try:
            result.success = self._handler.append_partition_by_name_with_environment_context(args.db_name, args.tbl_name, args.part_name, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append_partition_by_name_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition(self, seqid, iprot, oprot):
        args = drop_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_result()
        try:
            result.success = self._handler.drop_partition(args.db_name, args.tbl_name, args.part_vals, args.deleteData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition_with_environment_context(self, seqid, iprot, oprot):
        args = drop_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_with_environment_context_result()
        try:
            result.success = self._handler.drop_partition_with_environment_context(args.db_name, args.tbl_name, args.part_vals, args.deleteData, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition_by_name(self, seqid, iprot, oprot):
        args = drop_partition_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_by_name_result()
        try:
            result.success = self._handler.drop_partition_by_name(args.db_name, args.tbl_name, args.part_name, args.deleteData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_partition_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition_by_name_with_environment_context(self, seqid, iprot, oprot):
        args = drop_partition_by_name_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_by_name_with_environment_context_result()
        try:
            result.success = self._handler.drop_partition_by_name_with_environment_context(args.db_name, args.tbl_name, args.part_name, args.deleteData, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_partition_by_name_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partitions_req(self, seqid, iprot, oprot):
        args = drop_partitions_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partitions_req_result()
        try:
            result.success = self._handler.drop_partitions_req(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_partitions_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition(self, seqid, iprot, oprot):
        args = get_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_result()
        try:
            result.success = self._handler.get_partition(args.db_name, args.tbl_name, args.part_vals)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exchange_partition(self, seqid, iprot, oprot):
        args = exchange_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exchange_partition_result()
        try:
            result.success = self._handler.exchange_partition(args.partitionSpecs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exchange_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exchange_partitions(self, seqid, iprot, oprot):
        args = exchange_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exchange_partitions_result()
        try:
            result.success = self._handler.exchange_partitions(args.partitionSpecs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exchange_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_with_auth(self, seqid, iprot, oprot):
        args = get_partition_with_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_with_auth_result()
        try:
            result.success = self._handler.get_partition_with_auth(args.db_name, args.tbl_name, args.part_vals, args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_with_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_by_name(self, seqid, iprot, oprot):
        args = get_partition_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_by_name_result()
        try:
            result.success = self._handler.get_partition_by_name(args.db_name, args.tbl_name, args.part_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions(self, seqid, iprot, oprot):
        args = get_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_result()
        try:
            result.success = self._handler.get_partitions(args.db_name, args.tbl_name, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_with_auth(self, seqid, iprot, oprot):
        args = get_partitions_with_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_with_auth_result()
        try:
            result.success = self._handler.get_partitions_with_auth(args.db_name, args.tbl_name, args.max_parts, args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_with_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_pspec(self, seqid, iprot, oprot):
        args = get_partitions_pspec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_pspec_result()
        try:
            result.success = self._handler.get_partitions_pspec(args.db_name, args.tbl_name, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_pspec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_names(self, seqid, iprot, oprot):
        args = get_partition_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_names_result()
        try:
            result.success = self._handler.get_partition_names(args.db_name, args.tbl_name, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_values(self, seqid, iprot, oprot):
        args = get_partition_values_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_values_result()
        try:
            result.success = self._handler.get_partition_values(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_values", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_ps(self, seqid, iprot, oprot):
        args = get_partitions_ps_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_ps_result()
        try:
            result.success = self._handler.get_partitions_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_ps", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_ps_with_auth(self, seqid, iprot, oprot):
        args = get_partitions_ps_with_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_ps_with_auth_result()
        try:
            result.success = self._handler.get_partitions_ps_with_auth(args.db_name, args.tbl_name, args.part_vals, args.max_parts, args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_ps_with_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_names_ps(self, seqid, iprot, oprot):
        args = get_partition_names_ps_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_names_ps_result()
        try:
            result.success = self._handler.get_partition_names_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_names_ps", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_by_filter(self, seqid, iprot, oprot):
        args = get_partitions_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_by_filter_result()
        try:
            result.success = self._handler.get_partitions_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_part_specs_by_filter(self, seqid, iprot, oprot):
        args = get_part_specs_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_part_specs_by_filter_result()
        try:
            result.success = self._handler.get_part_specs_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_part_specs_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_by_expr(self, seqid, iprot, oprot):
        args = get_partitions_by_expr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_by_expr_result()
        try:
            result.success = self._handler.get_partitions_by_expr(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_by_expr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_num_partitions_by_filter(self, seqid, iprot, oprot):
        args = get_num_partitions_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_num_partitions_by_filter_result()
        try:
            result.success = self._handler.get_num_partitions_by_filter(args.db_name, args.tbl_name, args.filter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_num_partitions_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_by_names(self, seqid, iprot, oprot):
        args = get_partitions_by_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_by_names_result()
        try:
            result.success = self._handler.get_partitions_by_names(args.db_name, args.tbl_name, args.names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_by_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partition(self, seqid, iprot, oprot):
        args = alter_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partition_result()
        try:
            self._handler.alter_partition(args.db_name, args.tbl_name, args.new_part)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partitions(self, seqid, iprot, oprot):
        args = alter_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partitions_result()
        try:
            self._handler.alter_partitions(args.db_name, args.tbl_name, args.new_parts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partitions_with_environment_context(self, seqid, iprot, oprot):
        args = alter_partitions_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partitions_with_environment_context_result()
        try:
            self._handler.alter_partitions_with_environment_context(args.db_name, args.tbl_name, args.new_parts, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_partitions_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partition_with_environment_context(self, seqid, iprot, oprot):
        args = alter_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partition_with_environment_context_result()
        try:
            self._handler.alter_partition_with_environment_context(args.db_name, args.tbl_name, args.new_part, args.environment_context)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rename_partition(self, seqid, iprot, oprot):
        args = rename_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rename_partition_result()
        try:
            self._handler.rename_partition(args.db_name, args.tbl_name, args.part_vals, args.new_part)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rename_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_partition_name_has_valid_characters(self, seqid, iprot, oprot):
        args = partition_name_has_valid_characters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = partition_name_has_valid_characters_result()
        try:
            result.success = self._handler.partition_name_has_valid_characters(args.part_vals, args.throw_exception)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("partition_name_has_valid_characters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_config_value(self, seqid, iprot, oprot):
        args = get_config_value_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_config_value_result()
        try:
            result.success = self._handler.get_config_value(args.name, args.defaultValue)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ConfigValSecurityException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_config_value", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_partition_name_to_vals(self, seqid, iprot, oprot):
        args = partition_name_to_vals_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = partition_name_to_vals_result()
        try:
            result.success = self._handler.partition_name_to_vals(args.part_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("partition_name_to_vals", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_partition_name_to_spec(self, seqid, iprot, oprot):
        args = partition_name_to_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = partition_name_to_spec_result()
        try:
            result.success = self._handler.partition_name_to_spec(args.part_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("partition_name_to_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_markPartitionForEvent(self, seqid, iprot, oprot):
        args = markPartitionForEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = markPartitionForEvent_result()
        try:
            self._handler.markPartitionForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except UnknownTableException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except UnknownPartitionException as o5:
            msg_type = TMessageType.REPLY
            result.o5 = o5
        except InvalidPartitionException as o6:
            msg_type = TMessageType.REPLY
            result.o6 = o6
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("markPartitionForEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isPartitionMarkedForEvent(self, seqid, iprot, oprot):
        args = isPartitionMarkedForEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isPartitionMarkedForEvent_result()
        try:
            result.success = self._handler.isPartitionMarkedForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except UnknownTableException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except UnknownPartitionException as o5:
            msg_type = TMessageType.REPLY
            result.o5 = o5
        except InvalidPartitionException as o6:
            msg_type = TMessageType.REPLY
            result.o6 = o6
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isPartitionMarkedForEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_index(self, seqid, iprot, oprot):
        args = add_index_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_index_result()
        try:
            result.success = self._handler.add_index(args.new_index, args.index_table)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_index", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_index(self, seqid, iprot, oprot):
        args = alter_index_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_index_result()
        try:
            self._handler.alter_index(args.dbname, args.base_tbl_name, args.idx_name, args.new_idx)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_index", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_index_by_name(self, seqid, iprot, oprot):
        args = drop_index_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_index_by_name_result()
        try:
            result.success = self._handler.drop_index_by_name(args.db_name, args.tbl_name, args.index_name, args.deleteData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_index_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_index_by_name(self, seqid, iprot, oprot):
        args = get_index_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_index_by_name_result()
        try:
            result.success = self._handler.get_index_by_name(args.db_name, args.tbl_name, args.index_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_index_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_indexes(self, seqid, iprot, oprot):
        args = get_indexes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_indexes_result()
        try:
            result.success = self._handler.get_indexes(args.db_name, args.tbl_name, args.max_indexes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_indexes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_index_names(self, seqid, iprot, oprot):
        args = get_index_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_index_names_result()
        try:
            result.success = self._handler.get_index_names(args.db_name, args.tbl_name, args.max_indexes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_index_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_primary_keys(self, seqid, iprot, oprot):
        args = get_primary_keys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_primary_keys_result()
        try:
            result.success = self._handler.get_primary_keys(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_primary_keys", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_foreign_keys(self, seqid, iprot, oprot):
        args = get_foreign_keys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_foreign_keys_result()
        try:
            result.success = self._handler.get_foreign_keys(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_foreign_keys", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_table_column_statistics(self, seqid, iprot, oprot):
        args = update_table_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_table_column_statistics_result()
        try:
            result.success = self._handler.update_table_column_statistics(args.stats_obj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_table_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_partition_column_statistics(self, seqid, iprot, oprot):
        args = update_partition_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_partition_column_statistics_result()
        try:
            result.success = self._handler.update_partition_column_statistics(args.stats_obj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_partition_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_column_statistics(self, seqid, iprot, oprot):
        args = get_table_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_column_statistics_result()
        try:
            result.success = self._handler.get_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidInputException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_column_statistics(self, seqid, iprot, oprot):
        args = get_partition_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_column_statistics_result()
        try:
            result.success = self._handler.get_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidInputException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_statistics_req(self, seqid, iprot, oprot):
        args = get_table_statistics_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_statistics_req_result()
        try:
            result.success = self._handler.get_table_statistics_req(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_statistics_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_statistics_req(self, seqid, iprot, oprot):
        args = get_partitions_statistics_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_statistics_req_result()
        try:
            result.success = self._handler.get_partitions_statistics_req(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_statistics_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_aggr_stats_for(self, seqid, iprot, oprot):
        args = get_aggr_stats_for_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_aggr_stats_for_result()
        try:
            result.success = self._handler.get_aggr_stats_for(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_aggr_stats_for", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_aggr_stats_for(self, seqid, iprot, oprot):
        args = set_aggr_stats_for_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_aggr_stats_for_result()
        try:
            result.success = self._handler.set_aggr_stats_for(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_aggr_stats_for", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_partition_column_statistics(self, seqid, iprot, oprot):
        args = delete_partition_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_partition_column_statistics_result()
        try:
            result.success = self._handler.delete_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_partition_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_table_column_statistics(self, seqid, iprot, oprot):
        args = delete_table_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_table_column_statistics_result()
        try:
            result.success = self._handler.delete_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_table_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_function(self, seqid, iprot, oprot):
        args = create_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_function_result()
        try:
            self._handler.create_function(args.func)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_function(self, seqid, iprot, oprot):
        args = drop_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_function_result()
        try:
            self._handler.drop_function(args.dbName, args.funcName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_function(self, seqid, iprot, oprot):
        args = alter_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_function_result()
        try:
            self._handler.alter_function(args.dbName, args.funcName, args.newFunc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_functions(self, seqid, iprot, oprot):
        args = get_functions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_functions_result()
        try:
            result.success = self._handler.get_functions(args.dbName, args.pattern)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_functions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_function(self, seqid, iprot, oprot):
        args = get_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_function_result()
        try:
            result.success = self._handler.get_function(args.dbName, args.funcName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_functions(self, seqid, iprot, oprot):
        args = get_all_functions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_functions_result()
        try:
            result.success = self._handler.get_all_functions()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_functions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_role(self, seqid, iprot, oprot):
        args = create_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_role_result()
        try:
            result.success = self._handler.create_role(args.role)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_role(self, seqid, iprot, oprot):
        args = drop_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_role_result()
        try:
            result.success = self._handler.drop_role(args.role_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_role_names(self, seqid, iprot, oprot):
        args = get_role_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_role_names_result()
        try:
            result.success = self._handler.get_role_names()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_role_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_role(self, seqid, iprot, oprot):
        args = grant_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_role_result()
        try:
            result.success = self._handler.grant_role(args.role_name, args.principal_name, args.principal_type, args.grantor, args.grantorType, args.grant_option)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grant_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revoke_role(self, seqid, iprot, oprot):
        args = revoke_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revoke_role_result()
        try:
            result.success = self._handler.revoke_role(args.role_name, args.principal_name, args.principal_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revoke_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_list_roles(self, seqid, iprot, oprot):
        args = list_roles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = list_roles_result()
        try:
            result.success = self._handler.list_roles(args.principal_name, args.principal_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("list_roles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_revoke_role(self, seqid, iprot, oprot):
        args = grant_revoke_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_revoke_role_result()
        try:
            result.success = self._handler.grant_revoke_role(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grant_revoke_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_principals_in_role(self, seqid, iprot, oprot):
        args = get_principals_in_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_principals_in_role_result()
        try:
            result.success = self._handler.get_principals_in_role(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_principals_in_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_role_grants_for_principal(self, seqid, iprot, oprot):
        args = get_role_grants_for_principal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_role_grants_for_principal_result()
        try:
            result.success = self._handler.get_role_grants_for_principal(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_role_grants_for_principal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_privilege_set(self, seqid, iprot, oprot):
        args = get_privilege_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_privilege_set_result()
        try:
            result.success = self._handler.get_privilege_set(args.hiveObject, args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_privilege_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_list_privileges(self, seqid, iprot, oprot):
        args = list_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = list_privileges_result()
        try:
            result.success = self._handler.list_privileges(args.principal_name, args.principal_type, args.hiveObject)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("list_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_privileges(self, seqid, iprot, oprot):
        args = grant_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_privileges_result()
        try:
            result.success = self._handler.grant_privileges(args.privileges)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grant_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revoke_privileges(self, seqid, iprot, oprot):
        args = revoke_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revoke_privileges_result()
        try:
            result.success = self._handler.revoke_privileges(args.privileges)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revoke_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_revoke_privileges(self, seqid, iprot, oprot):
        args = grant_revoke_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_revoke_privileges_result()
        try:
            result.success = self._handler.grant_revoke_privileges(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grant_revoke_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_ugi(self, seqid, iprot, oprot):
        args = set_ugi_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_ugi_result()
        try:
            result.success = self._handler.set_ugi(args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_ugi", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_delegation_token(self, seqid, iprot, oprot):
        args = get_delegation_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_delegation_token_result()
        try:
            result.success = self._handler.get_delegation_token(args.token_owner, args.renewer_kerberos_principal_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_delegation_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_renew_delegation_token(self, seqid, iprot, oprot):
        args = renew_delegation_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = renew_delegation_token_result()
        try:
            result.success = self._handler.renew_delegation_token(args.token_str_form)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("renew_delegation_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancel_delegation_token(self, seqid, iprot, oprot):
        args = cancel_delegation_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancel_delegation_token_result()
        try:
            self._handler.cancel_delegation_token(args.token_str_form)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancel_delegation_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_token(self, seqid, iprot, oprot):
        args = add_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_token_result()
        try:
            result.success = self._handler.add_token(args.token_identifier, args.delegation_token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_token(self, seqid, iprot, oprot):
        args = remove_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_token_result()
        try:
            result.success = self._handler.remove_token(args.token_identifier)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_token(self, seqid, iprot, oprot):
        args = get_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_token_result()
        try:
            result.success = self._handler.get_token(args.token_identifier)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_token_identifiers(self, seqid, iprot, oprot):
        args = get_all_token_identifiers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_token_identifiers_result()
        try:
            result.success = self._handler.get_all_token_identifiers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_token_identifiers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_master_key(self, seqid, iprot, oprot):
        args = add_master_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_master_key_result()
        try:
            result.success = self._handler.add_master_key(args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_master_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_master_key(self, seqid, iprot, oprot):
        args = update_master_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_master_key_result()
        try:
            self._handler.update_master_key(args.seq_number, args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_master_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_master_key(self, seqid, iprot, oprot):
        args = remove_master_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_master_key_result()
        try:
            result.success = self._handler.remove_master_key(args.key_seq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_master_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_master_keys(self, seqid, iprot, oprot):
        args = get_master_keys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_master_keys_result()
        try:
            result.success = self._handler.get_master_keys()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_master_keys", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_open_txns(self, seqid, iprot, oprot):
        args = get_open_txns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_open_txns_result()
        try:
            result.success = self._handler.get_open_txns()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_open_txns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_open_txns_info(self, seqid, iprot, oprot):
        args = get_open_txns_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_open_txns_info_result()
        try:
            result.success = self._handler.get_open_txns_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_open_txns_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open_txns(self, seqid, iprot, oprot):
        args = open_txns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_txns_result()
        try:
            result.success = self._handler.open_txns(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("open_txns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abort_txn(self, seqid, iprot, oprot):
        args = abort_txn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abort_txn_result()
        try:
            self._handler.abort_txn(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("abort_txn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abort_txns(self, seqid, iprot, oprot):
        args = abort_txns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abort_txns_result()
        try:
            self._handler.abort_txns(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("abort_txns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commit_txn(self, seqid, iprot, oprot):
        args = commit_txn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commit_txn_result()
        try:
            self._handler.commit_txn(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commit_txn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_lock(self, seqid, iprot, oprot):
        args = lock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = lock_result()
        try:
            result.success = self._handler.lock(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("lock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_lock(self, seqid, iprot, oprot):
        args = check_lock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_lock_result()
        try:
            result.success = self._handler.check_lock(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except NoSuchLockException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_lock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unlock(self, seqid, iprot, oprot):
        args = unlock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unlock_result()
        try:
            self._handler.unlock(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchLockException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnOpenException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("unlock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_show_locks(self, seqid, iprot, oprot):
        args = show_locks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = show_locks_result()
        try:
            result.success = self._handler.show_locks(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("show_locks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_heartbeat(self, seqid, iprot, oprot):
        args = heartbeat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = heartbeat_result()
        try:
            self._handler.heartbeat(args.ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchLockException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchTxnException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TxnAbortedException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("heartbeat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_heartbeat_txn_range(self, seqid, iprot, oprot):
        args = heartbeat_txn_range_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = heartbeat_txn_range_result()
        try:
            result.success = self._handler.heartbeat_txn_range(args.txns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("heartbeat_txn_range", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compact(self, seqid, iprot, oprot):
        args = compact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compact_result()
        try:
            self._handler.compact(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("compact", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compact2(self, seqid, iprot, oprot):
        args = compact2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compact2_result()
        try:
            result.success = self._handler.compact2(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("compact2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_show_compact(self, seqid, iprot, oprot):
        args = show_compact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = show_compact_result()
        try:
            result.success = self._handler.show_compact(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("show_compact", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_dynamic_partitions(self, seqid, iprot, oprot):
        args = add_dynamic_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_dynamic_partitions_result()
        try:
            self._handler.add_dynamic_partitions(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_dynamic_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_next_notification(self, seqid, iprot, oprot):
        args = get_next_notification_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_next_notification_result()
        try:
            result.success = self._handler.get_next_notification(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_next_notification", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_current_notificationEventId(self, seqid, iprot, oprot):
        args = get_current_notificationEventId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_current_notificationEventId_result()
        try:
            result.success = self._handler.get_current_notificationEventId()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_current_notificationEventId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fire_listener_event(self, seqid, iprot, oprot):
        args = fire_listener_event_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fire_listener_event_result()
        try:
            result.success = self._handler.fire_listener_event(args.rqst)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fire_listener_event", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_flushCache(self, seqid, iprot, oprot):
        args = flushCache_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = flushCache_result()
        try:
            self._handler.flushCache()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("flushCache", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_file_metadata_by_expr(self, seqid, iprot, oprot):
        args = get_file_metadata_by_expr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_file_metadata_by_expr_result()
        try:
            result.success = self._handler.get_file_metadata_by_expr(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_file_metadata_by_expr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_file_metadata(self, seqid, iprot, oprot):
        args = get_file_metadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_file_metadata_result()
        try:
            result.success = self._handler.get_file_metadata(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_file_metadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_put_file_metadata(self, seqid, iprot, oprot):
        args = put_file_metadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = put_file_metadata_result()
        try:
            result.success = self._handler.put_file_metadata(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("put_file_metadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clear_file_metadata(self, seqid, iprot, oprot):
        args = clear_file_metadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clear_file_metadata_result()
        try:
            result.success = self._handler.clear_file_metadata(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clear_file_metadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cache_file_metadata(self, seqid, iprot, oprot):
        args = cache_file_metadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cache_file_metadata_result()
        try:
            result.success = self._handler.cache_file_metadata(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cache_file_metadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getMetaConf_args(object):
    """
    Attributes:
     - key

    """


    def __init__(self, key=None,):
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMetaConf_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMetaConf_args)
getMetaConf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
)


class getMetaConf_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMetaConf_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMetaConf_result)
getMetaConf_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class setMetaConf_args(object):
    """
    Attributes:
     - key
     - value

    """


    def __init__(self, key=None, value=None,):
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setMetaConf_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setMetaConf_args)
setMetaConf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
)


class setMetaConf_result(object):
    """
    Attributes:
     - o1

    """


    def __init__(self, o1=None,):
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setMetaConf_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setMetaConf_result)
setMetaConf_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class create_database_args(object):
    """
    Attributes:
     - database

    """


    def __init__(self, database=None,):
        self.database = database

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.database = Database()
                    self.database.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_database_args')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRUCT, 1)
            self.database.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_database_args)
create_database_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'database', [Database, None], None, ),  # 1
)


class create_database_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3

    """


    def __init__(self, o1=None, o2=None, o3=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_database_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_database_result)
create_database_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [AlreadyExistsException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class get_database_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_database_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_database_args)
get_database_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_database_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Database()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_database_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_database_result)
get_database_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Database, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class drop_database_args(object):
    """
    Attributes:
     - name
     - deleteData
     - cascade

    """


    def __init__(self, name=None, deleteData=None, cascade=None,):
        self.name = name
        self.deleteData = deleteData
        self.cascade = cascade

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.cascade = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_database_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 2)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.cascade is not None:
            oprot.writeFieldBegin('cascade', TType.BOOL, 3)
            oprot.writeBool(self.cascade)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_database_args)
drop_database_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'deleteData', None, None, ),  # 2
    (3, TType.BOOL, 'cascade', None, None, ),  # 3
)


class drop_database_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3

    """


    def __init__(self, o1=None, o2=None, o3=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_database_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_database_result)
drop_database_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidOperationException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class get_databases_args(object):
    """
    Attributes:
     - pattern

    """


    def __init__(self, pattern=None,):
        self.pattern = pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_databases_args')
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 1)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_databases_args)
get_databases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pattern', 'UTF8', None, ),  # 1
)


class get_databases_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype625, _size622) = iprot.readListBegin()
                    for _i626 in range(_size622):
                        _elem627 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem627)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_databases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter628 in self.success:
                oprot.writeString(iter628.encode('utf-8') if sys.version_info[0] == 2 else iter628)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_databases_result)
get_databases_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_all_databases_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_databases_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_databases_args)
get_all_databases_args.thrift_spec = (
)


class get_all_databases_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype632, _size629) = iprot.readListBegin()
                    for _i633 in range(_size629):
                        _elem634 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem634)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_databases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter635 in self.success:
                oprot.writeString(iter635.encode('utf-8') if sys.version_info[0] == 2 else iter635)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_databases_result)
get_all_databases_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class alter_database_args(object):
    """
    Attributes:
     - dbname
     - db

    """


    def __init__(self, dbname=None, db=None,):
        self.dbname = dbname
        self.db = db

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.db = Database()
                    self.db.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_database_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRUCT, 2)
            self.db.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_database_args)
alter_database_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'db', [Database, None], None, ),  # 2
)


class alter_database_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_database_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_database_result)
alter_database_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_type_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_type_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_type_args)
get_type_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_type_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Type()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_type_result)
get_type_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Type, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class create_type_args(object):
    """
    Attributes:
     - type

    """


    def __init__(self, type=None,):
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.type = Type()
                    self.type.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_type_args')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRUCT, 1)
            self.type.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_type_args)
create_type_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'type', [Type, None], None, ),  # 1
)


class create_type_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_type_result)
create_type_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [AlreadyExistsException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class drop_type_args(object):
    """
    Attributes:
     - type

    """


    def __init__(self, type=None,):
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_type_args')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 1)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_type_args)
drop_type_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'type', 'UTF8', None, ),  # 1
)


class drop_type_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_type_result)
drop_type_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_type_all_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_type_all_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_type_all_args)
get_type_all_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_type_all_result(object):
    """
    Attributes:
     - success
     - o2

    """


    def __init__(self, success=None, o2=None,):
        self.success = success
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype637, _vtype638, _size636) = iprot.readMapBegin()
                    for _i640 in range(_size636):
                        _key641 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val642 = Type()
                        _val642.read(iprot)
                        self.success[_key641] = _val642
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_type_all_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter643, viter644 in self.success.items():
                oprot.writeString(kiter643.encode('utf-8') if sys.version_info[0] == 2 else kiter643)
                viter644.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 1)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_type_all_result)
get_type_all_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [Type, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 1
)


class get_fields_args(object):
    """
    Attributes:
     - db_name
     - table_name

    """


    def __init__(self, db_name=None, table_name=None,):
        self.db_name = db_name
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fields_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fields_args)
get_fields_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
)


class get_fields_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype648, _size645) = iprot.readListBegin()
                    for _i649 in range(_size645):
                        _elem650 = FieldSchema()
                        _elem650.read(iprot)
                        self.success.append(_elem650)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fields_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter651 in self.success:
                iter651.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fields_result)
get_fields_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [FieldSchema, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [UnknownTableException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [UnknownDBException, None], None, ),  # 3
)


class get_fields_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - table_name
     - environment_context

    """


    def __init__(self, db_name=None, table_name=None, environment_context=None,):
        self.db_name = db_name
        self.table_name = table_name
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fields_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 3)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fields_with_environment_context_args)
get_fields_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 3
)


class get_fields_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype655, _size652) = iprot.readListBegin()
                    for _i656 in range(_size652):
                        _elem657 = FieldSchema()
                        _elem657.read(iprot)
                        self.success.append(_elem657)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fields_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter658 in self.success:
                iter658.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fields_with_environment_context_result)
get_fields_with_environment_context_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [FieldSchema, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [UnknownTableException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [UnknownDBException, None], None, ),  # 3
)


class get_schema_args(object):
    """
    Attributes:
     - db_name
     - table_name

    """


    def __init__(self, db_name=None, table_name=None,):
        self.db_name = db_name
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schema_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schema_args)
get_schema_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
)


class get_schema_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype662, _size659) = iprot.readListBegin()
                    for _i663 in range(_size659):
                        _elem664 = FieldSchema()
                        _elem664.read(iprot)
                        self.success.append(_elem664)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schema_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter665 in self.success:
                iter665.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schema_result)
get_schema_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [FieldSchema, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [UnknownTableException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [UnknownDBException, None], None, ),  # 3
)


class get_schema_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - table_name
     - environment_context

    """


    def __init__(self, db_name=None, table_name=None, environment_context=None,):
        self.db_name = db_name
        self.table_name = table_name
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schema_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 3)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schema_with_environment_context_args)
get_schema_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 3
)


class get_schema_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype669, _size666) = iprot.readListBegin()
                    for _i670 in range(_size666):
                        _elem671 = FieldSchema()
                        _elem671.read(iprot)
                        self.success.append(_elem671)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schema_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter672 in self.success:
                iter672.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schema_with_environment_context_result)
get_schema_with_environment_context_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [FieldSchema, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [UnknownTableException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [UnknownDBException, None], None, ),  # 3
)


class create_table_args(object):
    """
    Attributes:
     - tbl

    """


    def __init__(self, tbl=None,):
        self.tbl = tbl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tbl = Table()
                    self.tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_table_args')
        if self.tbl is not None:
            oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
            self.tbl.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_table_args)
create_table_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tbl', [Table, None], None, ),  # 1
)


class create_table_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, o1=None, o2=None, o3=None, o4=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_table_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_table_result)
create_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [AlreadyExistsException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [NoSuchObjectException, None], None, ),  # 4
)


class create_table_with_environment_context_args(object):
    """
    Attributes:
     - tbl
     - environment_context

    """


    def __init__(self, tbl=None, environment_context=None,):
        self.tbl = tbl
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tbl = Table()
                    self.tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_table_with_environment_context_args')
        if self.tbl is not None:
            oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
            self.tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 2)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_table_with_environment_context_args)
create_table_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tbl', [Table, None], None, ),  # 1
    (2, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 2
)


class create_table_with_environment_context_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, o1=None, o2=None, o3=None, o4=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_table_with_environment_context_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_table_with_environment_context_result)
create_table_with_environment_context_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [AlreadyExistsException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [NoSuchObjectException, None], None, ),  # 4
)


class create_table_with_constraints_args(object):
    """
    Attributes:
     - tbl
     - primaryKeys
     - foreignKeys

    """


    def __init__(self, tbl=None, primaryKeys=None, foreignKeys=None,):
        self.tbl = tbl
        self.primaryKeys = primaryKeys
        self.foreignKeys = foreignKeys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tbl = Table()
                    self.tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.primaryKeys = []
                    (_etype676, _size673) = iprot.readListBegin()
                    for _i677 in range(_size673):
                        _elem678 = SQLPrimaryKey()
                        _elem678.read(iprot)
                        self.primaryKeys.append(_elem678)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.foreignKeys = []
                    (_etype682, _size679) = iprot.readListBegin()
                    for _i683 in range(_size679):
                        _elem684 = SQLForeignKey()
                        _elem684.read(iprot)
                        self.foreignKeys.append(_elem684)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_table_with_constraints_args')
        if self.tbl is not None:
            oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
            self.tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.primaryKeys is not None:
            oprot.writeFieldBegin('primaryKeys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.primaryKeys))
            for iter685 in self.primaryKeys:
                iter685.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.foreignKeys is not None:
            oprot.writeFieldBegin('foreignKeys', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.foreignKeys))
            for iter686 in self.foreignKeys:
                iter686.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_table_with_constraints_args)
create_table_with_constraints_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tbl', [Table, None], None, ),  # 1
    (2, TType.LIST, 'primaryKeys', (TType.STRUCT, [SQLPrimaryKey, None], False), None, ),  # 2
    (3, TType.LIST, 'foreignKeys', (TType.STRUCT, [SQLForeignKey, None], False), None, ),  # 3
)


class create_table_with_constraints_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, o1=None, o2=None, o3=None, o4=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_table_with_constraints_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_table_with_constraints_result)
create_table_with_constraints_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [AlreadyExistsException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [NoSuchObjectException, None], None, ),  # 4
)


class drop_constraint_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = DropConstraintRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_constraint_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_constraint_args)
drop_constraint_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [DropConstraintRequest, None], None, ),  # 1
)


class drop_constraint_result(object):
    """
    Attributes:
     - o1
     - o3

    """


    def __init__(self, o1=None, o3=None,):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_constraint_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_constraint_result)
drop_constraint_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 2
)


class add_primary_key_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = AddPrimaryKeyRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_primary_key_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_primary_key_args)
add_primary_key_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [AddPrimaryKeyRequest, None], None, ),  # 1
)


class add_primary_key_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_primary_key_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_primary_key_result)
add_primary_key_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class add_foreign_key_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = AddForeignKeyRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_foreign_key_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_foreign_key_args)
add_foreign_key_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [AddForeignKeyRequest, None], None, ),  # 1
)


class add_foreign_key_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_foreign_key_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_foreign_key_result)
add_foreign_key_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class drop_table_args(object):
    """
    Attributes:
     - dbname
     - name
     - deleteData

    """


    def __init__(self, dbname=None, name=None, deleteData=None,):
        self.dbname = dbname
        self.name = name
        self.deleteData = deleteData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_table_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_table_args)
drop_table_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'deleteData', None, None, ),  # 3
)


class drop_table_result(object):
    """
    Attributes:
     - o1
     - o3

    """


    def __init__(self, o1=None, o3=None,):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_table_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_table_result)
drop_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 2
)


class drop_table_with_environment_context_args(object):
    """
    Attributes:
     - dbname
     - name
     - deleteData
     - environment_context

    """


    def __init__(self, dbname=None, name=None, deleteData=None, environment_context=None,):
        self.dbname = dbname
        self.name = name
        self.deleteData = deleteData
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_table_with_environment_context_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_table_with_environment_context_args)
drop_table_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'deleteData', None, None, ),  # 3
    (4, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 4
)


class drop_table_with_environment_context_result(object):
    """
    Attributes:
     - o1
     - o3

    """


    def __init__(self, o1=None, o3=None,):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_table_with_environment_context_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_table_with_environment_context_result)
drop_table_with_environment_context_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 2
)


class get_tables_args(object):
    """
    Attributes:
     - db_name
     - pattern

    """


    def __init__(self, db_name=None, pattern=None,):
        self.db_name = db_name
        self.pattern = pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 2)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_args)
get_tables_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pattern', 'UTF8', None, ),  # 2
)


class get_tables_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype690, _size687) = iprot.readListBegin()
                    for _i691 in range(_size687):
                        _elem692 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem692)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter693 in self.success:
                oprot.writeString(iter693.encode('utf-8') if sys.version_info[0] == 2 else iter693)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_result)
get_tables_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_tables_by_type_args(object):
    """
    Attributes:
     - db_name
     - pattern
     - tableType

    """


    def __init__(self, db_name=None, pattern=None, tableType=None,):
        self.db_name = db_name
        self.pattern = pattern
        self.tableType = tableType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_by_type_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 2)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        if self.tableType is not None:
            oprot.writeFieldBegin('tableType', TType.STRING, 3)
            oprot.writeString(self.tableType.encode('utf-8') if sys.version_info[0] == 2 else self.tableType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_by_type_args)
get_tables_by_type_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pattern', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tableType', 'UTF8', None, ),  # 3
)


class get_tables_by_type_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype697, _size694) = iprot.readListBegin()
                    for _i698 in range(_size694):
                        _elem699 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem699)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_by_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter700 in self.success:
                oprot.writeString(iter700.encode('utf-8') if sys.version_info[0] == 2 else iter700)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_by_type_result)
get_tables_by_type_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_table_meta_args(object):
    """
    Attributes:
     - db_patterns
     - tbl_patterns
     - tbl_types

    """


    def __init__(self, db_patterns=None, tbl_patterns=None, tbl_types=None,):
        self.db_patterns = db_patterns
        self.tbl_patterns = tbl_patterns
        self.tbl_types = tbl_types

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_patterns = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_patterns = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tbl_types = []
                    (_etype704, _size701) = iprot.readListBegin()
                    for _i705 in range(_size701):
                        _elem706 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tbl_types.append(_elem706)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_meta_args')
        if self.db_patterns is not None:
            oprot.writeFieldBegin('db_patterns', TType.STRING, 1)
            oprot.writeString(self.db_patterns.encode('utf-8') if sys.version_info[0] == 2 else self.db_patterns)
            oprot.writeFieldEnd()
        if self.tbl_patterns is not None:
            oprot.writeFieldBegin('tbl_patterns', TType.STRING, 2)
            oprot.writeString(self.tbl_patterns.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_patterns)
            oprot.writeFieldEnd()
        if self.tbl_types is not None:
            oprot.writeFieldBegin('tbl_types', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.tbl_types))
            for iter707 in self.tbl_types:
                oprot.writeString(iter707.encode('utf-8') if sys.version_info[0] == 2 else iter707)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_meta_args)
get_table_meta_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_patterns', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_patterns', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'tbl_types', (TType.STRING, 'UTF8', False), None, ),  # 3
)


class get_table_meta_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype711, _size708) = iprot.readListBegin()
                    for _i712 in range(_size708):
                        _elem713 = TableMeta()
                        _elem713.read(iprot)
                        self.success.append(_elem713)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_meta_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter714 in self.success:
                iter714.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_meta_result)
get_table_meta_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TableMeta, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_all_tables_args(object):
    """
    Attributes:
     - db_name

    """


    def __init__(self, db_name=None,):
        self.db_name = db_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_tables_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_tables_args)
get_all_tables_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
)


class get_all_tables_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype718, _size715) = iprot.readListBegin()
                    for _i719 in range(_size715):
                        _elem720 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem720)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_tables_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter721 in self.success:
                oprot.writeString(iter721.encode('utf-8') if sys.version_info[0] == 2 else iter721)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_tables_result)
get_all_tables_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_table_args(object):
    """
    Attributes:
     - dbname
     - tbl_name

    """


    def __init__(self, dbname=None, tbl_name=None,):
        self.dbname = dbname
        self.tbl_name = tbl_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_args)
get_table_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
)


class get_table_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Table()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_result)
get_table_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Table, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_table_objects_by_name_args(object):
    """
    Attributes:
     - dbname
     - tbl_names

    """


    def __init__(self, dbname=None, tbl_names=None,):
        self.dbname = dbname
        self.tbl_names = tbl_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tbl_names = []
                    (_etype725, _size722) = iprot.readListBegin()
                    for _i726 in range(_size722):
                        _elem727 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tbl_names.append(_elem727)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_objects_by_name_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_names is not None:
            oprot.writeFieldBegin('tbl_names', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.tbl_names))
            for iter728 in self.tbl_names:
                oprot.writeString(iter728.encode('utf-8') if sys.version_info[0] == 2 else iter728)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_objects_by_name_args)
get_table_objects_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'tbl_names', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class get_table_objects_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype732, _size729) = iprot.readListBegin()
                    for _i733 in range(_size729):
                        _elem734 = Table()
                        _elem734.read(iprot)
                        self.success.append(_elem734)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_objects_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter735 in self.success:
                iter735.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_objects_by_name_result)
get_table_objects_by_name_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Table, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidOperationException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [UnknownDBException, None], None, ),  # 3
)


class get_table_req_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetTableRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_req_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_req_args)
get_table_req_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [GetTableRequest, None], None, ),  # 1
)


class get_table_req_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetTableResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_req_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_req_result)
get_table_req_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetTableResult, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_table_objects_by_name_req_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetTablesRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_objects_by_name_req_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_objects_by_name_req_args)
get_table_objects_by_name_req_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [GetTablesRequest, None], None, ),  # 1
)


class get_table_objects_by_name_req_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetTablesResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_objects_by_name_req_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_objects_by_name_req_result)
get_table_objects_by_name_req_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetTablesResult, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidOperationException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [UnknownDBException, None], None, ),  # 3
)


class get_table_names_by_filter_args(object):
    """
    Attributes:
     - dbname
     - filter
     - max_tables

    """


    def __init__(self, dbname=None, filter=None, max_tables=-1,):
        self.dbname = dbname
        self.filter = filter
        self.max_tables = max_tables

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_tables = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_names_by_filter_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRING, 2)
            oprot.writeString(self.filter.encode('utf-8') if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.max_tables is not None:
            oprot.writeFieldBegin('max_tables', TType.I16, 3)
            oprot.writeI16(self.max_tables)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_names_by_filter_args)
get_table_names_by_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'filter', 'UTF8', None, ),  # 2
    (3, TType.I16, 'max_tables', None, -1, ),  # 3
)


class get_table_names_by_filter_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype739, _size736) = iprot.readListBegin()
                    for _i740 in range(_size736):
                        _elem741 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem741)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_names_by_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter742 in self.success:
                oprot.writeString(iter742.encode('utf-8') if sys.version_info[0] == 2 else iter742)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_names_by_filter_result)
get_table_names_by_filter_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidOperationException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [UnknownDBException, None], None, ),  # 3
)


class alter_table_args(object):
    """
    Attributes:
     - dbname
     - tbl_name
     - new_tbl

    """


    def __init__(self, dbname=None, tbl_name=None, new_tbl=None,):
        self.dbname = dbname
        self.tbl_name = tbl_name
        self.new_tbl = new_tbl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_tbl = Table()
                    self.new_tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_table_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_tbl is not None:
            oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
            self.new_tbl.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_table_args)
alter_table_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'new_tbl', [Table, None], None, ),  # 3
)


class alter_table_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_table_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_table_result)
alter_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [InvalidOperationException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class alter_table_with_environment_context_args(object):
    """
    Attributes:
     - dbname
     - tbl_name
     - new_tbl
     - environment_context

    """


    def __init__(self, dbname=None, tbl_name=None, new_tbl=None, environment_context=None,):
        self.dbname = dbname
        self.tbl_name = tbl_name
        self.new_tbl = new_tbl
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_tbl = Table()
                    self.new_tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_table_with_environment_context_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_tbl is not None:
            oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
            self.new_tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_table_with_environment_context_args)
alter_table_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'new_tbl', [Table, None], None, ),  # 3
    (4, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 4
)


class alter_table_with_environment_context_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_table_with_environment_context_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_table_with_environment_context_result)
alter_table_with_environment_context_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [InvalidOperationException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class alter_table_with_cascade_args(object):
    """
    Attributes:
     - dbname
     - tbl_name
     - new_tbl
     - cascade

    """


    def __init__(self, dbname=None, tbl_name=None, new_tbl=None, cascade=None,):
        self.dbname = dbname
        self.tbl_name = tbl_name
        self.new_tbl = new_tbl
        self.cascade = cascade

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_tbl = Table()
                    self.new_tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.cascade = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_table_with_cascade_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_tbl is not None:
            oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
            self.new_tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.cascade is not None:
            oprot.writeFieldBegin('cascade', TType.BOOL, 4)
            oprot.writeBool(self.cascade)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_table_with_cascade_args)
alter_table_with_cascade_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'new_tbl', [Table, None], None, ),  # 3
    (4, TType.BOOL, 'cascade', None, None, ),  # 4
)


class alter_table_with_cascade_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_table_with_cascade_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_table_with_cascade_result)
alter_table_with_cascade_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [InvalidOperationException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class add_partition_args(object):
    """
    Attributes:
     - new_part

    """


    def __init__(self, new_part=None,):
        self.new_part = new_part

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_partition_args')
        if self.new_part is not None:
            oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_partition_args)
add_partition_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'new_part', [Partition, None], None, ),  # 1
)


class add_partition_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_partition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_partition_result)
add_partition_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Partition, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [InvalidObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [AlreadyExistsException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class add_partition_with_environment_context_args(object):
    """
    Attributes:
     - new_part
     - environment_context

    """


    def __init__(self, new_part=None, environment_context=None,):
        self.new_part = new_part
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_partition_with_environment_context_args')
        if self.new_part is not None:
            oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 2)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_partition_with_environment_context_args)
add_partition_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'new_part', [Partition, None], None, ),  # 1
    (2, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 2
)


class add_partition_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_partition_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_partition_with_environment_context_result)
add_partition_with_environment_context_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Partition, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [InvalidObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [AlreadyExistsException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class add_partitions_args(object):
    """
    Attributes:
     - new_parts

    """


    def __init__(self, new_parts=None,):
        self.new_parts = new_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype746, _size743) = iprot.readListBegin()
                    for _i747 in range(_size743):
                        _elem748 = Partition()
                        _elem748.read(iprot)
                        self.new_parts.append(_elem748)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_partitions_args')
        if self.new_parts is not None:
            oprot.writeFieldBegin('new_parts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter749 in self.new_parts:
                iter749.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_partitions_args)
add_partitions_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'new_parts', (TType.STRUCT, [Partition, None], False), None, ),  # 1
)


class add_partitions_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_partitions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_partitions_result)
add_partitions_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [InvalidObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [AlreadyExistsException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class add_partitions_pspec_args(object):
    """
    Attributes:
     - new_parts

    """


    def __init__(self, new_parts=None,):
        self.new_parts = new_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype753, _size750) = iprot.readListBegin()
                    for _i754 in range(_size750):
                        _elem755 = PartitionSpec()
                        _elem755.read(iprot)
                        self.new_parts.append(_elem755)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_partitions_pspec_args')
        if self.new_parts is not None:
            oprot.writeFieldBegin('new_parts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter756 in self.new_parts:
                iter756.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_partitions_pspec_args)
add_partitions_pspec_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'new_parts', (TType.STRUCT, [PartitionSpec, None], False), None, ),  # 1
)


class add_partitions_pspec_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_partitions_pspec_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_partitions_pspec_result)
add_partitions_pspec_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [InvalidObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [AlreadyExistsException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class append_partition_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype760, _size757) = iprot.readListBegin()
                    for _i761 in range(_size757):
                        _elem762 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem762)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_partition_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter763 in self.part_vals:
                oprot.writeString(iter763.encode('utf-8') if sys.version_info[0] == 2 else iter763)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_partition_args)
append_partition_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
)


class append_partition_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_partition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_partition_result)
append_partition_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Partition, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [InvalidObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [AlreadyExistsException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class add_partitions_req_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = AddPartitionsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_partitions_req_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_partitions_req_args)
add_partitions_req_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [AddPartitionsRequest, None], None, ),  # 1
)


class add_partitions_req_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AddPartitionsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_partitions_req_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_partitions_req_result)
add_partitions_req_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AddPartitionsResult, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [InvalidObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [AlreadyExistsException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class append_partition_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - environment_context

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype767, _size764) = iprot.readListBegin()
                    for _i768 in range(_size764):
                        _elem769 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem769)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_partition_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter770 in self.part_vals:
                oprot.writeString(iter770.encode('utf-8') if sys.version_info[0] == 2 else iter770)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_partition_with_environment_context_args)
append_partition_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 4
)


class append_partition_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_partition_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_partition_with_environment_context_result)
append_partition_with_environment_context_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Partition, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [InvalidObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [AlreadyExistsException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class append_partition_by_name_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name

    """


    def __init__(self, db_name=None, tbl_name=None, part_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_partition_by_name_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_partition_by_name_args)
append_partition_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
)


class append_partition_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_partition_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_partition_by_name_result)
append_partition_by_name_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Partition, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [InvalidObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [AlreadyExistsException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class append_partition_by_name_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - environment_context

    """


    def __init__(self, db_name=None, tbl_name=None, part_name=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_partition_by_name_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_partition_by_name_with_environment_context_args)
append_partition_by_name_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 4
)


class append_partition_by_name_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_partition_by_name_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_partition_by_name_with_environment_context_result)
append_partition_by_name_with_environment_context_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Partition, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [InvalidObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [AlreadyExistsException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class drop_partition_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - deleteData

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.deleteData = deleteData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype774, _size771) = iprot.readListBegin()
                    for _i775 in range(_size771):
                        _elem776 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem776)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_partition_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter777 in self.part_vals:
                oprot.writeString(iter777.encode('utf-8') if sys.version_info[0] == 2 else iter777)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_partition_args)
drop_partition_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.BOOL, 'deleteData', None, None, ),  # 4
)


class drop_partition_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_partition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_partition_result)
drop_partition_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class drop_partition_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
     - environment_context

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.deleteData = deleteData
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype781, _size778) = iprot.readListBegin()
                    for _i782 in range(_size778):
                        _elem783 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem783)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_partition_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter784 in self.part_vals:
                oprot.writeString(iter784.encode('utf-8') if sys.version_info[0] == 2 else iter784)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 5)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_partition_with_environment_context_args)
drop_partition_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.BOOL, 'deleteData', None, None, ),  # 4
    (5, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 5
)


class drop_partition_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_partition_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_partition_with_environment_context_result)
drop_partition_with_environment_context_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class drop_partition_by_name_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - deleteData

    """


    def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.deleteData = deleteData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_partition_by_name_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_partition_by_name_args)
drop_partition_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'deleteData', None, None, ),  # 4
)


class drop_partition_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_partition_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_partition_by_name_result)
drop_partition_by_name_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class drop_partition_by_name_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - deleteData
     - environment_context

    """


    def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.deleteData = deleteData
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_partition_by_name_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 5)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_partition_by_name_with_environment_context_args)
drop_partition_by_name_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'deleteData', None, None, ),  # 4
    (5, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 5
)


class drop_partition_by_name_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_partition_by_name_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_partition_by_name_with_environment_context_result)
drop_partition_by_name_with_environment_context_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class drop_partitions_req_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = DropPartitionsRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_partitions_req_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_partitions_req_args)
drop_partitions_req_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [DropPartitionsRequest, None], None, ),  # 1
)


class drop_partitions_req_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DropPartitionsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_partitions_req_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_partitions_req_result)
drop_partitions_req_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [DropPartitionsResult, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class get_partition_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype788, _size785) = iprot.readListBegin()
                    for _i789 in range(_size785):
                        _elem790 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem790)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter791 in self.part_vals:
                oprot.writeString(iter791.encode('utf-8') if sys.version_info[0] == 2 else iter791)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_args)
get_partition_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
)


class get_partition_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_result)
get_partition_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Partition, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class exchange_partition_args(object):
    """
    Attributes:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name

    """


    def __init__(self, partitionSpecs=None, source_db=None, source_table_name=None, dest_db=None, dest_table_name=None,):
        self.partitionSpecs = partitionSpecs
        self.source_db = source_db
        self.source_table_name = source_table_name
        self.dest_db = dest_db
        self.dest_table_name = dest_table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partitionSpecs = {}
                    (_ktype793, _vtype794, _size792) = iprot.readMapBegin()
                    for _i796 in range(_size792):
                        _key797 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val798 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.partitionSpecs[_key797] = _val798
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.source_db = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.source_table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dest_db = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.dest_table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exchange_partition_args')
        if self.partitionSpecs is not None:
            oprot.writeFieldBegin('partitionSpecs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partitionSpecs))
            for kiter799, viter800 in self.partitionSpecs.items():
                oprot.writeString(kiter799.encode('utf-8') if sys.version_info[0] == 2 else kiter799)
                oprot.writeString(viter800.encode('utf-8') if sys.version_info[0] == 2 else viter800)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.source_db is not None:
            oprot.writeFieldBegin('source_db', TType.STRING, 2)
            oprot.writeString(self.source_db.encode('utf-8') if sys.version_info[0] == 2 else self.source_db)
            oprot.writeFieldEnd()
        if self.source_table_name is not None:
            oprot.writeFieldBegin('source_table_name', TType.STRING, 3)
            oprot.writeString(self.source_table_name.encode('utf-8') if sys.version_info[0] == 2 else self.source_table_name)
            oprot.writeFieldEnd()
        if self.dest_db is not None:
            oprot.writeFieldBegin('dest_db', TType.STRING, 4)
            oprot.writeString(self.dest_db.encode('utf-8') if sys.version_info[0] == 2 else self.dest_db)
            oprot.writeFieldEnd()
        if self.dest_table_name is not None:
            oprot.writeFieldBegin('dest_table_name', TType.STRING, 5)
            oprot.writeString(self.dest_table_name.encode('utf-8') if sys.version_info[0] == 2 else self.dest_table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exchange_partition_args)
exchange_partition_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'partitionSpecs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'source_db', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'source_table_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'dest_db', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'dest_table_name', 'UTF8', None, ),  # 5
)


class exchange_partition_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exchange_partition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exchange_partition_result)
exchange_partition_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Partition, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [InvalidObjectException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [InvalidInputException, None], None, ),  # 4
)


class exchange_partitions_args(object):
    """
    Attributes:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name

    """


    def __init__(self, partitionSpecs=None, source_db=None, source_table_name=None, dest_db=None, dest_table_name=None,):
        self.partitionSpecs = partitionSpecs
        self.source_db = source_db
        self.source_table_name = source_table_name
        self.dest_db = dest_db
        self.dest_table_name = dest_table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partitionSpecs = {}
                    (_ktype802, _vtype803, _size801) = iprot.readMapBegin()
                    for _i805 in range(_size801):
                        _key806 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val807 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.partitionSpecs[_key806] = _val807
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.source_db = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.source_table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dest_db = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.dest_table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exchange_partitions_args')
        if self.partitionSpecs is not None:
            oprot.writeFieldBegin('partitionSpecs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partitionSpecs))
            for kiter808, viter809 in self.partitionSpecs.items():
                oprot.writeString(kiter808.encode('utf-8') if sys.version_info[0] == 2 else kiter808)
                oprot.writeString(viter809.encode('utf-8') if sys.version_info[0] == 2 else viter809)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.source_db is not None:
            oprot.writeFieldBegin('source_db', TType.STRING, 2)
            oprot.writeString(self.source_db.encode('utf-8') if sys.version_info[0] == 2 else self.source_db)
            oprot.writeFieldEnd()
        if self.source_table_name is not None:
            oprot.writeFieldBegin('source_table_name', TType.STRING, 3)
            oprot.writeString(self.source_table_name.encode('utf-8') if sys.version_info[0] == 2 else self.source_table_name)
            oprot.writeFieldEnd()
        if self.dest_db is not None:
            oprot.writeFieldBegin('dest_db', TType.STRING, 4)
            oprot.writeString(self.dest_db.encode('utf-8') if sys.version_info[0] == 2 else self.dest_db)
            oprot.writeFieldEnd()
        if self.dest_table_name is not None:
            oprot.writeFieldBegin('dest_table_name', TType.STRING, 5)
            oprot.writeString(self.dest_table_name.encode('utf-8') if sys.version_info[0] == 2 else self.dest_table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exchange_partitions_args)
exchange_partitions_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'partitionSpecs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'source_db', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'source_table_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'dest_db', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'dest_table_name', 'UTF8', None, ),  # 5
)


class exchange_partitions_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype813, _size810) = iprot.readListBegin()
                    for _i814 in range(_size810):
                        _elem815 = Partition()
                        _elem815.read(iprot)
                        self.success.append(_elem815)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exchange_partitions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter816 in self.success:
                iter816.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exchange_partitions_result)
exchange_partitions_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Partition, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [InvalidObjectException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [InvalidInputException, None], None, ),  # 4
)


class get_partition_with_auth_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None, user_name=None, group_names=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype820, _size817) = iprot.readListBegin()
                    for _i821 in range(_size817):
                        _elem822 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem822)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype826, _size823) = iprot.readListBegin()
                    for _i827 in range(_size823):
                        _elem828 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem828)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_with_auth_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter829 in self.part_vals:
                oprot.writeString(iter829.encode('utf-8') if sys.version_info[0] == 2 else iter829)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 4)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter830 in self.group_names:
                oprot.writeString(iter830.encode('utf-8') if sys.version_info[0] == 2 else iter830)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_with_auth_args)
get_partition_with_auth_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'user_name', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 5
)


class get_partition_with_auth_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_with_auth_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_with_auth_result)
get_partition_with_auth_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Partition, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_partition_by_name_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name

    """


    def __init__(self, db_name=None, tbl_name=None, part_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_by_name_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_by_name_args)
get_partition_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
)


class get_partition_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_by_name_result)
get_partition_by_name_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Partition, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_partitions_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts

    """


    def __init__(self, db_name=None, tbl_name=None, max_parts=-1,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 3)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_args)
get_partitions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.I16, 'max_parts', None, -1, ),  # 3
)


class get_partitions_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype834, _size831) = iprot.readListBegin()
                    for _i835 in range(_size831):
                        _elem836 = Partition()
                        _elem836.read(iprot)
                        self.success.append(_elem836)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter837 in self.success:
                iter837.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_result)
get_partitions_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Partition, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class get_partitions_with_auth_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names

    """


    def __init__(self, db_name=None, tbl_name=None, max_parts=-1, user_name=None, group_names=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype841, _size838) = iprot.readListBegin()
                    for _i842 in range(_size838):
                        _elem843 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem843)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_with_auth_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 3)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 4)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter844 in self.group_names:
                oprot.writeString(iter844.encode('utf-8') if sys.version_info[0] == 2 else iter844)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_with_auth_args)
get_partitions_with_auth_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.I16, 'max_parts', None, -1, ),  # 3
    (4, TType.STRING, 'user_name', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 5
)


class get_partitions_with_auth_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype848, _size845) = iprot.readListBegin()
                    for _i849 in range(_size845):
                        _elem850 = Partition()
                        _elem850.read(iprot)
                        self.success.append(_elem850)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_with_auth_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter851 in self.success:
                iter851.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_with_auth_result)
get_partitions_with_auth_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Partition, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class get_partitions_pspec_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts

    """


    def __init__(self, db_name=None, tbl_name=None, max_parts=-1,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.max_parts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_pspec_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I32, 3)
            oprot.writeI32(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_pspec_args)
get_partitions_pspec_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'max_parts', None, -1, ),  # 3
)


class get_partitions_pspec_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype855, _size852) = iprot.readListBegin()
                    for _i856 in range(_size852):
                        _elem857 = PartitionSpec()
                        _elem857.read(iprot)
                        self.success.append(_elem857)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_pspec_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter858 in self.success:
                iter858.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_pspec_result)
get_partitions_pspec_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [PartitionSpec, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class get_partition_names_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts

    """


    def __init__(self, db_name=None, tbl_name=None, max_parts=-1,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_names_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 3)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_names_args)
get_partition_names_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.I16, 'max_parts', None, -1, ),  # 3
)


class get_partition_names_result(object):
    """
    Attributes:
     - success
     - o2

    """


    def __init__(self, success=None, o2=None,):
        self.success = success
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype862, _size859) = iprot.readListBegin()
                    for _i863 in range(_size859):
                        _elem864 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem864)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter865 in self.success:
                oprot.writeString(iter865.encode('utf-8') if sys.version_info[0] == 2 else iter865)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 1)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_names_result)
get_partition_names_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 1
)


class get_partition_values_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PartitionValuesRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_values_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_values_args)
get_partition_values_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [PartitionValuesRequest, None], None, ),  # 1
)


class get_partition_values_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionValuesResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_values_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_values_result)
get_partition_values_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PartitionValuesResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_partitions_ps_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - max_parts

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=-1,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype869, _size866) = iprot.readListBegin()
                    for _i870 in range(_size866):
                        _elem871 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem871)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_ps_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter872 in self.part_vals:
                oprot.writeString(iter872.encode('utf-8') if sys.version_info[0] == 2 else iter872)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_ps_args)
get_partitions_ps_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.I16, 'max_parts', None, -1, ),  # 4
)


class get_partitions_ps_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype876, _size873) = iprot.readListBegin()
                    for _i877 in range(_size873):
                        _elem878 = Partition()
                        _elem878.read(iprot)
                        self.success.append(_elem878)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_ps_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter879 in self.success:
                iter879.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_ps_result)
get_partitions_ps_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Partition, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_partitions_ps_with_auth_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=-1, user_name=None, group_names=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.max_parts = max_parts
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype883, _size880) = iprot.readListBegin()
                    for _i884 in range(_size880):
                        _elem885 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem885)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype889, _size886) = iprot.readListBegin()
                    for _i890 in range(_size886):
                        _elem891 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem891)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_ps_with_auth_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter892 in self.part_vals:
                oprot.writeString(iter892.encode('utf-8') if sys.version_info[0] == 2 else iter892)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 5)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter893 in self.group_names:
                oprot.writeString(iter893.encode('utf-8') if sys.version_info[0] == 2 else iter893)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_ps_with_auth_args)
get_partitions_ps_with_auth_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.I16, 'max_parts', None, -1, ),  # 4
    (5, TType.STRING, 'user_name', 'UTF8', None, ),  # 5
    (6, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 6
)


class get_partitions_ps_with_auth_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype897, _size894) = iprot.readListBegin()
                    for _i898 in range(_size894):
                        _elem899 = Partition()
                        _elem899.read(iprot)
                        self.success.append(_elem899)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_ps_with_auth_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter900 in self.success:
                iter900.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_ps_with_auth_result)
get_partitions_ps_with_auth_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Partition, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class get_partition_names_ps_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - max_parts

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=-1,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype904, _size901) = iprot.readListBegin()
                    for _i905 in range(_size901):
                        _elem906 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem906)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_names_ps_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter907 in self.part_vals:
                oprot.writeString(iter907.encode('utf-8') if sys.version_info[0] == 2 else iter907)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_names_ps_args)
get_partition_names_ps_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.I16, 'max_parts', None, -1, ),  # 4
)


class get_partition_names_ps_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype911, _size908) = iprot.readListBegin()
                    for _i912 in range(_size908):
                        _elem913 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem913)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_names_ps_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter914 in self.success:
                oprot.writeString(iter914.encode('utf-8') if sys.version_info[0] == 2 else iter914)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_names_ps_result)
get_partition_names_ps_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_partitions_by_filter_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - filter
     - max_parts

    """


    def __init__(self, db_name=None, tbl_name=None, filter=None, max_parts=-1,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.filter = filter
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_by_filter_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRING, 3)
            oprot.writeString(self.filter.encode('utf-8') if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_by_filter_args)
get_partitions_by_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'filter', 'UTF8', None, ),  # 3
    (4, TType.I16, 'max_parts', None, -1, ),  # 4
)


class get_partitions_by_filter_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype918, _size915) = iprot.readListBegin()
                    for _i919 in range(_size915):
                        _elem920 = Partition()
                        _elem920.read(iprot)
                        self.success.append(_elem920)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_by_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter921 in self.success:
                iter921.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_by_filter_result)
get_partitions_by_filter_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Partition, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_part_specs_by_filter_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - filter
     - max_parts

    """


    def __init__(self, db_name=None, tbl_name=None, filter=None, max_parts=-1,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.filter = filter
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.max_parts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_part_specs_by_filter_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRING, 3)
            oprot.writeString(self.filter.encode('utf-8') if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I32, 4)
            oprot.writeI32(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_part_specs_by_filter_args)
get_part_specs_by_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'filter', 'UTF8', None, ),  # 3
    (4, TType.I32, 'max_parts', None, -1, ),  # 4
)


class get_part_specs_by_filter_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype925, _size922) = iprot.readListBegin()
                    for _i926 in range(_size922):
                        _elem927 = PartitionSpec()
                        _elem927.read(iprot)
                        self.success.append(_elem927)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_part_specs_by_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter928 in self.success:
                iter928.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_part_specs_by_filter_result)
get_part_specs_by_filter_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [PartitionSpec, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_partitions_by_expr_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = PartitionsByExprRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_by_expr_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_by_expr_args)
get_partitions_by_expr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [PartitionsByExprRequest, None], None, ),  # 1
)


class get_partitions_by_expr_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionsByExprResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_by_expr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_by_expr_result)
get_partitions_by_expr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PartitionsByExprResult, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_num_partitions_by_filter_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - filter

    """


    def __init__(self, db_name=None, tbl_name=None, filter=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.filter = filter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_num_partitions_by_filter_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRING, 3)
            oprot.writeString(self.filter.encode('utf-8') if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_num_partitions_by_filter_args)
get_num_partitions_by_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'filter', 'UTF8', None, ),  # 3
)


class get_num_partitions_by_filter_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_num_partitions_by_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_num_partitions_by_filter_result)
get_num_partitions_by_filter_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_partitions_by_names_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - names

    """


    def __init__(self, db_name=None, tbl_name=None, names=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.names = names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.names = []
                    (_etype932, _size929) = iprot.readListBegin()
                    for _i933 in range(_size929):
                        _elem934 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.names.append(_elem934)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_by_names_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.names is not None:
            oprot.writeFieldBegin('names', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.names))
            for iter935 in self.names:
                oprot.writeString(iter935.encode('utf-8') if sys.version_info[0] == 2 else iter935)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_by_names_args)
get_partitions_by_names_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'names', (TType.STRING, 'UTF8', False), None, ),  # 3
)


class get_partitions_by_names_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype939, _size936) = iprot.readListBegin()
                    for _i940 in range(_size936):
                        _elem941 = Partition()
                        _elem941.read(iprot)
                        self.success.append(_elem941)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_by_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter942 in self.success:
                iter942.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_by_names_result)
get_partitions_by_names_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Partition, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class alter_partition_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - new_part

    """


    def __init__(self, db_name=None, tbl_name=None, new_part=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_part = new_part

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_partition_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_part is not None:
            oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_partition_args)
alter_partition_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'new_part', [Partition, None], None, ),  # 3
)


class alter_partition_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_partition_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_partition_result)
alter_partition_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [InvalidOperationException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class alter_partitions_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - new_parts

    """


    def __init__(self, db_name=None, tbl_name=None, new_parts=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_parts = new_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype946, _size943) = iprot.readListBegin()
                    for _i947 in range(_size943):
                        _elem948 = Partition()
                        _elem948.read(iprot)
                        self.new_parts.append(_elem948)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_partitions_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_parts is not None:
            oprot.writeFieldBegin('new_parts', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter949 in self.new_parts:
                iter949.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_partitions_args)
alter_partitions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'new_parts', (TType.STRUCT, [Partition, None], False), None, ),  # 3
)


class alter_partitions_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_partitions_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_partitions_result)
alter_partitions_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [InvalidOperationException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class alter_partitions_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - new_parts
     - environment_context

    """


    def __init__(self, db_name=None, tbl_name=None, new_parts=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_parts = new_parts
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype953, _size950) = iprot.readListBegin()
                    for _i954 in range(_size950):
                        _elem955 = Partition()
                        _elem955.read(iprot)
                        self.new_parts.append(_elem955)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_partitions_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_parts is not None:
            oprot.writeFieldBegin('new_parts', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter956 in self.new_parts:
                iter956.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_partitions_with_environment_context_args)
alter_partitions_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'new_parts', (TType.STRUCT, [Partition, None], False), None, ),  # 3
    (4, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 4
)


class alter_partitions_with_environment_context_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_partitions_with_environment_context_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_partitions_with_environment_context_result)
alter_partitions_with_environment_context_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [InvalidOperationException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class alter_partition_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - new_part
     - environment_context

    """


    def __init__(self, db_name=None, tbl_name=None, new_part=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_part = new_part
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_partition_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_part is not None:
            oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_partition_with_environment_context_args)
alter_partition_with_environment_context_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'new_part', [Partition, None], None, ),  # 3
    (4, TType.STRUCT, 'environment_context', [EnvironmentContext, None], None, ),  # 4
)


class alter_partition_with_environment_context_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_partition_with_environment_context_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_partition_with_environment_context_result)
alter_partition_with_environment_context_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [InvalidOperationException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class rename_partition_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - new_part

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None, new_part=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.new_part = new_part

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype960, _size957) = iprot.readListBegin()
                    for _i961 in range(_size957):
                        _elem962 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem962)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rename_partition_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter963 in self.part_vals:
                oprot.writeString(iter963.encode('utf-8') if sys.version_info[0] == 2 else iter963)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.new_part is not None:
            oprot.writeFieldBegin('new_part', TType.STRUCT, 4)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rename_partition_args)
rename_partition_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'new_part', [Partition, None], None, ),  # 4
)


class rename_partition_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rename_partition_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rename_partition_result)
rename_partition_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [InvalidOperationException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class partition_name_has_valid_characters_args(object):
    """
    Attributes:
     - part_vals
     - throw_exception

    """


    def __init__(self, part_vals=None, throw_exception=None,):
        self.part_vals = part_vals
        self.throw_exception = throw_exception

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype967, _size964) = iprot.readListBegin()
                    for _i968 in range(_size964):
                        _elem969 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem969)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.throw_exception = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('partition_name_has_valid_characters_args')
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter970 in self.part_vals:
                oprot.writeString(iter970.encode('utf-8') if sys.version_info[0] == 2 else iter970)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.throw_exception is not None:
            oprot.writeFieldBegin('throw_exception', TType.BOOL, 2)
            oprot.writeBool(self.throw_exception)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(partition_name_has_valid_characters_args)
partition_name_has_valid_characters_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.BOOL, 'throw_exception', None, None, ),  # 2
)


class partition_name_has_valid_characters_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('partition_name_has_valid_characters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(partition_name_has_valid_characters_result)
partition_name_has_valid_characters_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_config_value_args(object):
    """
    Attributes:
     - name
     - defaultValue

    """


    def __init__(self, name=None, defaultValue=None,):
        self.name = name
        self.defaultValue = defaultValue

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.defaultValue = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_config_value_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.defaultValue is not None:
            oprot.writeFieldBegin('defaultValue', TType.STRING, 2)
            oprot.writeString(self.defaultValue.encode('utf-8') if sys.version_info[0] == 2 else self.defaultValue)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_config_value_args)
get_config_value_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'defaultValue', 'UTF8', None, ),  # 2
)


class get_config_value_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = ConfigValSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_config_value_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_config_value_result)
get_config_value_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'o1', [ConfigValSecurityException, None], None, ),  # 1
)


class partition_name_to_vals_args(object):
    """
    Attributes:
     - part_name

    """


    def __init__(self, part_name=None,):
        self.part_name = part_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('partition_name_to_vals_args')
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 1)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(partition_name_to_vals_args)
partition_name_to_vals_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'part_name', 'UTF8', None, ),  # 1
)


class partition_name_to_vals_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype974, _size971) = iprot.readListBegin()
                    for _i975 in range(_size971):
                        _elem976 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem976)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('partition_name_to_vals_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter977 in self.success:
                oprot.writeString(iter977.encode('utf-8') if sys.version_info[0] == 2 else iter977)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(partition_name_to_vals_result)
partition_name_to_vals_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class partition_name_to_spec_args(object):
    """
    Attributes:
     - part_name

    """


    def __init__(self, part_name=None,):
        self.part_name = part_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('partition_name_to_spec_args')
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 1)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(partition_name_to_spec_args)
partition_name_to_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'part_name', 'UTF8', None, ),  # 1
)


class partition_name_to_spec_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype979, _vtype980, _size978) = iprot.readMapBegin()
                    for _i982 in range(_size978):
                        _key983 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val984 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key983] = _val984
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('partition_name_to_spec_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter985, viter986 in self.success.items():
                oprot.writeString(kiter985.encode('utf-8') if sys.version_info[0] == 2 else kiter985)
                oprot.writeString(viter986.encode('utf-8') if sys.version_info[0] == 2 else viter986)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(partition_name_to_spec_result)
partition_name_to_spec_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class markPartitionForEvent_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - eventType

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.eventType = eventType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.part_vals = {}
                    (_ktype988, _vtype989, _size987) = iprot.readMapBegin()
                    for _i991 in range(_size987):
                        _key992 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val993 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals[_key992] = _val993
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.eventType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('markPartitionForEvent_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
            for kiter994, viter995 in self.part_vals.items():
                oprot.writeString(kiter994.encode('utf-8') if sys.version_info[0] == 2 else kiter994)
                oprot.writeString(viter995.encode('utf-8') if sys.version_info[0] == 2 else viter995)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.eventType is not None:
            oprot.writeFieldBegin('eventType', TType.I32, 4)
            oprot.writeI32(self.eventType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(markPartitionForEvent_args)
markPartitionForEvent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'part_vals', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.I32, 'eventType', None, None, ),  # 4
)


class markPartitionForEvent_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4
     - o5
     - o6

    """


    def __init__(self, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4
        self.o5 = o5
        self.o6 = o6

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.o5 = UnknownPartitionException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.o6 = InvalidPartitionException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('markPartitionForEvent_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        if self.o5 is not None:
            oprot.writeFieldBegin('o5', TType.STRUCT, 5)
            self.o5.write(oprot)
            oprot.writeFieldEnd()
        if self.o6 is not None:
            oprot.writeFieldBegin('o6', TType.STRUCT, 6)
            self.o6.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(markPartitionForEvent_result)
markPartitionForEvent_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [UnknownDBException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [UnknownTableException, None], None, ),  # 4
    (5, TType.STRUCT, 'o5', [UnknownPartitionException, None], None, ),  # 5
    (6, TType.STRUCT, 'o6', [InvalidPartitionException, None], None, ),  # 6
)


class isPartitionMarkedForEvent_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - eventType

    """


    def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.eventType = eventType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.part_vals = {}
                    (_ktype997, _vtype998, _size996) = iprot.readMapBegin()
                    for _i1000 in range(_size996):
                        _key1001 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val1002 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals[_key1001] = _val1002
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.eventType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isPartitionMarkedForEvent_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
            for kiter1003, viter1004 in self.part_vals.items():
                oprot.writeString(kiter1003.encode('utf-8') if sys.version_info[0] == 2 else kiter1003)
                oprot.writeString(viter1004.encode('utf-8') if sys.version_info[0] == 2 else viter1004)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.eventType is not None:
            oprot.writeFieldBegin('eventType', TType.I32, 4)
            oprot.writeI32(self.eventType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isPartitionMarkedForEvent_args)
isPartitionMarkedForEvent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'part_vals', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.I32, 'eventType', None, None, ),  # 4
)


class isPartitionMarkedForEvent_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
     - o5
     - o6

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4
        self.o5 = o5
        self.o6 = o6

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = UnknownTableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.o5 = UnknownPartitionException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.o6 = InvalidPartitionException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isPartitionMarkedForEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        if self.o5 is not None:
            oprot.writeFieldBegin('o5', TType.STRUCT, 5)
            self.o5.write(oprot)
            oprot.writeFieldEnd()
        if self.o6 is not None:
            oprot.writeFieldBegin('o6', TType.STRUCT, 6)
            self.o6.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isPartitionMarkedForEvent_result)
isPartitionMarkedForEvent_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [UnknownDBException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [UnknownTableException, None], None, ),  # 4
    (5, TType.STRUCT, 'o5', [UnknownPartitionException, None], None, ),  # 5
    (6, TType.STRUCT, 'o6', [InvalidPartitionException, None], None, ),  # 6
)


class add_index_args(object):
    """
    Attributes:
     - new_index
     - index_table

    """


    def __init__(self, new_index=None, index_table=None,):
        self.new_index = new_index
        self.index_table = index_table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.new_index = Index()
                    self.new_index.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.index_table = Table()
                    self.index_table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_index_args')
        if self.new_index is not None:
            oprot.writeFieldBegin('new_index', TType.STRUCT, 1)
            self.new_index.write(oprot)
            oprot.writeFieldEnd()
        if self.index_table is not None:
            oprot.writeFieldBegin('index_table', TType.STRUCT, 2)
            self.index_table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_index_args)
add_index_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'new_index', [Index, None], None, ),  # 1
    (2, TType.STRUCT, 'index_table', [Table, None], None, ),  # 2
)


class add_index_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Index()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_index_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_index_result)
add_index_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Index, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [InvalidObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [AlreadyExistsException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
)


class alter_index_args(object):
    """
    Attributes:
     - dbname
     - base_tbl_name
     - idx_name
     - new_idx

    """


    def __init__(self, dbname=None, base_tbl_name=None, idx_name=None, new_idx=None,):
        self.dbname = dbname
        self.base_tbl_name = base_tbl_name
        self.idx_name = idx_name
        self.new_idx = new_idx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.base_tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.idx_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.new_idx = Index()
                    self.new_idx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_index_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.base_tbl_name is not None:
            oprot.writeFieldBegin('base_tbl_name', TType.STRING, 2)
            oprot.writeString(self.base_tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.base_tbl_name)
            oprot.writeFieldEnd()
        if self.idx_name is not None:
            oprot.writeFieldBegin('idx_name', TType.STRING, 3)
            oprot.writeString(self.idx_name.encode('utf-8') if sys.version_info[0] == 2 else self.idx_name)
            oprot.writeFieldEnd()
        if self.new_idx is not None:
            oprot.writeFieldBegin('new_idx', TType.STRUCT, 4)
            self.new_idx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_index_args)
alter_index_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'base_tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'idx_name', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'new_idx', [Index, None], None, ),  # 4
)


class alter_index_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_index_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_index_result)
alter_index_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [InvalidOperationException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class drop_index_by_name_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - index_name
     - deleteData

    """


    def __init__(self, db_name=None, tbl_name=None, index_name=None, deleteData=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.index_name = index_name
        self.deleteData = deleteData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_index_by_name_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.index_name is not None:
            oprot.writeFieldBegin('index_name', TType.STRING, 3)
            oprot.writeString(self.index_name.encode('utf-8') if sys.version_info[0] == 2 else self.index_name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_index_by_name_args)
drop_index_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'index_name', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'deleteData', None, None, ),  # 4
)


class drop_index_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_index_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_index_by_name_result)
drop_index_by_name_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class get_index_by_name_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - index_name

    """


    def __init__(self, db_name=None, tbl_name=None, index_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.index_name = index_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_index_by_name_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.index_name is not None:
            oprot.writeFieldBegin('index_name', TType.STRING, 3)
            oprot.writeString(self.index_name.encode('utf-8') if sys.version_info[0] == 2 else self.index_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_index_by_name_args)
get_index_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'index_name', 'UTF8', None, ),  # 3
)


class get_index_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Index()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_index_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_index_by_name_result)
get_index_by_name_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Index, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_indexes_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_indexes

    """


    def __init__(self, db_name=None, tbl_name=None, max_indexes=-1,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_indexes = max_indexes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_indexes = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_indexes_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_indexes is not None:
            oprot.writeFieldBegin('max_indexes', TType.I16, 3)
            oprot.writeI16(self.max_indexes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_indexes_args)
get_indexes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.I16, 'max_indexes', None, -1, ),  # 3
)


class get_indexes_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1008, _size1005) = iprot.readListBegin()
                    for _i1009 in range(_size1005):
                        _elem1010 = Index()
                        _elem1010.read(iprot)
                        self.success.append(_elem1010)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_indexes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1011 in self.success:
                iter1011.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_indexes_result)
get_indexes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Index, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class get_index_names_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_indexes

    """


    def __init__(self, db_name=None, tbl_name=None, max_indexes=-1,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_indexes = max_indexes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_indexes = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_index_names_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_indexes is not None:
            oprot.writeFieldBegin('max_indexes', TType.I16, 3)
            oprot.writeI16(self.max_indexes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_index_names_args)
get_index_names_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.I16, 'max_indexes', None, -1, ),  # 3
)


class get_index_names_result(object):
    """
    Attributes:
     - success
     - o2

    """


    def __init__(self, success=None, o2=None,):
        self.success = success
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1015, _size1012) = iprot.readListBegin()
                    for _i1016 in range(_size1012):
                        _elem1017 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem1017)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_index_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1018 in self.success:
                oprot.writeString(iter1018.encode('utf-8') if sys.version_info[0] == 2 else iter1018)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 1)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_index_names_result)
get_index_names_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 1
)


class get_primary_keys_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PrimaryKeysRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_primary_keys_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_primary_keys_args)
get_primary_keys_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [PrimaryKeysRequest, None], None, ),  # 1
)


class get_primary_keys_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PrimaryKeysResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_primary_keys_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_primary_keys_result)
get_primary_keys_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PrimaryKeysResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_foreign_keys_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ForeignKeysRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_foreign_keys_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_foreign_keys_args)
get_foreign_keys_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ForeignKeysRequest, None], None, ),  # 1
)


class get_foreign_keys_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ForeignKeysResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_foreign_keys_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_foreign_keys_result)
get_foreign_keys_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ForeignKeysResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class update_table_column_statistics_args(object):
    """
    Attributes:
     - stats_obj

    """


    def __init__(self, stats_obj=None,):
        self.stats_obj = stats_obj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stats_obj = ColumnStatistics()
                    self.stats_obj.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_table_column_statistics_args')
        if self.stats_obj is not None:
            oprot.writeFieldBegin('stats_obj', TType.STRUCT, 1)
            self.stats_obj.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_table_column_statistics_args)
update_table_column_statistics_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stats_obj', [ColumnStatistics, None], None, ),  # 1
)


class update_table_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_table_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_table_column_statistics_result)
update_table_column_statistics_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [InvalidInputException, None], None, ),  # 4
)


class update_partition_column_statistics_args(object):
    """
    Attributes:
     - stats_obj

    """


    def __init__(self, stats_obj=None,):
        self.stats_obj = stats_obj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stats_obj = ColumnStatistics()
                    self.stats_obj.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_partition_column_statistics_args')
        if self.stats_obj is not None:
            oprot.writeFieldBegin('stats_obj', TType.STRUCT, 1)
            self.stats_obj.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_partition_column_statistics_args)
update_partition_column_statistics_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stats_obj', [ColumnStatistics, None], None, ),  # 1
)


class update_partition_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_partition_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_partition_column_statistics_result)
update_partition_column_statistics_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [InvalidInputException, None], None, ),  # 4
)


class get_table_column_statistics_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - col_name

    """


    def __init__(self, db_name=None, tbl_name=None, col_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.col_name = col_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_column_statistics_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 3)
            oprot.writeString(self.col_name.encode('utf-8') if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_column_statistics_args)
get_table_column_statistics_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'col_name', 'UTF8', None, ),  # 3
)


class get_table_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ColumnStatistics()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_column_statistics_result)
get_table_column_statistics_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ColumnStatistics, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [InvalidInputException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [InvalidObjectException, None], None, ),  # 4
)


class get_partition_column_statistics_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - col_name

    """


    def __init__(self, db_name=None, tbl_name=None, part_name=None, col_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.col_name = col_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_column_statistics_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 4)
            oprot.writeString(self.col_name.encode('utf-8') if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_column_statistics_args)
get_partition_column_statistics_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'col_name', 'UTF8', None, ),  # 4
)


class get_partition_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ColumnStatistics()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partition_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partition_column_statistics_result)
get_partition_column_statistics_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ColumnStatistics, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [InvalidInputException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [InvalidObjectException, None], None, ),  # 4
)


class get_table_statistics_req_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = TableStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_statistics_req_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_statistics_req_args)
get_table_statistics_req_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [TableStatsRequest, None], None, ),  # 1
)


class get_table_statistics_req_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TableStatsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_statistics_req_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_statistics_req_result)
get_table_statistics_req_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TableStatsResult, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class get_partitions_statistics_req_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PartitionsStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_statistics_req_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_statistics_req_args)
get_partitions_statistics_req_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [PartitionsStatsRequest, None], None, ),  # 1
)


class get_partitions_statistics_req_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionsStatsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_partitions_statistics_req_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_partitions_statistics_req_result)
get_partitions_statistics_req_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PartitionsStatsResult, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class get_aggr_stats_for_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PartitionsStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_aggr_stats_for_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_aggr_stats_for_args)
get_aggr_stats_for_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [PartitionsStatsRequest, None], None, ),  # 1
)


class get_aggr_stats_for_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AggrStats()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_aggr_stats_for_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_aggr_stats_for_result)
get_aggr_stats_for_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AggrStats, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class set_aggr_stats_for_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = SetPartitionsStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_aggr_stats_for_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_aggr_stats_for_args)
set_aggr_stats_for_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [SetPartitionsStatsRequest, None], None, ),  # 1
)


class set_aggr_stats_for_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_aggr_stats_for_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_aggr_stats_for_result)
set_aggr_stats_for_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [InvalidInputException, None], None, ),  # 4
)


class delete_partition_column_statistics_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - col_name

    """


    def __init__(self, db_name=None, tbl_name=None, part_name=None, col_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.col_name = col_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_partition_column_statistics_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 4)
            oprot.writeString(self.col_name.encode('utf-8') if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_partition_column_statistics_args)
delete_partition_column_statistics_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'col_name', 'UTF8', None, ),  # 4
)


class delete_partition_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_partition_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_partition_column_statistics_result)
delete_partition_column_statistics_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [InvalidObjectException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [InvalidInputException, None], None, ),  # 4
)


class delete_table_column_statistics_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - col_name

    """


    def __init__(self, db_name=None, tbl_name=None, col_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.col_name = col_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_table_column_statistics_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 3)
            oprot.writeString(self.col_name.encode('utf-8') if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_table_column_statistics_args)
delete_table_column_statistics_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'col_name', 'UTF8', None, ),  # 3
)


class delete_table_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_table_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_table_column_statistics_result)
delete_table_column_statistics_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [InvalidObjectException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [InvalidInputException, None], None, ),  # 4
)


class create_function_args(object):
    """
    Attributes:
     - func

    """


    def __init__(self, func=None,):
        self.func = func

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.func = Function()
                    self.func.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_function_args')
        if self.func is not None:
            oprot.writeFieldBegin('func', TType.STRUCT, 1)
            self.func.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_function_args)
create_function_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'func', [Function, None], None, ),  # 1
)


class create_function_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4

    """


    def __init__(self, o1=None, o2=None, o3=None, o4=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_function_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_function_result)
create_function_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [AlreadyExistsException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [InvalidObjectException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 3
    (4, TType.STRUCT, 'o4', [NoSuchObjectException, None], None, ),  # 4
)


class drop_function_args(object):
    """
    Attributes:
     - dbName
     - funcName

    """


    def __init__(self, dbName=None, funcName=None,):
        self.dbName = dbName
        self.funcName = funcName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.funcName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_function_args')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.funcName is not None:
            oprot.writeFieldBegin('funcName', TType.STRING, 2)
            oprot.writeString(self.funcName.encode('utf-8') if sys.version_info[0] == 2 else self.funcName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_function_args)
drop_function_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'funcName', 'UTF8', None, ),  # 2
)


class drop_function_result(object):
    """
    Attributes:
     - o1
     - o3

    """


    def __init__(self, o1=None, o3=None,):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_function_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_function_result)
drop_function_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o3', [MetaException, None], None, ),  # 2
)


class alter_function_args(object):
    """
    Attributes:
     - dbName
     - funcName
     - newFunc

    """


    def __init__(self, dbName=None, funcName=None, newFunc=None,):
        self.dbName = dbName
        self.funcName = funcName
        self.newFunc = newFunc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.funcName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.newFunc = Function()
                    self.newFunc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_function_args')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.funcName is not None:
            oprot.writeFieldBegin('funcName', TType.STRING, 2)
            oprot.writeString(self.funcName.encode('utf-8') if sys.version_info[0] == 2 else self.funcName)
            oprot.writeFieldEnd()
        if self.newFunc is not None:
            oprot.writeFieldBegin('newFunc', TType.STRUCT, 3)
            self.newFunc.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_function_args)
alter_function_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'funcName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'newFunc', [Function, None], None, ),  # 3
)


class alter_function_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alter_function_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alter_function_result)
alter_function_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [InvalidOperationException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class get_functions_args(object):
    """
    Attributes:
     - dbName
     - pattern

    """


    def __init__(self, dbName=None, pattern=None,):
        self.dbName = dbName
        self.pattern = pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_functions_args')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 2)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_functions_args)
get_functions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pattern', 'UTF8', None, ),  # 2
)


class get_functions_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1022, _size1019) = iprot.readListBegin()
                    for _i1023 in range(_size1019):
                        _elem1024 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem1024)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_functions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1025 in self.success:
                oprot.writeString(iter1025.encode('utf-8') if sys.version_info[0] == 2 else iter1025)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_functions_result)
get_functions_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_function_args(object):
    """
    Attributes:
     - dbName
     - funcName

    """


    def __init__(self, dbName=None, funcName=None,):
        self.dbName = dbName
        self.funcName = funcName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.funcName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_args')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.funcName is not None:
            oprot.writeFieldBegin('funcName', TType.STRING, 2)
            oprot.writeString(self.funcName.encode('utf-8') if sys.version_info[0] == 2 else self.funcName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_args)
get_function_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'funcName', 'UTF8', None, ),  # 2
)


class get_function_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Function()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_result)
get_function_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Function, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchObjectException, None], None, ),  # 2
)


class get_all_functions_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_functions_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_functions_args)
get_all_functions_args.thrift_spec = (
)


class get_all_functions_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAllFunctionsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_functions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_functions_result)
get_all_functions_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetAllFunctionsResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class create_role_args(object):
    """
    Attributes:
     - role

    """


    def __init__(self, role=None,):
        self.role = role

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.role = Role()
                    self.role.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_role_args')
        if self.role is not None:
            oprot.writeFieldBegin('role', TType.STRUCT, 1)
            self.role.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_role_args)
create_role_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'role', [Role, None], None, ),  # 1
)


class create_role_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_role_result)
create_role_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class drop_role_args(object):
    """
    Attributes:
     - role_name

    """


    def __init__(self, role_name=None,):
        self.role_name = role_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_role_args')
        if self.role_name is not None:
            oprot.writeFieldBegin('role_name', TType.STRING, 1)
            oprot.writeString(self.role_name.encode('utf-8') if sys.version_info[0] == 2 else self.role_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_role_args)
drop_role_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'role_name', 'UTF8', None, ),  # 1
)


class drop_role_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_role_result)
drop_role_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_role_names_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_role_names_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_role_names_args)
get_role_names_args.thrift_spec = (
)


class get_role_names_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1029, _size1026) = iprot.readListBegin()
                    for _i1030 in range(_size1026):
                        _elem1031 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem1031)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_role_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1032 in self.success:
                oprot.writeString(iter1032.encode('utf-8') if sys.version_info[0] == 2 else iter1032)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_role_names_result)
get_role_names_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class grant_role_args(object):
    """
    Attributes:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option

    """


    def __init__(self, role_name=None, principal_name=None, principal_type=None, grantor=None, grantorType=None, grant_option=None,):
        self.role_name = role_name
        self.principal_name = principal_name
        self.principal_type = principal_type
        self.grantor = grantor
        self.grantorType = grantorType
        self.grant_option = grant_option

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.grantor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.grantorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.grant_option = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grant_role_args')
        if self.role_name is not None:
            oprot.writeFieldBegin('role_name', TType.STRING, 1)
            oprot.writeString(self.role_name.encode('utf-8') if sys.version_info[0] == 2 else self.role_name)
            oprot.writeFieldEnd()
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 2)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 3)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.grantor is not None:
            oprot.writeFieldBegin('grantor', TType.STRING, 4)
            oprot.writeString(self.grantor.encode('utf-8') if sys.version_info[0] == 2 else self.grantor)
            oprot.writeFieldEnd()
        if self.grantorType is not None:
            oprot.writeFieldBegin('grantorType', TType.I32, 5)
            oprot.writeI32(self.grantorType)
            oprot.writeFieldEnd()
        if self.grant_option is not None:
            oprot.writeFieldBegin('grant_option', TType.BOOL, 6)
            oprot.writeBool(self.grant_option)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grant_role_args)
grant_role_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'role_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'principal_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'principal_type', None, None, ),  # 3
    (4, TType.STRING, 'grantor', 'UTF8', None, ),  # 4
    (5, TType.I32, 'grantorType', None, None, ),  # 5
    (6, TType.BOOL, 'grant_option', None, None, ),  # 6
)


class grant_role_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grant_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grant_role_result)
grant_role_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class revoke_role_args(object):
    """
    Attributes:
     - role_name
     - principal_name
     - principal_type

    """


    def __init__(self, role_name=None, principal_name=None, principal_type=None,):
        self.role_name = role_name
        self.principal_name = principal_name
        self.principal_type = principal_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revoke_role_args')
        if self.role_name is not None:
            oprot.writeFieldBegin('role_name', TType.STRING, 1)
            oprot.writeString(self.role_name.encode('utf-8') if sys.version_info[0] == 2 else self.role_name)
            oprot.writeFieldEnd()
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 2)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 3)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revoke_role_args)
revoke_role_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'role_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'principal_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'principal_type', None, None, ),  # 3
)


class revoke_role_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revoke_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revoke_role_result)
revoke_role_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class list_roles_args(object):
    """
    Attributes:
     - principal_name
     - principal_type

    """


    def __init__(self, principal_name=None, principal_type=None,):
        self.principal_name = principal_name
        self.principal_type = principal_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('list_roles_args')
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 1)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 2)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(list_roles_args)
list_roles_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'principal_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'principal_type', None, None, ),  # 2
)


class list_roles_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1036, _size1033) = iprot.readListBegin()
                    for _i1037 in range(_size1033):
                        _elem1038 = Role()
                        _elem1038.read(iprot)
                        self.success.append(_elem1038)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('list_roles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1039 in self.success:
                iter1039.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(list_roles_result)
list_roles_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Role, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class grant_revoke_role_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GrantRevokeRoleRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grant_revoke_role_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grant_revoke_role_args)
grant_revoke_role_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [GrantRevokeRoleRequest, None], None, ),  # 1
)


class grant_revoke_role_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GrantRevokeRoleResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grant_revoke_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grant_revoke_role_result)
grant_revoke_role_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GrantRevokeRoleResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_principals_in_role_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetPrincipalsInRoleRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_principals_in_role_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_principals_in_role_args)
get_principals_in_role_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [GetPrincipalsInRoleRequest, None], None, ),  # 1
)


class get_principals_in_role_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPrincipalsInRoleResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_principals_in_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_principals_in_role_result)
get_principals_in_role_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetPrincipalsInRoleResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_role_grants_for_principal_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetRoleGrantsForPrincipalRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_role_grants_for_principal_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_role_grants_for_principal_args)
get_role_grants_for_principal_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [GetRoleGrantsForPrincipalRequest, None], None, ),  # 1
)


class get_role_grants_for_principal_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetRoleGrantsForPrincipalResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_role_grants_for_principal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_role_grants_for_principal_result)
get_role_grants_for_principal_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetRoleGrantsForPrincipalResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_privilege_set_args(object):
    """
    Attributes:
     - hiveObject
     - user_name
     - group_names

    """


    def __init__(self, hiveObject=None, user_name=None, group_names=None,):
        self.hiveObject = hiveObject
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hiveObject = HiveObjectRef()
                    self.hiveObject.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype1043, _size1040) = iprot.readListBegin()
                    for _i1044 in range(_size1040):
                        _elem1045 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem1045)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_privilege_set_args')
        if self.hiveObject is not None:
            oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
            self.hiveObject.write(oprot)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 2)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter1046 in self.group_names:
                oprot.writeString(iter1046.encode('utf-8') if sys.version_info[0] == 2 else iter1046)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_privilege_set_args)
get_privilege_set_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hiveObject', [HiveObjectRef, None], None, ),  # 1
    (2, TType.STRING, 'user_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 3
)


class get_privilege_set_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PrincipalPrivilegeSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_privilege_set_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_privilege_set_result)
get_privilege_set_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PrincipalPrivilegeSet, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class list_privileges_args(object):
    """
    Attributes:
     - principal_name
     - principal_type
     - hiveObject

    """


    def __init__(self, principal_name=None, principal_type=None, hiveObject=None,):
        self.principal_name = principal_name
        self.principal_type = principal_type
        self.hiveObject = hiveObject

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.hiveObject = HiveObjectRef()
                    self.hiveObject.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('list_privileges_args')
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 1)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 2)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.hiveObject is not None:
            oprot.writeFieldBegin('hiveObject', TType.STRUCT, 3)
            self.hiveObject.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(list_privileges_args)
list_privileges_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'principal_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'principal_type', None, None, ),  # 2
    (3, TType.STRUCT, 'hiveObject', [HiveObjectRef, None], None, ),  # 3
)


class list_privileges_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1050, _size1047) = iprot.readListBegin()
                    for _i1051 in range(_size1047):
                        _elem1052 = HiveObjectPrivilege()
                        _elem1052.read(iprot)
                        self.success.append(_elem1052)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('list_privileges_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1053 in self.success:
                iter1053.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(list_privileges_result)
list_privileges_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [HiveObjectPrivilege, None], False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class grant_privileges_args(object):
    """
    Attributes:
     - privileges

    """


    def __init__(self, privileges=None,):
        self.privileges = privileges

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.privileges = PrivilegeBag()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grant_privileges_args')
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grant_privileges_args)
grant_privileges_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'privileges', [PrivilegeBag, None], None, ),  # 1
)


class grant_privileges_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grant_privileges_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grant_privileges_result)
grant_privileges_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class revoke_privileges_args(object):
    """
    Attributes:
     - privileges

    """


    def __init__(self, privileges=None,):
        self.privileges = privileges

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.privileges = PrivilegeBag()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revoke_privileges_args')
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revoke_privileges_args)
revoke_privileges_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'privileges', [PrivilegeBag, None], None, ),  # 1
)


class revoke_privileges_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revoke_privileges_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revoke_privileges_result)
revoke_privileges_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class grant_revoke_privileges_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GrantRevokePrivilegeRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grant_revoke_privileges_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grant_revoke_privileges_args)
grant_revoke_privileges_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [GrantRevokePrivilegeRequest, None], None, ),  # 1
)


class grant_revoke_privileges_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GrantRevokePrivilegeResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grant_revoke_privileges_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grant_revoke_privileges_result)
grant_revoke_privileges_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GrantRevokePrivilegeResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class set_ugi_args(object):
    """
    Attributes:
     - user_name
     - group_names

    """


    def __init__(self, user_name=None, group_names=None,):
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype1057, _size1054) = iprot.readListBegin()
                    for _i1058 in range(_size1054):
                        _elem1059 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem1059)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_ugi_args')
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 1)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter1060 in self.group_names:
                oprot.writeString(iter1060.encode('utf-8') if sys.version_info[0] == 2 else iter1060)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_ugi_args)
set_ugi_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'user_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class set_ugi_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1064, _size1061) = iprot.readListBegin()
                    for _i1065 in range(_size1061):
                        _elem1066 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem1066)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_ugi_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1067 in self.success:
                oprot.writeString(iter1067.encode('utf-8') if sys.version_info[0] == 2 else iter1067)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_ugi_result)
set_ugi_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class get_delegation_token_args(object):
    """
    Attributes:
     - token_owner
     - renewer_kerberos_principal_name

    """


    def __init__(self, token_owner=None, renewer_kerberos_principal_name=None,):
        self.token_owner = token_owner
        self.renewer_kerberos_principal_name = renewer_kerberos_principal_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_owner = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.renewer_kerberos_principal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_delegation_token_args')
        if self.token_owner is not None:
            oprot.writeFieldBegin('token_owner', TType.STRING, 1)
            oprot.writeString(self.token_owner.encode('utf-8') if sys.version_info[0] == 2 else self.token_owner)
            oprot.writeFieldEnd()
        if self.renewer_kerberos_principal_name is not None:
            oprot.writeFieldBegin('renewer_kerberos_principal_name', TType.STRING, 2)
            oprot.writeString(self.renewer_kerberos_principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.renewer_kerberos_principal_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_delegation_token_args)
get_delegation_token_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'token_owner', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'renewer_kerberos_principal_name', 'UTF8', None, ),  # 2
)


class get_delegation_token_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_delegation_token_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_delegation_token_result)
get_delegation_token_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class renew_delegation_token_args(object):
    """
    Attributes:
     - token_str_form

    """


    def __init__(self, token_str_form=None,):
        self.token_str_form = token_str_form

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_str_form = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('renew_delegation_token_args')
        if self.token_str_form is not None:
            oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
            oprot.writeString(self.token_str_form.encode('utf-8') if sys.version_info[0] == 2 else self.token_str_form)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(renew_delegation_token_args)
renew_delegation_token_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'token_str_form', 'UTF8', None, ),  # 1
)


class renew_delegation_token_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('renew_delegation_token_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(renew_delegation_token_result)
renew_delegation_token_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class cancel_delegation_token_args(object):
    """
    Attributes:
     - token_str_form

    """


    def __init__(self, token_str_form=None,):
        self.token_str_form = token_str_form

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_str_form = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_delegation_token_args')
        if self.token_str_form is not None:
            oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
            oprot.writeString(self.token_str_form.encode('utf-8') if sys.version_info[0] == 2 else self.token_str_form)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_delegation_token_args)
cancel_delegation_token_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'token_str_form', 'UTF8', None, ),  # 1
)


class cancel_delegation_token_result(object):
    """
    Attributes:
     - o1

    """


    def __init__(self, o1=None,):
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_delegation_token_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_delegation_token_result)
cancel_delegation_token_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class add_token_args(object):
    """
    Attributes:
     - token_identifier
     - delegation_token

    """


    def __init__(self, token_identifier=None, delegation_token=None,):
        self.token_identifier = token_identifier
        self.delegation_token = delegation_token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_identifier = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.delegation_token = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_token_args')
        if self.token_identifier is not None:
            oprot.writeFieldBegin('token_identifier', TType.STRING, 1)
            oprot.writeString(self.token_identifier.encode('utf-8') if sys.version_info[0] == 2 else self.token_identifier)
            oprot.writeFieldEnd()
        if self.delegation_token is not None:
            oprot.writeFieldBegin('delegation_token', TType.STRING, 2)
            oprot.writeString(self.delegation_token.encode('utf-8') if sys.version_info[0] == 2 else self.delegation_token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_token_args)
add_token_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'token_identifier', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'delegation_token', 'UTF8', None, ),  # 2
)


class add_token_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_token_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_token_result)
add_token_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class remove_token_args(object):
    """
    Attributes:
     - token_identifier

    """


    def __init__(self, token_identifier=None,):
        self.token_identifier = token_identifier

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_identifier = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_token_args')
        if self.token_identifier is not None:
            oprot.writeFieldBegin('token_identifier', TType.STRING, 1)
            oprot.writeString(self.token_identifier.encode('utf-8') if sys.version_info[0] == 2 else self.token_identifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_token_args)
remove_token_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'token_identifier', 'UTF8', None, ),  # 1
)


class remove_token_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_token_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_token_result)
remove_token_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_token_args(object):
    """
    Attributes:
     - token_identifier

    """


    def __init__(self, token_identifier=None,):
        self.token_identifier = token_identifier

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_identifier = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_token_args')
        if self.token_identifier is not None:
            oprot.writeFieldBegin('token_identifier', TType.STRING, 1)
            oprot.writeString(self.token_identifier.encode('utf-8') if sys.version_info[0] == 2 else self.token_identifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_token_args)
get_token_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'token_identifier', 'UTF8', None, ),  # 1
)


class get_token_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_token_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_token_result)
get_token_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_all_token_identifiers_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_token_identifiers_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_token_identifiers_args)
get_all_token_identifiers_args.thrift_spec = (
)


class get_all_token_identifiers_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1071, _size1068) = iprot.readListBegin()
                    for _i1072 in range(_size1068):
                        _elem1073 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem1073)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_token_identifiers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1074 in self.success:
                oprot.writeString(iter1074.encode('utf-8') if sys.version_info[0] == 2 else iter1074)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_token_identifiers_result)
get_all_token_identifiers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class add_master_key_args(object):
    """
    Attributes:
     - key

    """


    def __init__(self, key=None,):
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_master_key_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_master_key_args)
add_master_key_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
)


class add_master_key_result(object):
    """
    Attributes:
     - success
     - o1

    """


    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_master_key_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_master_key_result)
add_master_key_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'o1', [MetaException, None], None, ),  # 1
)


class update_master_key_args(object):
    """
    Attributes:
     - seq_number
     - key

    """


    def __init__(self, seq_number=None, key=None,):
        self.seq_number = seq_number
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq_number = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_master_key_args')
        if self.seq_number is not None:
            oprot.writeFieldBegin('seq_number', TType.I32, 1)
            oprot.writeI32(self.seq_number)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_master_key_args)
update_master_key_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'seq_number', None, None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
)


class update_master_key_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_master_key_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_master_key_result)
update_master_key_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchObjectException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [MetaException, None], None, ),  # 2
)


class remove_master_key_args(object):
    """
    Attributes:
     - key_seq

    """


    def __init__(self, key_seq=None,):
        self.key_seq = key_seq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.key_seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_master_key_args')
        if self.key_seq is not None:
            oprot.writeFieldBegin('key_seq', TType.I32, 1)
            oprot.writeI32(self.key_seq)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_master_key_args)
remove_master_key_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'key_seq', None, None, ),  # 1
)


class remove_master_key_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_master_key_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_master_key_result)
remove_master_key_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_master_keys_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_master_keys_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_master_keys_args)
get_master_keys_args.thrift_spec = (
)


class get_master_keys_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1078, _size1075) = iprot.readListBegin()
                    for _i1079 in range(_size1075):
                        _elem1080 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem1080)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_master_keys_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1081 in self.success:
                oprot.writeString(iter1081.encode('utf-8') if sys.version_info[0] == 2 else iter1081)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_master_keys_result)
get_master_keys_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_open_txns_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_open_txns_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_open_txns_args)
get_open_txns_args.thrift_spec = (
)


class get_open_txns_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetOpenTxnsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_open_txns_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_open_txns_result)
get_open_txns_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetOpenTxnsResponse, None], None, ),  # 0
)


class get_open_txns_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_open_txns_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_open_txns_info_args)
get_open_txns_info_args.thrift_spec = (
)


class get_open_txns_info_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetOpenTxnsInfoResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_open_txns_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_open_txns_info_result)
get_open_txns_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetOpenTxnsInfoResponse, None], None, ),  # 0
)


class open_txns_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = OpenTxnRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_txns_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_txns_args)
open_txns_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [OpenTxnRequest, None], None, ),  # 1
)


class open_txns_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = OpenTxnsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_txns_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_txns_result)
open_txns_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [OpenTxnsResponse, None], None, ),  # 0
)


class abort_txn_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = AbortTxnRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abort_txn_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abort_txn_args)
abort_txn_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [AbortTxnRequest, None], None, ),  # 1
)


class abort_txn_result(object):
    """
    Attributes:
     - o1

    """


    def __init__(self, o1=None,):
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abort_txn_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abort_txn_result)
abort_txn_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchTxnException, None], None, ),  # 1
)


class abort_txns_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = AbortTxnsRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abort_txns_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abort_txns_args)
abort_txns_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [AbortTxnsRequest, None], None, ),  # 1
)


class abort_txns_result(object):
    """
    Attributes:
     - o1

    """


    def __init__(self, o1=None,):
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abort_txns_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abort_txns_result)
abort_txns_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchTxnException, None], None, ),  # 1
)


class commit_txn_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CommitTxnRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_txn_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_txn_args)
commit_txn_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [CommitTxnRequest, None], None, ),  # 1
)


class commit_txn_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_txn_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_txn_result)
commit_txn_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchTxnException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [TxnAbortedException, None], None, ),  # 2
)


class lock_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = LockRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('lock_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(lock_args)
lock_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [LockRequest, None], None, ),  # 1
)


class lock_result(object):
    """
    Attributes:
     - success
     - o1
     - o2

    """


    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LockResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('lock_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(lock_result)
lock_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LockResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchTxnException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [TxnAbortedException, None], None, ),  # 2
)


class check_lock_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CheckLockRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_lock_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_lock_args)
check_lock_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [CheckLockRequest, None], None, ),  # 1
)


class check_lock_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3

    """


    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LockResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = NoSuchLockException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_lock_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_lock_result)
check_lock_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LockResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'o1', [NoSuchTxnException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [TxnAbortedException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [NoSuchLockException, None], None, ),  # 3
)


class unlock_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = UnlockRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unlock_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unlock_args)
unlock_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [UnlockRequest, None], None, ),  # 1
)


class unlock_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchLockException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnOpenException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unlock_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unlock_result)
unlock_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchLockException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [TxnOpenException, None], None, ),  # 2
)


class show_locks_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = ShowLocksRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('show_locks_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(show_locks_args)
show_locks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [ShowLocksRequest, None], None, ),  # 1
)


class show_locks_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ShowLocksResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('show_locks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(show_locks_result)
show_locks_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ShowLocksResponse, None], None, ),  # 0
)


class heartbeat_args(object):
    """
    Attributes:
     - ids

    """


    def __init__(self, ids=None,):
        self.ids = ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ids = HeartbeatRequest()
                    self.ids.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('heartbeat_args')
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.STRUCT, 1)
            self.ids.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(heartbeat_args)
heartbeat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ids', [HeartbeatRequest, None], None, ),  # 1
)


class heartbeat_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3

    """


    def __init__(self, o1=None, o2=None, o3=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchLockException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('heartbeat_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(heartbeat_result)
heartbeat_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchLockException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [NoSuchTxnException, None], None, ),  # 2
    (3, TType.STRUCT, 'o3', [TxnAbortedException, None], None, ),  # 3
)


class heartbeat_txn_range_args(object):
    """
    Attributes:
     - txns

    """


    def __init__(self, txns=None,):
        self.txns = txns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.txns = HeartbeatTxnRangeRequest()
                    self.txns.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('heartbeat_txn_range_args')
        if self.txns is not None:
            oprot.writeFieldBegin('txns', TType.STRUCT, 1)
            self.txns.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(heartbeat_txn_range_args)
heartbeat_txn_range_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'txns', [HeartbeatTxnRangeRequest, None], None, ),  # 1
)


class heartbeat_txn_range_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = HeartbeatTxnRangeResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('heartbeat_txn_range_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(heartbeat_txn_range_result)
heartbeat_txn_range_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [HeartbeatTxnRangeResponse, None], None, ),  # 0
)


class compact_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CompactionRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('compact_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(compact_args)
compact_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [CompactionRequest, None], None, ),  # 1
)


class compact_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('compact_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(compact_result)
compact_result.thrift_spec = (
)


class compact2_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CompactionRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('compact2_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(compact2_args)
compact2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [CompactionRequest, None], None, ),  # 1
)


class compact2_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CompactionResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('compact2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(compact2_result)
compact2_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CompactionResponse, None], None, ),  # 0
)


class show_compact_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = ShowCompactRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('show_compact_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(show_compact_args)
show_compact_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [ShowCompactRequest, None], None, ),  # 1
)


class show_compact_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ShowCompactResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('show_compact_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(show_compact_result)
show_compact_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ShowCompactResponse, None], None, ),  # 0
)


class add_dynamic_partitions_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = AddDynamicPartitions()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_dynamic_partitions_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_dynamic_partitions_args)
add_dynamic_partitions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [AddDynamicPartitions, None], None, ),  # 1
)


class add_dynamic_partitions_result(object):
    """
    Attributes:
     - o1
     - o2

    """


    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_dynamic_partitions_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_dynamic_partitions_result)
add_dynamic_partitions_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'o1', [NoSuchTxnException, None], None, ),  # 1
    (2, TType.STRUCT, 'o2', [TxnAbortedException, None], None, ),  # 2
)


class get_next_notification_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = NotificationEventRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_next_notification_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_next_notification_args)
get_next_notification_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [NotificationEventRequest, None], None, ),  # 1
)


class get_next_notification_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NotificationEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_next_notification_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_next_notification_result)
get_next_notification_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NotificationEventResponse, None], None, ),  # 0
)


class get_current_notificationEventId_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_current_notificationEventId_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_current_notificationEventId_args)
get_current_notificationEventId_args.thrift_spec = (
)


class get_current_notificationEventId_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CurrentNotificationEventId()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_current_notificationEventId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_current_notificationEventId_result)
get_current_notificationEventId_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CurrentNotificationEventId, None], None, ),  # 0
)


class fire_listener_event_args(object):
    """
    Attributes:
     - rqst

    """


    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = FireEventRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fire_listener_event_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fire_listener_event_args)
fire_listener_event_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rqst', [FireEventRequest, None], None, ),  # 1
)


class fire_listener_event_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FireEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fire_listener_event_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fire_listener_event_result)
fire_listener_event_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FireEventResponse, None], None, ),  # 0
)


class flushCache_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flushCache_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flushCache_args)
flushCache_args.thrift_spec = (
)


class flushCache_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flushCache_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flushCache_result)
flushCache_result.thrift_spec = (
)


class get_file_metadata_by_expr_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetFileMetadataByExprRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_file_metadata_by_expr_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_file_metadata_by_expr_args)
get_file_metadata_by_expr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [GetFileMetadataByExprRequest, None], None, ),  # 1
)


class get_file_metadata_by_expr_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetFileMetadataByExprResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_file_metadata_by_expr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_file_metadata_by_expr_result)
get_file_metadata_by_expr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetFileMetadataByExprResult, None], None, ),  # 0
)


class get_file_metadata_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = GetFileMetadataRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_file_metadata_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_file_metadata_args)
get_file_metadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [GetFileMetadataRequest, None], None, ),  # 1
)


class get_file_metadata_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetFileMetadataResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_file_metadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_file_metadata_result)
get_file_metadata_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetFileMetadataResult, None], None, ),  # 0
)


class put_file_metadata_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = PutFileMetadataRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('put_file_metadata_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(put_file_metadata_args)
put_file_metadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [PutFileMetadataRequest, None], None, ),  # 1
)


class put_file_metadata_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PutFileMetadataResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('put_file_metadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(put_file_metadata_result)
put_file_metadata_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PutFileMetadataResult, None], None, ),  # 0
)


class clear_file_metadata_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = ClearFileMetadataRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_file_metadata_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_file_metadata_args)
clear_file_metadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [ClearFileMetadataRequest, None], None, ),  # 1
)


class clear_file_metadata_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ClearFileMetadataResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_file_metadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_file_metadata_result)
clear_file_metadata_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ClearFileMetadataResult, None], None, ),  # 0
)


class cache_file_metadata_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = CacheFileMetadataRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cache_file_metadata_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cache_file_metadata_args)
cache_file_metadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [CacheFileMetadataRequest, None], None, ),  # 1
)


class cache_file_metadata_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CacheFileMetadataResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cache_file_metadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cache_file_metadata_result)
cache_file_metadata_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CacheFileMetadataResult, None], None, ),  # 0
)
fix_spec(all_structs)
del all_structs
