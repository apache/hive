#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
import fb303.FacebookService
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(fb303.FacebookService.Iface):
  """
  This interface is live.
  """
  def create_database(self, database):
    """
    Parameters:
     - database
    """
    pass

  def get_database(self, name):
    """
    Parameters:
     - name
    """
    pass

  def drop_database(self, name, deleteData, cascade):
    """
    Parameters:
     - name
     - deleteData
     - cascade
    """
    pass

  def get_databases(self, pattern):
    """
    Parameters:
     - pattern
    """
    pass

  def get_all_databases(self, ):
    pass

  def alter_database(self, dbname, db):
    """
    Parameters:
     - dbname
     - db
    """
    pass

  def get_type(self, name):
    """
    Parameters:
     - name
    """
    pass

  def create_type(self, type):
    """
    Parameters:
     - type
    """
    pass

  def drop_type(self, type):
    """
    Parameters:
     - type
    """
    pass

  def get_type_all(self, name):
    """
    Parameters:
     - name
    """
    pass

  def get_fields(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    pass

  def get_schema(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    pass

  def create_table(self, tbl):
    """
    Parameters:
     - tbl
    """
    pass

  def drop_table(self, dbname, name, deleteData):
    """
    Parameters:
     - dbname
     - name
     - deleteData
    """
    pass

  def get_tables(self, db_name, pattern):
    """
    Parameters:
     - db_name
     - pattern
    """
    pass

  def get_all_tables(self, db_name):
    """
    Parameters:
     - db_name
    """
    pass

  def get_table(self, dbname, tbl_name):
    """
    Parameters:
     - dbname
     - tbl_name
    """
    pass

  def get_table_objects_by_name(self, dbname, tbl_names):
    """
    Parameters:
     - dbname
     - tbl_names
    """
    pass

  def get_table_names_by_filter(self, dbname, filter, max_tables):
    """
    Parameters:
     - dbname
     - filter
     - max_tables
    """
    pass

  def alter_table(self, dbname, tbl_name, new_tbl):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
    """
    pass

  def add_partition(self, new_part):
    """
    Parameters:
     - new_part
    """
    pass

  def add_partitions(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    pass

  def append_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    pass

  def append_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    pass

  def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """
    pass

  def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """
    pass

  def get_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    pass

  def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names
    """
    pass

  def get_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    pass

  def get_partitions(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names
    """
    pass

  def get_partition_names(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    pass

  def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names
    """
    pass

  def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    pass

  def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    pass

  def get_partitions_by_names(self, db_name, tbl_name, names):
    """
    Parameters:
     - db_name
     - tbl_name
     - names
    """
    pass

  def alter_partition(self, db_name, tbl_name, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
    """
    pass

  def rename_partition(self, db_name, tbl_name, part_vals, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - new_part
    """
    pass

  def get_config_value(self, name, defaultValue):
    """
    Parameters:
     - name
     - defaultValue
    """
    pass

  def partition_name_to_vals(self, part_name):
    """
    Parameters:
     - part_name
    """
    pass

  def partition_name_to_spec(self, part_name):
    """
    Parameters:
     - part_name
    """
    pass

  def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    pass

  def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    pass

  def add_index(self, new_index, index_table):
    """
    Parameters:
     - new_index
     - index_table
    """
    pass

  def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    """
    Parameters:
     - dbname
     - base_tbl_name
     - idx_name
     - new_idx
    """
    pass

  def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """
    pass

  def get_index_by_name(self, db_name, tbl_name, index_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
    """
    pass

  def get_indexes(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass

  def get_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass

  def create_role(self, role):
    """
    Parameters:
     - role
    """
    pass

  def drop_role(self, role_name):
    """
    Parameters:
     - role_name
    """
    pass

  def get_role_names(self, ):
    pass

  def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option
    """
    pass

  def revoke_role(self, role_name, principal_name, principal_type):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
    """
    pass

  def list_roles(self, principal_name, principal_type):
    """
    Parameters:
     - principal_name
     - principal_type
    """
    pass

  def get_privilege_set(self, hiveObject, user_name, group_names):
    """
    Parameters:
     - hiveObject
     - user_name
     - group_names
    """
    pass

  def list_privileges(self, principal_name, principal_type, hiveObject):
    """
    Parameters:
     - principal_name
     - principal_type
     - hiveObject
    """
    pass

  def grant_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    pass

  def revoke_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    pass

  def set_ugi(self, user_name, group_names):
    """
    Parameters:
     - user_name
     - group_names
    """
    pass

  def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    """
    Parameters:
     - token_owner
     - renewer_kerberos_principal_name
    """
    pass

  def renew_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    pass

  def cancel_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    pass


class Client(fb303.FacebookService.Client, Iface):
  """
  This interface is live.
  """
  def __init__(self, iprot, oprot=None):
    fb303.FacebookService.Client.__init__(self, iprot, oprot)

  def create_database(self, database):
    """
    Parameters:
     - database
    """
    self.send_create_database(database)
    self.recv_create_database()

  def send_create_database(self, database):
    self._oprot.writeMessageBegin('create_database', TMessageType.CALL, self._seqid)
    args = create_database_args()
    args.database = database
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def get_database(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_database(name)
    return self.recv_get_database()

  def send_get_database(self, name):
    self._oprot.writeMessageBegin('get_database', TMessageType.CALL, self._seqid)
    args = get_database_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_database failed: unknown result");

  def drop_database(self, name, deleteData, cascade):
    """
    Parameters:
     - name
     - deleteData
     - cascade
    """
    self.send_drop_database(name, deleteData, cascade)
    self.recv_drop_database()

  def send_drop_database(self, name, deleteData, cascade):
    self._oprot.writeMessageBegin('drop_database', TMessageType.CALL, self._seqid)
    args = drop_database_args()
    args.name = name
    args.deleteData = deleteData
    args.cascade = cascade
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def get_databases(self, pattern):
    """
    Parameters:
     - pattern
    """
    self.send_get_databases(pattern)
    return self.recv_get_databases()

  def send_get_databases(self, pattern):
    self._oprot.writeMessageBegin('get_databases', TMessageType.CALL, self._seqid)
    args = get_databases_args()
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_databases(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_databases_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_databases failed: unknown result");

  def get_all_databases(self, ):
    self.send_get_all_databases()
    return self.recv_get_all_databases()

  def send_get_all_databases(self, ):
    self._oprot.writeMessageBegin('get_all_databases', TMessageType.CALL, self._seqid)
    args = get_all_databases_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_databases(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_all_databases_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_databases failed: unknown result");

  def alter_database(self, dbname, db):
    """
    Parameters:
     - dbname
     - db
    """
    self.send_alter_database(dbname, db)
    self.recv_alter_database()

  def send_alter_database(self, dbname, db):
    self._oprot.writeMessageBegin('alter_database', TMessageType.CALL, self._seqid)
    args = alter_database_args()
    args.dbname = dbname
    args.db = db
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def get_type(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_type(name)
    return self.recv_get_type()

  def send_get_type(self, name):
    self._oprot.writeMessageBegin('get_type', TMessageType.CALL, self._seqid)
    args = get_type_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type failed: unknown result");

  def create_type(self, type):
    """
    Parameters:
     - type
    """
    self.send_create_type(type)
    return self.recv_create_type()

  def send_create_type(self, type):
    self._oprot.writeMessageBegin('create_type', TMessageType.CALL, self._seqid)
    args = create_type_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_type failed: unknown result");

  def drop_type(self, type):
    """
    Parameters:
     - type
    """
    self.send_drop_type(type)
    return self.recv_drop_type()

  def send_drop_type(self, type):
    self._oprot.writeMessageBegin('drop_type', TMessageType.CALL, self._seqid)
    args = drop_type_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_type failed: unknown result");

  def get_type_all(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_type_all(name)
    return self.recv_get_type_all()

  def send_get_type_all(self, name):
    self._oprot.writeMessageBegin('get_type_all', TMessageType.CALL, self._seqid)
    args = get_type_all_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_type_all(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_type_all_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type_all failed: unknown result");

  def get_fields(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    self.send_get_fields(db_name, table_name)
    return self.recv_get_fields()

  def send_get_fields(self, db_name, table_name):
    self._oprot.writeMessageBegin('get_fields', TMessageType.CALL, self._seqid)
    args = get_fields_args()
    args.db_name = db_name
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_fields(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_fields_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields failed: unknown result");

  def get_schema(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    self.send_get_schema(db_name, table_name)
    return self.recv_get_schema()

  def send_get_schema(self, db_name, table_name):
    self._oprot.writeMessageBegin('get_schema', TMessageType.CALL, self._seqid)
    args = get_schema_args()
    args.db_name = db_name
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_schema(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_schema_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result");

  def create_table(self, tbl):
    """
    Parameters:
     - tbl
    """
    self.send_create_table(tbl)
    self.recv_create_table()

  def send_create_table(self, tbl):
    self._oprot.writeMessageBegin('create_table', TMessageType.CALL, self._seqid)
    args = create_table_args()
    args.tbl = tbl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def drop_table(self, dbname, name, deleteData):
    """
    Parameters:
     - dbname
     - name
     - deleteData
    """
    self.send_drop_table(dbname, name, deleteData)
    self.recv_drop_table()

  def send_drop_table(self, dbname, name, deleteData):
    self._oprot.writeMessageBegin('drop_table', TMessageType.CALL, self._seqid)
    args = drop_table_args()
    args.dbname = dbname
    args.name = name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o3 is not None:
      raise result.o3
    return

  def get_tables(self, db_name, pattern):
    """
    Parameters:
     - db_name
     - pattern
    """
    self.send_get_tables(db_name, pattern)
    return self.recv_get_tables()

  def send_get_tables(self, db_name, pattern):
    self._oprot.writeMessageBegin('get_tables', TMessageType.CALL, self._seqid)
    args = get_tables_args()
    args.db_name = db_name
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_tables(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_tables_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result");

  def get_all_tables(self, db_name):
    """
    Parameters:
     - db_name
    """
    self.send_get_all_tables(db_name)
    return self.recv_get_all_tables()

  def send_get_all_tables(self, db_name):
    self._oprot.writeMessageBegin('get_all_tables', TMessageType.CALL, self._seqid)
    args = get_all_tables_args()
    args.db_name = db_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_tables(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_all_tables_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_tables failed: unknown result");

  def get_table(self, dbname, tbl_name):
    """
    Parameters:
     - dbname
     - tbl_name
    """
    self.send_get_table(dbname, tbl_name)
    return self.recv_get_table()

  def send_get_table(self, dbname, tbl_name):
    self._oprot.writeMessageBegin('get_table', TMessageType.CALL, self._seqid)
    args = get_table_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table failed: unknown result");

  def get_table_objects_by_name(self, dbname, tbl_names):
    """
    Parameters:
     - dbname
     - tbl_names
    """
    self.send_get_table_objects_by_name(dbname, tbl_names)
    return self.recv_get_table_objects_by_name()

  def send_get_table_objects_by_name(self, dbname, tbl_names):
    self._oprot.writeMessageBegin('get_table_objects_by_name', TMessageType.CALL, self._seqid)
    args = get_table_objects_by_name_args()
    args.dbname = dbname
    args.tbl_names = tbl_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_objects_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_objects_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_objects_by_name failed: unknown result");

  def get_table_names_by_filter(self, dbname, filter, max_tables):
    """
    Parameters:
     - dbname
     - filter
     - max_tables
    """
    self.send_get_table_names_by_filter(dbname, filter, max_tables)
    return self.recv_get_table_names_by_filter()

  def send_get_table_names_by_filter(self, dbname, filter, max_tables):
    self._oprot.writeMessageBegin('get_table_names_by_filter', TMessageType.CALL, self._seqid)
    args = get_table_names_by_filter_args()
    args.dbname = dbname
    args.filter = filter
    args.max_tables = max_tables
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_names_by_filter(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_names_by_filter_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_names_by_filter failed: unknown result");

  def alter_table(self, dbname, tbl_name, new_tbl):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
    """
    self.send_alter_table(dbname, tbl_name, new_tbl)
    self.recv_alter_table()

  def send_alter_table(self, dbname, tbl_name, new_tbl):
    self._oprot.writeMessageBegin('alter_table', TMessageType.CALL, self._seqid)
    args = alter_table_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.new_tbl = new_tbl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def add_partition(self, new_part):
    """
    Parameters:
     - new_part
    """
    self.send_add_partition(new_part)
    return self.recv_add_partition()

  def send_add_partition(self, new_part):
    self._oprot.writeMessageBegin('add_partition', TMessageType.CALL, self._seqid)
    args = add_partition_args()
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition failed: unknown result");

  def add_partitions(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    self.send_add_partitions(new_parts)
    return self.recv_add_partitions()

  def send_add_partitions(self, new_parts):
    self._oprot.writeMessageBegin('add_partitions', TMessageType.CALL, self._seqid)
    args = add_partitions_args()
    args.new_parts = new_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partitions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_partitions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions failed: unknown result");

  def append_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    self.send_append_partition(db_name, tbl_name, part_vals)
    return self.recv_append_partition()

  def send_append_partition(self, db_name, tbl_name, part_vals):
    self._oprot.writeMessageBegin('append_partition', TMessageType.CALL, self._seqid)
    args = append_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = append_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition failed: unknown result");

  def append_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    self.send_append_partition_by_name(db_name, tbl_name, part_name)
    return self.recv_append_partition_by_name()

  def send_append_partition_by_name(self, db_name, tbl_name, part_name):
    self._oprot.writeMessageBegin('append_partition_by_name', TMessageType.CALL, self._seqid)
    args = append_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = append_partition_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name failed: unknown result");

  def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """
    self.send_drop_partition(db_name, tbl_name, part_vals, deleteData)
    return self.recv_drop_partition()

  def send_drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    self._oprot.writeMessageBegin('drop_partition', TMessageType.CALL, self._seqid)
    args = drop_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition failed: unknown result");

  def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """
    self.send_drop_partition_by_name(db_name, tbl_name, part_name, deleteData)
    return self.recv_drop_partition_by_name()

  def send_drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    self._oprot.writeMessageBegin('drop_partition_by_name', TMessageType.CALL, self._seqid)
    args = drop_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_partition_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name failed: unknown result");

  def get_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    self.send_get_partition(db_name, tbl_name, part_vals)
    return self.recv_get_partition()

  def send_get_partition(self, db_name, tbl_name, part_vals):
    self._oprot.writeMessageBegin('get_partition', TMessageType.CALL, self._seqid)
    args = get_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition failed: unknown result");

  def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names
    """
    self.send_get_partition_with_auth(db_name, tbl_name, part_vals, user_name, group_names)
    return self.recv_get_partition_with_auth()

  def send_get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    self._oprot.writeMessageBegin('get_partition_with_auth', TMessageType.CALL, self._seqid)
    args = get_partition_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_with_auth(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_with_auth_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_with_auth failed: unknown result");

  def get_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    self.send_get_partition_by_name(db_name, tbl_name, part_name)
    return self.recv_get_partition_by_name()

  def send_get_partition_by_name(self, db_name, tbl_name, part_name):
    self._oprot.writeMessageBegin('get_partition_by_name', TMessageType.CALL, self._seqid)
    args = get_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_by_name failed: unknown result");

  def get_partitions(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partitions(db_name, tbl_name, max_parts)
    return self.recv_get_partitions()

  def send_get_partitions(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partitions', TMessageType.CALL, self._seqid)
    args = get_partitions_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions failed: unknown result");

  def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names
    """
    self.send_get_partitions_with_auth(db_name, tbl_name, max_parts, user_name, group_names)
    return self.recv_get_partitions_with_auth()

  def send_get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    self._oprot.writeMessageBegin('get_partitions_with_auth', TMessageType.CALL, self._seqid)
    args = get_partitions_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_with_auth(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_with_auth_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_with_auth failed: unknown result");

  def get_partition_names(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partition_names(db_name, tbl_name, max_parts)
    return self.recv_get_partition_names()

  def send_get_partition_names(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partition_names', TMessageType.CALL, self._seqid)
    args = get_partition_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names failed: unknown result");

  def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    self.send_get_partitions_ps(db_name, tbl_name, part_vals, max_parts)
    return self.recv_get_partitions_ps()

  def send_get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    self._oprot.writeMessageBegin('get_partitions_ps', TMessageType.CALL, self._seqid)
    args = get_partitions_ps_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_ps(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_ps_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps failed: unknown result");

  def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names
    """
    self.send_get_partitions_ps_with_auth(db_name, tbl_name, part_vals, max_parts, user_name, group_names)
    return self.recv_get_partitions_ps_with_auth()

  def send_get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    self._oprot.writeMessageBegin('get_partitions_ps_with_auth', TMessageType.CALL, self._seqid)
    args = get_partitions_ps_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_ps_with_auth(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_ps_with_auth_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps_with_auth failed: unknown result");

  def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    self.send_get_partition_names_ps(db_name, tbl_name, part_vals, max_parts)
    return self.recv_get_partition_names_ps()

  def send_get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    self._oprot.writeMessageBegin('get_partition_names_ps', TMessageType.CALL, self._seqid)
    args = get_partition_names_ps_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_names_ps(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_names_ps_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_ps failed: unknown result");

  def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    self.send_get_partitions_by_filter(db_name, tbl_name, filter, max_parts)
    return self.recv_get_partitions_by_filter()

  def send_get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    self._oprot.writeMessageBegin('get_partitions_by_filter', TMessageType.CALL, self._seqid)
    args = get_partitions_by_filter_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.filter = filter
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_by_filter(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_by_filter_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_filter failed: unknown result");

  def get_partitions_by_names(self, db_name, tbl_name, names):
    """
    Parameters:
     - db_name
     - tbl_name
     - names
    """
    self.send_get_partitions_by_names(db_name, tbl_name, names)
    return self.recv_get_partitions_by_names()

  def send_get_partitions_by_names(self, db_name, tbl_name, names):
    self._oprot.writeMessageBegin('get_partitions_by_names', TMessageType.CALL, self._seqid)
    args = get_partitions_by_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.names = names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_by_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_by_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_names failed: unknown result");

  def alter_partition(self, db_name, tbl_name, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
    """
    self.send_alter_partition(db_name, tbl_name, new_part)
    self.recv_alter_partition()

  def send_alter_partition(self, db_name, tbl_name, new_part):
    self._oprot.writeMessageBegin('alter_partition', TMessageType.CALL, self._seqid)
    args = alter_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def rename_partition(self, db_name, tbl_name, part_vals, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - new_part
    """
    self.send_rename_partition(db_name, tbl_name, part_vals, new_part)
    self.recv_rename_partition()

  def send_rename_partition(self, db_name, tbl_name, part_vals, new_part):
    self._oprot.writeMessageBegin('rename_partition', TMessageType.CALL, self._seqid)
    args = rename_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rename_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = rename_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def get_config_value(self, name, defaultValue):
    """
    Parameters:
     - name
     - defaultValue
    """
    self.send_get_config_value(name, defaultValue)
    return self.recv_get_config_value()

  def send_get_config_value(self, name, defaultValue):
    self._oprot.writeMessageBegin('get_config_value', TMessageType.CALL, self._seqid)
    args = get_config_value_args()
    args.name = name
    args.defaultValue = defaultValue
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_config_value(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_config_value_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_config_value failed: unknown result");

  def partition_name_to_vals(self, part_name):
    """
    Parameters:
     - part_name
    """
    self.send_partition_name_to_vals(part_name)
    return self.recv_partition_name_to_vals()

  def send_partition_name_to_vals(self, part_name):
    self._oprot.writeMessageBegin('partition_name_to_vals', TMessageType.CALL, self._seqid)
    args = partition_name_to_vals_args()
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_to_vals(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = partition_name_to_vals_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_vals failed: unknown result");

  def partition_name_to_spec(self, part_name):
    """
    Parameters:
     - part_name
    """
    self.send_partition_name_to_spec(part_name)
    return self.recv_partition_name_to_spec()

  def send_partition_name_to_spec(self, part_name):
    self._oprot.writeMessageBegin('partition_name_to_spec', TMessageType.CALL, self._seqid)
    args = partition_name_to_spec_args()
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_to_spec(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = partition_name_to_spec_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_spec failed: unknown result");

  def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    self.send_markPartitionForEvent(db_name, tbl_name, part_vals, eventType)
    self.recv_markPartitionForEvent()

  def send_markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    self._oprot.writeMessageBegin('markPartitionForEvent', TMessageType.CALL, self._seqid)
    args = markPartitionForEvent_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.eventType = eventType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_markPartitionForEvent(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = markPartitionForEvent_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    if result.o5 is not None:
      raise result.o5
    if result.o6 is not None:
      raise result.o6
    return

  def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    self.send_isPartitionMarkedForEvent(db_name, tbl_name, part_vals, eventType)
    return self.recv_isPartitionMarkedForEvent()

  def send_isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    self._oprot.writeMessageBegin('isPartitionMarkedForEvent', TMessageType.CALL, self._seqid)
    args = isPartitionMarkedForEvent_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.eventType = eventType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isPartitionMarkedForEvent(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = isPartitionMarkedForEvent_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    if result.o5 is not None:
      raise result.o5
    if result.o6 is not None:
      raise result.o6
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isPartitionMarkedForEvent failed: unknown result");

  def add_index(self, new_index, index_table):
    """
    Parameters:
     - new_index
     - index_table
    """
    self.send_add_index(new_index, index_table)
    return self.recv_add_index()

  def send_add_index(self, new_index, index_table):
    self._oprot.writeMessageBegin('add_index', TMessageType.CALL, self._seqid)
    args = add_index_args()
    args.new_index = new_index
    args.index_table = index_table
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_index failed: unknown result");

  def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    """
    Parameters:
     - dbname
     - base_tbl_name
     - idx_name
     - new_idx
    """
    self.send_alter_index(dbname, base_tbl_name, idx_name, new_idx)
    self.recv_alter_index()

  def send_alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    self._oprot.writeMessageBegin('alter_index', TMessageType.CALL, self._seqid)
    args = alter_index_args()
    args.dbname = dbname
    args.base_tbl_name = base_tbl_name
    args.idx_name = idx_name
    args.new_idx = new_idx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """
    self.send_drop_index_by_name(db_name, tbl_name, index_name, deleteData)
    return self.recv_drop_index_by_name()

  def send_drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    self._oprot.writeMessageBegin('drop_index_by_name', TMessageType.CALL, self._seqid)
    args = drop_index_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.index_name = index_name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_index_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_index_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_index_by_name failed: unknown result");

  def get_index_by_name(self, db_name, tbl_name, index_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
    """
    self.send_get_index_by_name(db_name, tbl_name, index_name)
    return self.recv_get_index_by_name()

  def send_get_index_by_name(self, db_name, tbl_name, index_name):
    self._oprot.writeMessageBegin('get_index_by_name', TMessageType.CALL, self._seqid)
    args = get_index_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.index_name = index_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_index_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_index_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_by_name failed: unknown result");

  def get_indexes(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_indexes(db_name, tbl_name, max_indexes)
    return self.recv_get_indexes()

  def send_get_indexes(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_indexes', TMessageType.CALL, self._seqid)
    args = get_indexes_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_indexes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_indexes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_indexes failed: unknown result");

  def get_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_index_names(db_name, tbl_name, max_indexes)
    return self.recv_get_index_names()

  def send_get_index_names(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_index_names', TMessageType.CALL, self._seqid)
    args = get_index_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_index_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_index_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_names failed: unknown result");

  def create_role(self, role):
    """
    Parameters:
     - role
    """
    self.send_create_role(role)
    return self.recv_create_role()

  def send_create_role(self, role):
    self._oprot.writeMessageBegin('create_role', TMessageType.CALL, self._seqid)
    args = create_role_args()
    args.role = role
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_role(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_role_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_role failed: unknown result");

  def drop_role(self, role_name):
    """
    Parameters:
     - role_name
    """
    self.send_drop_role(role_name)
    return self.recv_drop_role()

  def send_drop_role(self, role_name):
    self._oprot.writeMessageBegin('drop_role', TMessageType.CALL, self._seqid)
    args = drop_role_args()
    args.role_name = role_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_role(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_role_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_role failed: unknown result");

  def get_role_names(self, ):
    self.send_get_role_names()
    return self.recv_get_role_names()

  def send_get_role_names(self, ):
    self._oprot.writeMessageBegin('get_role_names', TMessageType.CALL, self._seqid)
    args = get_role_names_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_role_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_role_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_names failed: unknown result");

  def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option
    """
    self.send_grant_role(role_name, principal_name, principal_type, grantor, grantorType, grant_option)
    return self.recv_grant_role()

  def send_grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    self._oprot.writeMessageBegin('grant_role', TMessageType.CALL, self._seqid)
    args = grant_role_args()
    args.role_name = role_name
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.grantor = grantor
    args.grantorType = grantorType
    args.grant_option = grant_option
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_role(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = grant_role_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_role failed: unknown result");

  def revoke_role(self, role_name, principal_name, principal_type):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
    """
    self.send_revoke_role(role_name, principal_name, principal_type)
    return self.recv_revoke_role()

  def send_revoke_role(self, role_name, principal_name, principal_type):
    self._oprot.writeMessageBegin('revoke_role', TMessageType.CALL, self._seqid)
    args = revoke_role_args()
    args.role_name = role_name
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revoke_role(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = revoke_role_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_role failed: unknown result");

  def list_roles(self, principal_name, principal_type):
    """
    Parameters:
     - principal_name
     - principal_type
    """
    self.send_list_roles(principal_name, principal_type)
    return self.recv_list_roles()

  def send_list_roles(self, principal_name, principal_type):
    self._oprot.writeMessageBegin('list_roles', TMessageType.CALL, self._seqid)
    args = list_roles_args()
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_roles(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_roles_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_roles failed: unknown result");

  def get_privilege_set(self, hiveObject, user_name, group_names):
    """
    Parameters:
     - hiveObject
     - user_name
     - group_names
    """
    self.send_get_privilege_set(hiveObject, user_name, group_names)
    return self.recv_get_privilege_set()

  def send_get_privilege_set(self, hiveObject, user_name, group_names):
    self._oprot.writeMessageBegin('get_privilege_set', TMessageType.CALL, self._seqid)
    args = get_privilege_set_args()
    args.hiveObject = hiveObject
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_privilege_set(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_privilege_set_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_privilege_set failed: unknown result");

  def list_privileges(self, principal_name, principal_type, hiveObject):
    """
    Parameters:
     - principal_name
     - principal_type
     - hiveObject
    """
    self.send_list_privileges(principal_name, principal_type, hiveObject)
    return self.recv_list_privileges()

  def send_list_privileges(self, principal_name, principal_type, hiveObject):
    self._oprot.writeMessageBegin('list_privileges', TMessageType.CALL, self._seqid)
    args = list_privileges_args()
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.hiveObject = hiveObject
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_privileges(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_privileges_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_privileges failed: unknown result");

  def grant_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    self.send_grant_privileges(privileges)
    return self.recv_grant_privileges()

  def send_grant_privileges(self, privileges):
    self._oprot.writeMessageBegin('grant_privileges', TMessageType.CALL, self._seqid)
    args = grant_privileges_args()
    args.privileges = privileges
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_privileges(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = grant_privileges_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_privileges failed: unknown result");

  def revoke_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    self.send_revoke_privileges(privileges)
    return self.recv_revoke_privileges()

  def send_revoke_privileges(self, privileges):
    self._oprot.writeMessageBegin('revoke_privileges', TMessageType.CALL, self._seqid)
    args = revoke_privileges_args()
    args.privileges = privileges
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revoke_privileges(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = revoke_privileges_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_privileges failed: unknown result");

  def set_ugi(self, user_name, group_names):
    """
    Parameters:
     - user_name
     - group_names
    """
    self.send_set_ugi(user_name, group_names)
    return self.recv_set_ugi()

  def send_set_ugi(self, user_name, group_names):
    self._oprot.writeMessageBegin('set_ugi', TMessageType.CALL, self._seqid)
    args = set_ugi_args()
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_ugi(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = set_ugi_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_ugi failed: unknown result");

  def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    """
    Parameters:
     - token_owner
     - renewer_kerberos_principal_name
    """
    self.send_get_delegation_token(token_owner, renewer_kerberos_principal_name)
    return self.recv_get_delegation_token()

  def send_get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    self._oprot.writeMessageBegin('get_delegation_token', TMessageType.CALL, self._seqid)
    args = get_delegation_token_args()
    args.token_owner = token_owner
    args.renewer_kerberos_principal_name = renewer_kerberos_principal_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_delegation_token(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_delegation_token_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_delegation_token failed: unknown result");

  def renew_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    self.send_renew_delegation_token(token_str_form)
    return self.recv_renew_delegation_token()

  def send_renew_delegation_token(self, token_str_form):
    self._oprot.writeMessageBegin('renew_delegation_token', TMessageType.CALL, self._seqid)
    args = renew_delegation_token_args()
    args.token_str_form = token_str_form
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_renew_delegation_token(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = renew_delegation_token_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "renew_delegation_token failed: unknown result");

  def cancel_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    self.send_cancel_delegation_token(token_str_form)
    self.recv_cancel_delegation_token()

  def send_cancel_delegation_token(self, token_str_form):
    self._oprot.writeMessageBegin('cancel_delegation_token', TMessageType.CALL, self._seqid)
    args = cancel_delegation_token_args()
    args.token_str_form = token_str_form
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cancel_delegation_token(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cancel_delegation_token_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return


class Processor(fb303.FacebookService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    fb303.FacebookService.Processor.__init__(self, handler)
    self._processMap["create_database"] = Processor.process_create_database
    self._processMap["get_database"] = Processor.process_get_database
    self._processMap["drop_database"] = Processor.process_drop_database
    self._processMap["get_databases"] = Processor.process_get_databases
    self._processMap["get_all_databases"] = Processor.process_get_all_databases
    self._processMap["alter_database"] = Processor.process_alter_database
    self._processMap["get_type"] = Processor.process_get_type
    self._processMap["create_type"] = Processor.process_create_type
    self._processMap["drop_type"] = Processor.process_drop_type
    self._processMap["get_type_all"] = Processor.process_get_type_all
    self._processMap["get_fields"] = Processor.process_get_fields
    self._processMap["get_schema"] = Processor.process_get_schema
    self._processMap["create_table"] = Processor.process_create_table
    self._processMap["drop_table"] = Processor.process_drop_table
    self._processMap["get_tables"] = Processor.process_get_tables
    self._processMap["get_all_tables"] = Processor.process_get_all_tables
    self._processMap["get_table"] = Processor.process_get_table
    self._processMap["get_table_objects_by_name"] = Processor.process_get_table_objects_by_name
    self._processMap["get_table_names_by_filter"] = Processor.process_get_table_names_by_filter
    self._processMap["alter_table"] = Processor.process_alter_table
    self._processMap["add_partition"] = Processor.process_add_partition
    self._processMap["add_partitions"] = Processor.process_add_partitions
    self._processMap["append_partition"] = Processor.process_append_partition
    self._processMap["append_partition_by_name"] = Processor.process_append_partition_by_name
    self._processMap["drop_partition"] = Processor.process_drop_partition
    self._processMap["drop_partition_by_name"] = Processor.process_drop_partition_by_name
    self._processMap["get_partition"] = Processor.process_get_partition
    self._processMap["get_partition_with_auth"] = Processor.process_get_partition_with_auth
    self._processMap["get_partition_by_name"] = Processor.process_get_partition_by_name
    self._processMap["get_partitions"] = Processor.process_get_partitions
    self._processMap["get_partitions_with_auth"] = Processor.process_get_partitions_with_auth
    self._processMap["get_partition_names"] = Processor.process_get_partition_names
    self._processMap["get_partitions_ps"] = Processor.process_get_partitions_ps
    self._processMap["get_partitions_ps_with_auth"] = Processor.process_get_partitions_ps_with_auth
    self._processMap["get_partition_names_ps"] = Processor.process_get_partition_names_ps
    self._processMap["get_partitions_by_filter"] = Processor.process_get_partitions_by_filter
    self._processMap["get_partitions_by_names"] = Processor.process_get_partitions_by_names
    self._processMap["alter_partition"] = Processor.process_alter_partition
    self._processMap["rename_partition"] = Processor.process_rename_partition
    self._processMap["get_config_value"] = Processor.process_get_config_value
    self._processMap["partition_name_to_vals"] = Processor.process_partition_name_to_vals
    self._processMap["partition_name_to_spec"] = Processor.process_partition_name_to_spec
    self._processMap["markPartitionForEvent"] = Processor.process_markPartitionForEvent
    self._processMap["isPartitionMarkedForEvent"] = Processor.process_isPartitionMarkedForEvent
    self._processMap["add_index"] = Processor.process_add_index
    self._processMap["alter_index"] = Processor.process_alter_index
    self._processMap["drop_index_by_name"] = Processor.process_drop_index_by_name
    self._processMap["get_index_by_name"] = Processor.process_get_index_by_name
    self._processMap["get_indexes"] = Processor.process_get_indexes
    self._processMap["get_index_names"] = Processor.process_get_index_names
    self._processMap["create_role"] = Processor.process_create_role
    self._processMap["drop_role"] = Processor.process_drop_role
    self._processMap["get_role_names"] = Processor.process_get_role_names
    self._processMap["grant_role"] = Processor.process_grant_role
    self._processMap["revoke_role"] = Processor.process_revoke_role
    self._processMap["list_roles"] = Processor.process_list_roles
    self._processMap["get_privilege_set"] = Processor.process_get_privilege_set
    self._processMap["list_privileges"] = Processor.process_list_privileges
    self._processMap["grant_privileges"] = Processor.process_grant_privileges
    self._processMap["revoke_privileges"] = Processor.process_revoke_privileges
    self._processMap["set_ugi"] = Processor.process_set_ugi
    self._processMap["get_delegation_token"] = Processor.process_get_delegation_token
    self._processMap["renew_delegation_token"] = Processor.process_renew_delegation_token
    self._processMap["cancel_delegation_token"] = Processor.process_cancel_delegation_token

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_create_database(self, seqid, iprot, oprot):
    args = create_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_database_result()
    try:
      self._handler.create_database(args.database)
    except AlreadyExistsException, o1:
      result.o1 = o1
    except InvalidObjectException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("create_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_database(self, seqid, iprot, oprot):
    args = get_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_database_result()
    try:
      result.success = self._handler.get_database(args.name)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_database(self, seqid, iprot, oprot):
    args = drop_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_database_result()
    try:
      self._handler.drop_database(args.name, args.deleteData, args.cascade)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except InvalidOperationException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("drop_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_databases(self, seqid, iprot, oprot):
    args = get_databases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_databases_result()
    try:
      result.success = self._handler.get_databases(args.pattern)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_databases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_databases(self, seqid, iprot, oprot):
    args = get_all_databases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_databases_result()
    try:
      result.success = self._handler.get_all_databases()
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_all_databases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_database(self, seqid, iprot, oprot):
    args = alter_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_database_result()
    try:
      self._handler.alter_database(args.dbname, args.db)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_type(self, seqid, iprot, oprot):
    args = get_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_type_result()
    try:
      result.success = self._handler.get_type(args.name)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_type(self, seqid, iprot, oprot):
    args = create_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_type_result()
    try:
      result.success = self._handler.create_type(args.type)
    except AlreadyExistsException, o1:
      result.o1 = o1
    except InvalidObjectException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("create_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_type(self, seqid, iprot, oprot):
    args = drop_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_type_result()
    try:
      result.success = self._handler.drop_type(args.type)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_type_all(self, seqid, iprot, oprot):
    args = get_type_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_type_all_result()
    try:
      result.success = self._handler.get_type_all(args.name)
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_type_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_fields(self, seqid, iprot, oprot):
    args = get_fields_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_fields_result()
    try:
      result.success = self._handler.get_fields(args.db_name, args.table_name)
    except MetaException, o1:
      result.o1 = o1
    except UnknownTableException, o2:
      result.o2 = o2
    except UnknownDBException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("get_fields", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_schema(self, seqid, iprot, oprot):
    args = get_schema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_schema_result()
    try:
      result.success = self._handler.get_schema(args.db_name, args.table_name)
    except MetaException, o1:
      result.o1 = o1
    except UnknownTableException, o2:
      result.o2 = o2
    except UnknownDBException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("get_schema", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table(self, seqid, iprot, oprot):
    args = create_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_result()
    try:
      self._handler.create_table(args.tbl)
    except AlreadyExistsException, o1:
      result.o1 = o1
    except InvalidObjectException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    except NoSuchObjectException, o4:
      result.o4 = o4
    oprot.writeMessageBegin("create_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_table(self, seqid, iprot, oprot):
    args = drop_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_table_result()
    try:
      self._handler.drop_table(args.dbname, args.name, args.deleteData)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("drop_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_tables(self, seqid, iprot, oprot):
    args = get_tables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_tables_result()
    try:
      result.success = self._handler.get_tables(args.db_name, args.pattern)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_tables", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_tables(self, seqid, iprot, oprot):
    args = get_all_tables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_tables_result()
    try:
      result.success = self._handler.get_all_tables(args.db_name)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_all_tables", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table(self, seqid, iprot, oprot):
    args = get_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_result()
    try:
      result.success = self._handler.get_table(args.dbname, args.tbl_name)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_objects_by_name(self, seqid, iprot, oprot):
    args = get_table_objects_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_objects_by_name_result()
    try:
      result.success = self._handler.get_table_objects_by_name(args.dbname, args.tbl_names)
    except MetaException, o1:
      result.o1 = o1
    except InvalidOperationException, o2:
      result.o2 = o2
    except UnknownDBException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("get_table_objects_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_names_by_filter(self, seqid, iprot, oprot):
    args = get_table_names_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_names_by_filter_result()
    try:
      result.success = self._handler.get_table_names_by_filter(args.dbname, args.filter, args.max_tables)
    except MetaException, o1:
      result.o1 = o1
    except InvalidOperationException, o2:
      result.o2 = o2
    except UnknownDBException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("get_table_names_by_filter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table(self, seqid, iprot, oprot):
    args = alter_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_result()
    try:
      self._handler.alter_table(args.dbname, args.tbl_name, args.new_tbl)
    except InvalidOperationException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition(self, seqid, iprot, oprot):
    args = add_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_result()
    try:
      result.success = self._handler.add_partition(args.new_part)
    except InvalidObjectException, o1:
      result.o1 = o1
    except AlreadyExistsException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("add_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partitions(self, seqid, iprot, oprot):
    args = add_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partitions_result()
    try:
      result.success = self._handler.add_partitions(args.new_parts)
    except InvalidObjectException, o1:
      result.o1 = o1
    except AlreadyExistsException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("add_partitions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition(self, seqid, iprot, oprot):
    args = append_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_result()
    try:
      result.success = self._handler.append_partition(args.db_name, args.tbl_name, args.part_vals)
    except InvalidObjectException, o1:
      result.o1 = o1
    except AlreadyExistsException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("append_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition_by_name(self, seqid, iprot, oprot):
    args = append_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_by_name_result()
    try:
      result.success = self._handler.append_partition_by_name(args.db_name, args.tbl_name, args.part_name)
    except InvalidObjectException, o1:
      result.o1 = o1
    except AlreadyExistsException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("append_partition_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition(self, seqid, iprot, oprot):
    args = drop_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_result()
    try:
      result.success = self._handler.drop_partition(args.db_name, args.tbl_name, args.part_vals, args.deleteData)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_by_name(self, seqid, iprot, oprot):
    args = drop_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_by_name_result()
    try:
      result.success = self._handler.drop_partition_by_name(args.db_name, args.tbl_name, args.part_name, args.deleteData)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_partition_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition(self, seqid, iprot, oprot):
    args = get_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_result()
    try:
      result.success = self._handler.get_partition(args.db_name, args.tbl_name, args.part_vals)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_with_auth(self, seqid, iprot, oprot):
    args = get_partition_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_with_auth_result()
    try:
      result.success = self._handler.get_partition_with_auth(args.db_name, args.tbl_name, args.part_vals, args.user_name, args.group_names)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition_with_auth", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_by_name(self, seqid, iprot, oprot):
    args = get_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_by_name_result()
    try:
      result.success = self._handler.get_partition_by_name(args.db_name, args.tbl_name, args.part_name)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions(self, seqid, iprot, oprot):
    args = get_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_result()
    try:
      result.success = self._handler.get_partitions(args.db_name, args.tbl_name, args.max_parts)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_with_auth(self, seqid, iprot, oprot):
    args = get_partitions_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_with_auth_result()
    try:
      result.success = self._handler.get_partitions_with_auth(args.db_name, args.tbl_name, args.max_parts, args.user_name, args.group_names)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions_with_auth", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_names(self, seqid, iprot, oprot):
    args = get_partition_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_names_result()
    try:
      result.success = self._handler.get_partition_names(args.db_name, args.tbl_name, args.max_parts)
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_ps(self, seqid, iprot, oprot):
    args = get_partitions_ps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_ps_result()
    try:
      result.success = self._handler.get_partitions_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_partitions_ps", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_ps_with_auth(self, seqid, iprot, oprot):
    args = get_partitions_ps_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_ps_with_auth_result()
    try:
      result.success = self._handler.get_partitions_ps_with_auth(args.db_name, args.tbl_name, args.part_vals, args.max_parts, args.user_name, args.group_names)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions_ps_with_auth", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_names_ps(self, seqid, iprot, oprot):
    args = get_partition_names_ps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_names_ps_result()
    try:
      result.success = self._handler.get_partition_names_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_partition_names_ps", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_by_filter(self, seqid, iprot, oprot):
    args = get_partitions_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_by_filter_result()
    try:
      result.success = self._handler.get_partitions_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions_by_filter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_by_names(self, seqid, iprot, oprot):
    args = get_partitions_by_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_by_names_result()
    try:
      result.success = self._handler.get_partitions_by_names(args.db_name, args.tbl_name, args.names)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions_by_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partition(self, seqid, iprot, oprot):
    args = alter_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partition_result()
    try:
      self._handler.alter_partition(args.db_name, args.tbl_name, args.new_part)
    except InvalidOperationException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rename_partition(self, seqid, iprot, oprot):
    args = rename_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rename_partition_result()
    try:
      self._handler.rename_partition(args.db_name, args.tbl_name, args.part_vals, args.new_part)
    except InvalidOperationException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("rename_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_config_value(self, seqid, iprot, oprot):
    args = get_config_value_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_config_value_result()
    try:
      result.success = self._handler.get_config_value(args.name, args.defaultValue)
    except ConfigValSecurityException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_config_value", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_to_vals(self, seqid, iprot, oprot):
    args = partition_name_to_vals_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_to_vals_result()
    try:
      result.success = self._handler.partition_name_to_vals(args.part_name)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("partition_name_to_vals", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_to_spec(self, seqid, iprot, oprot):
    args = partition_name_to_spec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_to_spec_result()
    try:
      result.success = self._handler.partition_name_to_spec(args.part_name)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("partition_name_to_spec", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_markPartitionForEvent(self, seqid, iprot, oprot):
    args = markPartitionForEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = markPartitionForEvent_result()
    try:
      self._handler.markPartitionForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    except UnknownDBException, o3:
      result.o3 = o3
    except UnknownTableException, o4:
      result.o4 = o4
    except UnknownPartitionException, o5:
      result.o5 = o5
    except InvalidPartitionException, o6:
      result.o6 = o6
    oprot.writeMessageBegin("markPartitionForEvent", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isPartitionMarkedForEvent(self, seqid, iprot, oprot):
    args = isPartitionMarkedForEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isPartitionMarkedForEvent_result()
    try:
      result.success = self._handler.isPartitionMarkedForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    except UnknownDBException, o3:
      result.o3 = o3
    except UnknownTableException, o4:
      result.o4 = o4
    except UnknownPartitionException, o5:
      result.o5 = o5
    except InvalidPartitionException, o6:
      result.o6 = o6
    oprot.writeMessageBegin("isPartitionMarkedForEvent", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_index(self, seqid, iprot, oprot):
    args = add_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_index_result()
    try:
      result.success = self._handler.add_index(args.new_index, args.index_table)
    except InvalidObjectException, o1:
      result.o1 = o1
    except AlreadyExistsException, o2:
      result.o2 = o2
    except MetaException, o3:
      result.o3 = o3
    oprot.writeMessageBegin("add_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_index(self, seqid, iprot, oprot):
    args = alter_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_index_result()
    try:
      self._handler.alter_index(args.dbname, args.base_tbl_name, args.idx_name, args.new_idx)
    except InvalidOperationException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_index_by_name(self, seqid, iprot, oprot):
    args = drop_index_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_index_by_name_result()
    try:
      result.success = self._handler.drop_index_by_name(args.db_name, args.tbl_name, args.index_name, args.deleteData)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_index_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_index_by_name(self, seqid, iprot, oprot):
    args = get_index_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_index_by_name_result()
    try:
      result.success = self._handler.get_index_by_name(args.db_name, args.tbl_name, args.index_name)
    except MetaException, o1:
      result.o1 = o1
    except NoSuchObjectException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_index_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_indexes(self, seqid, iprot, oprot):
    args = get_indexes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_indexes_result()
    try:
      result.success = self._handler.get_indexes(args.db_name, args.tbl_name, args.max_indexes)
    except NoSuchObjectException, o1:
      result.o1 = o1
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_indexes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_index_names(self, seqid, iprot, oprot):
    args = get_index_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_index_names_result()
    try:
      result.success = self._handler.get_index_names(args.db_name, args.tbl_name, args.max_indexes)
    except MetaException, o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_index_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_role(self, seqid, iprot, oprot):
    args = create_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_role_result()
    try:
      result.success = self._handler.create_role(args.role)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("create_role", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_role(self, seqid, iprot, oprot):
    args = drop_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_role_result()
    try:
      result.success = self._handler.drop_role(args.role_name)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("drop_role", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_role_names(self, seqid, iprot, oprot):
    args = get_role_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_role_names_result()
    try:
      result.success = self._handler.get_role_names()
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_role_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_role(self, seqid, iprot, oprot):
    args = grant_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_role_result()
    try:
      result.success = self._handler.grant_role(args.role_name, args.principal_name, args.principal_type, args.grantor, args.grantorType, args.grant_option)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("grant_role", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revoke_role(self, seqid, iprot, oprot):
    args = revoke_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revoke_role_result()
    try:
      result.success = self._handler.revoke_role(args.role_name, args.principal_name, args.principal_type)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("revoke_role", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_roles(self, seqid, iprot, oprot):
    args = list_roles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_roles_result()
    try:
      result.success = self._handler.list_roles(args.principal_name, args.principal_type)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("list_roles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_privilege_set(self, seqid, iprot, oprot):
    args = get_privilege_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_privilege_set_result()
    try:
      result.success = self._handler.get_privilege_set(args.hiveObject, args.user_name, args.group_names)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_privilege_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_privileges(self, seqid, iprot, oprot):
    args = list_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_privileges_result()
    try:
      result.success = self._handler.list_privileges(args.principal_name, args.principal_type, args.hiveObject)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("list_privileges", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_privileges(self, seqid, iprot, oprot):
    args = grant_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_privileges_result()
    try:
      result.success = self._handler.grant_privileges(args.privileges)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("grant_privileges", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revoke_privileges(self, seqid, iprot, oprot):
    args = revoke_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revoke_privileges_result()
    try:
      result.success = self._handler.revoke_privileges(args.privileges)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("revoke_privileges", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_ugi(self, seqid, iprot, oprot):
    args = set_ugi_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_ugi_result()
    try:
      result.success = self._handler.set_ugi(args.user_name, args.group_names)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("set_ugi", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_delegation_token(self, seqid, iprot, oprot):
    args = get_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_delegation_token_result()
    try:
      result.success = self._handler.get_delegation_token(args.token_owner, args.renewer_kerberos_principal_name)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_delegation_token", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_renew_delegation_token(self, seqid, iprot, oprot):
    args = renew_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = renew_delegation_token_result()
    try:
      result.success = self._handler.renew_delegation_token(args.token_str_form)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("renew_delegation_token", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cancel_delegation_token(self, seqid, iprot, oprot):
    args = cancel_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cancel_delegation_token_result()
    try:
      self._handler.cancel_delegation_token(args.token_str_form)
    except MetaException, o1:
      result.o1 = o1
    oprot.writeMessageBegin("cancel_delegation_token", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class create_database_args:
  """
  Attributes:
   - database
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'database', (Database, Database.thrift_spec), None, ), # 1
  )

  def __init__(self, database=None,):
    self.database = database

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.database = Database()
          self.database.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_database_args')
    if self.database is not None:
      oprot.writeFieldBegin('database', TType.STRUCT, 1)
      self.database.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_database_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_database_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_database_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_database_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Database, Database.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Database()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_database_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_database_args:
  """
  Attributes:
   - name
   - deleteData
   - cascade
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.BOOL, 'deleteData', None, None, ), # 2
    (3, TType.BOOL, 'cascade', None, None, ), # 3
  )

  def __init__(self, name=None, deleteData=None, cascade=None,):
    self.name = name
    self.deleteData = deleteData
    self.cascade = cascade

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.cascade = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_database_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 2)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.cascade is not None:
      oprot.writeFieldBegin('cascade', TType.BOOL, 3)
      oprot.writeBool(self.cascade)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_database_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_databases_args:
  """
  Attributes:
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pattern', None, None, ), # 1
  )

  def __init__(self, pattern=None,):
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_databases_args')
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 1)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_databases_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype177, _size174) = iprot.readListBegin()
          for _i178 in xrange(_size174):
            _elem179 = iprot.readString();
            self.success.append(_elem179)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_databases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter180 in self.success:
        oprot.writeString(iter180)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_databases_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_databases_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_databases_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype184, _size181) = iprot.readListBegin()
          for _i185 in xrange(_size181):
            _elem186 = iprot.readString();
            self.success.append(_elem186)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_databases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter187 in self.success:
        oprot.writeString(iter187)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_database_args:
  """
  Attributes:
   - dbname
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRUCT, 'db', (Database, Database.thrift_spec), None, ), # 2
  )

  def __init__(self, dbname=None, db=None,):
    self.dbname = dbname
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.db = Database()
          self.db.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_database_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRUCT, 2)
      self.db.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_database_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Type, Type.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Type()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_type_args:
  """
  Attributes:
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'type', (Type, Type.thrift_spec), None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.type = Type()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_type_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRUCT, 1)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_type_args:
  """
  Attributes:
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type', None, None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_type_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 1)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_all_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_all_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_all_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Type, Type.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype189, _vtype190, _size188 ) = iprot.readMapBegin() 
          for _i192 in xrange(_size188):
            _key193 = iprot.readString();
            _val194 = Type()
            _val194.read(iprot)
            self.success[_key193] = _val194
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter195,viter196 in self.success.items():
        oprot.writeString(kiter195)
        viter196.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_args:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype200, _size197) = iprot.readListBegin()
          for _i201 in xrange(_size197):
            _elem202 = FieldSchema()
            _elem202.read(iprot)
            self.success.append(_elem202)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter203 in self.success:
        iter203.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_args:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype207, _size204) = iprot.readListBegin()
          for _i208 in xrange(_size204):
            _elem209 = FieldSchema()
            _elem209.read(iprot)
            self.success.append(_elem209)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter210 in self.success:
        iter210.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_args:
  """
  Attributes:
   - tbl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
  )

  def __init__(self, tbl=None,):
    self.tbl = tbl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_args:
  """
  Attributes:
   - dbname
   - name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.BOOL, 'deleteData', None, None, ), # 3
  )

  def __init__(self, dbname=None, name=None, deleteData=None,):
    self.dbname = dbname
    self.name = name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_result:
  """
  Attributes:
   - o1
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o3=None,):
    self.o1 = o1
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 2)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_args:
  """
  Attributes:
   - db_name
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
  )

  def __init__(self, db_name=None, pattern=None,):
    self.db_name = db_name
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype214, _size211) = iprot.readListBegin()
          for _i215 in xrange(_size211):
            _elem216 = iprot.readString();
            self.success.append(_elem216)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter217 in self.success:
        oprot.writeString(iter217)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_tables_args:
  """
  Attributes:
   - db_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
  )

  def __init__(self, db_name=None,):
    self.db_name = db_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_tables_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_tables_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype221, _size218) = iprot.readListBegin()
          for _i222 in xrange(_size218):
            _elem223 = iprot.readString();
            self.success.append(_elem223)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_tables_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter224 in self.success:
        oprot.writeString(iter224)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_args:
  """
  Attributes:
   - dbname
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, dbname=None, tbl_name=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Table, Table.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Table()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_objects_by_name_args:
  """
  Attributes:
   - dbname
   - tbl_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.LIST, 'tbl_names', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, dbname=None, tbl_names=None,):
    self.dbname = dbname
    self.tbl_names = tbl_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tbl_names = []
          (_etype228, _size225) = iprot.readListBegin()
          for _i229 in xrange(_size225):
            _elem230 = iprot.readString();
            self.tbl_names.append(_elem230)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_objects_by_name_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_names is not None:
      oprot.writeFieldBegin('tbl_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.tbl_names))
      for iter231 in self.tbl_names:
        oprot.writeString(iter231)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_objects_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Table, Table.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype235, _size232) = iprot.readListBegin()
          for _i236 in xrange(_size232):
            _elem237 = Table()
            _elem237.read(iprot)
            self.success.append(_elem237)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_objects_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter238 in self.success:
        iter238.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_names_by_filter_args:
  """
  Attributes:
   - dbname
   - filter
   - max_tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'filter', None, None, ), # 2
    (3, TType.I16, 'max_tables', None, -1, ), # 3
  )

  def __init__(self, dbname=None, filter=None, max_tables=thrift_spec[3][4],):
    self.dbname = dbname
    self.filter = filter
    self.max_tables = max_tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.filter = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_tables = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_names_by_filter_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 2)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.max_tables is not None:
      oprot.writeFieldBegin('max_tables', TType.I16, 3)
      oprot.writeI16(self.max_tables)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_names_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype242, _size239) = iprot.readListBegin()
          for _i243 in xrange(_size239):
            _elem244 = iprot.readString();
            self.success.append(_elem244)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_names_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter245 in self.success:
        oprot.writeString(iter245)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - new_tbl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ), # 3
  )

  def __init__(self, dbname=None, tbl_name=None, new_tbl=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.new_tbl = new_tbl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_tbl = Table()
          self.new_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_tbl is not None:
      oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
      self.new_tbl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_args:
  """
  Attributes:
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 1
  )

  def __init__(self, new_part=None,):
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_args')
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_args:
  """
  Attributes:
   - new_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'new_parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, new_parts=None,):
    self.new_parts = new_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.new_parts = []
          (_etype249, _size246) = iprot.readListBegin()
          for _i250 in xrange(_size246):
            _elem251 = Partition()
            _elem251.read(iprot)
            self.new_parts.append(_elem251)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_args')
    if self.new_parts is not None:
      oprot.writeFieldBegin('new_parts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
      for iter252 in self.new_parts:
        iter252.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype256, _size253) = iprot.readListBegin()
          for _i257 in xrange(_size253):
            _elem258 = iprot.readString();
            self.part_vals.append(_elem258)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter259 in self.part_vals:
        oprot.writeString(iter259)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype263, _size260) = iprot.readListBegin()
          for _i264 in xrange(_size260):
            _elem265 = iprot.readString();
            self.part_vals.append(_elem265)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter266 in self.part_vals:
        oprot.writeString(iter266)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype270, _size267) = iprot.readListBegin()
          for _i271 in xrange(_size267):
            _elem272 = iprot.readString();
            self.part_vals.append(_elem272)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter273 in self.part_vals:
        oprot.writeString(iter273)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'user_name', None, None, ), # 4
    (5, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype277, _size274) = iprot.readListBegin()
          for _i278 in xrange(_size274):
            _elem279 = iprot.readString();
            self.part_vals.append(_elem279)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype283, _size280) = iprot.readListBegin()
          for _i284 in xrange(_size280):
            _elem285 = iprot.readString();
            self.group_names.append(_elem285)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter286 in self.part_vals:
        oprot.writeString(iter286)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 4)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter287 in self.group_names:
        oprot.writeString(iter287)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype291, _size288) = iprot.readListBegin()
          for _i292 in xrange(_size288):
            _elem293 = Partition()
            _elem293.read(iprot)
            self.success.append(_elem293)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter294 in self.success:
        iter294.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
    (4, TType.STRING, 'user_name', None, None, ), # 4
    (5, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4], user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype298, _size295) = iprot.readListBegin()
          for _i299 in xrange(_size295):
            _elem300 = iprot.readString();
            self.group_names.append(_elem300)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 4)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter301 in self.group_names:
        oprot.writeString(iter301)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype305, _size302) = iprot.readListBegin()
          for _i306 in xrange(_size302):
            _elem307 = Partition()
            _elem307.read(iprot)
            self.success.append(_elem307)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter308 in self.success:
        iter308.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype312, _size309) = iprot.readListBegin()
          for _i313 in xrange(_size309):
            _elem314 = iprot.readString();
            self.success.append(_elem314)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter315 in self.success:
        oprot.writeString(iter315)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype319, _size316) = iprot.readListBegin()
          for _i320 in xrange(_size316):
            _elem321 = iprot.readString();
            self.part_vals.append(_elem321)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter322 in self.part_vals:
        oprot.writeString(iter322)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype326, _size323) = iprot.readListBegin()
          for _i327 in xrange(_size323):
            _elem328 = Partition()
            _elem328.read(iprot)
            self.success.append(_elem328)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter329 in self.success:
        iter329.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
    (5, TType.STRING, 'user_name', None, None, ), # 5
    (6, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 6
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4], user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype333, _size330) = iprot.readListBegin()
          for _i334 in xrange(_size330):
            _elem335 = iprot.readString();
            self.part_vals.append(_elem335)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype339, _size336) = iprot.readListBegin()
          for _i340 in xrange(_size336):
            _elem341 = iprot.readString();
            self.group_names.append(_elem341)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter342 in self.part_vals:
        oprot.writeString(iter342)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 5)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter343 in self.group_names:
        oprot.writeString(iter343)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype347, _size344) = iprot.readListBegin()
          for _i348 in xrange(_size344):
            _elem349 = Partition()
            _elem349.read(iprot)
            self.success.append(_elem349)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter350 in self.success:
        iter350.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_ps_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype354, _size351) = iprot.readListBegin()
          for _i355 in xrange(_size351):
            _elem356 = iprot.readString();
            self.part_vals.append(_elem356)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_ps_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter357 in self.part_vals:
        oprot.writeString(iter357)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_ps_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype361, _size358) = iprot.readListBegin()
          for _i362 in xrange(_size358):
            _elem363 = iprot.readString();
            self.success.append(_elem363)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_ps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter364 in self.success:
        oprot.writeString(iter364)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_filter_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - filter
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'filter', None, None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, filter=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.filter = filter
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.filter = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_filter_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 3)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype368, _size365) = iprot.readListBegin()
          for _i369 in xrange(_size365):
            _elem370 = Partition()
            _elem370.read(iprot)
            self.success.append(_elem370)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter371 in self.success:
        iter371.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'names', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.names = names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.names = []
          (_etype375, _size372) = iprot.readListBegin()
          for _i376 in xrange(_size372):
            _elem377 = iprot.readString();
            self.names.append(_elem377)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.names is not None:
      oprot.writeFieldBegin('names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.names))
      for iter378 in self.names:
        oprot.writeString(iter378)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_names_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype382, _size379) = iprot.readListBegin()
          for _i383 in xrange(_size379):
            _elem384 = Partition()
            _elem384.read(iprot)
            self.success.append(_elem384)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter385 in self.success:
        iter385.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, new_part=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, new_part=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype389, _size386) = iprot.readListBegin()
          for _i390 in xrange(_size386):
            _elem391 = iprot.readString();
            self.part_vals.append(_elem391)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter392 in self.part_vals:
        oprot.writeString(iter392)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 4)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_partition_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_partition_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_config_value_args:
  """
  Attributes:
   - name
   - defaultValue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'defaultValue', None, None, ), # 2
  )

  def __init__(self, name=None, defaultValue=None,):
    self.name = name
    self.defaultValue = defaultValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.defaultValue = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_config_value_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.defaultValue is not None:
      oprot.writeFieldBegin('defaultValue', TType.STRING, 2)
      oprot.writeString(self.defaultValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_config_value_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (ConfigValSecurityException, ConfigValSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = ConfigValSecurityException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_config_value_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_vals_args:
  """
  Attributes:
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'part_name', None, None, ), # 1
  )

  def __init__(self, part_name=None,):
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_vals_args')
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 1)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_vals_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype396, _size393) = iprot.readListBegin()
          for _i397 in xrange(_size393):
            _elem398 = iprot.readString();
            self.success.append(_elem398)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_vals_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter399 in self.success:
        oprot.writeString(iter399)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_spec_args:
  """
  Attributes:
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'part_name', None, None, ), # 1
  )

  def __init__(self, part_name=None,):
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_spec_args')
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 1)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_spec_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype401, _vtype402, _size400 ) = iprot.readMapBegin() 
          for _i404 in xrange(_size400):
            _key405 = iprot.readString();
            _val406 = iprot.readString();
            self.success[_key405] = _val406
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_spec_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter407,viter408 in self.success.items():
        oprot.writeString(kiter407)
        oprot.writeString(viter408)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markPartitionForEvent_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - eventType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.MAP, 'part_vals', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.I32, 'eventType', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.eventType = eventType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.part_vals = {}
          (_ktype410, _vtype411, _size409 ) = iprot.readMapBegin() 
          for _i413 in xrange(_size409):
            _key414 = iprot.readString();
            _val415 = iprot.readString();
            self.part_vals[_key414] = _val415
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.eventType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markPartitionForEvent_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
      for kiter416,viter417 in self.part_vals.items():
        oprot.writeString(kiter416)
        oprot.writeString(viter417)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 4)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markPartitionForEvent_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
   - o5
   - o6
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'o5', (UnknownPartitionException, UnknownPartitionException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'o6', (InvalidPartitionException, InvalidPartitionException.thrift_spec), None, ), # 6
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4
    self.o5 = o5
    self.o6 = o6

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = UnknownTableException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.o5 = UnknownPartitionException()
          self.o5.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.o6 = InvalidPartitionException()
          self.o6.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markPartitionForEvent_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    if self.o5 is not None:
      oprot.writeFieldBegin('o5', TType.STRUCT, 5)
      self.o5.write(oprot)
      oprot.writeFieldEnd()
    if self.o6 is not None:
      oprot.writeFieldBegin('o6', TType.STRUCT, 6)
      self.o6.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPartitionMarkedForEvent_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - eventType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.MAP, 'part_vals', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.I32, 'eventType', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.eventType = eventType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.part_vals = {}
          (_ktype419, _vtype420, _size418 ) = iprot.readMapBegin() 
          for _i422 in xrange(_size418):
            _key423 = iprot.readString();
            _val424 = iprot.readString();
            self.part_vals[_key423] = _val424
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.eventType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPartitionMarkedForEvent_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
      for kiter425,viter426 in self.part_vals.items():
        oprot.writeString(kiter425)
        oprot.writeString(viter426)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 4)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPartitionMarkedForEvent_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
   - o5
   - o6
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'o5', (UnknownPartitionException, UnknownPartitionException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'o6', (InvalidPartitionException, InvalidPartitionException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4
    self.o5 = o5
    self.o6 = o6

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = UnknownTableException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.o5 = UnknownPartitionException()
          self.o5.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.o6 = InvalidPartitionException()
          self.o6.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPartitionMarkedForEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    if self.o5 is not None:
      oprot.writeFieldBegin('o5', TType.STRUCT, 5)
      self.o5.write(oprot)
      oprot.writeFieldEnd()
    if self.o6 is not None:
      oprot.writeFieldBegin('o6', TType.STRUCT, 6)
      self.o6.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_index_args:
  """
  Attributes:
   - new_index
   - index_table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'index_table', (Table, Table.thrift_spec), None, ), # 2
  )

  def __init__(self, new_index=None, index_table=None,):
    self.new_index = new_index
    self.index_table = index_table

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_index = Index()
          self.new_index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.index_table = Table()
          self.index_table.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_index_args')
    if self.new_index is not None:
      oprot.writeFieldBegin('new_index', TType.STRUCT, 1)
      self.new_index.write(oprot)
      oprot.writeFieldEnd()
    if self.index_table is not None:
      oprot.writeFieldBegin('index_table', TType.STRUCT, 2)
      self.index_table.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_index_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Index()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_index_args:
  """
  Attributes:
   - dbname
   - base_tbl_name
   - idx_name
   - new_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'base_tbl_name', None, None, ), # 2
    (3, TType.STRING, 'idx_name', None, None, ), # 3
    (4, TType.STRUCT, 'new_idx', (Index, Index.thrift_spec), None, ), # 4
  )

  def __init__(self, dbname=None, base_tbl_name=None, idx_name=None, new_idx=None,):
    self.dbname = dbname
    self.base_tbl_name = base_tbl_name
    self.idx_name = idx_name
    self.new_idx = new_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.base_tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.idx_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.new_idx = Index()
          self.new_idx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_index_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.base_tbl_name is not None:
      oprot.writeFieldBegin('base_tbl_name', TType.STRING, 2)
      oprot.writeString(self.base_tbl_name)
      oprot.writeFieldEnd()
    if self.idx_name is not None:
      oprot.writeFieldBegin('idx_name', TType.STRING, 3)
      oprot.writeString(self.idx_name)
      oprot.writeFieldEnd()
    if self.new_idx is not None:
      oprot.writeFieldBegin('new_idx', TType.STRUCT, 4)
      self.new_idx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_index_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_index_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_index_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - index_name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'index_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, index_name=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.index_name = index_name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_index_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.index_name is not None:
      oprot.writeFieldBegin('index_name', TType.STRING, 3)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_index_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_index_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - index_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'index_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, index_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.index_name = index_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.index_name is not None:
      oprot.writeFieldBegin('index_name', TType.STRING, 3)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Index()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_indexes_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_indexes_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes is not None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_indexes_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Index, Index.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype430, _size427) = iprot.readListBegin()
          for _i431 in xrange(_size427):
            _elem432 = Index()
            _elem432.read(iprot)
            self.success.append(_elem432)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_indexes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter433 in self.success:
        iter433.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes is not None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_names_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype437, _size434) = iprot.readListBegin()
          for _i438 in xrange(_size434):
            _elem439 = iprot.readString();
            self.success.append(_elem439)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter440 in self.success:
        oprot.writeString(iter440)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_role_args:
  """
  Attributes:
   - role
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'role', (Role, Role.thrift_spec), None, ), # 1
  )

  def __init__(self, role=None,):
    self.role = role

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.role = Role()
          self.role.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_role_args')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRUCT, 1)
      self.role.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_role_args:
  """
  Attributes:
   - role_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
  )

  def __init__(self, role_name=None,):
    self.role_name = role_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_names_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_names_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_names_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype444, _size441) = iprot.readListBegin()
          for _i445 in xrange(_size441):
            _elem446 = iprot.readString();
            self.success.append(_elem446)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter447 in self.success:
        oprot.writeString(iter447)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_role_args:
  """
  Attributes:
   - role_name
   - principal_name
   - principal_type
   - grantor
   - grantorType
   - grant_option
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
    (2, TType.STRING, 'principal_name', None, None, ), # 2
    (3, TType.I32, 'principal_type', None, None, ), # 3
    (4, TType.STRING, 'grantor', None, None, ), # 4
    (5, TType.I32, 'grantorType', None, None, ), # 5
    (6, TType.BOOL, 'grant_option', None, None, ), # 6
  )

  def __init__(self, role_name=None, principal_name=None, principal_type=None, grantor=None, grantorType=None, grant_option=None,):
    self.role_name = role_name
    self.principal_name = principal_name
    self.principal_type = principal_type
    self.grantor = grantor
    self.grantorType = grantorType
    self.grant_option = grant_option

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.grantor = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.grant_option = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 2)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 3)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 4)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 5)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grant_option is not None:
      oprot.writeFieldBegin('grant_option', TType.BOOL, 6)
      oprot.writeBool(self.grant_option)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_role_args:
  """
  Attributes:
   - role_name
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
    (2, TType.STRING, 'principal_name', None, None, ), # 2
    (3, TType.I32, 'principal_type', None, None, ), # 3
  )

  def __init__(self, role_name=None, principal_name=None, principal_type=None,):
    self.role_name = role_name
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 2)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 3)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_roles_args:
  """
  Attributes:
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
  )

  def __init__(self, principal_name=None, principal_type=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_roles_args')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_roles_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Role, Role.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype451, _size448) = iprot.readListBegin()
          for _i452 in xrange(_size448):
            _elem453 = Role()
            _elem453.read(iprot)
            self.success.append(_elem453)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_roles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter454 in self.success:
        iter454.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_privilege_set_args:
  """
  Attributes:
   - hiveObject
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 1
    (2, TType.STRING, 'user_name', None, None, ), # 2
    (3, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, hiveObject=None, user_name=None, group_names=None,):
    self.hiveObject = hiveObject
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype458, _size455) = iprot.readListBegin()
          for _i459 in xrange(_size455):
            _elem460 = iprot.readString();
            self.group_names.append(_elem460)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_privilege_set_args')
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 2)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter461 in self.group_names:
        oprot.writeString(iter461)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_privilege_set_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PrincipalPrivilegeSet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_privilege_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_privileges_args:
  """
  Attributes:
   - principal_name
   - principal_type
   - hiveObject
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
    (3, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 3
  )

  def __init__(self, principal_name=None, principal_type=None, hiveObject=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type
    self.hiveObject = hiveObject

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_privileges_args')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 3)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(HiveObjectPrivilege, HiveObjectPrivilege.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype465, _size462) = iprot.readListBegin()
          for _i466 in xrange(_size462):
            _elem467 = HiveObjectPrivilege()
            _elem467.read(iprot)
            self.success.append(_elem467)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter468 in self.success:
        iter468.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_privileges_args:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_privileges_args')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_privileges_args:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_privileges_args')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_ugi_args:
  """
  Attributes:
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user_name', None, None, ), # 1
    (2, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, user_name=None, group_names=None,):
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype472, _size469) = iprot.readListBegin()
          for _i473 in xrange(_size469):
            _elem474 = iprot.readString();
            self.group_names.append(_elem474)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_ugi_args')
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 1)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter475 in self.group_names:
        oprot.writeString(iter475)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_ugi_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype479, _size476) = iprot.readListBegin()
          for _i480 in xrange(_size476):
            _elem481 = iprot.readString();
            self.success.append(_elem481)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_ugi_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter482 in self.success:
        oprot.writeString(iter482)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_delegation_token_args:
  """
  Attributes:
   - token_owner
   - renewer_kerberos_principal_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_owner', None, None, ), # 1
    (2, TType.STRING, 'renewer_kerberos_principal_name', None, None, ), # 2
  )

  def __init__(self, token_owner=None, renewer_kerberos_principal_name=None,):
    self.token_owner = token_owner
    self.renewer_kerberos_principal_name = renewer_kerberos_principal_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.renewer_kerberos_principal_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_delegation_token_args')
    if self.token_owner is not None:
      oprot.writeFieldBegin('token_owner', TType.STRING, 1)
      oprot.writeString(self.token_owner)
      oprot.writeFieldEnd()
    if self.renewer_kerberos_principal_name is not None:
      oprot.writeFieldBegin('renewer_kerberos_principal_name', TType.STRING, 2)
      oprot.writeString(self.renewer_kerberos_principal_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_delegation_token_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_delegation_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renew_delegation_token_args:
  """
  Attributes:
   - token_str_form
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_str_form', None, None, ), # 1
  )

  def __init__(self, token_str_form=None,):
    self.token_str_form = token_str_form

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_str_form = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renew_delegation_token_args')
    if self.token_str_form is not None:
      oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
      oprot.writeString(self.token_str_form)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renew_delegation_token_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renew_delegation_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancel_delegation_token_args:
  """
  Attributes:
   - token_str_form
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_str_form', None, None, ), # 1
  )

  def __init__(self, token_str_form=None,):
    self.token_str_form = token_str_form

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_str_form = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancel_delegation_token_args')
    if self.token_str_form is not None:
      oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
      oprot.writeString(self.token_str_form)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancel_delegation_token_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancel_delegation_token_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
