#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import fb303.ttypes

from thrift.transport import TTransport
all_structs = []


class HiveObjectType(object):
    GLOBAL = 1
    DATABASE = 2
    TABLE = 3
    PARTITION = 4
    COLUMN = 5

    _VALUES_TO_NAMES = {
        1: "GLOBAL",
        2: "DATABASE",
        3: "TABLE",
        4: "PARTITION",
        5: "COLUMN",
    }

    _NAMES_TO_VALUES = {
        "GLOBAL": 1,
        "DATABASE": 2,
        "TABLE": 3,
        "PARTITION": 4,
        "COLUMN": 5,
    }


class PrincipalType(object):
    USER = 1
    ROLE = 2
    GROUP = 3

    _VALUES_TO_NAMES = {
        1: "USER",
        2: "ROLE",
        3: "GROUP",
    }

    _NAMES_TO_VALUES = {
        "USER": 1,
        "ROLE": 2,
        "GROUP": 3,
    }


class PartitionEventType(object):
    LOAD_DONE = 1

    _VALUES_TO_NAMES = {
        1: "LOAD_DONE",
    }

    _NAMES_TO_VALUES = {
        "LOAD_DONE": 1,
    }


class TxnState(object):
    COMMITTED = 1
    ABORTED = 2
    OPEN = 3

    _VALUES_TO_NAMES = {
        1: "COMMITTED",
        2: "ABORTED",
        3: "OPEN",
    }

    _NAMES_TO_VALUES = {
        "COMMITTED": 1,
        "ABORTED": 2,
        "OPEN": 3,
    }


class LockLevel(object):
    DB = 1
    TABLE = 2
    PARTITION = 3

    _VALUES_TO_NAMES = {
        1: "DB",
        2: "TABLE",
        3: "PARTITION",
    }

    _NAMES_TO_VALUES = {
        "DB": 1,
        "TABLE": 2,
        "PARTITION": 3,
    }


class LockState(object):
    ACQUIRED = 1
    WAITING = 2
    ABORT = 3
    NOT_ACQUIRED = 4

    _VALUES_TO_NAMES = {
        1: "ACQUIRED",
        2: "WAITING",
        3: "ABORT",
        4: "NOT_ACQUIRED",
    }

    _NAMES_TO_VALUES = {
        "ACQUIRED": 1,
        "WAITING": 2,
        "ABORT": 3,
        "NOT_ACQUIRED": 4,
    }


class LockType(object):
    SHARED_READ = 1
    SHARED_WRITE = 2
    EXCLUSIVE = 3

    _VALUES_TO_NAMES = {
        1: "SHARED_READ",
        2: "SHARED_WRITE",
        3: "EXCLUSIVE",
    }

    _NAMES_TO_VALUES = {
        "SHARED_READ": 1,
        "SHARED_WRITE": 2,
        "EXCLUSIVE": 3,
    }


class CompactionType(object):
    MINOR = 1
    MAJOR = 2

    _VALUES_TO_NAMES = {
        1: "MINOR",
        2: "MAJOR",
    }

    _NAMES_TO_VALUES = {
        "MINOR": 1,
        "MAJOR": 2,
    }


class GrantRevokeType(object):
    GRANT = 1
    REVOKE = 2

    _VALUES_TO_NAMES = {
        1: "GRANT",
        2: "REVOKE",
    }

    _NAMES_TO_VALUES = {
        "GRANT": 1,
        "REVOKE": 2,
    }


class DataOperationType(object):
    SELECT = 1
    INSERT = 2
    UPDATE = 3
    DELETE = 4
    UNSET = 5
    NO_TXN = 6

    _VALUES_TO_NAMES = {
        1: "SELECT",
        2: "INSERT",
        3: "UPDATE",
        4: "DELETE",
        5: "UNSET",
        6: "NO_TXN",
    }

    _NAMES_TO_VALUES = {
        "SELECT": 1,
        "INSERT": 2,
        "UPDATE": 3,
        "DELETE": 4,
        "UNSET": 5,
        "NO_TXN": 6,
    }


class EventRequestType(object):
    INSERT = 1
    UPDATE = 2
    DELETE = 3

    _VALUES_TO_NAMES = {
        1: "INSERT",
        2: "UPDATE",
        3: "DELETE",
    }

    _NAMES_TO_VALUES = {
        "INSERT": 1,
        "UPDATE": 2,
        "DELETE": 3,
    }


class FunctionType(object):
    JAVA = 1

    _VALUES_TO_NAMES = {
        1: "JAVA",
    }

    _NAMES_TO_VALUES = {
        "JAVA": 1,
    }


class ResourceType(object):
    JAR = 1
    FILE = 2
    ARCHIVE = 3

    _VALUES_TO_NAMES = {
        1: "JAR",
        2: "FILE",
        3: "ARCHIVE",
    }

    _NAMES_TO_VALUES = {
        "JAR": 1,
        "FILE": 2,
        "ARCHIVE": 3,
    }


class FileMetadataExprType(object):
    ORC_SARG = 1

    _VALUES_TO_NAMES = {
        1: "ORC_SARG",
    }

    _NAMES_TO_VALUES = {
        "ORC_SARG": 1,
    }


class ClientCapability(object):
    TEST_CAPABILITY = 1

    _VALUES_TO_NAMES = {
        1: "TEST_CAPABILITY",
    }

    _NAMES_TO_VALUES = {
        "TEST_CAPABILITY": 1,
    }


class Version(object):
    """
    Attributes:
     - version
     - comments

    """


    def __init__(self, version=None, comments=None,):
        self.version = version
        self.comments = comments

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.comments = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Version')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 1)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.comments is not None:
            oprot.writeFieldBegin('comments', TType.STRING, 2)
            oprot.writeString(self.comments.encode('utf-8') if sys.version_info[0] == 2 else self.comments)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FieldSchema(object):
    """
    Attributes:
     - name
     - type
     - comment

    """


    def __init__(self, name=None, type=None, comment=None,):
        self.name = name
        self.type = type
        self.comment = comment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.comment = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FieldSchema')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 2)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 3)
            oprot.writeString(self.comment.encode('utf-8') if sys.version_info[0] == 2 else self.comment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SQLPrimaryKey(object):
    """
    Attributes:
     - table_db
     - table_name
     - column_name
     - key_seq
     - pk_name
     - enable_cstr
     - validate_cstr
     - rely_cstr

    """


    def __init__(self, table_db=None, table_name=None, column_name=None, key_seq=None, pk_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
        self.table_db = table_db
        self.table_name = table_name
        self.column_name = column_name
        self.key_seq = key_seq
        self.pk_name = pk_name
        self.enable_cstr = enable_cstr
        self.validate_cstr = validate_cstr
        self.rely_cstr = rely_cstr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table_db = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.column_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.key_seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.pk_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.enable_cstr = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.validate_cstr = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.rely_cstr = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SQLPrimaryKey')
        if self.table_db is not None:
            oprot.writeFieldBegin('table_db', TType.STRING, 1)
            oprot.writeString(self.table_db.encode('utf-8') if sys.version_info[0] == 2 else self.table_db)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.column_name is not None:
            oprot.writeFieldBegin('column_name', TType.STRING, 3)
            oprot.writeString(self.column_name.encode('utf-8') if sys.version_info[0] == 2 else self.column_name)
            oprot.writeFieldEnd()
        if self.key_seq is not None:
            oprot.writeFieldBegin('key_seq', TType.I32, 4)
            oprot.writeI32(self.key_seq)
            oprot.writeFieldEnd()
        if self.pk_name is not None:
            oprot.writeFieldBegin('pk_name', TType.STRING, 5)
            oprot.writeString(self.pk_name.encode('utf-8') if sys.version_info[0] == 2 else self.pk_name)
            oprot.writeFieldEnd()
        if self.enable_cstr is not None:
            oprot.writeFieldBegin('enable_cstr', TType.BOOL, 6)
            oprot.writeBool(self.enable_cstr)
            oprot.writeFieldEnd()
        if self.validate_cstr is not None:
            oprot.writeFieldBegin('validate_cstr', TType.BOOL, 7)
            oprot.writeBool(self.validate_cstr)
            oprot.writeFieldEnd()
        if self.rely_cstr is not None:
            oprot.writeFieldBegin('rely_cstr', TType.BOOL, 8)
            oprot.writeBool(self.rely_cstr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SQLForeignKey(object):
    """
    Attributes:
     - pktable_db
     - pktable_name
     - pkcolumn_name
     - fktable_db
     - fktable_name
     - fkcolumn_name
     - key_seq
     - update_rule
     - delete_rule
     - fk_name
     - pk_name
     - enable_cstr
     - validate_cstr
     - rely_cstr

    """


    def __init__(self, pktable_db=None, pktable_name=None, pkcolumn_name=None, fktable_db=None, fktable_name=None, fkcolumn_name=None, key_seq=None, update_rule=None, delete_rule=None, fk_name=None, pk_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
        self.pktable_db = pktable_db
        self.pktable_name = pktable_name
        self.pkcolumn_name = pkcolumn_name
        self.fktable_db = fktable_db
        self.fktable_name = fktable_name
        self.fkcolumn_name = fkcolumn_name
        self.key_seq = key_seq
        self.update_rule = update_rule
        self.delete_rule = delete_rule
        self.fk_name = fk_name
        self.pk_name = pk_name
        self.enable_cstr = enable_cstr
        self.validate_cstr = validate_cstr
        self.rely_cstr = rely_cstr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pktable_db = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pktable_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pkcolumn_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.fktable_db = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.fktable_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.fkcolumn_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.key_seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.update_rule = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.delete_rule = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.fk_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.pk_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.enable_cstr = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.validate_cstr = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.rely_cstr = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SQLForeignKey')
        if self.pktable_db is not None:
            oprot.writeFieldBegin('pktable_db', TType.STRING, 1)
            oprot.writeString(self.pktable_db.encode('utf-8') if sys.version_info[0] == 2 else self.pktable_db)
            oprot.writeFieldEnd()
        if self.pktable_name is not None:
            oprot.writeFieldBegin('pktable_name', TType.STRING, 2)
            oprot.writeString(self.pktable_name.encode('utf-8') if sys.version_info[0] == 2 else self.pktable_name)
            oprot.writeFieldEnd()
        if self.pkcolumn_name is not None:
            oprot.writeFieldBegin('pkcolumn_name', TType.STRING, 3)
            oprot.writeString(self.pkcolumn_name.encode('utf-8') if sys.version_info[0] == 2 else self.pkcolumn_name)
            oprot.writeFieldEnd()
        if self.fktable_db is not None:
            oprot.writeFieldBegin('fktable_db', TType.STRING, 4)
            oprot.writeString(self.fktable_db.encode('utf-8') if sys.version_info[0] == 2 else self.fktable_db)
            oprot.writeFieldEnd()
        if self.fktable_name is not None:
            oprot.writeFieldBegin('fktable_name', TType.STRING, 5)
            oprot.writeString(self.fktable_name.encode('utf-8') if sys.version_info[0] == 2 else self.fktable_name)
            oprot.writeFieldEnd()
        if self.fkcolumn_name is not None:
            oprot.writeFieldBegin('fkcolumn_name', TType.STRING, 6)
            oprot.writeString(self.fkcolumn_name.encode('utf-8') if sys.version_info[0] == 2 else self.fkcolumn_name)
            oprot.writeFieldEnd()
        if self.key_seq is not None:
            oprot.writeFieldBegin('key_seq', TType.I32, 7)
            oprot.writeI32(self.key_seq)
            oprot.writeFieldEnd()
        if self.update_rule is not None:
            oprot.writeFieldBegin('update_rule', TType.I32, 8)
            oprot.writeI32(self.update_rule)
            oprot.writeFieldEnd()
        if self.delete_rule is not None:
            oprot.writeFieldBegin('delete_rule', TType.I32, 9)
            oprot.writeI32(self.delete_rule)
            oprot.writeFieldEnd()
        if self.fk_name is not None:
            oprot.writeFieldBegin('fk_name', TType.STRING, 10)
            oprot.writeString(self.fk_name.encode('utf-8') if sys.version_info[0] == 2 else self.fk_name)
            oprot.writeFieldEnd()
        if self.pk_name is not None:
            oprot.writeFieldBegin('pk_name', TType.STRING, 11)
            oprot.writeString(self.pk_name.encode('utf-8') if sys.version_info[0] == 2 else self.pk_name)
            oprot.writeFieldEnd()
        if self.enable_cstr is not None:
            oprot.writeFieldBegin('enable_cstr', TType.BOOL, 12)
            oprot.writeBool(self.enable_cstr)
            oprot.writeFieldEnd()
        if self.validate_cstr is not None:
            oprot.writeFieldBegin('validate_cstr', TType.BOOL, 13)
            oprot.writeBool(self.validate_cstr)
            oprot.writeFieldEnd()
        if self.rely_cstr is not None:
            oprot.writeFieldBegin('rely_cstr', TType.BOOL, 14)
            oprot.writeBool(self.rely_cstr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Type(object):
    """
    Attributes:
     - name
     - type1
     - type2
     - fields

    """


    def __init__(self, name=None, type1=None, type2=None, fields=None,):
        self.name = name
        self.type1 = type1
        self.type2 = type2
        self.fields = fields

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type1 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.type2 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.fields = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = FieldSchema()
                        _elem5.read(iprot)
                        self.fields.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Type')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.type1 is not None:
            oprot.writeFieldBegin('type1', TType.STRING, 2)
            oprot.writeString(self.type1.encode('utf-8') if sys.version_info[0] == 2 else self.type1)
            oprot.writeFieldEnd()
        if self.type2 is not None:
            oprot.writeFieldBegin('type2', TType.STRING, 3)
            oprot.writeString(self.type2.encode('utf-8') if sys.version_info[0] == 2 else self.type2)
            oprot.writeFieldEnd()
        if self.fields is not None:
            oprot.writeFieldBegin('fields', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.fields))
            for iter6 in self.fields:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HiveObjectRef(object):
    """
    Attributes:
     - objectType
     - dbName
     - objectName
     - partValues
     - columnName

    """


    def __init__(self, objectType=None, dbName=None, objectName=None, partValues=None, columnName=None,):
        self.objectType = objectType
        self.dbName = dbName
        self.objectName = objectName
        self.partValues = partValues
        self.columnName = columnName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.objectType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.objectName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partValues = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.partValues.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.columnName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HiveObjectRef')
        if self.objectType is not None:
            oprot.writeFieldBegin('objectType', TType.I32, 1)
            oprot.writeI32(self.objectType)
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 2)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.objectName is not None:
            oprot.writeFieldBegin('objectName', TType.STRING, 3)
            oprot.writeString(self.objectName.encode('utf-8') if sys.version_info[0] == 2 else self.objectName)
            oprot.writeFieldEnd()
        if self.partValues is not None:
            oprot.writeFieldBegin('partValues', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.partValues))
            for iter13 in self.partValues:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnName is not None:
            oprot.writeFieldBegin('columnName', TType.STRING, 5)
            oprot.writeString(self.columnName.encode('utf-8') if sys.version_info[0] == 2 else self.columnName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrivilegeGrantInfo(object):
    """
    Attributes:
     - privilege
     - createTime
     - grantor
     - grantorType
     - grantOption

    """


    def __init__(self, privilege=None, createTime=None, grantor=None, grantorType=None, grantOption=None,):
        self.privilege = privilege
        self.createTime = createTime
        self.grantor = grantor
        self.grantorType = grantorType
        self.grantOption = grantOption

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.privilege = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.createTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.grantor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.grantorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.grantOption = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PrivilegeGrantInfo')
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.STRING, 1)
            oprot.writeString(self.privilege.encode('utf-8') if sys.version_info[0] == 2 else self.privilege)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I32, 2)
            oprot.writeI32(self.createTime)
            oprot.writeFieldEnd()
        if self.grantor is not None:
            oprot.writeFieldBegin('grantor', TType.STRING, 3)
            oprot.writeString(self.grantor.encode('utf-8') if sys.version_info[0] == 2 else self.grantor)
            oprot.writeFieldEnd()
        if self.grantorType is not None:
            oprot.writeFieldBegin('grantorType', TType.I32, 4)
            oprot.writeI32(self.grantorType)
            oprot.writeFieldEnd()
        if self.grantOption is not None:
            oprot.writeFieldBegin('grantOption', TType.BOOL, 5)
            oprot.writeBool(self.grantOption)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HiveObjectPrivilege(object):
    """
    Attributes:
     - hiveObject
     - principalName
     - principalType
     - grantInfo

    """


    def __init__(self, hiveObject=None, principalName=None, principalType=None, grantInfo=None,):
        self.hiveObject = hiveObject
        self.principalName = principalName
        self.principalType = principalType
        self.grantInfo = grantInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hiveObject = HiveObjectRef()
                    self.hiveObject.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.principalName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principalType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.grantInfo = PrivilegeGrantInfo()
                    self.grantInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HiveObjectPrivilege')
        if self.hiveObject is not None:
            oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
            self.hiveObject.write(oprot)
            oprot.writeFieldEnd()
        if self.principalName is not None:
            oprot.writeFieldBegin('principalName', TType.STRING, 2)
            oprot.writeString(self.principalName.encode('utf-8') if sys.version_info[0] == 2 else self.principalName)
            oprot.writeFieldEnd()
        if self.principalType is not None:
            oprot.writeFieldBegin('principalType', TType.I32, 3)
            oprot.writeI32(self.principalType)
            oprot.writeFieldEnd()
        if self.grantInfo is not None:
            oprot.writeFieldBegin('grantInfo', TType.STRUCT, 4)
            self.grantInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrivilegeBag(object):
    """
    Attributes:
     - privileges

    """


    def __init__(self, privileges=None,):
        self.privileges = privileges

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.privileges = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = HiveObjectPrivilege()
                        _elem19.read(iprot)
                        self.privileges.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PrivilegeBag')
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.privileges))
            for iter20 in self.privileges:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrincipalPrivilegeSet(object):
    """
    Attributes:
     - userPrivileges
     - groupPrivileges
     - rolePrivileges

    """


    def __init__(self, userPrivileges=None, groupPrivileges=None, rolePrivileges=None,):
        self.userPrivileges = userPrivileges
        self.groupPrivileges = groupPrivileges
        self.rolePrivileges = rolePrivileges

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.userPrivileges = {}
                    (_ktype22, _vtype23, _size21) = iprot.readMapBegin()
                    for _i25 in range(_size21):
                        _key26 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val27 = []
                        (_etype31, _size28) = iprot.readListBegin()
                        for _i32 in range(_size28):
                            _elem33 = PrivilegeGrantInfo()
                            _elem33.read(iprot)
                            _val27.append(_elem33)
                        iprot.readListEnd()
                        self.userPrivileges[_key26] = _val27
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.groupPrivileges = {}
                    (_ktype35, _vtype36, _size34) = iprot.readMapBegin()
                    for _i38 in range(_size34):
                        _key39 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val40 = []
                        (_etype44, _size41) = iprot.readListBegin()
                        for _i45 in range(_size41):
                            _elem46 = PrivilegeGrantInfo()
                            _elem46.read(iprot)
                            _val40.append(_elem46)
                        iprot.readListEnd()
                        self.groupPrivileges[_key39] = _val40
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.rolePrivileges = {}
                    (_ktype48, _vtype49, _size47) = iprot.readMapBegin()
                    for _i51 in range(_size47):
                        _key52 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val53 = []
                        (_etype57, _size54) = iprot.readListBegin()
                        for _i58 in range(_size54):
                            _elem59 = PrivilegeGrantInfo()
                            _elem59.read(iprot)
                            _val53.append(_elem59)
                        iprot.readListEnd()
                        self.rolePrivileges[_key52] = _val53
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PrincipalPrivilegeSet')
        if self.userPrivileges is not None:
            oprot.writeFieldBegin('userPrivileges', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.userPrivileges))
            for kiter60, viter61 in self.userPrivileges.items():
                oprot.writeString(kiter60.encode('utf-8') if sys.version_info[0] == 2 else kiter60)
                oprot.writeListBegin(TType.STRUCT, len(viter61))
                for iter62 in viter61:
                    iter62.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.groupPrivileges is not None:
            oprot.writeFieldBegin('groupPrivileges', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.groupPrivileges))
            for kiter63, viter64 in self.groupPrivileges.items():
                oprot.writeString(kiter63.encode('utf-8') if sys.version_info[0] == 2 else kiter63)
                oprot.writeListBegin(TType.STRUCT, len(viter64))
                for iter65 in viter64:
                    iter65.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.rolePrivileges is not None:
            oprot.writeFieldBegin('rolePrivileges', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.rolePrivileges))
            for kiter66, viter67 in self.rolePrivileges.items():
                oprot.writeString(kiter66.encode('utf-8') if sys.version_info[0] == 2 else kiter66)
                oprot.writeListBegin(TType.STRUCT, len(viter67))
                for iter68 in viter67:
                    iter68.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GrantRevokePrivilegeRequest(object):
    """
    Attributes:
     - requestType
     - privileges
     - revokeGrantOption

    """


    def __init__(self, requestType=None, privileges=None, revokeGrantOption=None,):
        self.requestType = requestType
        self.privileges = privileges
        self.revokeGrantOption = revokeGrantOption

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.requestType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.privileges = PrivilegeBag()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.revokeGrantOption = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GrantRevokePrivilegeRequest')
        if self.requestType is not None:
            oprot.writeFieldBegin('requestType', TType.I32, 1)
            oprot.writeI32(self.requestType)
            oprot.writeFieldEnd()
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.STRUCT, 2)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        if self.revokeGrantOption is not None:
            oprot.writeFieldBegin('revokeGrantOption', TType.BOOL, 3)
            oprot.writeBool(self.revokeGrantOption)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GrantRevokePrivilegeResponse(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GrantRevokePrivilegeResponse')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 1)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Role(object):
    """
    Attributes:
     - roleName
     - createTime
     - ownerName

    """


    def __init__(self, roleName=None, createTime=None, ownerName=None,):
        self.roleName = roleName
        self.createTime = createTime
        self.ownerName = ownerName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.createTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ownerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Role')
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 1)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I32, 2)
            oprot.writeI32(self.createTime)
            oprot.writeFieldEnd()
        if self.ownerName is not None:
            oprot.writeFieldBegin('ownerName', TType.STRING, 3)
            oprot.writeString(self.ownerName.encode('utf-8') if sys.version_info[0] == 2 else self.ownerName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RolePrincipalGrant(object):
    """
    Attributes:
     - roleName
     - principalName
     - principalType
     - grantOption
     - grantTime
     - grantorName
     - grantorPrincipalType

    """


    def __init__(self, roleName=None, principalName=None, principalType=None, grantOption=None, grantTime=None, grantorName=None, grantorPrincipalType=None,):
        self.roleName = roleName
        self.principalName = principalName
        self.principalType = principalType
        self.grantOption = grantOption
        self.grantTime = grantTime
        self.grantorName = grantorName
        self.grantorPrincipalType = grantorPrincipalType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.principalName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principalType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.grantOption = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.grantTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.grantorName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.grantorPrincipalType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RolePrincipalGrant')
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 1)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        if self.principalName is not None:
            oprot.writeFieldBegin('principalName', TType.STRING, 2)
            oprot.writeString(self.principalName.encode('utf-8') if sys.version_info[0] == 2 else self.principalName)
            oprot.writeFieldEnd()
        if self.principalType is not None:
            oprot.writeFieldBegin('principalType', TType.I32, 3)
            oprot.writeI32(self.principalType)
            oprot.writeFieldEnd()
        if self.grantOption is not None:
            oprot.writeFieldBegin('grantOption', TType.BOOL, 4)
            oprot.writeBool(self.grantOption)
            oprot.writeFieldEnd()
        if self.grantTime is not None:
            oprot.writeFieldBegin('grantTime', TType.I32, 5)
            oprot.writeI32(self.grantTime)
            oprot.writeFieldEnd()
        if self.grantorName is not None:
            oprot.writeFieldBegin('grantorName', TType.STRING, 6)
            oprot.writeString(self.grantorName.encode('utf-8') if sys.version_info[0] == 2 else self.grantorName)
            oprot.writeFieldEnd()
        if self.grantorPrincipalType is not None:
            oprot.writeFieldBegin('grantorPrincipalType', TType.I32, 7)
            oprot.writeI32(self.grantorPrincipalType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRoleGrantsForPrincipalRequest(object):
    """
    Attributes:
     - principal_name
     - principal_type

    """


    def __init__(self, principal_name=None, principal_type=None,):
        self.principal_name = principal_name
        self.principal_type = principal_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRoleGrantsForPrincipalRequest')
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 1)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 2)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.principal_name is None:
            raise TProtocolException(message='Required field principal_name is unset!')
        if self.principal_type is None:
            raise TProtocolException(message='Required field principal_type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRoleGrantsForPrincipalResponse(object):
    """
    Attributes:
     - principalGrants

    """


    def __init__(self, principalGrants=None,):
        self.principalGrants = principalGrants

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.principalGrants = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = RolePrincipalGrant()
                        _elem74.read(iprot)
                        self.principalGrants.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRoleGrantsForPrincipalResponse')
        if self.principalGrants is not None:
            oprot.writeFieldBegin('principalGrants', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.principalGrants))
            for iter75 in self.principalGrants:
                iter75.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.principalGrants is None:
            raise TProtocolException(message='Required field principalGrants is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetPrincipalsInRoleRequest(object):
    """
    Attributes:
     - roleName

    """


    def __init__(self, roleName=None,):
        self.roleName = roleName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPrincipalsInRoleRequest')
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 1)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.roleName is None:
            raise TProtocolException(message='Required field roleName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetPrincipalsInRoleResponse(object):
    """
    Attributes:
     - principalGrants

    """


    def __init__(self, principalGrants=None,):
        self.principalGrants = principalGrants

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.principalGrants = []
                    (_etype79, _size76) = iprot.readListBegin()
                    for _i80 in range(_size76):
                        _elem81 = RolePrincipalGrant()
                        _elem81.read(iprot)
                        self.principalGrants.append(_elem81)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPrincipalsInRoleResponse')
        if self.principalGrants is not None:
            oprot.writeFieldBegin('principalGrants', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.principalGrants))
            for iter82 in self.principalGrants:
                iter82.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.principalGrants is None:
            raise TProtocolException(message='Required field principalGrants is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GrantRevokeRoleRequest(object):
    """
    Attributes:
     - requestType
     - roleName
     - principalName
     - principalType
     - grantor
     - grantorType
     - grantOption

    """


    def __init__(self, requestType=None, roleName=None, principalName=None, principalType=None, grantor=None, grantorType=None, grantOption=None,):
        self.requestType = requestType
        self.roleName = roleName
        self.principalName = principalName
        self.principalType = principalType
        self.grantor = grantor
        self.grantorType = grantorType
        self.grantOption = grantOption

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.requestType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.principalName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.principalType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.grantor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.grantorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.grantOption = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GrantRevokeRoleRequest')
        if self.requestType is not None:
            oprot.writeFieldBegin('requestType', TType.I32, 1)
            oprot.writeI32(self.requestType)
            oprot.writeFieldEnd()
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 2)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        if self.principalName is not None:
            oprot.writeFieldBegin('principalName', TType.STRING, 3)
            oprot.writeString(self.principalName.encode('utf-8') if sys.version_info[0] == 2 else self.principalName)
            oprot.writeFieldEnd()
        if self.principalType is not None:
            oprot.writeFieldBegin('principalType', TType.I32, 4)
            oprot.writeI32(self.principalType)
            oprot.writeFieldEnd()
        if self.grantor is not None:
            oprot.writeFieldBegin('grantor', TType.STRING, 5)
            oprot.writeString(self.grantor.encode('utf-8') if sys.version_info[0] == 2 else self.grantor)
            oprot.writeFieldEnd()
        if self.grantorType is not None:
            oprot.writeFieldBegin('grantorType', TType.I32, 6)
            oprot.writeI32(self.grantorType)
            oprot.writeFieldEnd()
        if self.grantOption is not None:
            oprot.writeFieldBegin('grantOption', TType.BOOL, 7)
            oprot.writeBool(self.grantOption)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GrantRevokeRoleResponse(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GrantRevokeRoleResponse')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 1)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Database(object):
    """
    Attributes:
     - name
     - description
     - locationUri
     - parameters
     - privileges
     - ownerName
     - ownerType

    """


    def __init__(self, name=None, description=None, locationUri=None, parameters=None, privileges=None, ownerName=None, ownerType=None,):
        self.name = name
        self.description = description
        self.locationUri = locationUri
        self.parameters = parameters
        self.privileges = privileges
        self.ownerName = ownerName
        self.ownerType = ownerType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.locationUri = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.parameters = {}
                    (_ktype84, _vtype85, _size83) = iprot.readMapBegin()
                    for _i87 in range(_size83):
                        _key88 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val89 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameters[_key88] = _val89
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.privileges = PrincipalPrivilegeSet()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.ownerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.ownerType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Database')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 2)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.locationUri is not None:
            oprot.writeFieldBegin('locationUri', TType.STRING, 3)
            oprot.writeString(self.locationUri.encode('utf-8') if sys.version_info[0] == 2 else self.locationUri)
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
            for kiter90, viter91 in self.parameters.items():
                oprot.writeString(kiter90.encode('utf-8') if sys.version_info[0] == 2 else kiter90)
                oprot.writeString(viter91.encode('utf-8') if sys.version_info[0] == 2 else viter91)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.STRUCT, 5)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        if self.ownerName is not None:
            oprot.writeFieldBegin('ownerName', TType.STRING, 6)
            oprot.writeString(self.ownerName.encode('utf-8') if sys.version_info[0] == 2 else self.ownerName)
            oprot.writeFieldEnd()
        if self.ownerType is not None:
            oprot.writeFieldBegin('ownerType', TType.I32, 7)
            oprot.writeI32(self.ownerType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SerDeInfo(object):
    """
    Attributes:
     - name
     - serializationLib
     - parameters

    """


    def __init__(self, name=None, serializationLib=None, parameters=None,):
        self.name = name
        self.serializationLib = serializationLib
        self.parameters = parameters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.serializationLib = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.parameters = {}
                    (_ktype93, _vtype94, _size92) = iprot.readMapBegin()
                    for _i96 in range(_size92):
                        _key97 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val98 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameters[_key97] = _val98
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SerDeInfo')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.serializationLib is not None:
            oprot.writeFieldBegin('serializationLib', TType.STRING, 2)
            oprot.writeString(self.serializationLib.encode('utf-8') if sys.version_info[0] == 2 else self.serializationLib)
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
            for kiter99, viter100 in self.parameters.items():
                oprot.writeString(kiter99.encode('utf-8') if sys.version_info[0] == 2 else kiter99)
                oprot.writeString(viter100.encode('utf-8') if sys.version_info[0] == 2 else viter100)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Order(object):
    """
    Attributes:
     - col
     - order

    """


    def __init__(self, col=None, order=None,):
        self.col = col
        self.order = order

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.col = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Order')
        if self.col is not None:
            oprot.writeFieldBegin('col', TType.STRING, 1)
            oprot.writeString(self.col.encode('utf-8') if sys.version_info[0] == 2 else self.col)
            oprot.writeFieldEnd()
        if self.order is not None:
            oprot.writeFieldBegin('order', TType.I32, 2)
            oprot.writeI32(self.order)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SkewedInfo(object):
    """
    Attributes:
     - skewedColNames
     - skewedColValues
     - skewedColValueLocationMaps

    """


    def __init__(self, skewedColNames=None, skewedColValues=None, skewedColValueLocationMaps=None,):
        self.skewedColNames = skewedColNames
        self.skewedColValues = skewedColValues
        self.skewedColValueLocationMaps = skewedColValueLocationMaps

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.skewedColNames = []
                    (_etype104, _size101) = iprot.readListBegin()
                    for _i105 in range(_size101):
                        _elem106 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.skewedColNames.append(_elem106)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.skewedColValues = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = []
                        (_etype116, _size113) = iprot.readListBegin()
                        for _i117 in range(_size113):
                            _elem118 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem112.append(_elem118)
                        iprot.readListEnd()
                        self.skewedColValues.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.skewedColValueLocationMaps = {}
                    (_ktype120, _vtype121, _size119) = iprot.readMapBegin()
                    for _i123 in range(_size119):
                        _key124 = []
                        (_etype129, _size126) = iprot.readListBegin()
                        for _i130 in range(_size126):
                            _elem131 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _key124.append(_elem131)
                        iprot.readListEnd()
                        _val125 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.skewedColValueLocationMaps[_key124] = _val125
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SkewedInfo')
        if self.skewedColNames is not None:
            oprot.writeFieldBegin('skewedColNames', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.skewedColNames))
            for iter132 in self.skewedColNames:
                oprot.writeString(iter132.encode('utf-8') if sys.version_info[0] == 2 else iter132)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.skewedColValues is not None:
            oprot.writeFieldBegin('skewedColValues', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.skewedColValues))
            for iter133 in self.skewedColValues:
                oprot.writeListBegin(TType.STRING, len(iter133))
                for iter134 in iter133:
                    oprot.writeString(iter134.encode('utf-8') if sys.version_info[0] == 2 else iter134)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.skewedColValueLocationMaps is not None:
            oprot.writeFieldBegin('skewedColValueLocationMaps', TType.MAP, 3)
            oprot.writeMapBegin(TType.LIST, TType.STRING, len(self.skewedColValueLocationMaps))
            for kiter135, viter136 in self.skewedColValueLocationMaps.items():
                oprot.writeListBegin(TType.STRING, len(kiter135))
                for iter137 in kiter135:
                    oprot.writeString(iter137.encode('utf-8') if sys.version_info[0] == 2 else iter137)
                oprot.writeListEnd()
                oprot.writeString(viter136.encode('utf-8') if sys.version_info[0] == 2 else viter136)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StorageDescriptor(object):
    """
    Attributes:
     - cols
     - location
     - inputFormat
     - outputFormat
     - compressed
     - numBuckets
     - serdeInfo
     - bucketCols
     - sortCols
     - parameters
     - skewedInfo
     - storedAsSubDirectories

    """


    def __init__(self, cols=None, location=None, inputFormat=None, outputFormat=None, compressed=None, numBuckets=None, serdeInfo=None, bucketCols=None, sortCols=None, parameters=None, skewedInfo=None, storedAsSubDirectories=None,):
        self.cols = cols
        self.location = location
        self.inputFormat = inputFormat
        self.outputFormat = outputFormat
        self.compressed = compressed
        self.numBuckets = numBuckets
        self.serdeInfo = serdeInfo
        self.bucketCols = bucketCols
        self.sortCols = sortCols
        self.parameters = parameters
        self.skewedInfo = skewedInfo
        self.storedAsSubDirectories = storedAsSubDirectories

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.cols = []
                    (_etype141, _size138) = iprot.readListBegin()
                    for _i142 in range(_size138):
                        _elem143 = FieldSchema()
                        _elem143.read(iprot)
                        self.cols.append(_elem143)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.location = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.inputFormat = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.outputFormat = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.compressed = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.numBuckets = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.serdeInfo = SerDeInfo()
                    self.serdeInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.bucketCols = []
                    (_etype147, _size144) = iprot.readListBegin()
                    for _i148 in range(_size144):
                        _elem149 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.bucketCols.append(_elem149)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.sortCols = []
                    (_etype153, _size150) = iprot.readListBegin()
                    for _i154 in range(_size150):
                        _elem155 = Order()
                        _elem155.read(iprot)
                        self.sortCols.append(_elem155)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.MAP:
                    self.parameters = {}
                    (_ktype157, _vtype158, _size156) = iprot.readMapBegin()
                    for _i160 in range(_size156):
                        _key161 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val162 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameters[_key161] = _val162
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.skewedInfo = SkewedInfo()
                    self.skewedInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.storedAsSubDirectories = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StorageDescriptor')
        if self.cols is not None:
            oprot.writeFieldBegin('cols', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.cols))
            for iter163 in self.cols:
                iter163.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 2)
            oprot.writeString(self.location.encode('utf-8') if sys.version_info[0] == 2 else self.location)
            oprot.writeFieldEnd()
        if self.inputFormat is not None:
            oprot.writeFieldBegin('inputFormat', TType.STRING, 3)
            oprot.writeString(self.inputFormat.encode('utf-8') if sys.version_info[0] == 2 else self.inputFormat)
            oprot.writeFieldEnd()
        if self.outputFormat is not None:
            oprot.writeFieldBegin('outputFormat', TType.STRING, 4)
            oprot.writeString(self.outputFormat.encode('utf-8') if sys.version_info[0] == 2 else self.outputFormat)
            oprot.writeFieldEnd()
        if self.compressed is not None:
            oprot.writeFieldBegin('compressed', TType.BOOL, 5)
            oprot.writeBool(self.compressed)
            oprot.writeFieldEnd()
        if self.numBuckets is not None:
            oprot.writeFieldBegin('numBuckets', TType.I32, 6)
            oprot.writeI32(self.numBuckets)
            oprot.writeFieldEnd()
        if self.serdeInfo is not None:
            oprot.writeFieldBegin('serdeInfo', TType.STRUCT, 7)
            self.serdeInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.bucketCols is not None:
            oprot.writeFieldBegin('bucketCols', TType.LIST, 8)
            oprot.writeListBegin(TType.STRING, len(self.bucketCols))
            for iter164 in self.bucketCols:
                oprot.writeString(iter164.encode('utf-8') if sys.version_info[0] == 2 else iter164)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sortCols is not None:
            oprot.writeFieldBegin('sortCols', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.sortCols))
            for iter165 in self.sortCols:
                iter165.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.MAP, 10)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
            for kiter166, viter167 in self.parameters.items():
                oprot.writeString(kiter166.encode('utf-8') if sys.version_info[0] == 2 else kiter166)
                oprot.writeString(viter167.encode('utf-8') if sys.version_info[0] == 2 else viter167)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.skewedInfo is not None:
            oprot.writeFieldBegin('skewedInfo', TType.STRUCT, 11)
            self.skewedInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.storedAsSubDirectories is not None:
            oprot.writeFieldBegin('storedAsSubDirectories', TType.BOOL, 12)
            oprot.writeBool(self.storedAsSubDirectories)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Table(object):
    """
    Attributes:
     - tableName
     - dbName
     - owner
     - createTime
     - lastAccessTime
     - retention
     - sd
     - partitionKeys
     - parameters
     - viewOriginalText
     - viewExpandedText
     - tableType
     - privileges
     - temporary
     - rewriteEnabled

    """


    def __init__(self, tableName=None, dbName=None, owner=None, createTime=None, lastAccessTime=None, retention=None, sd=None, partitionKeys=None, parameters=None, viewOriginalText=None, viewExpandedText=None, tableType=None, privileges=None, temporary=False, rewriteEnabled=None,):
        self.tableName = tableName
        self.dbName = dbName
        self.owner = owner
        self.createTime = createTime
        self.lastAccessTime = lastAccessTime
        self.retention = retention
        self.sd = sd
        self.partitionKeys = partitionKeys
        self.parameters = parameters
        self.viewOriginalText = viewOriginalText
        self.viewExpandedText = viewExpandedText
        self.tableType = tableType
        self.privileges = privileges
        self.temporary = temporary
        self.rewriteEnabled = rewriteEnabled

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.owner = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.createTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.lastAccessTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.retention = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.sd = StorageDescriptor()
                    self.sd.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.partitionKeys = []
                    (_etype171, _size168) = iprot.readListBegin()
                    for _i172 in range(_size168):
                        _elem173 = FieldSchema()
                        _elem173.read(iprot)
                        self.partitionKeys.append(_elem173)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.parameters = {}
                    (_ktype175, _vtype176, _size174) = iprot.readMapBegin()
                    for _i178 in range(_size174):
                        _key179 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val180 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameters[_key179] = _val180
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.viewOriginalText = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.viewExpandedText = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.tableType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.privileges = PrincipalPrivilegeSet()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.temporary = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.rewriteEnabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Table')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 2)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRING, 3)
            oprot.writeString(self.owner.encode('utf-8') if sys.version_info[0] == 2 else self.owner)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I32, 4)
            oprot.writeI32(self.createTime)
            oprot.writeFieldEnd()
        if self.lastAccessTime is not None:
            oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
            oprot.writeI32(self.lastAccessTime)
            oprot.writeFieldEnd()
        if self.retention is not None:
            oprot.writeFieldBegin('retention', TType.I32, 6)
            oprot.writeI32(self.retention)
            oprot.writeFieldEnd()
        if self.sd is not None:
            oprot.writeFieldBegin('sd', TType.STRUCT, 7)
            self.sd.write(oprot)
            oprot.writeFieldEnd()
        if self.partitionKeys is not None:
            oprot.writeFieldBegin('partitionKeys', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.partitionKeys))
            for iter181 in self.partitionKeys:
                iter181.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
            for kiter182, viter183 in self.parameters.items():
                oprot.writeString(kiter182.encode('utf-8') if sys.version_info[0] == 2 else kiter182)
                oprot.writeString(viter183.encode('utf-8') if sys.version_info[0] == 2 else viter183)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.viewOriginalText is not None:
            oprot.writeFieldBegin('viewOriginalText', TType.STRING, 10)
            oprot.writeString(self.viewOriginalText.encode('utf-8') if sys.version_info[0] == 2 else self.viewOriginalText)
            oprot.writeFieldEnd()
        if self.viewExpandedText is not None:
            oprot.writeFieldBegin('viewExpandedText', TType.STRING, 11)
            oprot.writeString(self.viewExpandedText.encode('utf-8') if sys.version_info[0] == 2 else self.viewExpandedText)
            oprot.writeFieldEnd()
        if self.tableType is not None:
            oprot.writeFieldBegin('tableType', TType.STRING, 12)
            oprot.writeString(self.tableType.encode('utf-8') if sys.version_info[0] == 2 else self.tableType)
            oprot.writeFieldEnd()
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.STRUCT, 13)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        if self.temporary is not None:
            oprot.writeFieldBegin('temporary', TType.BOOL, 14)
            oprot.writeBool(self.temporary)
            oprot.writeFieldEnd()
        if self.rewriteEnabled is not None:
            oprot.writeFieldBegin('rewriteEnabled', TType.BOOL, 15)
            oprot.writeBool(self.rewriteEnabled)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Partition(object):
    """
    Attributes:
     - values
     - dbName
     - tableName
     - createTime
     - lastAccessTime
     - sd
     - parameters
     - privileges

    """


    def __init__(self, values=None, dbName=None, tableName=None, createTime=None, lastAccessTime=None, sd=None, parameters=None, privileges=None,):
        self.values = values
        self.dbName = dbName
        self.tableName = tableName
        self.createTime = createTime
        self.lastAccessTime = lastAccessTime
        self.sd = sd
        self.parameters = parameters
        self.privileges = privileges

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype187, _size184) = iprot.readListBegin()
                    for _i188 in range(_size184):
                        _elem189 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.values.append(_elem189)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.createTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.lastAccessTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.sd = StorageDescriptor()
                    self.sd.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.parameters = {}
                    (_ktype191, _vtype192, _size190) = iprot.readMapBegin()
                    for _i194 in range(_size190):
                        _key195 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val196 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameters[_key195] = _val196
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.privileges = PrincipalPrivilegeSet()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Partition')
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.values))
            for iter197 in self.values:
                oprot.writeString(iter197.encode('utf-8') if sys.version_info[0] == 2 else iter197)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 2)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 3)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I32, 4)
            oprot.writeI32(self.createTime)
            oprot.writeFieldEnd()
        if self.lastAccessTime is not None:
            oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
            oprot.writeI32(self.lastAccessTime)
            oprot.writeFieldEnd()
        if self.sd is not None:
            oprot.writeFieldBegin('sd', TType.STRUCT, 6)
            self.sd.write(oprot)
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
            for kiter198, viter199 in self.parameters.items():
                oprot.writeString(kiter198.encode('utf-8') if sys.version_info[0] == 2 else kiter198)
                oprot.writeString(viter199.encode('utf-8') if sys.version_info[0] == 2 else viter199)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.STRUCT, 8)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionWithoutSD(object):
    """
    Attributes:
     - values
     - createTime
     - lastAccessTime
     - relativePath
     - parameters
     - privileges

    """


    def __init__(self, values=None, createTime=None, lastAccessTime=None, relativePath=None, parameters=None, privileges=None,):
        self.values = values
        self.createTime = createTime
        self.lastAccessTime = lastAccessTime
        self.relativePath = relativePath
        self.parameters = parameters
        self.privileges = privileges

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype203, _size200) = iprot.readListBegin()
                    for _i204 in range(_size200):
                        _elem205 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.values.append(_elem205)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.createTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.lastAccessTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.relativePath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.parameters = {}
                    (_ktype207, _vtype208, _size206) = iprot.readMapBegin()
                    for _i210 in range(_size206):
                        _key211 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val212 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameters[_key211] = _val212
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.privileges = PrincipalPrivilegeSet()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionWithoutSD')
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.values))
            for iter213 in self.values:
                oprot.writeString(iter213.encode('utf-8') if sys.version_info[0] == 2 else iter213)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I32, 2)
            oprot.writeI32(self.createTime)
            oprot.writeFieldEnd()
        if self.lastAccessTime is not None:
            oprot.writeFieldBegin('lastAccessTime', TType.I32, 3)
            oprot.writeI32(self.lastAccessTime)
            oprot.writeFieldEnd()
        if self.relativePath is not None:
            oprot.writeFieldBegin('relativePath', TType.STRING, 4)
            oprot.writeString(self.relativePath.encode('utf-8') if sys.version_info[0] == 2 else self.relativePath)
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
            for kiter214, viter215 in self.parameters.items():
                oprot.writeString(kiter214.encode('utf-8') if sys.version_info[0] == 2 else kiter214)
                oprot.writeString(viter215.encode('utf-8') if sys.version_info[0] == 2 else viter215)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.STRUCT, 6)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionSpecWithSharedSD(object):
    """
    Attributes:
     - partitions
     - sd

    """


    def __init__(self, partitions=None, sd=None,):
        self.partitions = partitions
        self.sd = sd

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype219, _size216) = iprot.readListBegin()
                    for _i220 in range(_size216):
                        _elem221 = PartitionWithoutSD()
                        _elem221.read(iprot)
                        self.partitions.append(_elem221)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sd = StorageDescriptor()
                    self.sd.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionSpecWithSharedSD')
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter222 in self.partitions:
                iter222.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sd is not None:
            oprot.writeFieldBegin('sd', TType.STRUCT, 2)
            self.sd.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionListComposingSpec(object):
    """
    Attributes:
     - partitions

    """


    def __init__(self, partitions=None,):
        self.partitions = partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype226, _size223) = iprot.readListBegin()
                    for _i227 in range(_size223):
                        _elem228 = Partition()
                        _elem228.read(iprot)
                        self.partitions.append(_elem228)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionListComposingSpec')
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter229 in self.partitions:
                iter229.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionSpec(object):
    """
    Attributes:
     - dbName
     - tableName
     - rootPath
     - sharedSDPartitionSpec
     - partitionList

    """


    def __init__(self, dbName=None, tableName=None, rootPath=None, sharedSDPartitionSpec=None, partitionList=None,):
        self.dbName = dbName
        self.tableName = tableName
        self.rootPath = rootPath
        self.sharedSDPartitionSpec = sharedSDPartitionSpec
        self.partitionList = partitionList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.rootPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.sharedSDPartitionSpec = PartitionSpecWithSharedSD()
                    self.sharedSDPartitionSpec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.partitionList = PartitionListComposingSpec()
                    self.partitionList.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionSpec')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.rootPath is not None:
            oprot.writeFieldBegin('rootPath', TType.STRING, 3)
            oprot.writeString(self.rootPath.encode('utf-8') if sys.version_info[0] == 2 else self.rootPath)
            oprot.writeFieldEnd()
        if self.sharedSDPartitionSpec is not None:
            oprot.writeFieldBegin('sharedSDPartitionSpec', TType.STRUCT, 4)
            self.sharedSDPartitionSpec.write(oprot)
            oprot.writeFieldEnd()
        if self.partitionList is not None:
            oprot.writeFieldBegin('partitionList', TType.STRUCT, 5)
            self.partitionList.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Index(object):
    """
    Attributes:
     - indexName
     - indexHandlerClass
     - dbName
     - origTableName
     - createTime
     - lastAccessTime
     - indexTableName
     - sd
     - parameters
     - deferredRebuild

    """


    def __init__(self, indexName=None, indexHandlerClass=None, dbName=None, origTableName=None, createTime=None, lastAccessTime=None, indexTableName=None, sd=None, parameters=None, deferredRebuild=None,):
        self.indexName = indexName
        self.indexHandlerClass = indexHandlerClass
        self.dbName = dbName
        self.origTableName = origTableName
        self.createTime = createTime
        self.lastAccessTime = lastAccessTime
        self.indexTableName = indexTableName
        self.sd = sd
        self.parameters = parameters
        self.deferredRebuild = deferredRebuild

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.indexName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.indexHandlerClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.origTableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.createTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.lastAccessTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.indexTableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.sd = StorageDescriptor()
                    self.sd.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.parameters = {}
                    (_ktype231, _vtype232, _size230) = iprot.readMapBegin()
                    for _i234 in range(_size230):
                        _key235 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val236 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameters[_key235] = _val236
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.deferredRebuild = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Index')
        if self.indexName is not None:
            oprot.writeFieldBegin('indexName', TType.STRING, 1)
            oprot.writeString(self.indexName.encode('utf-8') if sys.version_info[0] == 2 else self.indexName)
            oprot.writeFieldEnd()
        if self.indexHandlerClass is not None:
            oprot.writeFieldBegin('indexHandlerClass', TType.STRING, 2)
            oprot.writeString(self.indexHandlerClass.encode('utf-8') if sys.version_info[0] == 2 else self.indexHandlerClass)
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 3)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.origTableName is not None:
            oprot.writeFieldBegin('origTableName', TType.STRING, 4)
            oprot.writeString(self.origTableName.encode('utf-8') if sys.version_info[0] == 2 else self.origTableName)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I32, 5)
            oprot.writeI32(self.createTime)
            oprot.writeFieldEnd()
        if self.lastAccessTime is not None:
            oprot.writeFieldBegin('lastAccessTime', TType.I32, 6)
            oprot.writeI32(self.lastAccessTime)
            oprot.writeFieldEnd()
        if self.indexTableName is not None:
            oprot.writeFieldBegin('indexTableName', TType.STRING, 7)
            oprot.writeString(self.indexTableName.encode('utf-8') if sys.version_info[0] == 2 else self.indexTableName)
            oprot.writeFieldEnd()
        if self.sd is not None:
            oprot.writeFieldBegin('sd', TType.STRUCT, 8)
            self.sd.write(oprot)
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
            for kiter237, viter238 in self.parameters.items():
                oprot.writeString(kiter237.encode('utf-8') if sys.version_info[0] == 2 else kiter237)
                oprot.writeString(viter238.encode('utf-8') if sys.version_info[0] == 2 else viter238)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.deferredRebuild is not None:
            oprot.writeFieldBegin('deferredRebuild', TType.BOOL, 10)
            oprot.writeBool(self.deferredRebuild)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BooleanColumnStatsData(object):
    """
    Attributes:
     - numTrues
     - numFalses
     - numNulls
     - bitVectors

    """


    def __init__(self, numTrues=None, numFalses=None, numNulls=None, bitVectors=None,):
        self.numTrues = numTrues
        self.numFalses = numFalses
        self.numNulls = numNulls
        self.bitVectors = bitVectors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.numTrues = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.numFalses = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.numNulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.bitVectors = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BooleanColumnStatsData')
        if self.numTrues is not None:
            oprot.writeFieldBegin('numTrues', TType.I64, 1)
            oprot.writeI64(self.numTrues)
            oprot.writeFieldEnd()
        if self.numFalses is not None:
            oprot.writeFieldBegin('numFalses', TType.I64, 2)
            oprot.writeI64(self.numFalses)
            oprot.writeFieldEnd()
        if self.numNulls is not None:
            oprot.writeFieldBegin('numNulls', TType.I64, 3)
            oprot.writeI64(self.numNulls)
            oprot.writeFieldEnd()
        if self.bitVectors is not None:
            oprot.writeFieldBegin('bitVectors', TType.STRING, 4)
            oprot.writeString(self.bitVectors.encode('utf-8') if sys.version_info[0] == 2 else self.bitVectors)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.numTrues is None:
            raise TProtocolException(message='Required field numTrues is unset!')
        if self.numFalses is None:
            raise TProtocolException(message='Required field numFalses is unset!')
        if self.numNulls is None:
            raise TProtocolException(message='Required field numNulls is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DoubleColumnStatsData(object):
    """
    Attributes:
     - lowValue
     - highValue
     - numNulls
     - numDVs
     - bitVectors

    """


    def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
        self.lowValue = lowValue
        self.highValue = highValue
        self.numNulls = numNulls
        self.numDVs = numDVs
        self.bitVectors = bitVectors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.lowValue = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.highValue = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.numNulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.numDVs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.bitVectors = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DoubleColumnStatsData')
        if self.lowValue is not None:
            oprot.writeFieldBegin('lowValue', TType.DOUBLE, 1)
            oprot.writeDouble(self.lowValue)
            oprot.writeFieldEnd()
        if self.highValue is not None:
            oprot.writeFieldBegin('highValue', TType.DOUBLE, 2)
            oprot.writeDouble(self.highValue)
            oprot.writeFieldEnd()
        if self.numNulls is not None:
            oprot.writeFieldBegin('numNulls', TType.I64, 3)
            oprot.writeI64(self.numNulls)
            oprot.writeFieldEnd()
        if self.numDVs is not None:
            oprot.writeFieldBegin('numDVs', TType.I64, 4)
            oprot.writeI64(self.numDVs)
            oprot.writeFieldEnd()
        if self.bitVectors is not None:
            oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
            oprot.writeString(self.bitVectors.encode('utf-8') if sys.version_info[0] == 2 else self.bitVectors)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.numNulls is None:
            raise TProtocolException(message='Required field numNulls is unset!')
        if self.numDVs is None:
            raise TProtocolException(message='Required field numDVs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LongColumnStatsData(object):
    """
    Attributes:
     - lowValue
     - highValue
     - numNulls
     - numDVs
     - bitVectors

    """


    def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
        self.lowValue = lowValue
        self.highValue = highValue
        self.numNulls = numNulls
        self.numDVs = numDVs
        self.bitVectors = bitVectors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.lowValue = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.highValue = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.numNulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.numDVs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.bitVectors = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LongColumnStatsData')
        if self.lowValue is not None:
            oprot.writeFieldBegin('lowValue', TType.I64, 1)
            oprot.writeI64(self.lowValue)
            oprot.writeFieldEnd()
        if self.highValue is not None:
            oprot.writeFieldBegin('highValue', TType.I64, 2)
            oprot.writeI64(self.highValue)
            oprot.writeFieldEnd()
        if self.numNulls is not None:
            oprot.writeFieldBegin('numNulls', TType.I64, 3)
            oprot.writeI64(self.numNulls)
            oprot.writeFieldEnd()
        if self.numDVs is not None:
            oprot.writeFieldBegin('numDVs', TType.I64, 4)
            oprot.writeI64(self.numDVs)
            oprot.writeFieldEnd()
        if self.bitVectors is not None:
            oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
            oprot.writeString(self.bitVectors.encode('utf-8') if sys.version_info[0] == 2 else self.bitVectors)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.numNulls is None:
            raise TProtocolException(message='Required field numNulls is unset!')
        if self.numDVs is None:
            raise TProtocolException(message='Required field numDVs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StringColumnStatsData(object):
    """
    Attributes:
     - maxColLen
     - avgColLen
     - numNulls
     - numDVs
     - bitVectors

    """


    def __init__(self, maxColLen=None, avgColLen=None, numNulls=None, numDVs=None, bitVectors=None,):
        self.maxColLen = maxColLen
        self.avgColLen = avgColLen
        self.numNulls = numNulls
        self.numDVs = numDVs
        self.bitVectors = bitVectors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.maxColLen = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.avgColLen = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.numNulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.numDVs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.bitVectors = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StringColumnStatsData')
        if self.maxColLen is not None:
            oprot.writeFieldBegin('maxColLen', TType.I64, 1)
            oprot.writeI64(self.maxColLen)
            oprot.writeFieldEnd()
        if self.avgColLen is not None:
            oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
            oprot.writeDouble(self.avgColLen)
            oprot.writeFieldEnd()
        if self.numNulls is not None:
            oprot.writeFieldBegin('numNulls', TType.I64, 3)
            oprot.writeI64(self.numNulls)
            oprot.writeFieldEnd()
        if self.numDVs is not None:
            oprot.writeFieldBegin('numDVs', TType.I64, 4)
            oprot.writeI64(self.numDVs)
            oprot.writeFieldEnd()
        if self.bitVectors is not None:
            oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
            oprot.writeString(self.bitVectors.encode('utf-8') if sys.version_info[0] == 2 else self.bitVectors)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.maxColLen is None:
            raise TProtocolException(message='Required field maxColLen is unset!')
        if self.avgColLen is None:
            raise TProtocolException(message='Required field avgColLen is unset!')
        if self.numNulls is None:
            raise TProtocolException(message='Required field numNulls is unset!')
        if self.numDVs is None:
            raise TProtocolException(message='Required field numDVs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BinaryColumnStatsData(object):
    """
    Attributes:
     - maxColLen
     - avgColLen
     - numNulls
     - bitVectors

    """


    def __init__(self, maxColLen=None, avgColLen=None, numNulls=None, bitVectors=None,):
        self.maxColLen = maxColLen
        self.avgColLen = avgColLen
        self.numNulls = numNulls
        self.bitVectors = bitVectors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.maxColLen = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.avgColLen = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.numNulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.bitVectors = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BinaryColumnStatsData')
        if self.maxColLen is not None:
            oprot.writeFieldBegin('maxColLen', TType.I64, 1)
            oprot.writeI64(self.maxColLen)
            oprot.writeFieldEnd()
        if self.avgColLen is not None:
            oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
            oprot.writeDouble(self.avgColLen)
            oprot.writeFieldEnd()
        if self.numNulls is not None:
            oprot.writeFieldBegin('numNulls', TType.I64, 3)
            oprot.writeI64(self.numNulls)
            oprot.writeFieldEnd()
        if self.bitVectors is not None:
            oprot.writeFieldBegin('bitVectors', TType.STRING, 4)
            oprot.writeString(self.bitVectors.encode('utf-8') if sys.version_info[0] == 2 else self.bitVectors)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.maxColLen is None:
            raise TProtocolException(message='Required field maxColLen is unset!')
        if self.avgColLen is None:
            raise TProtocolException(message='Required field avgColLen is unset!')
        if self.numNulls is None:
            raise TProtocolException(message='Required field numNulls is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Decimal(object):
    """
    Attributes:
     - unscaled
     - scale

    """


    def __init__(self, unscaled=None, scale=None,):
        self.unscaled = unscaled
        self.scale = scale

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.unscaled = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.scale = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Decimal')
        if self.unscaled is not None:
            oprot.writeFieldBegin('unscaled', TType.STRING, 1)
            oprot.writeBinary(self.unscaled)
            oprot.writeFieldEnd()
        if self.scale is not None:
            oprot.writeFieldBegin('scale', TType.I16, 3)
            oprot.writeI16(self.scale)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.unscaled is None:
            raise TProtocolException(message='Required field unscaled is unset!')
        if self.scale is None:
            raise TProtocolException(message='Required field scale is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DecimalColumnStatsData(object):
    """
    Attributes:
     - lowValue
     - highValue
     - numNulls
     - numDVs
     - bitVectors

    """


    def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
        self.lowValue = lowValue
        self.highValue = highValue
        self.numNulls = numNulls
        self.numDVs = numDVs
        self.bitVectors = bitVectors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lowValue = Decimal()
                    self.lowValue.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.highValue = Decimal()
                    self.highValue.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.numNulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.numDVs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.bitVectors = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DecimalColumnStatsData')
        if self.lowValue is not None:
            oprot.writeFieldBegin('lowValue', TType.STRUCT, 1)
            self.lowValue.write(oprot)
            oprot.writeFieldEnd()
        if self.highValue is not None:
            oprot.writeFieldBegin('highValue', TType.STRUCT, 2)
            self.highValue.write(oprot)
            oprot.writeFieldEnd()
        if self.numNulls is not None:
            oprot.writeFieldBegin('numNulls', TType.I64, 3)
            oprot.writeI64(self.numNulls)
            oprot.writeFieldEnd()
        if self.numDVs is not None:
            oprot.writeFieldBegin('numDVs', TType.I64, 4)
            oprot.writeI64(self.numDVs)
            oprot.writeFieldEnd()
        if self.bitVectors is not None:
            oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
            oprot.writeString(self.bitVectors.encode('utf-8') if sys.version_info[0] == 2 else self.bitVectors)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.numNulls is None:
            raise TProtocolException(message='Required field numNulls is unset!')
        if self.numDVs is None:
            raise TProtocolException(message='Required field numDVs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Date(object):
    """
    Attributes:
     - daysSinceEpoch

    """


    def __init__(self, daysSinceEpoch=None,):
        self.daysSinceEpoch = daysSinceEpoch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.daysSinceEpoch = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Date')
        if self.daysSinceEpoch is not None:
            oprot.writeFieldBegin('daysSinceEpoch', TType.I64, 1)
            oprot.writeI64(self.daysSinceEpoch)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.daysSinceEpoch is None:
            raise TProtocolException(message='Required field daysSinceEpoch is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DateColumnStatsData(object):
    """
    Attributes:
     - lowValue
     - highValue
     - numNulls
     - numDVs
     - bitVectors

    """


    def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
        self.lowValue = lowValue
        self.highValue = highValue
        self.numNulls = numNulls
        self.numDVs = numDVs
        self.bitVectors = bitVectors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lowValue = Date()
                    self.lowValue.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.highValue = Date()
                    self.highValue.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.numNulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.numDVs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.bitVectors = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DateColumnStatsData')
        if self.lowValue is not None:
            oprot.writeFieldBegin('lowValue', TType.STRUCT, 1)
            self.lowValue.write(oprot)
            oprot.writeFieldEnd()
        if self.highValue is not None:
            oprot.writeFieldBegin('highValue', TType.STRUCT, 2)
            self.highValue.write(oprot)
            oprot.writeFieldEnd()
        if self.numNulls is not None:
            oprot.writeFieldBegin('numNulls', TType.I64, 3)
            oprot.writeI64(self.numNulls)
            oprot.writeFieldEnd()
        if self.numDVs is not None:
            oprot.writeFieldBegin('numDVs', TType.I64, 4)
            oprot.writeI64(self.numDVs)
            oprot.writeFieldEnd()
        if self.bitVectors is not None:
            oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
            oprot.writeString(self.bitVectors.encode('utf-8') if sys.version_info[0] == 2 else self.bitVectors)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.numNulls is None:
            raise TProtocolException(message='Required field numNulls is unset!')
        if self.numDVs is None:
            raise TProtocolException(message='Required field numDVs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnStatisticsData(object):
    """
    Attributes:
     - booleanStats
     - longStats
     - doubleStats
     - stringStats
     - binaryStats
     - decimalStats
     - dateStats

    """


    def __init__(self, booleanStats=None, longStats=None, doubleStats=None, stringStats=None, binaryStats=None, decimalStats=None, dateStats=None,):
        self.booleanStats = booleanStats
        self.longStats = longStats
        self.doubleStats = doubleStats
        self.stringStats = stringStats
        self.binaryStats = binaryStats
        self.decimalStats = decimalStats
        self.dateStats = dateStats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.booleanStats = BooleanColumnStatsData()
                    self.booleanStats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.longStats = LongColumnStatsData()
                    self.longStats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.doubleStats = DoubleColumnStatsData()
                    self.doubleStats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.stringStats = StringColumnStatsData()
                    self.stringStats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.binaryStats = BinaryColumnStatsData()
                    self.binaryStats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.decimalStats = DecimalColumnStatsData()
                    self.decimalStats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.dateStats = DateColumnStatsData()
                    self.dateStats.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnStatisticsData')
        if self.booleanStats is not None:
            oprot.writeFieldBegin('booleanStats', TType.STRUCT, 1)
            self.booleanStats.write(oprot)
            oprot.writeFieldEnd()
        if self.longStats is not None:
            oprot.writeFieldBegin('longStats', TType.STRUCT, 2)
            self.longStats.write(oprot)
            oprot.writeFieldEnd()
        if self.doubleStats is not None:
            oprot.writeFieldBegin('doubleStats', TType.STRUCT, 3)
            self.doubleStats.write(oprot)
            oprot.writeFieldEnd()
        if self.stringStats is not None:
            oprot.writeFieldBegin('stringStats', TType.STRUCT, 4)
            self.stringStats.write(oprot)
            oprot.writeFieldEnd()
        if self.binaryStats is not None:
            oprot.writeFieldBegin('binaryStats', TType.STRUCT, 5)
            self.binaryStats.write(oprot)
            oprot.writeFieldEnd()
        if self.decimalStats is not None:
            oprot.writeFieldBegin('decimalStats', TType.STRUCT, 6)
            self.decimalStats.write(oprot)
            oprot.writeFieldEnd()
        if self.dateStats is not None:
            oprot.writeFieldBegin('dateStats', TType.STRUCT, 7)
            self.dateStats.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnStatisticsObj(object):
    """
    Attributes:
     - colName
     - colType
     - statsData

    """


    def __init__(self, colName=None, colType=None, statsData=None,):
        self.colName = colName
        self.colType = colType
        self.statsData = statsData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.colName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.colType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.statsData = ColumnStatisticsData()
                    self.statsData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnStatisticsObj')
        if self.colName is not None:
            oprot.writeFieldBegin('colName', TType.STRING, 1)
            oprot.writeString(self.colName.encode('utf-8') if sys.version_info[0] == 2 else self.colName)
            oprot.writeFieldEnd()
        if self.colType is not None:
            oprot.writeFieldBegin('colType', TType.STRING, 2)
            oprot.writeString(self.colType.encode('utf-8') if sys.version_info[0] == 2 else self.colType)
            oprot.writeFieldEnd()
        if self.statsData is not None:
            oprot.writeFieldBegin('statsData', TType.STRUCT, 3)
            self.statsData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.colName is None:
            raise TProtocolException(message='Required field colName is unset!')
        if self.colType is None:
            raise TProtocolException(message='Required field colType is unset!')
        if self.statsData is None:
            raise TProtocolException(message='Required field statsData is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnStatisticsDesc(object):
    """
    Attributes:
     - isTblLevel
     - dbName
     - tableName
     - partName
     - lastAnalyzed

    """


    def __init__(self, isTblLevel=None, dbName=None, tableName=None, partName=None, lastAnalyzed=None,):
        self.isTblLevel = isTblLevel
        self.dbName = dbName
        self.tableName = tableName
        self.partName = partName
        self.lastAnalyzed = lastAnalyzed

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.isTblLevel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.partName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.lastAnalyzed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnStatisticsDesc')
        if self.isTblLevel is not None:
            oprot.writeFieldBegin('isTblLevel', TType.BOOL, 1)
            oprot.writeBool(self.isTblLevel)
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 2)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 3)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.partName is not None:
            oprot.writeFieldBegin('partName', TType.STRING, 4)
            oprot.writeString(self.partName.encode('utf-8') if sys.version_info[0] == 2 else self.partName)
            oprot.writeFieldEnd()
        if self.lastAnalyzed is not None:
            oprot.writeFieldBegin('lastAnalyzed', TType.I64, 5)
            oprot.writeI64(self.lastAnalyzed)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.isTblLevel is None:
            raise TProtocolException(message='Required field isTblLevel is unset!')
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnStatistics(object):
    """
    Attributes:
     - statsDesc
     - statsObj

    """


    def __init__(self, statsDesc=None, statsObj=None,):
        self.statsDesc = statsDesc
        self.statsObj = statsObj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.statsDesc = ColumnStatisticsDesc()
                    self.statsDesc.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.statsObj = []
                    (_etype242, _size239) = iprot.readListBegin()
                    for _i243 in range(_size239):
                        _elem244 = ColumnStatisticsObj()
                        _elem244.read(iprot)
                        self.statsObj.append(_elem244)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnStatistics')
        if self.statsDesc is not None:
            oprot.writeFieldBegin('statsDesc', TType.STRUCT, 1)
            self.statsDesc.write(oprot)
            oprot.writeFieldEnd()
        if self.statsObj is not None:
            oprot.writeFieldBegin('statsObj', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.statsObj))
            for iter245 in self.statsObj:
                iter245.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.statsDesc is None:
            raise TProtocolException(message='Required field statsDesc is unset!')
        if self.statsObj is None:
            raise TProtocolException(message='Required field statsObj is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AggrStats(object):
    """
    Attributes:
     - colStats
     - partsFound

    """


    def __init__(self, colStats=None, partsFound=None,):
        self.colStats = colStats
        self.partsFound = partsFound

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.colStats = []
                    (_etype249, _size246) = iprot.readListBegin()
                    for _i250 in range(_size246):
                        _elem251 = ColumnStatisticsObj()
                        _elem251.read(iprot)
                        self.colStats.append(_elem251)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.partsFound = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AggrStats')
        if self.colStats is not None:
            oprot.writeFieldBegin('colStats', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.colStats))
            for iter252 in self.colStats:
                iter252.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partsFound is not None:
            oprot.writeFieldBegin('partsFound', TType.I64, 2)
            oprot.writeI64(self.partsFound)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.colStats is None:
            raise TProtocolException(message='Required field colStats is unset!')
        if self.partsFound is None:
            raise TProtocolException(message='Required field partsFound is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetPartitionsStatsRequest(object):
    """
    Attributes:
     - colStats
     - needMerge

    """


    def __init__(self, colStats=None, needMerge=None,):
        self.colStats = colStats
        self.needMerge = needMerge

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.colStats = []
                    (_etype256, _size253) = iprot.readListBegin()
                    for _i257 in range(_size253):
                        _elem258 = ColumnStatistics()
                        _elem258.read(iprot)
                        self.colStats.append(_elem258)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needMerge = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetPartitionsStatsRequest')
        if self.colStats is not None:
            oprot.writeFieldBegin('colStats', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.colStats))
            for iter259 in self.colStats:
                iter259.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.needMerge is not None:
            oprot.writeFieldBegin('needMerge', TType.BOOL, 2)
            oprot.writeBool(self.needMerge)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.colStats is None:
            raise TProtocolException(message='Required field colStats is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Schema(object):
    """
    Attributes:
     - fieldSchemas
     - properties

    """


    def __init__(self, fieldSchemas=None, properties=None,):
        self.fieldSchemas = fieldSchemas
        self.properties = properties

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fieldSchemas = []
                    (_etype263, _size260) = iprot.readListBegin()
                    for _i264 in range(_size260):
                        _elem265 = FieldSchema()
                        _elem265.read(iprot)
                        self.fieldSchemas.append(_elem265)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.properties = {}
                    (_ktype267, _vtype268, _size266) = iprot.readMapBegin()
                    for _i270 in range(_size266):
                        _key271 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val272 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.properties[_key271] = _val272
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Schema')
        if self.fieldSchemas is not None:
            oprot.writeFieldBegin('fieldSchemas', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.fieldSchemas))
            for iter273 in self.fieldSchemas:
                iter273.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.properties is not None:
            oprot.writeFieldBegin('properties', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
            for kiter274, viter275 in self.properties.items():
                oprot.writeString(kiter274.encode('utf-8') if sys.version_info[0] == 2 else kiter274)
                oprot.writeString(viter275.encode('utf-8') if sys.version_info[0] == 2 else viter275)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EnvironmentContext(object):
    """
    Attributes:
     - properties

    """


    def __init__(self, properties=None,):
        self.properties = properties

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.properties = {}
                    (_ktype277, _vtype278, _size276) = iprot.readMapBegin()
                    for _i280 in range(_size276):
                        _key281 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val282 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.properties[_key281] = _val282
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EnvironmentContext')
        if self.properties is not None:
            oprot.writeFieldBegin('properties', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
            for kiter283, viter284 in self.properties.items():
                oprot.writeString(kiter283.encode('utf-8') if sys.version_info[0] == 2 else kiter283)
                oprot.writeString(viter284.encode('utf-8') if sys.version_info[0] == 2 else viter284)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrimaryKeysRequest(object):
    """
    Attributes:
     - db_name
     - tbl_name

    """


    def __init__(self, db_name=None, tbl_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PrimaryKeysRequest')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db_name is None:
            raise TProtocolException(message='Required field db_name is unset!')
        if self.tbl_name is None:
            raise TProtocolException(message='Required field tbl_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrimaryKeysResponse(object):
    """
    Attributes:
     - primaryKeys

    """


    def __init__(self, primaryKeys=None,):
        self.primaryKeys = primaryKeys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.primaryKeys = []
                    (_etype288, _size285) = iprot.readListBegin()
                    for _i289 in range(_size285):
                        _elem290 = SQLPrimaryKey()
                        _elem290.read(iprot)
                        self.primaryKeys.append(_elem290)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PrimaryKeysResponse')
        if self.primaryKeys is not None:
            oprot.writeFieldBegin('primaryKeys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.primaryKeys))
            for iter291 in self.primaryKeys:
                iter291.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.primaryKeys is None:
            raise TProtocolException(message='Required field primaryKeys is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ForeignKeysRequest(object):
    """
    Attributes:
     - parent_db_name
     - parent_tbl_name
     - foreign_db_name
     - foreign_tbl_name

    """


    def __init__(self, parent_db_name=None, parent_tbl_name=None, foreign_db_name=None, foreign_tbl_name=None,):
        self.parent_db_name = parent_db_name
        self.parent_tbl_name = parent_tbl_name
        self.foreign_db_name = foreign_db_name
        self.foreign_tbl_name = foreign_tbl_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.parent_db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.parent_tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.foreign_db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.foreign_tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ForeignKeysRequest')
        if self.parent_db_name is not None:
            oprot.writeFieldBegin('parent_db_name', TType.STRING, 1)
            oprot.writeString(self.parent_db_name.encode('utf-8') if sys.version_info[0] == 2 else self.parent_db_name)
            oprot.writeFieldEnd()
        if self.parent_tbl_name is not None:
            oprot.writeFieldBegin('parent_tbl_name', TType.STRING, 2)
            oprot.writeString(self.parent_tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.parent_tbl_name)
            oprot.writeFieldEnd()
        if self.foreign_db_name is not None:
            oprot.writeFieldBegin('foreign_db_name', TType.STRING, 3)
            oprot.writeString(self.foreign_db_name.encode('utf-8') if sys.version_info[0] == 2 else self.foreign_db_name)
            oprot.writeFieldEnd()
        if self.foreign_tbl_name is not None:
            oprot.writeFieldBegin('foreign_tbl_name', TType.STRING, 4)
            oprot.writeString(self.foreign_tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.foreign_tbl_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ForeignKeysResponse(object):
    """
    Attributes:
     - foreignKeys

    """


    def __init__(self, foreignKeys=None,):
        self.foreignKeys = foreignKeys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.foreignKeys = []
                    (_etype295, _size292) = iprot.readListBegin()
                    for _i296 in range(_size292):
                        _elem297 = SQLForeignKey()
                        _elem297.read(iprot)
                        self.foreignKeys.append(_elem297)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ForeignKeysResponse')
        if self.foreignKeys is not None:
            oprot.writeFieldBegin('foreignKeys', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.foreignKeys))
            for iter298 in self.foreignKeys:
                iter298.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.foreignKeys is None:
            raise TProtocolException(message='Required field foreignKeys is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DropConstraintRequest(object):
    """
    Attributes:
     - dbname
     - tablename
     - constraintname

    """


    def __init__(self, dbname=None, tablename=None, constraintname=None,):
        self.dbname = dbname
        self.tablename = tablename
        self.constraintname = constraintname

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tablename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.constraintname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DropConstraintRequest')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tablename is not None:
            oprot.writeFieldBegin('tablename', TType.STRING, 2)
            oprot.writeString(self.tablename.encode('utf-8') if sys.version_info[0] == 2 else self.tablename)
            oprot.writeFieldEnd()
        if self.constraintname is not None:
            oprot.writeFieldBegin('constraintname', TType.STRING, 3)
            oprot.writeString(self.constraintname.encode('utf-8') if sys.version_info[0] == 2 else self.constraintname)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbname is None:
            raise TProtocolException(message='Required field dbname is unset!')
        if self.tablename is None:
            raise TProtocolException(message='Required field tablename is unset!')
        if self.constraintname is None:
            raise TProtocolException(message='Required field constraintname is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AddPrimaryKeyRequest(object):
    """
    Attributes:
     - primaryKeyCols

    """


    def __init__(self, primaryKeyCols=None,):
        self.primaryKeyCols = primaryKeyCols

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.primaryKeyCols = []
                    (_etype302, _size299) = iprot.readListBegin()
                    for _i303 in range(_size299):
                        _elem304 = SQLPrimaryKey()
                        _elem304.read(iprot)
                        self.primaryKeyCols.append(_elem304)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddPrimaryKeyRequest')
        if self.primaryKeyCols is not None:
            oprot.writeFieldBegin('primaryKeyCols', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.primaryKeyCols))
            for iter305 in self.primaryKeyCols:
                iter305.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.primaryKeyCols is None:
            raise TProtocolException(message='Required field primaryKeyCols is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AddForeignKeyRequest(object):
    """
    Attributes:
     - foreignKeyCols

    """


    def __init__(self, foreignKeyCols=None,):
        self.foreignKeyCols = foreignKeyCols

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.foreignKeyCols = []
                    (_etype309, _size306) = iprot.readListBegin()
                    for _i310 in range(_size306):
                        _elem311 = SQLForeignKey()
                        _elem311.read(iprot)
                        self.foreignKeyCols.append(_elem311)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddForeignKeyRequest')
        if self.foreignKeyCols is not None:
            oprot.writeFieldBegin('foreignKeyCols', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.foreignKeyCols))
            for iter312 in self.foreignKeyCols:
                iter312.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.foreignKeyCols is None:
            raise TProtocolException(message='Required field foreignKeyCols is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionsByExprResult(object):
    """
    Attributes:
     - partitions
     - hasUnknownPartitions

    """


    def __init__(self, partitions=None, hasUnknownPartitions=None,):
        self.partitions = partitions
        self.hasUnknownPartitions = hasUnknownPartitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype316, _size313) = iprot.readListBegin()
                    for _i317 in range(_size313):
                        _elem318 = Partition()
                        _elem318.read(iprot)
                        self.partitions.append(_elem318)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.hasUnknownPartitions = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionsByExprResult')
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter319 in self.partitions:
                iter319.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasUnknownPartitions is not None:
            oprot.writeFieldBegin('hasUnknownPartitions', TType.BOOL, 2)
            oprot.writeBool(self.hasUnknownPartitions)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partitions is None:
            raise TProtocolException(message='Required field partitions is unset!')
        if self.hasUnknownPartitions is None:
            raise TProtocolException(message='Required field hasUnknownPartitions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionsByExprRequest(object):
    """
    Attributes:
     - dbName
     - tblName
     - expr
     - defaultPartitionName
     - maxParts

    """


    def __init__(self, dbName=None, tblName=None, expr=None, defaultPartitionName=None, maxParts=-1,):
        self.dbName = dbName
        self.tblName = tblName
        self.expr = expr
        self.defaultPartitionName = defaultPartitionName
        self.maxParts = maxParts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tblName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.expr = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.defaultPartitionName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I16:
                    self.maxParts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionsByExprRequest')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tblName is not None:
            oprot.writeFieldBegin('tblName', TType.STRING, 2)
            oprot.writeString(self.tblName.encode('utf-8') if sys.version_info[0] == 2 else self.tblName)
            oprot.writeFieldEnd()
        if self.expr is not None:
            oprot.writeFieldBegin('expr', TType.STRING, 3)
            oprot.writeBinary(self.expr)
            oprot.writeFieldEnd()
        if self.defaultPartitionName is not None:
            oprot.writeFieldBegin('defaultPartitionName', TType.STRING, 4)
            oprot.writeString(self.defaultPartitionName.encode('utf-8') if sys.version_info[0] == 2 else self.defaultPartitionName)
            oprot.writeFieldEnd()
        if self.maxParts is not None:
            oprot.writeFieldBegin('maxParts', TType.I16, 5)
            oprot.writeI16(self.maxParts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        if self.tblName is None:
            raise TProtocolException(message='Required field tblName is unset!')
        if self.expr is None:
            raise TProtocolException(message='Required field expr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableStatsResult(object):
    """
    Attributes:
     - tableStats

    """


    def __init__(self, tableStats=None,):
        self.tableStats = tableStats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tableStats = []
                    (_etype323, _size320) = iprot.readListBegin()
                    for _i324 in range(_size320):
                        _elem325 = ColumnStatisticsObj()
                        _elem325.read(iprot)
                        self.tableStats.append(_elem325)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TableStatsResult')
        if self.tableStats is not None:
            oprot.writeFieldBegin('tableStats', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.tableStats))
            for iter326 in self.tableStats:
                iter326.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tableStats is None:
            raise TProtocolException(message='Required field tableStats is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionsStatsResult(object):
    """
    Attributes:
     - partStats

    """


    def __init__(self, partStats=None,):
        self.partStats = partStats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partStats = {}
                    (_ktype328, _vtype329, _size327) = iprot.readMapBegin()
                    for _i331 in range(_size327):
                        _key332 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val333 = []
                        (_etype337, _size334) = iprot.readListBegin()
                        for _i338 in range(_size334):
                            _elem339 = ColumnStatisticsObj()
                            _elem339.read(iprot)
                            _val333.append(_elem339)
                        iprot.readListEnd()
                        self.partStats[_key332] = _val333
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionsStatsResult')
        if self.partStats is not None:
            oprot.writeFieldBegin('partStats', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.partStats))
            for kiter340, viter341 in self.partStats.items():
                oprot.writeString(kiter340.encode('utf-8') if sys.version_info[0] == 2 else kiter340)
                oprot.writeListBegin(TType.STRUCT, len(viter341))
                for iter342 in viter341:
                    iter342.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partStats is None:
            raise TProtocolException(message='Required field partStats is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableStatsRequest(object):
    """
    Attributes:
     - dbName
     - tblName
     - colNames

    """


    def __init__(self, dbName=None, tblName=None, colNames=None,):
        self.dbName = dbName
        self.tblName = tblName
        self.colNames = colNames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tblName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.colNames = []
                    (_etype346, _size343) = iprot.readListBegin()
                    for _i347 in range(_size343):
                        _elem348 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.colNames.append(_elem348)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TableStatsRequest')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tblName is not None:
            oprot.writeFieldBegin('tblName', TType.STRING, 2)
            oprot.writeString(self.tblName.encode('utf-8') if sys.version_info[0] == 2 else self.tblName)
            oprot.writeFieldEnd()
        if self.colNames is not None:
            oprot.writeFieldBegin('colNames', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.colNames))
            for iter349 in self.colNames:
                oprot.writeString(iter349.encode('utf-8') if sys.version_info[0] == 2 else iter349)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        if self.tblName is None:
            raise TProtocolException(message='Required field tblName is unset!')
        if self.colNames is None:
            raise TProtocolException(message='Required field colNames is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionsStatsRequest(object):
    """
    Attributes:
     - dbName
     - tblName
     - colNames
     - partNames

    """


    def __init__(self, dbName=None, tblName=None, colNames=None, partNames=None,):
        self.dbName = dbName
        self.tblName = tblName
        self.colNames = colNames
        self.partNames = partNames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tblName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.colNames = []
                    (_etype353, _size350) = iprot.readListBegin()
                    for _i354 in range(_size350):
                        _elem355 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.colNames.append(_elem355)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partNames = []
                    (_etype359, _size356) = iprot.readListBegin()
                    for _i360 in range(_size356):
                        _elem361 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.partNames.append(_elem361)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionsStatsRequest')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tblName is not None:
            oprot.writeFieldBegin('tblName', TType.STRING, 2)
            oprot.writeString(self.tblName.encode('utf-8') if sys.version_info[0] == 2 else self.tblName)
            oprot.writeFieldEnd()
        if self.colNames is not None:
            oprot.writeFieldBegin('colNames', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.colNames))
            for iter362 in self.colNames:
                oprot.writeString(iter362.encode('utf-8') if sys.version_info[0] == 2 else iter362)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partNames is not None:
            oprot.writeFieldBegin('partNames', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.partNames))
            for iter363 in self.partNames:
                oprot.writeString(iter363.encode('utf-8') if sys.version_info[0] == 2 else iter363)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        if self.tblName is None:
            raise TProtocolException(message='Required field tblName is unset!')
        if self.colNames is None:
            raise TProtocolException(message='Required field colNames is unset!')
        if self.partNames is None:
            raise TProtocolException(message='Required field partNames is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AddPartitionsResult(object):
    """
    Attributes:
     - partitions

    """


    def __init__(self, partitions=None,):
        self.partitions = partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype367, _size364) = iprot.readListBegin()
                    for _i368 in range(_size364):
                        _elem369 = Partition()
                        _elem369.read(iprot)
                        self.partitions.append(_elem369)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddPartitionsResult')
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter370 in self.partitions:
                iter370.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AddPartitionsRequest(object):
    """
    Attributes:
     - dbName
     - tblName
     - parts
     - ifNotExists
     - needResult

    """


    def __init__(self, dbName=None, tblName=None, parts=None, ifNotExists=None, needResult=True,):
        self.dbName = dbName
        self.tblName = tblName
        self.parts = parts
        self.ifNotExists = ifNotExists
        self.needResult = needResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tblName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.parts = []
                    (_etype374, _size371) = iprot.readListBegin()
                    for _i375 in range(_size371):
                        _elem376 = Partition()
                        _elem376.read(iprot)
                        self.parts.append(_elem376)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.ifNotExists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.needResult = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddPartitionsRequest')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tblName is not None:
            oprot.writeFieldBegin('tblName', TType.STRING, 2)
            oprot.writeString(self.tblName.encode('utf-8') if sys.version_info[0] == 2 else self.tblName)
            oprot.writeFieldEnd()
        if self.parts is not None:
            oprot.writeFieldBegin('parts', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.parts))
            for iter377 in self.parts:
                iter377.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ifNotExists is not None:
            oprot.writeFieldBegin('ifNotExists', TType.BOOL, 4)
            oprot.writeBool(self.ifNotExists)
            oprot.writeFieldEnd()
        if self.needResult is not None:
            oprot.writeFieldBegin('needResult', TType.BOOL, 5)
            oprot.writeBool(self.needResult)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        if self.tblName is None:
            raise TProtocolException(message='Required field tblName is unset!')
        if self.parts is None:
            raise TProtocolException(message='Required field parts is unset!')
        if self.ifNotExists is None:
            raise TProtocolException(message='Required field ifNotExists is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DropPartitionsResult(object):
    """
    Attributes:
     - partitions

    """


    def __init__(self, partitions=None,):
        self.partitions = partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype381, _size378) = iprot.readListBegin()
                    for _i382 in range(_size378):
                        _elem383 = Partition()
                        _elem383.read(iprot)
                        self.partitions.append(_elem383)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DropPartitionsResult')
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter384 in self.partitions:
                iter384.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DropPartitionsExpr(object):
    """
    Attributes:
     - expr
     - partArchiveLevel

    """


    def __init__(self, expr=None, partArchiveLevel=None,):
        self.expr = expr
        self.partArchiveLevel = partArchiveLevel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expr = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.partArchiveLevel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DropPartitionsExpr')
        if self.expr is not None:
            oprot.writeFieldBegin('expr', TType.STRING, 1)
            oprot.writeBinary(self.expr)
            oprot.writeFieldEnd()
        if self.partArchiveLevel is not None:
            oprot.writeFieldBegin('partArchiveLevel', TType.I32, 2)
            oprot.writeI32(self.partArchiveLevel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.expr is None:
            raise TProtocolException(message='Required field expr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RequestPartsSpec(object):
    """
    Attributes:
     - names
     - exprs

    """


    def __init__(self, names=None, exprs=None,):
        self.names = names
        self.exprs = exprs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.names = []
                    (_etype388, _size385) = iprot.readListBegin()
                    for _i389 in range(_size385):
                        _elem390 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.names.append(_elem390)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.exprs = []
                    (_etype394, _size391) = iprot.readListBegin()
                    for _i395 in range(_size391):
                        _elem396 = DropPartitionsExpr()
                        _elem396.read(iprot)
                        self.exprs.append(_elem396)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RequestPartsSpec')
        if self.names is not None:
            oprot.writeFieldBegin('names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.names))
            for iter397 in self.names:
                oprot.writeString(iter397.encode('utf-8') if sys.version_info[0] == 2 else iter397)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exprs is not None:
            oprot.writeFieldBegin('exprs', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.exprs))
            for iter398 in self.exprs:
                iter398.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DropPartitionsRequest(object):
    """
    Attributes:
     - dbName
     - tblName
     - parts
     - deleteData
     - ifExists
     - ignoreProtection
     - environmentContext
     - needResult

    """


    def __init__(self, dbName=None, tblName=None, parts=None, deleteData=None, ifExists=True, ignoreProtection=None, environmentContext=None, needResult=True,):
        self.dbName = dbName
        self.tblName = tblName
        self.parts = parts
        self.deleteData = deleteData
        self.ifExists = ifExists
        self.ignoreProtection = ignoreProtection
        self.environmentContext = environmentContext
        self.needResult = needResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tblName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.parts = RequestPartsSpec()
                    self.parts.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.ifExists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.ignoreProtection = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.environmentContext = EnvironmentContext()
                    self.environmentContext.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.needResult = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DropPartitionsRequest')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tblName is not None:
            oprot.writeFieldBegin('tblName', TType.STRING, 2)
            oprot.writeString(self.tblName.encode('utf-8') if sys.version_info[0] == 2 else self.tblName)
            oprot.writeFieldEnd()
        if self.parts is not None:
            oprot.writeFieldBegin('parts', TType.STRUCT, 3)
            self.parts.write(oprot)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.ifExists is not None:
            oprot.writeFieldBegin('ifExists', TType.BOOL, 5)
            oprot.writeBool(self.ifExists)
            oprot.writeFieldEnd()
        if self.ignoreProtection is not None:
            oprot.writeFieldBegin('ignoreProtection', TType.BOOL, 6)
            oprot.writeBool(self.ignoreProtection)
            oprot.writeFieldEnd()
        if self.environmentContext is not None:
            oprot.writeFieldBegin('environmentContext', TType.STRUCT, 7)
            self.environmentContext.write(oprot)
            oprot.writeFieldEnd()
        if self.needResult is not None:
            oprot.writeFieldBegin('needResult', TType.BOOL, 8)
            oprot.writeBool(self.needResult)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        if self.tblName is None:
            raise TProtocolException(message='Required field tblName is unset!')
        if self.parts is None:
            raise TProtocolException(message='Required field parts is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionValuesRequest(object):
    """
    Attributes:
     - dbName
     - tblName
     - partitionKeys
     - applyDistinct
     - filter
     - partitionOrder
     - ascending
     - maxParts

    """


    def __init__(self, dbName=None, tblName=None, partitionKeys=None, applyDistinct=True, filter=None, partitionOrder=None, ascending=True, maxParts=-1,):
        self.dbName = dbName
        self.tblName = tblName
        self.partitionKeys = partitionKeys
        self.applyDistinct = applyDistinct
        self.filter = filter
        self.partitionOrder = partitionOrder
        self.ascending = ascending
        self.maxParts = maxParts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tblName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.partitionKeys = []
                    (_etype402, _size399) = iprot.readListBegin()
                    for _i403 in range(_size399):
                        _elem404 = FieldSchema()
                        _elem404.read(iprot)
                        self.partitionKeys.append(_elem404)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.applyDistinct = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.filter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.partitionOrder = []
                    (_etype408, _size405) = iprot.readListBegin()
                    for _i409 in range(_size405):
                        _elem410 = FieldSchema()
                        _elem410.read(iprot)
                        self.partitionOrder.append(_elem410)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.ascending = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.maxParts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionValuesRequest')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tblName is not None:
            oprot.writeFieldBegin('tblName', TType.STRING, 2)
            oprot.writeString(self.tblName.encode('utf-8') if sys.version_info[0] == 2 else self.tblName)
            oprot.writeFieldEnd()
        if self.partitionKeys is not None:
            oprot.writeFieldBegin('partitionKeys', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.partitionKeys))
            for iter411 in self.partitionKeys:
                iter411.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.applyDistinct is not None:
            oprot.writeFieldBegin('applyDistinct', TType.BOOL, 4)
            oprot.writeBool(self.applyDistinct)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRING, 5)
            oprot.writeString(self.filter.encode('utf-8') if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.partitionOrder is not None:
            oprot.writeFieldBegin('partitionOrder', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.partitionOrder))
            for iter412 in self.partitionOrder:
                iter412.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ascending is not None:
            oprot.writeFieldBegin('ascending', TType.BOOL, 7)
            oprot.writeBool(self.ascending)
            oprot.writeFieldEnd()
        if self.maxParts is not None:
            oprot.writeFieldBegin('maxParts', TType.I64, 8)
            oprot.writeI64(self.maxParts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        if self.tblName is None:
            raise TProtocolException(message='Required field tblName is unset!')
        if self.partitionKeys is None:
            raise TProtocolException(message='Required field partitionKeys is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionValuesRow(object):
    """
    Attributes:
     - row

    """


    def __init__(self, row=None,):
        self.row = row

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.row = []
                    (_etype416, _size413) = iprot.readListBegin()
                    for _i417 in range(_size413):
                        _elem418 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.row.append(_elem418)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionValuesRow')
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.row))
            for iter419 in self.row:
                oprot.writeString(iter419.encode('utf-8') if sys.version_info[0] == 2 else iter419)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.row is None:
            raise TProtocolException(message='Required field row is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionValuesResponse(object):
    """
    Attributes:
     - partitionValues

    """


    def __init__(self, partitionValues=None,):
        self.partitionValues = partitionValues

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partitionValues = []
                    (_etype423, _size420) = iprot.readListBegin()
                    for _i424 in range(_size420):
                        _elem425 = PartitionValuesRow()
                        _elem425.read(iprot)
                        self.partitionValues.append(_elem425)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionValuesResponse')
        if self.partitionValues is not None:
            oprot.writeFieldBegin('partitionValues', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partitionValues))
            for iter426 in self.partitionValues:
                iter426.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partitionValues is None:
            raise TProtocolException(message='Required field partitionValues is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ResourceUri(object):
    """
    Attributes:
     - resourceType
     - uri

    """


    def __init__(self, resourceType=None, uri=None,):
        self.resourceType = resourceType
        self.uri = uri

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.resourceType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uri = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ResourceUri')
        if self.resourceType is not None:
            oprot.writeFieldBegin('resourceType', TType.I32, 1)
            oprot.writeI32(self.resourceType)
            oprot.writeFieldEnd()
        if self.uri is not None:
            oprot.writeFieldBegin('uri', TType.STRING, 2)
            oprot.writeString(self.uri.encode('utf-8') if sys.version_info[0] == 2 else self.uri)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Function(object):
    """
    Attributes:
     - functionName
     - dbName
     - className
     - ownerName
     - ownerType
     - createTime
     - functionType
     - resourceUris

    """


    def __init__(self, functionName=None, dbName=None, className=None, ownerName=None, ownerType=None, createTime=None, functionType=None, resourceUris=None,):
        self.functionName = functionName
        self.dbName = dbName
        self.className = className
        self.ownerName = ownerName
        self.ownerType = ownerType
        self.createTime = createTime
        self.functionType = functionType
        self.resourceUris = resourceUris

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.functionName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.ownerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.ownerType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.createTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.functionType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.resourceUris = []
                    (_etype430, _size427) = iprot.readListBegin()
                    for _i431 in range(_size427):
                        _elem432 = ResourceUri()
                        _elem432.read(iprot)
                        self.resourceUris.append(_elem432)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Function')
        if self.functionName is not None:
            oprot.writeFieldBegin('functionName', TType.STRING, 1)
            oprot.writeString(self.functionName.encode('utf-8') if sys.version_info[0] == 2 else self.functionName)
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 2)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 3)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.ownerName is not None:
            oprot.writeFieldBegin('ownerName', TType.STRING, 4)
            oprot.writeString(self.ownerName.encode('utf-8') if sys.version_info[0] == 2 else self.ownerName)
            oprot.writeFieldEnd()
        if self.ownerType is not None:
            oprot.writeFieldBegin('ownerType', TType.I32, 5)
            oprot.writeI32(self.ownerType)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I32, 6)
            oprot.writeI32(self.createTime)
            oprot.writeFieldEnd()
        if self.functionType is not None:
            oprot.writeFieldBegin('functionType', TType.I32, 7)
            oprot.writeI32(self.functionType)
            oprot.writeFieldEnd()
        if self.resourceUris is not None:
            oprot.writeFieldBegin('resourceUris', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.resourceUris))
            for iter433 in self.resourceUris:
                iter433.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TxnInfo(object):
    """
    Attributes:
     - id
     - state
     - user
     - hostname
     - agentInfo
     - heartbeatCount
     - metaInfo
     - startedTime
     - lastHeartbeatTime

    """


    def __init__(self, id=None, state=None, user=None, hostname=None, agentInfo="Unknown", heartbeatCount=0, metaInfo=None, startedTime=None, lastHeartbeatTime=None,):
        self.id = id
        self.state = state
        self.user = user
        self.hostname = hostname
        self.agentInfo = agentInfo
        self.heartbeatCount = heartbeatCount
        self.metaInfo = metaInfo
        self.startedTime = startedTime
        self.lastHeartbeatTime = lastHeartbeatTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.hostname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.agentInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.heartbeatCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.metaInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.startedTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.lastHeartbeatTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TxnInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 2)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 3)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.hostname is not None:
            oprot.writeFieldBegin('hostname', TType.STRING, 4)
            oprot.writeString(self.hostname.encode('utf-8') if sys.version_info[0] == 2 else self.hostname)
            oprot.writeFieldEnd()
        if self.agentInfo is not None:
            oprot.writeFieldBegin('agentInfo', TType.STRING, 5)
            oprot.writeString(self.agentInfo.encode('utf-8') if sys.version_info[0] == 2 else self.agentInfo)
            oprot.writeFieldEnd()
        if self.heartbeatCount is not None:
            oprot.writeFieldBegin('heartbeatCount', TType.I32, 6)
            oprot.writeI32(self.heartbeatCount)
            oprot.writeFieldEnd()
        if self.metaInfo is not None:
            oprot.writeFieldBegin('metaInfo', TType.STRING, 7)
            oprot.writeString(self.metaInfo.encode('utf-8') if sys.version_info[0] == 2 else self.metaInfo)
            oprot.writeFieldEnd()
        if self.startedTime is not None:
            oprot.writeFieldBegin('startedTime', TType.I64, 8)
            oprot.writeI64(self.startedTime)
            oprot.writeFieldEnd()
        if self.lastHeartbeatTime is not None:
            oprot.writeFieldBegin('lastHeartbeatTime', TType.I64, 9)
            oprot.writeI64(self.lastHeartbeatTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        if self.hostname is None:
            raise TProtocolException(message='Required field hostname is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetOpenTxnsInfoResponse(object):
    """
    Attributes:
     - txn_high_water_mark
     - open_txns

    """


    def __init__(self, txn_high_water_mark=None, open_txns=None,):
        self.txn_high_water_mark = txn_high_water_mark
        self.open_txns = open_txns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.txn_high_water_mark = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.open_txns = []
                    (_etype437, _size434) = iprot.readListBegin()
                    for _i438 in range(_size434):
                        _elem439 = TxnInfo()
                        _elem439.read(iprot)
                        self.open_txns.append(_elem439)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetOpenTxnsInfoResponse')
        if self.txn_high_water_mark is not None:
            oprot.writeFieldBegin('txn_high_water_mark', TType.I64, 1)
            oprot.writeI64(self.txn_high_water_mark)
            oprot.writeFieldEnd()
        if self.open_txns is not None:
            oprot.writeFieldBegin('open_txns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.open_txns))
            for iter440 in self.open_txns:
                iter440.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.txn_high_water_mark is None:
            raise TProtocolException(message='Required field txn_high_water_mark is unset!')
        if self.open_txns is None:
            raise TProtocolException(message='Required field open_txns is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetOpenTxnsResponse(object):
    """
    Attributes:
     - txn_high_water_mark
     - open_txns
     - min_open_txn

    """


    def __init__(self, txn_high_water_mark=None, open_txns=None, min_open_txn=None,):
        self.txn_high_water_mark = txn_high_water_mark
        self.open_txns = open_txns
        self.min_open_txn = min_open_txn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.txn_high_water_mark = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.open_txns = set()
                    (_etype444, _size441) = iprot.readSetBegin()
                    for _i445 in range(_size441):
                        _elem446 = iprot.readI64()
                        self.open_txns.add(_elem446)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.min_open_txn = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetOpenTxnsResponse')
        if self.txn_high_water_mark is not None:
            oprot.writeFieldBegin('txn_high_water_mark', TType.I64, 1)
            oprot.writeI64(self.txn_high_water_mark)
            oprot.writeFieldEnd()
        if self.open_txns is not None:
            oprot.writeFieldBegin('open_txns', TType.SET, 2)
            oprot.writeSetBegin(TType.I64, len(self.open_txns))
            for iter447 in self.open_txns:
                oprot.writeI64(iter447)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.min_open_txn is not None:
            oprot.writeFieldBegin('min_open_txn', TType.I64, 3)
            oprot.writeI64(self.min_open_txn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.txn_high_water_mark is None:
            raise TProtocolException(message='Required field txn_high_water_mark is unset!')
        if self.open_txns is None:
            raise TProtocolException(message='Required field open_txns is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OpenTxnRequest(object):
    """
    Attributes:
     - num_txns
     - user
     - hostname
     - agentInfo

    """


    def __init__(self, num_txns=None, user=None, hostname=None, agentInfo="Unknown",):
        self.num_txns = num_txns
        self.user = user
        self.hostname = hostname
        self.agentInfo = agentInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num_txns = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.hostname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.agentInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OpenTxnRequest')
        if self.num_txns is not None:
            oprot.writeFieldBegin('num_txns', TType.I32, 1)
            oprot.writeI32(self.num_txns)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.hostname is not None:
            oprot.writeFieldBegin('hostname', TType.STRING, 3)
            oprot.writeString(self.hostname.encode('utf-8') if sys.version_info[0] == 2 else self.hostname)
            oprot.writeFieldEnd()
        if self.agentInfo is not None:
            oprot.writeFieldBegin('agentInfo', TType.STRING, 4)
            oprot.writeString(self.agentInfo.encode('utf-8') if sys.version_info[0] == 2 else self.agentInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_txns is None:
            raise TProtocolException(message='Required field num_txns is unset!')
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        if self.hostname is None:
            raise TProtocolException(message='Required field hostname is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OpenTxnsResponse(object):
    """
    Attributes:
     - txn_ids

    """


    def __init__(self, txn_ids=None,):
        self.txn_ids = txn_ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.txn_ids = []
                    (_etype451, _size448) = iprot.readListBegin()
                    for _i452 in range(_size448):
                        _elem453 = iprot.readI64()
                        self.txn_ids.append(_elem453)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OpenTxnsResponse')
        if self.txn_ids is not None:
            oprot.writeFieldBegin('txn_ids', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.txn_ids))
            for iter454 in self.txn_ids:
                oprot.writeI64(iter454)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.txn_ids is None:
            raise TProtocolException(message='Required field txn_ids is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AbortTxnRequest(object):
    """
    Attributes:
     - txnid

    """


    def __init__(self, txnid=None,):
        self.txnid = txnid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.txnid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AbortTxnRequest')
        if self.txnid is not None:
            oprot.writeFieldBegin('txnid', TType.I64, 1)
            oprot.writeI64(self.txnid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.txnid is None:
            raise TProtocolException(message='Required field txnid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AbortTxnsRequest(object):
    """
    Attributes:
     - txn_ids

    """


    def __init__(self, txn_ids=None,):
        self.txn_ids = txn_ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.txn_ids = []
                    (_etype458, _size455) = iprot.readListBegin()
                    for _i459 in range(_size455):
                        _elem460 = iprot.readI64()
                        self.txn_ids.append(_elem460)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AbortTxnsRequest')
        if self.txn_ids is not None:
            oprot.writeFieldBegin('txn_ids', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.txn_ids))
            for iter461 in self.txn_ids:
                oprot.writeI64(iter461)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.txn_ids is None:
            raise TProtocolException(message='Required field txn_ids is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommitTxnRequest(object):
    """
    Attributes:
     - txnid

    """


    def __init__(self, txnid=None,):
        self.txnid = txnid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.txnid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommitTxnRequest')
        if self.txnid is not None:
            oprot.writeFieldBegin('txnid', TType.I64, 1)
            oprot.writeI64(self.txnid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.txnid is None:
            raise TProtocolException(message='Required field txnid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LockComponent(object):
    """
    Attributes:
     - type
     - level
     - dbname
     - tablename
     - partitionname
     - operationType
     - isAcid
     - isDynamicPartitionWrite

    """


    def __init__(self, type=None, level=None, dbname=None, tablename=None, partitionname=None, operationType=5, isAcid=False, isDynamicPartitionWrite=False,):
        self.type = type
        self.level = level
        self.dbname = dbname
        self.tablename = tablename
        self.partitionname = partitionname
        self.operationType = operationType
        self.isAcid = isAcid
        self.isDynamicPartitionWrite = isDynamicPartitionWrite

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tablename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.partitionname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.operationType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.isAcid = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isDynamicPartitionWrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LockComponent')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.I32, 2)
            oprot.writeI32(self.level)
            oprot.writeFieldEnd()
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 3)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tablename is not None:
            oprot.writeFieldBegin('tablename', TType.STRING, 4)
            oprot.writeString(self.tablename.encode('utf-8') if sys.version_info[0] == 2 else self.tablename)
            oprot.writeFieldEnd()
        if self.partitionname is not None:
            oprot.writeFieldBegin('partitionname', TType.STRING, 5)
            oprot.writeString(self.partitionname.encode('utf-8') if sys.version_info[0] == 2 else self.partitionname)
            oprot.writeFieldEnd()
        if self.operationType is not None:
            oprot.writeFieldBegin('operationType', TType.I32, 6)
            oprot.writeI32(self.operationType)
            oprot.writeFieldEnd()
        if self.isAcid is not None:
            oprot.writeFieldBegin('isAcid', TType.BOOL, 7)
            oprot.writeBool(self.isAcid)
            oprot.writeFieldEnd()
        if self.isDynamicPartitionWrite is not None:
            oprot.writeFieldBegin('isDynamicPartitionWrite', TType.BOOL, 8)
            oprot.writeBool(self.isDynamicPartitionWrite)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.level is None:
            raise TProtocolException(message='Required field level is unset!')
        if self.dbname is None:
            raise TProtocolException(message='Required field dbname is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LockRequest(object):
    """
    Attributes:
     - component
     - txnid
     - user
     - hostname
     - agentInfo

    """


    def __init__(self, component=None, txnid=None, user=None, hostname=None, agentInfo="Unknown",):
        self.component = component
        self.txnid = txnid
        self.user = user
        self.hostname = hostname
        self.agentInfo = agentInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.component = []
                    (_etype465, _size462) = iprot.readListBegin()
                    for _i466 in range(_size462):
                        _elem467 = LockComponent()
                        _elem467.read(iprot)
                        self.component.append(_elem467)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.txnid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.hostname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.agentInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LockRequest')
        if self.component is not None:
            oprot.writeFieldBegin('component', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.component))
            for iter468 in self.component:
                iter468.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.txnid is not None:
            oprot.writeFieldBegin('txnid', TType.I64, 2)
            oprot.writeI64(self.txnid)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 3)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.hostname is not None:
            oprot.writeFieldBegin('hostname', TType.STRING, 4)
            oprot.writeString(self.hostname.encode('utf-8') if sys.version_info[0] == 2 else self.hostname)
            oprot.writeFieldEnd()
        if self.agentInfo is not None:
            oprot.writeFieldBegin('agentInfo', TType.STRING, 5)
            oprot.writeString(self.agentInfo.encode('utf-8') if sys.version_info[0] == 2 else self.agentInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.component is None:
            raise TProtocolException(message='Required field component is unset!')
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        if self.hostname is None:
            raise TProtocolException(message='Required field hostname is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LockResponse(object):
    """
    Attributes:
     - lockid
     - state

    """


    def __init__(self, lockid=None, state=None,):
        self.lockid = lockid
        self.state = state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.lockid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LockResponse')
        if self.lockid is not None:
            oprot.writeFieldBegin('lockid', TType.I64, 1)
            oprot.writeI64(self.lockid)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 2)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lockid is None:
            raise TProtocolException(message='Required field lockid is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CheckLockRequest(object):
    """
    Attributes:
     - lockid
     - txnid
     - elapsed_ms

    """


    def __init__(self, lockid=None, txnid=None, elapsed_ms=None,):
        self.lockid = lockid
        self.txnid = txnid
        self.elapsed_ms = elapsed_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.lockid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.txnid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.elapsed_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckLockRequest')
        if self.lockid is not None:
            oprot.writeFieldBegin('lockid', TType.I64, 1)
            oprot.writeI64(self.lockid)
            oprot.writeFieldEnd()
        if self.txnid is not None:
            oprot.writeFieldBegin('txnid', TType.I64, 2)
            oprot.writeI64(self.txnid)
            oprot.writeFieldEnd()
        if self.elapsed_ms is not None:
            oprot.writeFieldBegin('elapsed_ms', TType.I64, 3)
            oprot.writeI64(self.elapsed_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lockid is None:
            raise TProtocolException(message='Required field lockid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnlockRequest(object):
    """
    Attributes:
     - lockid

    """


    def __init__(self, lockid=None,):
        self.lockid = lockid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.lockid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnlockRequest')
        if self.lockid is not None:
            oprot.writeFieldBegin('lockid', TType.I64, 1)
            oprot.writeI64(self.lockid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lockid is None:
            raise TProtocolException(message='Required field lockid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowLocksRequest(object):
    """
    Attributes:
     - dbname
     - tablename
     - partname
     - isExtended

    """


    def __init__(self, dbname=None, tablename=None, partname=None, isExtended=False,):
        self.dbname = dbname
        self.tablename = tablename
        self.partname = partname
        self.isExtended = isExtended

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tablename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.partname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isExtended = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowLocksRequest')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tablename is not None:
            oprot.writeFieldBegin('tablename', TType.STRING, 2)
            oprot.writeString(self.tablename.encode('utf-8') if sys.version_info[0] == 2 else self.tablename)
            oprot.writeFieldEnd()
        if self.partname is not None:
            oprot.writeFieldBegin('partname', TType.STRING, 3)
            oprot.writeString(self.partname.encode('utf-8') if sys.version_info[0] == 2 else self.partname)
            oprot.writeFieldEnd()
        if self.isExtended is not None:
            oprot.writeFieldBegin('isExtended', TType.BOOL, 4)
            oprot.writeBool(self.isExtended)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowLocksResponseElement(object):
    """
    Attributes:
     - lockid
     - dbname
     - tablename
     - partname
     - state
     - type
     - txnid
     - lastheartbeat
     - acquiredat
     - user
     - hostname
     - heartbeatCount
     - agentInfo
     - blockedByExtId
     - blockedByIntId
     - lockIdInternal

    """


    def __init__(self, lockid=None, dbname=None, tablename=None, partname=None, state=None, type=None, txnid=None, lastheartbeat=None, acquiredat=None, user=None, hostname=None, heartbeatCount=0, agentInfo=None, blockedByExtId=None, blockedByIntId=None, lockIdInternal=None,):
        self.lockid = lockid
        self.dbname = dbname
        self.tablename = tablename
        self.partname = partname
        self.state = state
        self.type = type
        self.txnid = txnid
        self.lastheartbeat = lastheartbeat
        self.acquiredat = acquiredat
        self.user = user
        self.hostname = hostname
        self.heartbeatCount = heartbeatCount
        self.agentInfo = agentInfo
        self.blockedByExtId = blockedByExtId
        self.blockedByIntId = blockedByIntId
        self.lockIdInternal = lockIdInternal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.lockid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tablename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.partname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.txnid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.lastheartbeat = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.acquiredat = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.hostname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.heartbeatCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.agentInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.blockedByExtId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I64:
                    self.blockedByIntId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I64:
                    self.lockIdInternal = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowLocksResponseElement')
        if self.lockid is not None:
            oprot.writeFieldBegin('lockid', TType.I64, 1)
            oprot.writeI64(self.lockid)
            oprot.writeFieldEnd()
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 2)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tablename is not None:
            oprot.writeFieldBegin('tablename', TType.STRING, 3)
            oprot.writeString(self.tablename.encode('utf-8') if sys.version_info[0] == 2 else self.tablename)
            oprot.writeFieldEnd()
        if self.partname is not None:
            oprot.writeFieldBegin('partname', TType.STRING, 4)
            oprot.writeString(self.partname.encode('utf-8') if sys.version_info[0] == 2 else self.partname)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 5)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 6)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.txnid is not None:
            oprot.writeFieldBegin('txnid', TType.I64, 7)
            oprot.writeI64(self.txnid)
            oprot.writeFieldEnd()
        if self.lastheartbeat is not None:
            oprot.writeFieldBegin('lastheartbeat', TType.I64, 8)
            oprot.writeI64(self.lastheartbeat)
            oprot.writeFieldEnd()
        if self.acquiredat is not None:
            oprot.writeFieldBegin('acquiredat', TType.I64, 9)
            oprot.writeI64(self.acquiredat)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 10)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.hostname is not None:
            oprot.writeFieldBegin('hostname', TType.STRING, 11)
            oprot.writeString(self.hostname.encode('utf-8') if sys.version_info[0] == 2 else self.hostname)
            oprot.writeFieldEnd()
        if self.heartbeatCount is not None:
            oprot.writeFieldBegin('heartbeatCount', TType.I32, 12)
            oprot.writeI32(self.heartbeatCount)
            oprot.writeFieldEnd()
        if self.agentInfo is not None:
            oprot.writeFieldBegin('agentInfo', TType.STRING, 13)
            oprot.writeString(self.agentInfo.encode('utf-8') if sys.version_info[0] == 2 else self.agentInfo)
            oprot.writeFieldEnd()
        if self.blockedByExtId is not None:
            oprot.writeFieldBegin('blockedByExtId', TType.I64, 14)
            oprot.writeI64(self.blockedByExtId)
            oprot.writeFieldEnd()
        if self.blockedByIntId is not None:
            oprot.writeFieldBegin('blockedByIntId', TType.I64, 15)
            oprot.writeI64(self.blockedByIntId)
            oprot.writeFieldEnd()
        if self.lockIdInternal is not None:
            oprot.writeFieldBegin('lockIdInternal', TType.I64, 16)
            oprot.writeI64(self.lockIdInternal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lockid is None:
            raise TProtocolException(message='Required field lockid is unset!')
        if self.dbname is None:
            raise TProtocolException(message='Required field dbname is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.lastheartbeat is None:
            raise TProtocolException(message='Required field lastheartbeat is unset!')
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        if self.hostname is None:
            raise TProtocolException(message='Required field hostname is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowLocksResponse(object):
    """
    Attributes:
     - locks

    """


    def __init__(self, locks=None,):
        self.locks = locks

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.locks = []
                    (_etype472, _size469) = iprot.readListBegin()
                    for _i473 in range(_size469):
                        _elem474 = ShowLocksResponseElement()
                        _elem474.read(iprot)
                        self.locks.append(_elem474)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowLocksResponse')
        if self.locks is not None:
            oprot.writeFieldBegin('locks', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.locks))
            for iter475 in self.locks:
                iter475.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HeartbeatRequest(object):
    """
    Attributes:
     - lockid
     - txnid

    """


    def __init__(self, lockid=None, txnid=None,):
        self.lockid = lockid
        self.txnid = txnid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.lockid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.txnid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HeartbeatRequest')
        if self.lockid is not None:
            oprot.writeFieldBegin('lockid', TType.I64, 1)
            oprot.writeI64(self.lockid)
            oprot.writeFieldEnd()
        if self.txnid is not None:
            oprot.writeFieldBegin('txnid', TType.I64, 2)
            oprot.writeI64(self.txnid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HeartbeatTxnRangeRequest(object):
    """
    Attributes:
     - min
     - max

    """


    def __init__(self, min=None, max=None,):
        self.min = min
        self.max = max

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.min = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HeartbeatTxnRangeRequest')
        if self.min is not None:
            oprot.writeFieldBegin('min', TType.I64, 1)
            oprot.writeI64(self.min)
            oprot.writeFieldEnd()
        if self.max is not None:
            oprot.writeFieldBegin('max', TType.I64, 2)
            oprot.writeI64(self.max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.min is None:
            raise TProtocolException(message='Required field min is unset!')
        if self.max is None:
            raise TProtocolException(message='Required field max is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HeartbeatTxnRangeResponse(object):
    """
    Attributes:
     - aborted
     - nosuch

    """


    def __init__(self, aborted=None, nosuch=None,):
        self.aborted = aborted
        self.nosuch = nosuch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.aborted = set()
                    (_etype479, _size476) = iprot.readSetBegin()
                    for _i480 in range(_size476):
                        _elem481 = iprot.readI64()
                        self.aborted.add(_elem481)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.nosuch = set()
                    (_etype485, _size482) = iprot.readSetBegin()
                    for _i486 in range(_size482):
                        _elem487 = iprot.readI64()
                        self.nosuch.add(_elem487)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HeartbeatTxnRangeResponse')
        if self.aborted is not None:
            oprot.writeFieldBegin('aborted', TType.SET, 1)
            oprot.writeSetBegin(TType.I64, len(self.aborted))
            for iter488 in self.aborted:
                oprot.writeI64(iter488)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.nosuch is not None:
            oprot.writeFieldBegin('nosuch', TType.SET, 2)
            oprot.writeSetBegin(TType.I64, len(self.nosuch))
            for iter489 in self.nosuch:
                oprot.writeI64(iter489)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.aborted is None:
            raise TProtocolException(message='Required field aborted is unset!')
        if self.nosuch is None:
            raise TProtocolException(message='Required field nosuch is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CompactionRequest(object):
    """
    Attributes:
     - dbname
     - tablename
     - partitionname
     - type
     - runas
     - properties

    """


    def __init__(self, dbname=None, tablename=None, partitionname=None, type=None, runas=None, properties=None,):
        self.dbname = dbname
        self.tablename = tablename
        self.partitionname = partitionname
        self.type = type
        self.runas = runas
        self.properties = properties

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tablename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.partitionname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.runas = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.properties = {}
                    (_ktype491, _vtype492, _size490) = iprot.readMapBegin()
                    for _i494 in range(_size490):
                        _key495 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val496 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.properties[_key495] = _val496
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CompactionRequest')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tablename is not None:
            oprot.writeFieldBegin('tablename', TType.STRING, 2)
            oprot.writeString(self.tablename.encode('utf-8') if sys.version_info[0] == 2 else self.tablename)
            oprot.writeFieldEnd()
        if self.partitionname is not None:
            oprot.writeFieldBegin('partitionname', TType.STRING, 3)
            oprot.writeString(self.partitionname.encode('utf-8') if sys.version_info[0] == 2 else self.partitionname)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.runas is not None:
            oprot.writeFieldBegin('runas', TType.STRING, 5)
            oprot.writeString(self.runas.encode('utf-8') if sys.version_info[0] == 2 else self.runas)
            oprot.writeFieldEnd()
        if self.properties is not None:
            oprot.writeFieldBegin('properties', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
            for kiter497, viter498 in self.properties.items():
                oprot.writeString(kiter497.encode('utf-8') if sys.version_info[0] == 2 else kiter497)
                oprot.writeString(viter498.encode('utf-8') if sys.version_info[0] == 2 else viter498)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbname is None:
            raise TProtocolException(message='Required field dbname is unset!')
        if self.tablename is None:
            raise TProtocolException(message='Required field tablename is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CompactionResponse(object):
    """
    Attributes:
     - id
     - state
     - accepted

    """


    def __init__(self, id=None, state=None, accepted=None,):
        self.id = id
        self.state = state
        self.accepted = accepted

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.accepted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CompactionResponse')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRING, 2)
            oprot.writeString(self.state.encode('utf-8') if sys.version_info[0] == 2 else self.state)
            oprot.writeFieldEnd()
        if self.accepted is not None:
            oprot.writeFieldBegin('accepted', TType.BOOL, 3)
            oprot.writeBool(self.accepted)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        if self.accepted is None:
            raise TProtocolException(message='Required field accepted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowCompactRequest(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowCompactRequest')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowCompactResponseElement(object):
    """
    Attributes:
     - dbname
     - tablename
     - partitionname
     - type
     - state
     - workerid
     - start
     - runAs
     - hightestTxnId
     - metaInfo
     - endTime
     - hadoopJobId
     - id

    """


    def __init__(self, dbname=None, tablename=None, partitionname=None, type=None, state=None, workerid=None, start=None, runAs=None, hightestTxnId=None, metaInfo=None, endTime=None, hadoopJobId="None", id=None,):
        self.dbname = dbname
        self.tablename = tablename
        self.partitionname = partitionname
        self.type = type
        self.state = state
        self.workerid = workerid
        self.start = start
        self.runAs = runAs
        self.hightestTxnId = hightestTxnId
        self.metaInfo = metaInfo
        self.endTime = endTime
        self.hadoopJobId = hadoopJobId
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tablename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.partitionname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.workerid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.start = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.runAs = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.hightestTxnId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.metaInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.hadoopJobId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowCompactResponseElement')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tablename is not None:
            oprot.writeFieldBegin('tablename', TType.STRING, 2)
            oprot.writeString(self.tablename.encode('utf-8') if sys.version_info[0] == 2 else self.tablename)
            oprot.writeFieldEnd()
        if self.partitionname is not None:
            oprot.writeFieldBegin('partitionname', TType.STRING, 3)
            oprot.writeString(self.partitionname.encode('utf-8') if sys.version_info[0] == 2 else self.partitionname)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRING, 5)
            oprot.writeString(self.state.encode('utf-8') if sys.version_info[0] == 2 else self.state)
            oprot.writeFieldEnd()
        if self.workerid is not None:
            oprot.writeFieldBegin('workerid', TType.STRING, 6)
            oprot.writeString(self.workerid.encode('utf-8') if sys.version_info[0] == 2 else self.workerid)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I64, 7)
            oprot.writeI64(self.start)
            oprot.writeFieldEnd()
        if self.runAs is not None:
            oprot.writeFieldBegin('runAs', TType.STRING, 8)
            oprot.writeString(self.runAs.encode('utf-8') if sys.version_info[0] == 2 else self.runAs)
            oprot.writeFieldEnd()
        if self.hightestTxnId is not None:
            oprot.writeFieldBegin('hightestTxnId', TType.I64, 9)
            oprot.writeI64(self.hightestTxnId)
            oprot.writeFieldEnd()
        if self.metaInfo is not None:
            oprot.writeFieldBegin('metaInfo', TType.STRING, 10)
            oprot.writeString(self.metaInfo.encode('utf-8') if sys.version_info[0] == 2 else self.metaInfo)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 11)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.hadoopJobId is not None:
            oprot.writeFieldBegin('hadoopJobId', TType.STRING, 12)
            oprot.writeString(self.hadoopJobId.encode('utf-8') if sys.version_info[0] == 2 else self.hadoopJobId)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 13)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbname is None:
            raise TProtocolException(message='Required field dbname is unset!')
        if self.tablename is None:
            raise TProtocolException(message='Required field tablename is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShowCompactResponse(object):
    """
    Attributes:
     - compacts

    """


    def __init__(self, compacts=None,):
        self.compacts = compacts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.compacts = []
                    (_etype502, _size499) = iprot.readListBegin()
                    for _i503 in range(_size499):
                        _elem504 = ShowCompactResponseElement()
                        _elem504.read(iprot)
                        self.compacts.append(_elem504)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShowCompactResponse')
        if self.compacts is not None:
            oprot.writeFieldBegin('compacts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.compacts))
            for iter505 in self.compacts:
                iter505.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.compacts is None:
            raise TProtocolException(message='Required field compacts is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AddDynamicPartitions(object):
    """
    Attributes:
     - txnid
     - dbname
     - tablename
     - partitionnames
     - operationType

    """


    def __init__(self, txnid=None, dbname=None, tablename=None, partitionnames=None, operationType=5,):
        self.txnid = txnid
        self.dbname = dbname
        self.tablename = tablename
        self.partitionnames = partitionnames
        self.operationType = operationType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.txnid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tablename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partitionnames = []
                    (_etype509, _size506) = iprot.readListBegin()
                    for _i510 in range(_size506):
                        _elem511 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.partitionnames.append(_elem511)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.operationType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AddDynamicPartitions')
        if self.txnid is not None:
            oprot.writeFieldBegin('txnid', TType.I64, 1)
            oprot.writeI64(self.txnid)
            oprot.writeFieldEnd()
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 2)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tablename is not None:
            oprot.writeFieldBegin('tablename', TType.STRING, 3)
            oprot.writeString(self.tablename.encode('utf-8') if sys.version_info[0] == 2 else self.tablename)
            oprot.writeFieldEnd()
        if self.partitionnames is not None:
            oprot.writeFieldBegin('partitionnames', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.partitionnames))
            for iter512 in self.partitionnames:
                oprot.writeString(iter512.encode('utf-8') if sys.version_info[0] == 2 else iter512)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operationType is not None:
            oprot.writeFieldBegin('operationType', TType.I32, 5)
            oprot.writeI32(self.operationType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.txnid is None:
            raise TProtocolException(message='Required field txnid is unset!')
        if self.dbname is None:
            raise TProtocolException(message='Required field dbname is unset!')
        if self.tablename is None:
            raise TProtocolException(message='Required field tablename is unset!')
        if self.partitionnames is None:
            raise TProtocolException(message='Required field partitionnames is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NotificationEventRequest(object):
    """
    Attributes:
     - lastEvent
     - maxEvents

    """


    def __init__(self, lastEvent=None, maxEvents=None,):
        self.lastEvent = lastEvent
        self.maxEvents = maxEvents

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.lastEvent = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.maxEvents = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotificationEventRequest')
        if self.lastEvent is not None:
            oprot.writeFieldBegin('lastEvent', TType.I64, 1)
            oprot.writeI64(self.lastEvent)
            oprot.writeFieldEnd()
        if self.maxEvents is not None:
            oprot.writeFieldBegin('maxEvents', TType.I32, 2)
            oprot.writeI32(self.maxEvents)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lastEvent is None:
            raise TProtocolException(message='Required field lastEvent is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NotificationEvent(object):
    """
    Attributes:
     - eventId
     - eventTime
     - eventType
     - dbName
     - tableName
     - message
     - messageFormat

    """


    def __init__(self, eventId=None, eventTime=None, eventType=None, dbName=None, tableName=None, message=None, messageFormat=None,):
        self.eventId = eventId
        self.eventTime = eventTime
        self.eventType = eventType
        self.dbName = dbName
        self.tableName = tableName
        self.message = message
        self.messageFormat = messageFormat

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.eventId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.eventTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.eventType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.messageFormat = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotificationEvent')
        if self.eventId is not None:
            oprot.writeFieldBegin('eventId', TType.I64, 1)
            oprot.writeI64(self.eventId)
            oprot.writeFieldEnd()
        if self.eventTime is not None:
            oprot.writeFieldBegin('eventTime', TType.I32, 2)
            oprot.writeI32(self.eventTime)
            oprot.writeFieldEnd()
        if self.eventType is not None:
            oprot.writeFieldBegin('eventType', TType.STRING, 3)
            oprot.writeString(self.eventType.encode('utf-8') if sys.version_info[0] == 2 else self.eventType)
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 4)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 5)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 6)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.messageFormat is not None:
            oprot.writeFieldBegin('messageFormat', TType.STRING, 7)
            oprot.writeString(self.messageFormat.encode('utf-8') if sys.version_info[0] == 2 else self.messageFormat)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.eventId is None:
            raise TProtocolException(message='Required field eventId is unset!')
        if self.eventTime is None:
            raise TProtocolException(message='Required field eventTime is unset!')
        if self.eventType is None:
            raise TProtocolException(message='Required field eventType is unset!')
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NotificationEventResponse(object):
    """
    Attributes:
     - events

    """


    def __init__(self, events=None,):
        self.events = events

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.events = []
                    (_etype516, _size513) = iprot.readListBegin()
                    for _i517 in range(_size513):
                        _elem518 = NotificationEvent()
                        _elem518.read(iprot)
                        self.events.append(_elem518)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotificationEventResponse')
        if self.events is not None:
            oprot.writeFieldBegin('events', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.events))
            for iter519 in self.events:
                iter519.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.events is None:
            raise TProtocolException(message='Required field events is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CurrentNotificationEventId(object):
    """
    Attributes:
     - eventId

    """


    def __init__(self, eventId=None,):
        self.eventId = eventId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.eventId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CurrentNotificationEventId')
        if self.eventId is not None:
            oprot.writeFieldBegin('eventId', TType.I64, 1)
            oprot.writeI64(self.eventId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.eventId is None:
            raise TProtocolException(message='Required field eventId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InsertEventRequestData(object):
    """
    Attributes:
     - filesAdded
     - filesAddedChecksum

    """


    def __init__(self, filesAdded=None, filesAddedChecksum=None,):
        self.filesAdded = filesAdded
        self.filesAddedChecksum = filesAddedChecksum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.filesAdded = []
                    (_etype523, _size520) = iprot.readListBegin()
                    for _i524 in range(_size520):
                        _elem525 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.filesAdded.append(_elem525)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.filesAddedChecksum = []
                    (_etype529, _size526) = iprot.readListBegin()
                    for _i530 in range(_size526):
                        _elem531 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.filesAddedChecksum.append(_elem531)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InsertEventRequestData')
        if self.filesAdded is not None:
            oprot.writeFieldBegin('filesAdded', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.filesAdded))
            for iter532 in self.filesAdded:
                oprot.writeString(iter532.encode('utf-8') if sys.version_info[0] == 2 else iter532)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.filesAddedChecksum is not None:
            oprot.writeFieldBegin('filesAddedChecksum', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.filesAddedChecksum))
            for iter533 in self.filesAddedChecksum:
                oprot.writeString(iter533.encode('utf-8') if sys.version_info[0] == 2 else iter533)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.filesAdded is None:
            raise TProtocolException(message='Required field filesAdded is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FireEventRequestData(object):
    """
    Attributes:
     - insertData

    """


    def __init__(self, insertData=None,):
        self.insertData = insertData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.insertData = InsertEventRequestData()
                    self.insertData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FireEventRequestData')
        if self.insertData is not None:
            oprot.writeFieldBegin('insertData', TType.STRUCT, 1)
            self.insertData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FireEventRequest(object):
    """
    Attributes:
     - successful
     - data
     - dbName
     - tableName
     - partitionVals

    """


    def __init__(self, successful=None, data=None, dbName=None, tableName=None, partitionVals=None,):
        self.successful = successful
        self.data = data
        self.dbName = dbName
        self.tableName = tableName
        self.partitionVals = partitionVals

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.successful = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.data = FireEventRequestData()
                    self.data.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.partitionVals = []
                    (_etype537, _size534) = iprot.readListBegin()
                    for _i538 in range(_size534):
                        _elem539 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.partitionVals.append(_elem539)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FireEventRequest')
        if self.successful is not None:
            oprot.writeFieldBegin('successful', TType.BOOL, 1)
            oprot.writeBool(self.successful)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRUCT, 2)
            self.data.write(oprot)
            oprot.writeFieldEnd()
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 3)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 4)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.partitionVals is not None:
            oprot.writeFieldBegin('partitionVals', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.partitionVals))
            for iter540 in self.partitionVals:
                oprot.writeString(iter540.encode('utf-8') if sys.version_info[0] == 2 else iter540)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.successful is None:
            raise TProtocolException(message='Required field successful is unset!')
        if self.data is None:
            raise TProtocolException(message='Required field data is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FireEventResponse(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FireEventResponse')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MetadataPpdResult(object):
    """
    Attributes:
     - metadata
     - includeBitset

    """


    def __init__(self, metadata=None, includeBitset=None,):
        self.metadata = metadata
        self.includeBitset = includeBitset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.metadata = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.includeBitset = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MetadataPpdResult')
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRING, 1)
            oprot.writeBinary(self.metadata)
            oprot.writeFieldEnd()
        if self.includeBitset is not None:
            oprot.writeFieldBegin('includeBitset', TType.STRING, 2)
            oprot.writeBinary(self.includeBitset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetFileMetadataByExprResult(object):
    """
    Attributes:
     - metadata
     - isSupported

    """


    def __init__(self, metadata=None, isSupported=None,):
        self.metadata = metadata
        self.isSupported = isSupported

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype542, _vtype543, _size541) = iprot.readMapBegin()
                    for _i545 in range(_size541):
                        _key546 = iprot.readI64()
                        _val547 = MetadataPpdResult()
                        _val547.read(iprot)
                        self.metadata[_key546] = _val547
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isSupported = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFileMetadataByExprResult')
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 1)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.metadata))
            for kiter548, viter549 in self.metadata.items():
                oprot.writeI64(kiter548)
                viter549.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.isSupported is not None:
            oprot.writeFieldBegin('isSupported', TType.BOOL, 2)
            oprot.writeBool(self.isSupported)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        if self.isSupported is None:
            raise TProtocolException(message='Required field isSupported is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetFileMetadataByExprRequest(object):
    """
    Attributes:
     - fileIds
     - expr
     - doGetFooters
     - type

    """


    def __init__(self, fileIds=None, expr=None, doGetFooters=None, type=None,):
        self.fileIds = fileIds
        self.expr = expr
        self.doGetFooters = doGetFooters
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fileIds = []
                    (_etype553, _size550) = iprot.readListBegin()
                    for _i554 in range(_size550):
                        _elem555 = iprot.readI64()
                        self.fileIds.append(_elem555)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.expr = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.doGetFooters = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFileMetadataByExprRequest')
        if self.fileIds is not None:
            oprot.writeFieldBegin('fileIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.fileIds))
            for iter556 in self.fileIds:
                oprot.writeI64(iter556)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.expr is not None:
            oprot.writeFieldBegin('expr', TType.STRING, 2)
            oprot.writeBinary(self.expr)
            oprot.writeFieldEnd()
        if self.doGetFooters is not None:
            oprot.writeFieldBegin('doGetFooters', TType.BOOL, 3)
            oprot.writeBool(self.doGetFooters)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fileIds is None:
            raise TProtocolException(message='Required field fileIds is unset!')
        if self.expr is None:
            raise TProtocolException(message='Required field expr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetFileMetadataResult(object):
    """
    Attributes:
     - metadata
     - isSupported

    """


    def __init__(self, metadata=None, isSupported=None,):
        self.metadata = metadata
        self.isSupported = isSupported

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype558, _vtype559, _size557) = iprot.readMapBegin()
                    for _i561 in range(_size557):
                        _key562 = iprot.readI64()
                        _val563 = iprot.readBinary()
                        self.metadata[_key562] = _val563
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isSupported = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFileMetadataResult')
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 1)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.metadata))
            for kiter564, viter565 in self.metadata.items():
                oprot.writeI64(kiter564)
                oprot.writeBinary(viter565)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.isSupported is not None:
            oprot.writeFieldBegin('isSupported', TType.BOOL, 2)
            oprot.writeBool(self.isSupported)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        if self.isSupported is None:
            raise TProtocolException(message='Required field isSupported is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetFileMetadataRequest(object):
    """
    Attributes:
     - fileIds

    """


    def __init__(self, fileIds=None,):
        self.fileIds = fileIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fileIds = []
                    (_etype569, _size566) = iprot.readListBegin()
                    for _i570 in range(_size566):
                        _elem571 = iprot.readI64()
                        self.fileIds.append(_elem571)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFileMetadataRequest')
        if self.fileIds is not None:
            oprot.writeFieldBegin('fileIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.fileIds))
            for iter572 in self.fileIds:
                oprot.writeI64(iter572)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fileIds is None:
            raise TProtocolException(message='Required field fileIds is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PutFileMetadataResult(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PutFileMetadataResult')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PutFileMetadataRequest(object):
    """
    Attributes:
     - fileIds
     - metadata
     - type

    """


    def __init__(self, fileIds=None, metadata=None, type=None,):
        self.fileIds = fileIds
        self.metadata = metadata
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fileIds = []
                    (_etype576, _size573) = iprot.readListBegin()
                    for _i577 in range(_size573):
                        _elem578 = iprot.readI64()
                        self.fileIds.append(_elem578)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.metadata = []
                    (_etype582, _size579) = iprot.readListBegin()
                    for _i583 in range(_size579):
                        _elem584 = iprot.readBinary()
                        self.metadata.append(_elem584)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PutFileMetadataRequest')
        if self.fileIds is not None:
            oprot.writeFieldBegin('fileIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.fileIds))
            for iter585 in self.fileIds:
                oprot.writeI64(iter585)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.metadata))
            for iter586 in self.metadata:
                oprot.writeBinary(iter586)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fileIds is None:
            raise TProtocolException(message='Required field fileIds is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ClearFileMetadataResult(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ClearFileMetadataResult')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ClearFileMetadataRequest(object):
    """
    Attributes:
     - fileIds

    """


    def __init__(self, fileIds=None,):
        self.fileIds = fileIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fileIds = []
                    (_etype590, _size587) = iprot.readListBegin()
                    for _i591 in range(_size587):
                        _elem592 = iprot.readI64()
                        self.fileIds.append(_elem592)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ClearFileMetadataRequest')
        if self.fileIds is not None:
            oprot.writeFieldBegin('fileIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.fileIds))
            for iter593 in self.fileIds:
                oprot.writeI64(iter593)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fileIds is None:
            raise TProtocolException(message='Required field fileIds is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CacheFileMetadataResult(object):
    """
    Attributes:
     - isSupported

    """


    def __init__(self, isSupported=None,):
        self.isSupported = isSupported

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.isSupported = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CacheFileMetadataResult')
        if self.isSupported is not None:
            oprot.writeFieldBegin('isSupported', TType.BOOL, 1)
            oprot.writeBool(self.isSupported)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.isSupported is None:
            raise TProtocolException(message='Required field isSupported is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CacheFileMetadataRequest(object):
    """
    Attributes:
     - dbName
     - tblName
     - partName
     - isAllParts

    """


    def __init__(self, dbName=None, tblName=None, partName=None, isAllParts=None,):
        self.dbName = dbName
        self.tblName = tblName
        self.partName = partName
        self.isAllParts = isAllParts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tblName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.partName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isAllParts = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CacheFileMetadataRequest')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tblName is not None:
            oprot.writeFieldBegin('tblName', TType.STRING, 2)
            oprot.writeString(self.tblName.encode('utf-8') if sys.version_info[0] == 2 else self.tblName)
            oprot.writeFieldEnd()
        if self.partName is not None:
            oprot.writeFieldBegin('partName', TType.STRING, 3)
            oprot.writeString(self.partName.encode('utf-8') if sys.version_info[0] == 2 else self.partName)
            oprot.writeFieldEnd()
        if self.isAllParts is not None:
            oprot.writeFieldBegin('isAllParts', TType.BOOL, 4)
            oprot.writeBool(self.isAllParts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        if self.tblName is None:
            raise TProtocolException(message='Required field tblName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetAllFunctionsResponse(object):
    """
    Attributes:
     - functions

    """


    def __init__(self, functions=None,):
        self.functions = functions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.functions = []
                    (_etype597, _size594) = iprot.readListBegin()
                    for _i598 in range(_size594):
                        _elem599 = Function()
                        _elem599.read(iprot)
                        self.functions.append(_elem599)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAllFunctionsResponse')
        if self.functions is not None:
            oprot.writeFieldBegin('functions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.functions))
            for iter600 in self.functions:
                iter600.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ClientCapabilities(object):
    """
    Attributes:
     - values

    """


    def __init__(self, values=None,):
        self.values = values

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype604, _size601) = iprot.readListBegin()
                    for _i605 in range(_size601):
                        _elem606 = iprot.readI32()
                        self.values.append(_elem606)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ClientCapabilities')
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.values))
            for iter607 in self.values:
                oprot.writeI32(iter607)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetTableRequest(object):
    """
    Attributes:
     - dbName
     - tblName
     - capabilities

    """


    def __init__(self, dbName=None, tblName=None, capabilities=None,):
        self.dbName = dbName
        self.tblName = tblName
        self.capabilities = capabilities

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tblName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.capabilities = ClientCapabilities()
                    self.capabilities.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTableRequest')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tblName is not None:
            oprot.writeFieldBegin('tblName', TType.STRING, 2)
            oprot.writeString(self.tblName.encode('utf-8') if sys.version_info[0] == 2 else self.tblName)
            oprot.writeFieldEnd()
        if self.capabilities is not None:
            oprot.writeFieldBegin('capabilities', TType.STRUCT, 3)
            self.capabilities.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        if self.tblName is None:
            raise TProtocolException(message='Required field tblName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetTableResult(object):
    """
    Attributes:
     - table

    """


    def __init__(self, table=None,):
        self.table = table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table = Table()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTableResult')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 1)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table is None:
            raise TProtocolException(message='Required field table is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetTablesRequest(object):
    """
    Attributes:
     - dbName
     - tblNames
     - capabilities

    """


    def __init__(self, dbName=None, tblNames=None, capabilities=None,):
        self.dbName = dbName
        self.tblNames = tblNames
        self.capabilities = capabilities

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tblNames = []
                    (_etype611, _size608) = iprot.readListBegin()
                    for _i612 in range(_size608):
                        _elem613 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tblNames.append(_elem613)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.capabilities = ClientCapabilities()
                    self.capabilities.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTablesRequest')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tblNames is not None:
            oprot.writeFieldBegin('tblNames', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.tblNames))
            for iter614 in self.tblNames:
                oprot.writeString(iter614.encode('utf-8') if sys.version_info[0] == 2 else iter614)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.capabilities is not None:
            oprot.writeFieldBegin('capabilities', TType.STRUCT, 3)
            self.capabilities.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetTablesResult(object):
    """
    Attributes:
     - tables

    """


    def __init__(self, tables=None,):
        self.tables = tables

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tables = []
                    (_etype618, _size615) = iprot.readListBegin()
                    for _i619 in range(_size615):
                        _elem620 = Table()
                        _elem620.read(iprot)
                        self.tables.append(_elem620)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetTablesResult')
        if self.tables is not None:
            oprot.writeFieldBegin('tables', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.tables))
            for iter621 in self.tables:
                iter621.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tables is None:
            raise TProtocolException(message='Required field tables is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableMeta(object):
    """
    Attributes:
     - dbName
     - tableName
     - tableType
     - comments

    """


    def __init__(self, dbName=None, tableName=None, tableType=None, comments=None,):
        self.dbName = dbName
        self.tableName = tableName
        self.tableType = tableType
        self.comments = comments

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tableType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.comments = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TableMeta')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.tableType is not None:
            oprot.writeFieldBegin('tableType', TType.STRING, 3)
            oprot.writeString(self.tableType.encode('utf-8') if sys.version_info[0] == 2 else self.tableType)
            oprot.writeFieldEnd()
        if self.comments is not None:
            oprot.writeFieldBegin('comments', TType.STRING, 4)
            oprot.writeString(self.comments.encode('utf-8') if sys.version_info[0] == 2 else self.comments)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbName is None:
            raise TProtocolException(message='Required field dbName is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.tableType is None:
            raise TProtocolException(message='Required field tableType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MetaException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(MetaException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MetaException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnknownTableException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(UnknownTableException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnknownTableException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnknownDBException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(UnknownDBException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnknownDBException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlreadyExistsException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(AlreadyExistsException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlreadyExistsException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidPartitionException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(InvalidPartitionException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidPartitionException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnknownPartitionException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(UnknownPartitionException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnknownPartitionException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidObjectException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(InvalidObjectException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidObjectException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoSuchObjectException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(NoSuchObjectException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoSuchObjectException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IndexAlreadyExistsException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(IndexAlreadyExistsException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IndexAlreadyExistsException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidOperationException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(InvalidOperationException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidOperationException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfigValSecurityException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(ConfigValSecurityException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfigValSecurityException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidInputException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(InvalidInputException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidInputException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoSuchTxnException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(NoSuchTxnException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoSuchTxnException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TxnAbortedException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(TxnAbortedException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TxnAbortedException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TxnOpenException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(TxnOpenException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TxnOpenException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoSuchLockException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(NoSuchLockException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoSuchLockException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Version)
Version.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'version', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'comments', 'UTF8', None, ),  # 2
)
all_structs.append(FieldSchema)
FieldSchema.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'type', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'comment', 'UTF8', None, ),  # 3
)
all_structs.append(SQLPrimaryKey)
SQLPrimaryKey.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table_db', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'column_name', 'UTF8', None, ),  # 3
    (4, TType.I32, 'key_seq', None, None, ),  # 4
    (5, TType.STRING, 'pk_name', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'enable_cstr', None, None, ),  # 6
    (7, TType.BOOL, 'validate_cstr', None, None, ),  # 7
    (8, TType.BOOL, 'rely_cstr', None, None, ),  # 8
)
all_structs.append(SQLForeignKey)
SQLForeignKey.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pktable_db', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pktable_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'pkcolumn_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'fktable_db', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'fktable_name', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'fkcolumn_name', 'UTF8', None, ),  # 6
    (7, TType.I32, 'key_seq', None, None, ),  # 7
    (8, TType.I32, 'update_rule', None, None, ),  # 8
    (9, TType.I32, 'delete_rule', None, None, ),  # 9
    (10, TType.STRING, 'fk_name', 'UTF8', None, ),  # 10
    (11, TType.STRING, 'pk_name', 'UTF8', None, ),  # 11
    (12, TType.BOOL, 'enable_cstr', None, None, ),  # 12
    (13, TType.BOOL, 'validate_cstr', None, None, ),  # 13
    (14, TType.BOOL, 'rely_cstr', None, None, ),  # 14
)
all_structs.append(Type)
Type.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'type1', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'type2', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'fields', (TType.STRUCT, [FieldSchema, None], False), None, ),  # 4
)
all_structs.append(HiveObjectRef)
HiveObjectRef.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'objectType', None, None, ),  # 1
    (2, TType.STRING, 'dbName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'objectName', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'partValues', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRING, 'columnName', 'UTF8', None, ),  # 5
)
all_structs.append(PrivilegeGrantInfo)
PrivilegeGrantInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'privilege', 'UTF8', None, ),  # 1
    (2, TType.I32, 'createTime', None, None, ),  # 2
    (3, TType.STRING, 'grantor', 'UTF8', None, ),  # 3
    (4, TType.I32, 'grantorType', None, None, ),  # 4
    (5, TType.BOOL, 'grantOption', None, None, ),  # 5
)
all_structs.append(HiveObjectPrivilege)
HiveObjectPrivilege.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hiveObject', [HiveObjectRef, None], None, ),  # 1
    (2, TType.STRING, 'principalName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'principalType', None, None, ),  # 3
    (4, TType.STRUCT, 'grantInfo', [PrivilegeGrantInfo, None], None, ),  # 4
)
all_structs.append(PrivilegeBag)
PrivilegeBag.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'privileges', (TType.STRUCT, [HiveObjectPrivilege, None], False), None, ),  # 1
)
all_structs.append(PrincipalPrivilegeSet)
PrincipalPrivilegeSet.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'userPrivileges', (TType.STRING, 'UTF8', TType.LIST, (TType.STRUCT, [PrivilegeGrantInfo, None], False), False), None, ),  # 1
    (2, TType.MAP, 'groupPrivileges', (TType.STRING, 'UTF8', TType.LIST, (TType.STRUCT, [PrivilegeGrantInfo, None], False), False), None, ),  # 2
    (3, TType.MAP, 'rolePrivileges', (TType.STRING, 'UTF8', TType.LIST, (TType.STRUCT, [PrivilegeGrantInfo, None], False), False), None, ),  # 3
)
all_structs.append(GrantRevokePrivilegeRequest)
GrantRevokePrivilegeRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'requestType', None, None, ),  # 1
    (2, TType.STRUCT, 'privileges', [PrivilegeBag, None], None, ),  # 2
    (3, TType.BOOL, 'revokeGrantOption', None, None, ),  # 3
)
all_structs.append(GrantRevokePrivilegeResponse)
GrantRevokePrivilegeResponse.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'success', None, None, ),  # 1
)
all_structs.append(Role)
Role.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'roleName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'createTime', None, None, ),  # 2
    (3, TType.STRING, 'ownerName', 'UTF8', None, ),  # 3
)
all_structs.append(RolePrincipalGrant)
RolePrincipalGrant.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'roleName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'principalName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'principalType', None, None, ),  # 3
    (4, TType.BOOL, 'grantOption', None, None, ),  # 4
    (5, TType.I32, 'grantTime', None, None, ),  # 5
    (6, TType.STRING, 'grantorName', 'UTF8', None, ),  # 6
    (7, TType.I32, 'grantorPrincipalType', None, None, ),  # 7
)
all_structs.append(GetRoleGrantsForPrincipalRequest)
GetRoleGrantsForPrincipalRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'principal_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'principal_type', None, None, ),  # 2
)
all_structs.append(GetRoleGrantsForPrincipalResponse)
GetRoleGrantsForPrincipalResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'principalGrants', (TType.STRUCT, [RolePrincipalGrant, None], False), None, ),  # 1
)
all_structs.append(GetPrincipalsInRoleRequest)
GetPrincipalsInRoleRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'roleName', 'UTF8', None, ),  # 1
)
all_structs.append(GetPrincipalsInRoleResponse)
GetPrincipalsInRoleResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'principalGrants', (TType.STRUCT, [RolePrincipalGrant, None], False), None, ),  # 1
)
all_structs.append(GrantRevokeRoleRequest)
GrantRevokeRoleRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'requestType', None, None, ),  # 1
    (2, TType.STRING, 'roleName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'principalName', 'UTF8', None, ),  # 3
    (4, TType.I32, 'principalType', None, None, ),  # 4
    (5, TType.STRING, 'grantor', 'UTF8', None, ),  # 5
    (6, TType.I32, 'grantorType', None, None, ),  # 6
    (7, TType.BOOL, 'grantOption', None, None, ),  # 7
)
all_structs.append(GrantRevokeRoleResponse)
GrantRevokeRoleResponse.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'success', None, None, ),  # 1
)
all_structs.append(Database)
Database.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'description', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'locationUri', 'UTF8', None, ),  # 3
    (4, TType.MAP, 'parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'privileges', [PrincipalPrivilegeSet, None], None, ),  # 5
    (6, TType.STRING, 'ownerName', 'UTF8', None, ),  # 6
    (7, TType.I32, 'ownerType', None, None, ),  # 7
)
all_structs.append(SerDeInfo)
SerDeInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'serializationLib', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(Order)
Order.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'col', 'UTF8', None, ),  # 1
    (2, TType.I32, 'order', None, None, ),  # 2
)
all_structs.append(SkewedInfo)
SkewedInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'skewedColNames', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'skewedColValues', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 2
    (3, TType.MAP, 'skewedColValueLocationMaps', (TType.LIST, (TType.STRING, 'UTF8', False), TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(StorageDescriptor)
StorageDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'cols', (TType.STRUCT, [FieldSchema, None], False), None, ),  # 1
    (2, TType.STRING, 'location', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'inputFormat', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'outputFormat', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'compressed', None, None, ),  # 5
    (6, TType.I32, 'numBuckets', None, None, ),  # 6
    (7, TType.STRUCT, 'serdeInfo', [SerDeInfo, None], None, ),  # 7
    (8, TType.LIST, 'bucketCols', (TType.STRING, 'UTF8', False), None, ),  # 8
    (9, TType.LIST, 'sortCols', (TType.STRUCT, [Order, None], False), None, ),  # 9
    (10, TType.MAP, 'parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 10
    (11, TType.STRUCT, 'skewedInfo', [SkewedInfo, None], None, ),  # 11
    (12, TType.BOOL, 'storedAsSubDirectories', None, None, ),  # 12
)
all_structs.append(Table)
Table.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dbName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'owner', 'UTF8', None, ),  # 3
    (4, TType.I32, 'createTime', None, None, ),  # 4
    (5, TType.I32, 'lastAccessTime', None, None, ),  # 5
    (6, TType.I32, 'retention', None, None, ),  # 6
    (7, TType.STRUCT, 'sd', [StorageDescriptor, None], None, ),  # 7
    (8, TType.LIST, 'partitionKeys', (TType.STRUCT, [FieldSchema, None], False), None, ),  # 8
    (9, TType.MAP, 'parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 9
    (10, TType.STRING, 'viewOriginalText', 'UTF8', None, ),  # 10
    (11, TType.STRING, 'viewExpandedText', 'UTF8', None, ),  # 11
    (12, TType.STRING, 'tableType', 'UTF8', None, ),  # 12
    (13, TType.STRUCT, 'privileges', [PrincipalPrivilegeSet, None], None, ),  # 13
    (14, TType.BOOL, 'temporary', None, False, ),  # 14
    (15, TType.BOOL, 'rewriteEnabled', None, None, ),  # 15
)
all_structs.append(Partition)
Partition.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'values', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'dbName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tableName', 'UTF8', None, ),  # 3
    (4, TType.I32, 'createTime', None, None, ),  # 4
    (5, TType.I32, 'lastAccessTime', None, None, ),  # 5
    (6, TType.STRUCT, 'sd', [StorageDescriptor, None], None, ),  # 6
    (7, TType.MAP, 'parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 7
    (8, TType.STRUCT, 'privileges', [PrincipalPrivilegeSet, None], None, ),  # 8
)
all_structs.append(PartitionWithoutSD)
PartitionWithoutSD.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'values', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'createTime', None, None, ),  # 2
    (3, TType.I32, 'lastAccessTime', None, None, ),  # 3
    (4, TType.STRING, 'relativePath', 'UTF8', None, ),  # 4
    (5, TType.MAP, 'parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.STRUCT, 'privileges', [PrincipalPrivilegeSet, None], None, ),  # 6
)
all_structs.append(PartitionSpecWithSharedSD)
PartitionSpecWithSharedSD.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT, [PartitionWithoutSD, None], False), None, ),  # 1
    (2, TType.STRUCT, 'sd', [StorageDescriptor, None], None, ),  # 2
)
all_structs.append(PartitionListComposingSpec)
PartitionListComposingSpec.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT, [Partition, None], False), None, ),  # 1
)
all_structs.append(PartitionSpec)
PartitionSpec.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'rootPath', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'sharedSDPartitionSpec', [PartitionSpecWithSharedSD, None], None, ),  # 4
    (5, TType.STRUCT, 'partitionList', [PartitionListComposingSpec, None], None, ),  # 5
)
all_structs.append(Index)
Index.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'indexName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'indexHandlerClass', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'dbName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'origTableName', 'UTF8', None, ),  # 4
    (5, TType.I32, 'createTime', None, None, ),  # 5
    (6, TType.I32, 'lastAccessTime', None, None, ),  # 6
    (7, TType.STRING, 'indexTableName', 'UTF8', None, ),  # 7
    (8, TType.STRUCT, 'sd', [StorageDescriptor, None], None, ),  # 8
    (9, TType.MAP, 'parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 9
    (10, TType.BOOL, 'deferredRebuild', None, None, ),  # 10
)
all_structs.append(BooleanColumnStatsData)
BooleanColumnStatsData.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'numTrues', None, None, ),  # 1
    (2, TType.I64, 'numFalses', None, None, ),  # 2
    (3, TType.I64, 'numNulls', None, None, ),  # 3
    (4, TType.STRING, 'bitVectors', 'UTF8', None, ),  # 4
)
all_structs.append(DoubleColumnStatsData)
DoubleColumnStatsData.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'lowValue', None, None, ),  # 1
    (2, TType.DOUBLE, 'highValue', None, None, ),  # 2
    (3, TType.I64, 'numNulls', None, None, ),  # 3
    (4, TType.I64, 'numDVs', None, None, ),  # 4
    (5, TType.STRING, 'bitVectors', 'UTF8', None, ),  # 5
)
all_structs.append(LongColumnStatsData)
LongColumnStatsData.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'lowValue', None, None, ),  # 1
    (2, TType.I64, 'highValue', None, None, ),  # 2
    (3, TType.I64, 'numNulls', None, None, ),  # 3
    (4, TType.I64, 'numDVs', None, None, ),  # 4
    (5, TType.STRING, 'bitVectors', 'UTF8', None, ),  # 5
)
all_structs.append(StringColumnStatsData)
StringColumnStatsData.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'maxColLen', None, None, ),  # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ),  # 2
    (3, TType.I64, 'numNulls', None, None, ),  # 3
    (4, TType.I64, 'numDVs', None, None, ),  # 4
    (5, TType.STRING, 'bitVectors', 'UTF8', None, ),  # 5
)
all_structs.append(BinaryColumnStatsData)
BinaryColumnStatsData.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'maxColLen', None, None, ),  # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ),  # 2
    (3, TType.I64, 'numNulls', None, None, ),  # 3
    (4, TType.STRING, 'bitVectors', 'UTF8', None, ),  # 4
)
all_structs.append(Decimal)
Decimal.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'unscaled', 'BINARY', None, ),  # 1
    None,  # 2
    (3, TType.I16, 'scale', None, None, ),  # 3
)
all_structs.append(DecimalColumnStatsData)
DecimalColumnStatsData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lowValue', [Decimal, None], None, ),  # 1
    (2, TType.STRUCT, 'highValue', [Decimal, None], None, ),  # 2
    (3, TType.I64, 'numNulls', None, None, ),  # 3
    (4, TType.I64, 'numDVs', None, None, ),  # 4
    (5, TType.STRING, 'bitVectors', 'UTF8', None, ),  # 5
)
all_structs.append(Date)
Date.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'daysSinceEpoch', None, None, ),  # 1
)
all_structs.append(DateColumnStatsData)
DateColumnStatsData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lowValue', [Date, None], None, ),  # 1
    (2, TType.STRUCT, 'highValue', [Date, None], None, ),  # 2
    (3, TType.I64, 'numNulls', None, None, ),  # 3
    (4, TType.I64, 'numDVs', None, None, ),  # 4
    (5, TType.STRING, 'bitVectors', 'UTF8', None, ),  # 5
)
all_structs.append(ColumnStatisticsData)
ColumnStatisticsData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'booleanStats', [BooleanColumnStatsData, None], None, ),  # 1
    (2, TType.STRUCT, 'longStats', [LongColumnStatsData, None], None, ),  # 2
    (3, TType.STRUCT, 'doubleStats', [DoubleColumnStatsData, None], None, ),  # 3
    (4, TType.STRUCT, 'stringStats', [StringColumnStatsData, None], None, ),  # 4
    (5, TType.STRUCT, 'binaryStats', [BinaryColumnStatsData, None], None, ),  # 5
    (6, TType.STRUCT, 'decimalStats', [DecimalColumnStatsData, None], None, ),  # 6
    (7, TType.STRUCT, 'dateStats', [DateColumnStatsData, None], None, ),  # 7
)
all_structs.append(ColumnStatisticsObj)
ColumnStatisticsObj.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'colName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'colType', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'statsData', [ColumnStatisticsData, None], None, ),  # 3
)
all_structs.append(ColumnStatisticsDesc)
ColumnStatisticsDesc.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'isTblLevel', None, None, ),  # 1
    (2, TType.STRING, 'dbName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tableName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'partName', 'UTF8', None, ),  # 4
    (5, TType.I64, 'lastAnalyzed', None, None, ),  # 5
)
all_structs.append(ColumnStatistics)
ColumnStatistics.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'statsDesc', [ColumnStatisticsDesc, None], None, ),  # 1
    (2, TType.LIST, 'statsObj', (TType.STRUCT, [ColumnStatisticsObj, None], False), None, ),  # 2
)
all_structs.append(AggrStats)
AggrStats.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'colStats', (TType.STRUCT, [ColumnStatisticsObj, None], False), None, ),  # 1
    (2, TType.I64, 'partsFound', None, None, ),  # 2
)
all_structs.append(SetPartitionsStatsRequest)
SetPartitionsStatsRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'colStats', (TType.STRUCT, [ColumnStatistics, None], False), None, ),  # 1
    (2, TType.BOOL, 'needMerge', None, None, ),  # 2
)
all_structs.append(Schema)
Schema.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fieldSchemas', (TType.STRUCT, [FieldSchema, None], False), None, ),  # 1
    (2, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(EnvironmentContext)
EnvironmentContext.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(PrimaryKeysRequest)
PrimaryKeysRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
)
all_structs.append(PrimaryKeysResponse)
PrimaryKeysResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'primaryKeys', (TType.STRUCT, [SQLPrimaryKey, None], False), None, ),  # 1
)
all_structs.append(ForeignKeysRequest)
ForeignKeysRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'parent_db_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'parent_tbl_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'foreign_db_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'foreign_tbl_name', 'UTF8', None, ),  # 4
)
all_structs.append(ForeignKeysResponse)
ForeignKeysResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'foreignKeys', (TType.STRUCT, [SQLForeignKey, None], False), None, ),  # 1
)
all_structs.append(DropConstraintRequest)
DropConstraintRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tablename', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'constraintname', 'UTF8', None, ),  # 3
)
all_structs.append(AddPrimaryKeyRequest)
AddPrimaryKeyRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'primaryKeyCols', (TType.STRUCT, [SQLPrimaryKey, None], False), None, ),  # 1
)
all_structs.append(AddForeignKeyRequest)
AddForeignKeyRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'foreignKeyCols', (TType.STRUCT, [SQLForeignKey, None], False), None, ),  # 1
)
all_structs.append(PartitionsByExprResult)
PartitionsByExprResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT, [Partition, None], False), None, ),  # 1
    (2, TType.BOOL, 'hasUnknownPartitions', None, None, ),  # 2
)
all_structs.append(PartitionsByExprRequest)
PartitionsByExprRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tblName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'expr', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'defaultPartitionName', 'UTF8', None, ),  # 4
    (5, TType.I16, 'maxParts', None, -1, ),  # 5
)
all_structs.append(TableStatsResult)
TableStatsResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tableStats', (TType.STRUCT, [ColumnStatisticsObj, None], False), None, ),  # 1
)
all_structs.append(PartitionsStatsResult)
PartitionsStatsResult.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'partStats', (TType.STRING, 'UTF8', TType.LIST, (TType.STRUCT, [ColumnStatisticsObj, None], False), False), None, ),  # 1
)
all_structs.append(TableStatsRequest)
TableStatsRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tblName', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'colNames', (TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(PartitionsStatsRequest)
PartitionsStatsRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tblName', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'colNames', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'partNames', (TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(AddPartitionsResult)
AddPartitionsResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT, [Partition, None], False), None, ),  # 1
)
all_structs.append(AddPartitionsRequest)
AddPartitionsRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tblName', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'parts', (TType.STRUCT, [Partition, None], False), None, ),  # 3
    (4, TType.BOOL, 'ifNotExists', None, None, ),  # 4
    (5, TType.BOOL, 'needResult', None, True, ),  # 5
)
all_structs.append(DropPartitionsResult)
DropPartitionsResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT, [Partition, None], False), None, ),  # 1
)
all_structs.append(DropPartitionsExpr)
DropPartitionsExpr.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expr', 'BINARY', None, ),  # 1
    (2, TType.I32, 'partArchiveLevel', None, None, ),  # 2
)
all_structs.append(RequestPartsSpec)
RequestPartsSpec.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'names', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'exprs', (TType.STRUCT, [DropPartitionsExpr, None], False), None, ),  # 2
)
all_structs.append(DropPartitionsRequest)
DropPartitionsRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tblName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'parts', [RequestPartsSpec, None], None, ),  # 3
    (4, TType.BOOL, 'deleteData', None, None, ),  # 4
    (5, TType.BOOL, 'ifExists', None, True, ),  # 5
    (6, TType.BOOL, 'ignoreProtection', None, None, ),  # 6
    (7, TType.STRUCT, 'environmentContext', [EnvironmentContext, None], None, ),  # 7
    (8, TType.BOOL, 'needResult', None, True, ),  # 8
)
all_structs.append(PartitionValuesRequest)
PartitionValuesRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tblName', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'partitionKeys', (TType.STRUCT, [FieldSchema, None], False), None, ),  # 3
    (4, TType.BOOL, 'applyDistinct', None, True, ),  # 4
    (5, TType.STRING, 'filter', 'UTF8', None, ),  # 5
    (6, TType.LIST, 'partitionOrder', (TType.STRUCT, [FieldSchema, None], False), None, ),  # 6
    (7, TType.BOOL, 'ascending', None, True, ),  # 7
    (8, TType.I64, 'maxParts', None, -1, ),  # 8
)
all_structs.append(PartitionValuesRow)
PartitionValuesRow.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'row', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(PartitionValuesResponse)
PartitionValuesResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partitionValues', (TType.STRUCT, [PartitionValuesRow, None], False), None, ),  # 1
)
all_structs.append(ResourceUri)
ResourceUri.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'resourceType', None, None, ),  # 1
    (2, TType.STRING, 'uri', 'UTF8', None, ),  # 2
)
all_structs.append(Function)
Function.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'functionName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dbName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'className', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'ownerName', 'UTF8', None, ),  # 4
    (5, TType.I32, 'ownerType', None, None, ),  # 5
    (6, TType.I32, 'createTime', None, None, ),  # 6
    (7, TType.I32, 'functionType', None, None, ),  # 7
    (8, TType.LIST, 'resourceUris', (TType.STRUCT, [ResourceUri, None], False), None, ),  # 8
)
all_structs.append(TxnInfo)
TxnInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I32, 'state', None, None, ),  # 2
    (3, TType.STRING, 'user', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'hostname', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'agentInfo', 'UTF8', "Unknown", ),  # 5
    (6, TType.I32, 'heartbeatCount', None, 0, ),  # 6
    (7, TType.STRING, 'metaInfo', 'UTF8', None, ),  # 7
    (8, TType.I64, 'startedTime', None, None, ),  # 8
    (9, TType.I64, 'lastHeartbeatTime', None, None, ),  # 9
)
all_structs.append(GetOpenTxnsInfoResponse)
GetOpenTxnsInfoResponse.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'txn_high_water_mark', None, None, ),  # 1
    (2, TType.LIST, 'open_txns', (TType.STRUCT, [TxnInfo, None], False), None, ),  # 2
)
all_structs.append(GetOpenTxnsResponse)
GetOpenTxnsResponse.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'txn_high_water_mark', None, None, ),  # 1
    (2, TType.SET, 'open_txns', (TType.I64, None, False), None, ),  # 2
    (3, TType.I64, 'min_open_txn', None, None, ),  # 3
)
all_structs.append(OpenTxnRequest)
OpenTxnRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_txns', None, None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'hostname', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'agentInfo', 'UTF8', "Unknown", ),  # 4
)
all_structs.append(OpenTxnsResponse)
OpenTxnsResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'txn_ids', (TType.I64, None, False), None, ),  # 1
)
all_structs.append(AbortTxnRequest)
AbortTxnRequest.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'txnid', None, None, ),  # 1
)
all_structs.append(AbortTxnsRequest)
AbortTxnsRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'txn_ids', (TType.I64, None, False), None, ),  # 1
)
all_structs.append(CommitTxnRequest)
CommitTxnRequest.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'txnid', None, None, ),  # 1
)
all_structs.append(LockComponent)
LockComponent.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I32, 'level', None, None, ),  # 2
    (3, TType.STRING, 'dbname', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'tablename', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'partitionname', 'UTF8', None, ),  # 5
    (6, TType.I32, 'operationType', None, 5, ),  # 6
    (7, TType.BOOL, 'isAcid', None, False, ),  # 7
    (8, TType.BOOL, 'isDynamicPartitionWrite', None, False, ),  # 8
)
all_structs.append(LockRequest)
LockRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'component', (TType.STRUCT, [LockComponent, None], False), None, ),  # 1
    (2, TType.I64, 'txnid', None, None, ),  # 2
    (3, TType.STRING, 'user', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'hostname', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'agentInfo', 'UTF8', "Unknown", ),  # 5
)
all_structs.append(LockResponse)
LockResponse.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'lockid', None, None, ),  # 1
    (2, TType.I32, 'state', None, None, ),  # 2
)
all_structs.append(CheckLockRequest)
CheckLockRequest.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'lockid', None, None, ),  # 1
    (2, TType.I64, 'txnid', None, None, ),  # 2
    (3, TType.I64, 'elapsed_ms', None, None, ),  # 3
)
all_structs.append(UnlockRequest)
UnlockRequest.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'lockid', None, None, ),  # 1
)
all_structs.append(ShowLocksRequest)
ShowLocksRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tablename', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'partname', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isExtended', None, False, ),  # 4
)
all_structs.append(ShowLocksResponseElement)
ShowLocksResponseElement.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'lockid', None, None, ),  # 1
    (2, TType.STRING, 'dbname', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tablename', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'partname', 'UTF8', None, ),  # 4
    (5, TType.I32, 'state', None, None, ),  # 5
    (6, TType.I32, 'type', None, None, ),  # 6
    (7, TType.I64, 'txnid', None, None, ),  # 7
    (8, TType.I64, 'lastheartbeat', None, None, ),  # 8
    (9, TType.I64, 'acquiredat', None, None, ),  # 9
    (10, TType.STRING, 'user', 'UTF8', None, ),  # 10
    (11, TType.STRING, 'hostname', 'UTF8', None, ),  # 11
    (12, TType.I32, 'heartbeatCount', None, 0, ),  # 12
    (13, TType.STRING, 'agentInfo', 'UTF8', None, ),  # 13
    (14, TType.I64, 'blockedByExtId', None, None, ),  # 14
    (15, TType.I64, 'blockedByIntId', None, None, ),  # 15
    (16, TType.I64, 'lockIdInternal', None, None, ),  # 16
)
all_structs.append(ShowLocksResponse)
ShowLocksResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'locks', (TType.STRUCT, [ShowLocksResponseElement, None], False), None, ),  # 1
)
all_structs.append(HeartbeatRequest)
HeartbeatRequest.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'lockid', None, None, ),  # 1
    (2, TType.I64, 'txnid', None, None, ),  # 2
)
all_structs.append(HeartbeatTxnRangeRequest)
HeartbeatTxnRangeRequest.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'min', None, None, ),  # 1
    (2, TType.I64, 'max', None, None, ),  # 2
)
all_structs.append(HeartbeatTxnRangeResponse)
HeartbeatTxnRangeResponse.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'aborted', (TType.I64, None, False), None, ),  # 1
    (2, TType.SET, 'nosuch', (TType.I64, None, False), None, ),  # 2
)
all_structs.append(CompactionRequest)
CompactionRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tablename', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'partitionname', 'UTF8', None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
    (5, TType.STRING, 'runas', 'UTF8', None, ),  # 5
    (6, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
)
all_structs.append(CompactionResponse)
CompactionResponse.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'state', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'accepted', None, None, ),  # 3
)
all_structs.append(ShowCompactRequest)
ShowCompactRequest.thrift_spec = (
)
all_structs.append(ShowCompactResponseElement)
ShowCompactResponseElement.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tablename', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'partitionname', 'UTF8', None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
    (5, TType.STRING, 'state', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'workerid', 'UTF8', None, ),  # 6
    (7, TType.I64, 'start', None, None, ),  # 7
    (8, TType.STRING, 'runAs', 'UTF8', None, ),  # 8
    (9, TType.I64, 'hightestTxnId', None, None, ),  # 9
    (10, TType.STRING, 'metaInfo', 'UTF8', None, ),  # 10
    (11, TType.I64, 'endTime', None, None, ),  # 11
    (12, TType.STRING, 'hadoopJobId', 'UTF8', "None", ),  # 12
    (13, TType.I64, 'id', None, None, ),  # 13
)
all_structs.append(ShowCompactResponse)
ShowCompactResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'compacts', (TType.STRUCT, [ShowCompactResponseElement, None], False), None, ),  # 1
)
all_structs.append(AddDynamicPartitions)
AddDynamicPartitions.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'txnid', None, None, ),  # 1
    (2, TType.STRING, 'dbname', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tablename', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'partitionnames', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I32, 'operationType', None, 5, ),  # 5
)
all_structs.append(NotificationEventRequest)
NotificationEventRequest.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'lastEvent', None, None, ),  # 1
    (2, TType.I32, 'maxEvents', None, None, ),  # 2
)
all_structs.append(NotificationEvent)
NotificationEvent.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'eventId', None, None, ),  # 1
    (2, TType.I32, 'eventTime', None, None, ),  # 2
    (3, TType.STRING, 'eventType', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'dbName', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'tableName', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'message', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'messageFormat', 'UTF8', None, ),  # 7
)
all_structs.append(NotificationEventResponse)
NotificationEventResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'events', (TType.STRUCT, [NotificationEvent, None], False), None, ),  # 1
)
all_structs.append(CurrentNotificationEventId)
CurrentNotificationEventId.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'eventId', None, None, ),  # 1
)
all_structs.append(InsertEventRequestData)
InsertEventRequestData.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'filesAdded', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'filesAddedChecksum', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(FireEventRequestData)
FireEventRequestData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'insertData', [InsertEventRequestData, None], None, ),  # 1
)
all_structs.append(FireEventRequest)
FireEventRequest.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'successful', None, None, ),  # 1
    (2, TType.STRUCT, 'data', [FireEventRequestData, None], None, ),  # 2
    (3, TType.STRING, 'dbName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'tableName', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'partitionVals', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(FireEventResponse)
FireEventResponse.thrift_spec = (
)
all_structs.append(MetadataPpdResult)
MetadataPpdResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'metadata', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'includeBitset', 'BINARY', None, ),  # 2
)
all_structs.append(GetFileMetadataByExprResult)
GetFileMetadataByExprResult.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'metadata', (TType.I64, None, TType.STRUCT, [MetadataPpdResult, None], False), None, ),  # 1
    (2, TType.BOOL, 'isSupported', None, None, ),  # 2
)
all_structs.append(GetFileMetadataByExprRequest)
GetFileMetadataByExprRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fileIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRING, 'expr', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'doGetFooters', None, None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
)
all_structs.append(GetFileMetadataResult)
GetFileMetadataResult.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'metadata', (TType.I64, None, TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.BOOL, 'isSupported', None, None, ),  # 2
)
all_structs.append(GetFileMetadataRequest)
GetFileMetadataRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fileIds', (TType.I64, None, False), None, ),  # 1
)
all_structs.append(PutFileMetadataResult)
PutFileMetadataResult.thrift_spec = (
)
all_structs.append(PutFileMetadataRequest)
PutFileMetadataRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fileIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.LIST, 'metadata', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
)
all_structs.append(ClearFileMetadataResult)
ClearFileMetadataResult.thrift_spec = (
)
all_structs.append(ClearFileMetadataRequest)
ClearFileMetadataRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fileIds', (TType.I64, None, False), None, ),  # 1
)
all_structs.append(CacheFileMetadataResult)
CacheFileMetadataResult.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'isSupported', None, None, ),  # 1
)
all_structs.append(CacheFileMetadataRequest)
CacheFileMetadataRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tblName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'partName', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isAllParts', None, None, ),  # 4
)
all_structs.append(GetAllFunctionsResponse)
GetAllFunctionsResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'functions', (TType.STRUCT, [Function, None], False), None, ),  # 1
)
all_structs.append(ClientCapabilities)
ClientCapabilities.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'values', (TType.I32, None, False), None, ),  # 1
)
all_structs.append(GetTableRequest)
GetTableRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tblName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'capabilities', [ClientCapabilities, None], None, ),  # 3
)
all_structs.append(GetTableResult)
GetTableResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table', [Table, None], None, ),  # 1
)
all_structs.append(GetTablesRequest)
GetTablesRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'tblNames', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRUCT, 'capabilities', [ClientCapabilities, None], None, ),  # 3
)
all_structs.append(GetTablesResult)
GetTablesResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tables', (TType.STRUCT, [Table, None], False), None, ),  # 1
)
all_structs.append(TableMeta)
TableMeta.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tableType', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'comments', 'UTF8', None, ),  # 4
)
all_structs.append(MetaException)
MetaException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(UnknownTableException)
UnknownTableException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(UnknownDBException)
UnknownDBException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(AlreadyExistsException)
AlreadyExistsException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(InvalidPartitionException)
InvalidPartitionException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(UnknownPartitionException)
UnknownPartitionException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(InvalidObjectException)
InvalidObjectException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(NoSuchObjectException)
NoSuchObjectException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(IndexAlreadyExistsException)
IndexAlreadyExistsException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(InvalidOperationException)
InvalidOperationException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(ConfigValSecurityException)
ConfigValSecurityException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(InvalidInputException)
InvalidInputException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(NoSuchTxnException)
NoSuchTxnException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TxnAbortedException)
TxnAbortedException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TxnOpenException)
TxnOpenException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(NoSuchLockException)
NoSuchLockException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
fix_spec(all_structs)
del all_structs
