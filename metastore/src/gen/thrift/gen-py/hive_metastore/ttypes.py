#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import fb303.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class HiveObjectType:
  GLOBAL = 1
  DATABASE = 2
  TABLE = 3
  PARTITION = 4
  COLUMN = 5

  _VALUES_TO_NAMES = {
    1: "GLOBAL",
    2: "DATABASE",
    3: "TABLE",
    4: "PARTITION",
    5: "COLUMN",
  }

  _NAMES_TO_VALUES = {
    "GLOBAL": 1,
    "DATABASE": 2,
    "TABLE": 3,
    "PARTITION": 4,
    "COLUMN": 5,
  }

class PrincipalType:
  USER = 1
  ROLE = 2
  GROUP = 3

  _VALUES_TO_NAMES = {
    1: "USER",
    2: "ROLE",
    3: "GROUP",
  }

  _NAMES_TO_VALUES = {
    "USER": 1,
    "ROLE": 2,
    "GROUP": 3,
  }

class PartitionEventType:
  LOAD_DONE = 1

  _VALUES_TO_NAMES = {
    1: "LOAD_DONE",
  }

  _NAMES_TO_VALUES = {
    "LOAD_DONE": 1,
  }


class Version:
  """
  Attributes:
   - version
   - comments
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'version', None, None, ), # 1
    (2, TType.STRING, 'comments', None, None, ), # 2
  )

  def __init__(self, version=None, comments=None,):
    self.version = version
    self.comments = comments

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.version = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comments = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Version')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 1)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 2)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FieldSchema:
  """
  Attributes:
   - name
   - type
   - comment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type', None, None, ), # 2
    (3, TType.STRING, 'comment', None, None, ), # 3
  )

  def __init__(self, name=None, type=None, comment=None,):
    self.name = name
    self.type = type
    self.comment = comment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FieldSchema')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 2)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 3)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Type:
  """
  Attributes:
   - name
   - type1
   - type2
   - fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type1', None, None, ), # 2
    (3, TType.STRING, 'type2', None, None, ), # 3
    (4, TType.LIST, 'fields', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 4
  )

  def __init__(self, name=None, type1=None, type2=None, fields=None,):
    self.name = name
    self.type1 = type1
    self.type2 = type2
    self.fields = fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type1 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.type2 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fields = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = FieldSchema()
            _elem5.read(iprot)
            self.fields.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Type')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type1 is not None:
      oprot.writeFieldBegin('type1', TType.STRING, 2)
      oprot.writeString(self.type1)
      oprot.writeFieldEnd()
    if self.type2 is not None:
      oprot.writeFieldBegin('type2', TType.STRING, 3)
      oprot.writeString(self.type2)
      oprot.writeFieldEnd()
    if self.fields is not None:
      oprot.writeFieldBegin('fields', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter6 in self.fields:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HiveObjectRef:
  """
  Attributes:
   - objectType
   - dbName
   - objectName
   - partValues
   - columnName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'objectType', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'objectName', None, None, ), # 3
    (4, TType.LIST, 'partValues', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'columnName', None, None, ), # 5
  )

  def __init__(self, objectType=None, dbName=None, objectName=None, partValues=None, columnName=None,):
    self.objectType = objectType
    self.dbName = dbName
    self.objectName = objectName
    self.partValues = partValues
    self.columnName = columnName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.objectType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.objectName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partValues = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.partValues.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.columnName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HiveObjectRef')
    if self.objectType is not None:
      oprot.writeFieldBegin('objectType', TType.I32, 1)
      oprot.writeI32(self.objectType)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.objectName is not None:
      oprot.writeFieldBegin('objectName', TType.STRING, 3)
      oprot.writeString(self.objectName)
      oprot.writeFieldEnd()
    if self.partValues is not None:
      oprot.writeFieldBegin('partValues', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.partValues))
      for iter13 in self.partValues:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.columnName is not None:
      oprot.writeFieldBegin('columnName', TType.STRING, 5)
      oprot.writeString(self.columnName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrivilegeGrantInfo:
  """
  Attributes:
   - privilege
   - createTime
   - grantor
   - grantorType
   - grantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'privilege', None, None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.STRING, 'grantor', None, None, ), # 3
    (4, TType.I32, 'grantorType', None, None, ), # 4
    (5, TType.BOOL, 'grantOption', None, None, ), # 5
  )

  def __init__(self, privilege=None, createTime=None, grantor=None, grantorType=None, grantOption=None,):
    self.privilege = privilege
    self.createTime = createTime
    self.grantor = grantor
    self.grantorType = grantorType
    self.grantOption = grantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.privilege = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.grantor = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrivilegeGrantInfo')
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.STRING, 1)
      oprot.writeString(self.privilege)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 3)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 4)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 5)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HiveObjectPrivilege:
  """
  Attributes:
   - hiveObject
   - principalName
   - principalType
   - grantInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 1
    (2, TType.STRING, 'principalName', None, None, ), # 2
    (3, TType.I32, 'principalType', None, None, ), # 3
    (4, TType.STRUCT, 'grantInfo', (PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec), None, ), # 4
  )

  def __init__(self, hiveObject=None, principalName=None, principalType=None, grantInfo=None,):
    self.hiveObject = hiveObject
    self.principalName = principalName
    self.principalType = principalType
    self.grantInfo = grantInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principalName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principalType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.grantInfo = PrivilegeGrantInfo()
          self.grantInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HiveObjectPrivilege')
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 2)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 3)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantInfo is not None:
      oprot.writeFieldBegin('grantInfo', TType.STRUCT, 4)
      self.grantInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrivilegeBag:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'privileges', (TType.STRUCT,(HiveObjectPrivilege, HiveObjectPrivilege.thrift_spec)), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.privileges = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = HiveObjectPrivilege()
            _elem19.read(iprot)
            self.privileges.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrivilegeBag')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.privileges))
      for iter20 in self.privileges:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrincipalPrivilegeSet:
  """
  Attributes:
   - userPrivileges
   - groupPrivileges
   - rolePrivileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'userPrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 1
    (2, TType.MAP, 'groupPrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 2
    (3, TType.MAP, 'rolePrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 3
  )

  def __init__(self, userPrivileges=None, groupPrivileges=None, rolePrivileges=None,):
    self.userPrivileges = userPrivileges
    self.groupPrivileges = groupPrivileges
    self.rolePrivileges = rolePrivileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.userPrivileges = {}
          (_ktype22, _vtype23, _size21 ) = iprot.readMapBegin() 
          for _i25 in xrange(_size21):
            _key26 = iprot.readString();
            _val27 = []
            (_etype31, _size28) = iprot.readListBegin()
            for _i32 in xrange(_size28):
              _elem33 = PrivilegeGrantInfo()
              _elem33.read(iprot)
              _val27.append(_elem33)
            iprot.readListEnd()
            self.userPrivileges[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.groupPrivileges = {}
          (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin() 
          for _i38 in xrange(_size34):
            _key39 = iprot.readString();
            _val40 = []
            (_etype44, _size41) = iprot.readListBegin()
            for _i45 in xrange(_size41):
              _elem46 = PrivilegeGrantInfo()
              _elem46.read(iprot)
              _val40.append(_elem46)
            iprot.readListEnd()
            self.groupPrivileges[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.rolePrivileges = {}
          (_ktype48, _vtype49, _size47 ) = iprot.readMapBegin() 
          for _i51 in xrange(_size47):
            _key52 = iprot.readString();
            _val53 = []
            (_etype57, _size54) = iprot.readListBegin()
            for _i58 in xrange(_size54):
              _elem59 = PrivilegeGrantInfo()
              _elem59.read(iprot)
              _val53.append(_elem59)
            iprot.readListEnd()
            self.rolePrivileges[_key52] = _val53
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrincipalPrivilegeSet')
    if self.userPrivileges is not None:
      oprot.writeFieldBegin('userPrivileges', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.userPrivileges))
      for kiter60,viter61 in self.userPrivileges.items():
        oprot.writeString(kiter60)
        oprot.writeListBegin(TType.STRUCT, len(viter61))
        for iter62 in viter61:
          iter62.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.groupPrivileges is not None:
      oprot.writeFieldBegin('groupPrivileges', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.groupPrivileges))
      for kiter63,viter64 in self.groupPrivileges.items():
        oprot.writeString(kiter63)
        oprot.writeListBegin(TType.STRUCT, len(viter64))
        for iter65 in viter64:
          iter65.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.rolePrivileges is not None:
      oprot.writeFieldBegin('rolePrivileges', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.rolePrivileges))
      for kiter66,viter67 in self.rolePrivileges.items():
        oprot.writeString(kiter66)
        oprot.writeListBegin(TType.STRUCT, len(viter67))
        for iter68 in viter67:
          iter68.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Role:
  """
  Attributes:
   - roleName
   - createTime
   - ownerName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.STRING, 'ownerName', None, None, ), # 3
  )

  def __init__(self, roleName=None, createTime=None, ownerName=None,):
    self.roleName = roleName
    self.createTime = createTime
    self.ownerName = ownerName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Role')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 3)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Database:
  """
  Attributes:
   - name
   - description
   - locationUri
   - parameters
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
    (3, TType.STRING, 'locationUri', None, None, ), # 3
    (4, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 4
    (5, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 5
  )

  def __init__(self, name=None, description=None, locationUri=None, parameters=None, privileges=None,):
    self.name = name
    self.description = description
    self.locationUri = locationUri
    self.parameters = parameters
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.locationUri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype70, _vtype71, _size69 ) = iprot.readMapBegin() 
          for _i73 in xrange(_size69):
            _key74 = iprot.readString();
            _val75 = iprot.readString();
            self.parameters[_key74] = _val75
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Database')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.locationUri is not None:
      oprot.writeFieldBegin('locationUri', TType.STRING, 3)
      oprot.writeString(self.locationUri)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter76,viter77 in self.parameters.items():
        oprot.writeString(kiter76)
        oprot.writeString(viter77)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 5)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SerDeInfo:
  """
  Attributes:
   - name
   - serializationLib
   - parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'serializationLib', None, None, ), # 2
    (3, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, name=None, serializationLib=None, parameters=None,):
    self.name = name
    self.serializationLib = serializationLib
    self.parameters = parameters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serializationLib = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype79, _vtype80, _size78 ) = iprot.readMapBegin() 
          for _i82 in xrange(_size78):
            _key83 = iprot.readString();
            _val84 = iprot.readString();
            self.parameters[_key83] = _val84
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SerDeInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.serializationLib is not None:
      oprot.writeFieldBegin('serializationLib', TType.STRING, 2)
      oprot.writeString(self.serializationLib)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter85,viter86 in self.parameters.items():
        oprot.writeString(kiter85)
        oprot.writeString(viter86)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Order:
  """
  Attributes:
   - col
   - order
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col', None, None, ), # 1
    (2, TType.I32, 'order', None, None, ), # 2
  )

  def __init__(self, col=None, order=None,):
    self.col = col
    self.order = order

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.order = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Order')
    if self.col is not None:
      oprot.writeFieldBegin('col', TType.STRING, 1)
      oprot.writeString(self.col)
      oprot.writeFieldEnd()
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 2)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SkewedValueList:
  """
  Attributes:
   - skewedValueList
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'skewedValueList', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, skewedValueList=None,):
    self.skewedValueList = skewedValueList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.skewedValueList = []
          (_etype90, _size87) = iprot.readListBegin()
          for _i91 in xrange(_size87):
            _elem92 = iprot.readString();
            self.skewedValueList.append(_elem92)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SkewedValueList')
    if self.skewedValueList is not None:
      oprot.writeFieldBegin('skewedValueList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.skewedValueList))
      for iter93 in self.skewedValueList:
        oprot.writeString(iter93)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SkewedInfo:
  """
  Attributes:
   - skewedColNames
   - skewedColValues
   - skewedColValueLocationMaps
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'skewedColNames', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'skewedColValues', (TType.LIST,(TType.STRING,None)), None, ), # 2
    (3, TType.MAP, 'skewedColValueLocationMaps', (TType.STRUCT,(SkewedValueList, SkewedValueList.thrift_spec),TType.STRING,None), None, ), # 3
  )

  def __init__(self, skewedColNames=None, skewedColValues=None, skewedColValueLocationMaps=None,):
    self.skewedColNames = skewedColNames
    self.skewedColValues = skewedColValues
    self.skewedColValueLocationMaps = skewedColValueLocationMaps

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.skewedColNames = []
          (_etype97, _size94) = iprot.readListBegin()
          for _i98 in xrange(_size94):
            _elem99 = iprot.readString();
            self.skewedColNames.append(_elem99)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.skewedColValues = []
          (_etype103, _size100) = iprot.readListBegin()
          for _i104 in xrange(_size100):
            _elem105 = []
            (_etype109, _size106) = iprot.readListBegin()
            for _i110 in xrange(_size106):
              _elem111 = iprot.readString();
              _elem105.append(_elem111)
            iprot.readListEnd()
            self.skewedColValues.append(_elem105)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.skewedColValueLocationMaps = {}
          (_ktype113, _vtype114, _size112 ) = iprot.readMapBegin() 
          for _i116 in xrange(_size112):
            _key117 = SkewedValueList()
            _key117.read(iprot)
            _val118 = iprot.readString();
            self.skewedColValueLocationMaps[_key117] = _val118
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SkewedInfo')
    if self.skewedColNames is not None:
      oprot.writeFieldBegin('skewedColNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.skewedColNames))
      for iter119 in self.skewedColNames:
        oprot.writeString(iter119)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewedColValues is not None:
      oprot.writeFieldBegin('skewedColValues', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.skewedColValues))
      for iter120 in self.skewedColValues:
        oprot.writeListBegin(TType.STRING, len(iter120))
        for iter121 in iter120:
          oprot.writeString(iter121)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewedColValueLocationMaps is not None:
      oprot.writeFieldBegin('skewedColValueLocationMaps', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRUCT, TType.STRING, len(self.skewedColValueLocationMaps))
      for kiter122,viter123 in self.skewedColValueLocationMaps.items():
        kiter122.write(oprot)
        oprot.writeString(viter123)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StorageDescriptor:
  """
  Attributes:
   - cols
   - location
   - inputFormat
   - outputFormat
   - compressed
   - numBuckets
   - serdeInfo
   - bucketCols
   - sortCols
   - parameters
   - skewedInfo
   - storedAsSubDirectories
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cols', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'location', None, None, ), # 2
    (3, TType.STRING, 'inputFormat', None, None, ), # 3
    (4, TType.STRING, 'outputFormat', None, None, ), # 4
    (5, TType.BOOL, 'compressed', None, None, ), # 5
    (6, TType.I32, 'numBuckets', None, None, ), # 6
    (7, TType.STRUCT, 'serdeInfo', (SerDeInfo, SerDeInfo.thrift_spec), None, ), # 7
    (8, TType.LIST, 'bucketCols', (TType.STRING,None), None, ), # 8
    (9, TType.LIST, 'sortCols', (TType.STRUCT,(Order, Order.thrift_spec)), None, ), # 9
    (10, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 10
    (11, TType.STRUCT, 'skewedInfo', (SkewedInfo, SkewedInfo.thrift_spec), None, ), # 11
    (12, TType.BOOL, 'storedAsSubDirectories', None, None, ), # 12
  )

  def __init__(self, cols=None, location=None, inputFormat=None, outputFormat=None, compressed=None, numBuckets=None, serdeInfo=None, bucketCols=None, sortCols=None, parameters=None, skewedInfo=None, storedAsSubDirectories=None,):
    self.cols = cols
    self.location = location
    self.inputFormat = inputFormat
    self.outputFormat = outputFormat
    self.compressed = compressed
    self.numBuckets = numBuckets
    self.serdeInfo = serdeInfo
    self.bucketCols = bucketCols
    self.sortCols = sortCols
    self.parameters = parameters
    self.skewedInfo = skewedInfo
    self.storedAsSubDirectories = storedAsSubDirectories

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cols = []
          (_etype127, _size124) = iprot.readListBegin()
          for _i128 in xrange(_size124):
            _elem129 = FieldSchema()
            _elem129.read(iprot)
            self.cols.append(_elem129)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.inputFormat = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.outputFormat = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.compressed = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.numBuckets = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.serdeInfo = SerDeInfo()
          self.serdeInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.bucketCols = []
          (_etype133, _size130) = iprot.readListBegin()
          for _i134 in xrange(_size130):
            _elem135 = iprot.readString();
            self.bucketCols.append(_elem135)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.sortCols = []
          (_etype139, _size136) = iprot.readListBegin()
          for _i140 in xrange(_size136):
            _elem141 = Order()
            _elem141.read(iprot)
            self.sortCols.append(_elem141)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype143, _vtype144, _size142 ) = iprot.readMapBegin() 
          for _i146 in xrange(_size142):
            _key147 = iprot.readString();
            _val148 = iprot.readString();
            self.parameters[_key147] = _val148
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.skewedInfo = SkewedInfo()
          self.skewedInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.storedAsSubDirectories = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StorageDescriptor')
    if self.cols is not None:
      oprot.writeFieldBegin('cols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cols))
      for iter149 in self.cols:
        iter149.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 2)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.inputFormat is not None:
      oprot.writeFieldBegin('inputFormat', TType.STRING, 3)
      oprot.writeString(self.inputFormat)
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.STRING, 4)
      oprot.writeString(self.outputFormat)
      oprot.writeFieldEnd()
    if self.compressed is not None:
      oprot.writeFieldBegin('compressed', TType.BOOL, 5)
      oprot.writeBool(self.compressed)
      oprot.writeFieldEnd()
    if self.numBuckets is not None:
      oprot.writeFieldBegin('numBuckets', TType.I32, 6)
      oprot.writeI32(self.numBuckets)
      oprot.writeFieldEnd()
    if self.serdeInfo is not None:
      oprot.writeFieldBegin('serdeInfo', TType.STRUCT, 7)
      self.serdeInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.bucketCols is not None:
      oprot.writeFieldBegin('bucketCols', TType.LIST, 8)
      oprot.writeListBegin(TType.STRING, len(self.bucketCols))
      for iter150 in self.bucketCols:
        oprot.writeString(iter150)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sortCols is not None:
      oprot.writeFieldBegin('sortCols', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.sortCols))
      for iter151 in self.sortCols:
        iter151.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter152,viter153 in self.parameters.items():
        oprot.writeString(kiter152)
        oprot.writeString(viter153)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.skewedInfo is not None:
      oprot.writeFieldBegin('skewedInfo', TType.STRUCT, 11)
      self.skewedInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.storedAsSubDirectories is not None:
      oprot.writeFieldBegin('storedAsSubDirectories', TType.BOOL, 12)
      oprot.writeBool(self.storedAsSubDirectories)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Table:
  """
  Attributes:
   - tableName
   - dbName
   - owner
   - createTime
   - lastAccessTime
   - retention
   - sd
   - partitionKeys
   - parameters
   - viewOriginalText
   - viewExpandedText
   - tableType
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'owner', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.I32, 'retention', None, None, ), # 6
    (7, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 7
    (8, TType.LIST, 'partitionKeys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 8
    (9, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 9
    (10, TType.STRING, 'viewOriginalText', None, None, ), # 10
    (11, TType.STRING, 'viewExpandedText', None, None, ), # 11
    (12, TType.STRING, 'tableType', None, None, ), # 12
    (13, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 13
  )

  def __init__(self, tableName=None, dbName=None, owner=None, createTime=None, lastAccessTime=None, retention=None, sd=None, partitionKeys=None, parameters=None, viewOriginalText=None, viewExpandedText=None, tableType=None, privileges=None,):
    self.tableName = tableName
    self.dbName = dbName
    self.owner = owner
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.retention = retention
    self.sd = sd
    self.partitionKeys = partitionKeys
    self.parameters = parameters
    self.viewOriginalText = viewOriginalText
    self.viewExpandedText = viewExpandedText
    self.tableType = tableType
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.retention = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.partitionKeys = []
          (_etype157, _size154) = iprot.readListBegin()
          for _i158 in xrange(_size154):
            _elem159 = FieldSchema()
            _elem159.read(iprot)
            self.partitionKeys.append(_elem159)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype161, _vtype162, _size160 ) = iprot.readMapBegin() 
          for _i164 in xrange(_size160):
            _key165 = iprot.readString();
            _val166 = iprot.readString();
            self.parameters[_key165] = _val166
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.viewOriginalText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.viewExpandedText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.tableType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Table')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 3)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.retention is not None:
      oprot.writeFieldBegin('retention', TType.I32, 6)
      oprot.writeI32(self.retention)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 7)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.partitionKeys is not None:
      oprot.writeFieldBegin('partitionKeys', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionKeys))
      for iter167 in self.partitionKeys:
        iter167.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter168,viter169 in self.parameters.items():
        oprot.writeString(kiter168)
        oprot.writeString(viter169)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.viewOriginalText is not None:
      oprot.writeFieldBegin('viewOriginalText', TType.STRING, 10)
      oprot.writeString(self.viewOriginalText)
      oprot.writeFieldEnd()
    if self.viewExpandedText is not None:
      oprot.writeFieldBegin('viewExpandedText', TType.STRING, 11)
      oprot.writeString(self.viewExpandedText)
      oprot.writeFieldEnd()
    if self.tableType is not None:
      oprot.writeFieldBegin('tableType', TType.STRING, 12)
      oprot.writeString(self.tableType)
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 13)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Partition:
  """
  Attributes:
   - values
   - dbName
   - tableName
   - createTime
   - lastAccessTime
   - sd
   - parameters
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 6
    (7, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 7
    (8, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 8
  )

  def __init__(self, values=None, dbName=None, tableName=None, createTime=None, lastAccessTime=None, sd=None, parameters=None, privileges=None,):
    self.values = values
    self.dbName = dbName
    self.tableName = tableName
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.sd = sd
    self.parameters = parameters
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype173, _size170) = iprot.readListBegin()
          for _i174 in xrange(_size170):
            _elem175 = iprot.readString();
            self.values.append(_elem175)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype177, _vtype178, _size176 ) = iprot.readMapBegin() 
          for _i180 in xrange(_size176):
            _key181 = iprot.readString();
            _val182 = iprot.readString();
            self.parameters[_key181] = _val182
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Partition')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter183 in self.values:
        oprot.writeString(iter183)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 6)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter184,viter185 in self.parameters.items():
        oprot.writeString(kiter184)
        oprot.writeString(viter185)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 8)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Index:
  """
  Attributes:
   - indexName
   - indexHandlerClass
   - dbName
   - origTableName
   - createTime
   - lastAccessTime
   - indexTableName
   - sd
   - parameters
   - deferredRebuild
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'indexName', None, None, ), # 1
    (2, TType.STRING, 'indexHandlerClass', None, None, ), # 2
    (3, TType.STRING, 'dbName', None, None, ), # 3
    (4, TType.STRING, 'origTableName', None, None, ), # 4
    (5, TType.I32, 'createTime', None, None, ), # 5
    (6, TType.I32, 'lastAccessTime', None, None, ), # 6
    (7, TType.STRING, 'indexTableName', None, None, ), # 7
    (8, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 8
    (9, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 9
    (10, TType.BOOL, 'deferredRebuild', None, None, ), # 10
  )

  def __init__(self, indexName=None, indexHandlerClass=None, dbName=None, origTableName=None, createTime=None, lastAccessTime=None, indexTableName=None, sd=None, parameters=None, deferredRebuild=None,):
    self.indexName = indexName
    self.indexHandlerClass = indexHandlerClass
    self.dbName = dbName
    self.origTableName = origTableName
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.indexTableName = indexTableName
    self.sd = sd
    self.parameters = parameters
    self.deferredRebuild = deferredRebuild

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.indexName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.indexHandlerClass = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.origTableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.indexTableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype187, _vtype188, _size186 ) = iprot.readMapBegin() 
          for _i190 in xrange(_size186):
            _key191 = iprot.readString();
            _val192 = iprot.readString();
            self.parameters[_key191] = _val192
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.deferredRebuild = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Index')
    if self.indexName is not None:
      oprot.writeFieldBegin('indexName', TType.STRING, 1)
      oprot.writeString(self.indexName)
      oprot.writeFieldEnd()
    if self.indexHandlerClass is not None:
      oprot.writeFieldBegin('indexHandlerClass', TType.STRING, 2)
      oprot.writeString(self.indexHandlerClass)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 3)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.origTableName is not None:
      oprot.writeFieldBegin('origTableName', TType.STRING, 4)
      oprot.writeString(self.origTableName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 5)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 6)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.indexTableName is not None:
      oprot.writeFieldBegin('indexTableName', TType.STRING, 7)
      oprot.writeString(self.indexTableName)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 8)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter193,viter194 in self.parameters.items():
        oprot.writeString(kiter193)
        oprot.writeString(viter194)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.deferredRebuild is not None:
      oprot.writeFieldBegin('deferredRebuild', TType.BOOL, 10)
      oprot.writeBool(self.deferredRebuild)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BooleanColumnStatsData:
  """
  Attributes:
   - numTrues
   - numFalses
   - numNulls
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'numTrues', None, None, ), # 1
    (2, TType.I64, 'numFalses', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
  )

  def __init__(self, numTrues=None, numFalses=None, numNulls=None,):
    self.numTrues = numTrues
    self.numFalses = numFalses
    self.numNulls = numNulls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.numTrues = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.numFalses = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BooleanColumnStatsData')
    if self.numTrues is not None:
      oprot.writeFieldBegin('numTrues', TType.I64, 1)
      oprot.writeI64(self.numTrues)
      oprot.writeFieldEnd()
    if self.numFalses is not None:
      oprot.writeFieldBegin('numFalses', TType.I64, 2)
      oprot.writeI64(self.numFalses)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numTrues is None:
      raise TProtocol.TProtocolException(message='Required field numTrues is unset!')
    if self.numFalses is None:
      raise TProtocol.TProtocolException(message='Required field numFalses is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DoubleColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'lowValue', None, None, ), # 1
    (2, TType.DOUBLE, 'highValue', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.lowValue = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.highValue = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DoubleColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.DOUBLE, 1)
      oprot.writeDouble(self.lowValue)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.DOUBLE, 2)
      oprot.writeDouble(self.highValue)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lowValue is None:
      raise TProtocol.TProtocolException(message='Required field lowValue is unset!')
    if self.highValue is None:
      raise TProtocol.TProtocolException(message='Required field highValue is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LongColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lowValue', None, None, ), # 1
    (2, TType.I64, 'highValue', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lowValue = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.highValue = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LongColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.I64, 1)
      oprot.writeI64(self.lowValue)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.I64, 2)
      oprot.writeI64(self.highValue)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lowValue is None:
      raise TProtocol.TProtocolException(message='Required field lowValue is unset!')
    if self.highValue is None:
      raise TProtocol.TProtocolException(message='Required field highValue is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StringColumnStatsData:
  """
  Attributes:
   - maxColLen
   - avgColLen
   - numNulls
   - numDVs
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxColLen', None, None, ), # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
  )

  def __init__(self, maxColLen=None, avgColLen=None, numNulls=None, numDVs=None,):
    self.maxColLen = maxColLen
    self.avgColLen = avgColLen
    self.numNulls = numNulls
    self.numDVs = numDVs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxColLen = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.avgColLen = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StringColumnStatsData')
    if self.maxColLen is not None:
      oprot.writeFieldBegin('maxColLen', TType.I64, 1)
      oprot.writeI64(self.maxColLen)
      oprot.writeFieldEnd()
    if self.avgColLen is not None:
      oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
      oprot.writeDouble(self.avgColLen)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.maxColLen is None:
      raise TProtocol.TProtocolException(message='Required field maxColLen is unset!')
    if self.avgColLen is None:
      raise TProtocol.TProtocolException(message='Required field avgColLen is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BinaryColumnStatsData:
  """
  Attributes:
   - maxColLen
   - avgColLen
   - numNulls
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxColLen', None, None, ), # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
  )

  def __init__(self, maxColLen=None, avgColLen=None, numNulls=None,):
    self.maxColLen = maxColLen
    self.avgColLen = avgColLen
    self.numNulls = numNulls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxColLen = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.avgColLen = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BinaryColumnStatsData')
    if self.maxColLen is not None:
      oprot.writeFieldBegin('maxColLen', TType.I64, 1)
      oprot.writeI64(self.maxColLen)
      oprot.writeFieldEnd()
    if self.avgColLen is not None:
      oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
      oprot.writeDouble(self.avgColLen)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.maxColLen is None:
      raise TProtocol.TProtocolException(message='Required field maxColLen is unset!')
    if self.avgColLen is None:
      raise TProtocol.TProtocolException(message='Required field avgColLen is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsData:
  """
  Attributes:
   - booleanStats
   - longStats
   - doubleStats
   - stringStats
   - binaryStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'booleanStats', (BooleanColumnStatsData, BooleanColumnStatsData.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'longStats', (LongColumnStatsData, LongColumnStatsData.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'doubleStats', (DoubleColumnStatsData, DoubleColumnStatsData.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'stringStats', (StringColumnStatsData, StringColumnStatsData.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'binaryStats', (BinaryColumnStatsData, BinaryColumnStatsData.thrift_spec), None, ), # 5
  )

  def __init__(self, booleanStats=None, longStats=None, doubleStats=None, stringStats=None, binaryStats=None,):
    self.booleanStats = booleanStats
    self.longStats = longStats
    self.doubleStats = doubleStats
    self.stringStats = stringStats
    self.binaryStats = binaryStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.booleanStats = BooleanColumnStatsData()
          self.booleanStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.longStats = LongColumnStatsData()
          self.longStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.doubleStats = DoubleColumnStatsData()
          self.doubleStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.stringStats = StringColumnStatsData()
          self.stringStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.binaryStats = BinaryColumnStatsData()
          self.binaryStats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsData')
    if self.booleanStats is not None:
      oprot.writeFieldBegin('booleanStats', TType.STRUCT, 1)
      self.booleanStats.write(oprot)
      oprot.writeFieldEnd()
    if self.longStats is not None:
      oprot.writeFieldBegin('longStats', TType.STRUCT, 2)
      self.longStats.write(oprot)
      oprot.writeFieldEnd()
    if self.doubleStats is not None:
      oprot.writeFieldBegin('doubleStats', TType.STRUCT, 3)
      self.doubleStats.write(oprot)
      oprot.writeFieldEnd()
    if self.stringStats is not None:
      oprot.writeFieldBegin('stringStats', TType.STRUCT, 4)
      self.stringStats.write(oprot)
      oprot.writeFieldEnd()
    if self.binaryStats is not None:
      oprot.writeFieldBegin('binaryStats', TType.STRUCT, 5)
      self.binaryStats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsObj:
  """
  Attributes:
   - colName
   - colType
   - statsData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'colName', None, None, ), # 1
    (2, TType.STRING, 'colType', None, None, ), # 2
    (3, TType.STRUCT, 'statsData', (ColumnStatisticsData, ColumnStatisticsData.thrift_spec), None, ), # 3
  )

  def __init__(self, colName=None, colType=None, statsData=None,):
    self.colName = colName
    self.colType = colType
    self.statsData = statsData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.colName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.statsData = ColumnStatisticsData()
          self.statsData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsObj')
    if self.colName is not None:
      oprot.writeFieldBegin('colName', TType.STRING, 1)
      oprot.writeString(self.colName)
      oprot.writeFieldEnd()
    if self.colType is not None:
      oprot.writeFieldBegin('colType', TType.STRING, 2)
      oprot.writeString(self.colType)
      oprot.writeFieldEnd()
    if self.statsData is not None:
      oprot.writeFieldBegin('statsData', TType.STRUCT, 3)
      self.statsData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colName is None:
      raise TProtocol.TProtocolException(message='Required field colName is unset!')
    if self.colType is None:
      raise TProtocol.TProtocolException(message='Required field colType is unset!')
    if self.statsData is None:
      raise TProtocol.TProtocolException(message='Required field statsData is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsDesc:
  """
  Attributes:
   - isTblLevel
   - dbName
   - tableName
   - partName
   - lastAnalyzed
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isTblLevel', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.STRING, 'partName', None, None, ), # 4
    (5, TType.I64, 'lastAnalyzed', None, None, ), # 5
  )

  def __init__(self, isTblLevel=None, dbName=None, tableName=None, partName=None, lastAnalyzed=None,):
    self.isTblLevel = isTblLevel
    self.dbName = dbName
    self.tableName = tableName
    self.partName = partName
    self.lastAnalyzed = lastAnalyzed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isTblLevel = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.partName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.lastAnalyzed = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsDesc')
    if self.isTblLevel is not None:
      oprot.writeFieldBegin('isTblLevel', TType.BOOL, 1)
      oprot.writeBool(self.isTblLevel)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partName is not None:
      oprot.writeFieldBegin('partName', TType.STRING, 4)
      oprot.writeString(self.partName)
      oprot.writeFieldEnd()
    if self.lastAnalyzed is not None:
      oprot.writeFieldBegin('lastAnalyzed', TType.I64, 5)
      oprot.writeI64(self.lastAnalyzed)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isTblLevel is None:
      raise TProtocol.TProtocolException(message='Required field isTblLevel is unset!')
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatistics:
  """
  Attributes:
   - statsDesc
   - statsObj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'statsDesc', (ColumnStatisticsDesc, ColumnStatisticsDesc.thrift_spec), None, ), # 1
    (2, TType.LIST, 'statsObj', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 2
  )

  def __init__(self, statsDesc=None, statsObj=None,):
    self.statsDesc = statsDesc
    self.statsObj = statsObj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.statsDesc = ColumnStatisticsDesc()
          self.statsDesc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.statsObj = []
          (_etype198, _size195) = iprot.readListBegin()
          for _i199 in xrange(_size195):
            _elem200 = ColumnStatisticsObj()
            _elem200.read(iprot)
            self.statsObj.append(_elem200)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatistics')
    if self.statsDesc is not None:
      oprot.writeFieldBegin('statsDesc', TType.STRUCT, 1)
      self.statsDesc.write(oprot)
      oprot.writeFieldEnd()
    if self.statsObj is not None:
      oprot.writeFieldBegin('statsObj', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.statsObj))
      for iter201 in self.statsObj:
        iter201.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.statsDesc is None:
      raise TProtocol.TProtocolException(message='Required field statsDesc is unset!')
    if self.statsObj is None:
      raise TProtocol.TProtocolException(message='Required field statsObj is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Schema:
  """
  Attributes:
   - fieldSchemas
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fieldSchemas', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, fieldSchemas=None, properties=None,):
    self.fieldSchemas = fieldSchemas
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fieldSchemas = []
          (_etype205, _size202) = iprot.readListBegin()
          for _i206 in xrange(_size202):
            _elem207 = FieldSchema()
            _elem207.read(iprot)
            self.fieldSchemas.append(_elem207)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype209, _vtype210, _size208 ) = iprot.readMapBegin() 
          for _i212 in xrange(_size208):
            _key213 = iprot.readString();
            _val214 = iprot.readString();
            self.properties[_key213] = _val214
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Schema')
    if self.fieldSchemas is not None:
      oprot.writeFieldBegin('fieldSchemas', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.fieldSchemas))
      for iter215 in self.fieldSchemas:
        iter215.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter216,viter217 in self.properties.items():
        oprot.writeString(kiter216)
        oprot.writeString(viter217)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EnvironmentContext:
  """
  Attributes:
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, properties=None,):
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype219, _vtype220, _size218 ) = iprot.readMapBegin() 
          for _i222 in xrange(_size218):
            _key223 = iprot.readString();
            _val224 = iprot.readString();
            self.properties[_key223] = _val224
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EnvironmentContext')
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter225,viter226 in self.properties.items():
        oprot.writeString(kiter225)
        oprot.writeString(viter226)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetaException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetaException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownTableException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownTableException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownDBException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownDBException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AlreadyExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AlreadyExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidPartitionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidPartitionException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownPartitionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownPartitionException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidObjectException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidObjectException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchObjectException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchObjectException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndexAlreadyExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndexAlreadyExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidOperationException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidOperationException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigValSecurityException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigValSecurityException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidInputException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidInputException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
