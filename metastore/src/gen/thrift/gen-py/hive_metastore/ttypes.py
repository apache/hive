#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import fb303.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class HiveObjectType:
  GLOBAL = 1
  DATABASE = 2
  TABLE = 3
  PARTITION = 4
  COLUMN = 5

  _VALUES_TO_NAMES = {
    1: "GLOBAL",
    2: "DATABASE",
    3: "TABLE",
    4: "PARTITION",
    5: "COLUMN",
  }

  _NAMES_TO_VALUES = {
    "GLOBAL": 1,
    "DATABASE": 2,
    "TABLE": 3,
    "PARTITION": 4,
    "COLUMN": 5,
  }

class PrincipalType:
  USER = 1
  ROLE = 2
  GROUP = 3

  _VALUES_TO_NAMES = {
    1: "USER",
    2: "ROLE",
    3: "GROUP",
  }

  _NAMES_TO_VALUES = {
    "USER": 1,
    "ROLE": 2,
    "GROUP": 3,
  }

class PartitionEventType:
  LOAD_DONE = 1

  _VALUES_TO_NAMES = {
    1: "LOAD_DONE",
  }

  _NAMES_TO_VALUES = {
    "LOAD_DONE": 1,
  }

class TxnState:
  COMMITTED = 1
  ABORTED = 2
  OPEN = 3

  _VALUES_TO_NAMES = {
    1: "COMMITTED",
    2: "ABORTED",
    3: "OPEN",
  }

  _NAMES_TO_VALUES = {
    "COMMITTED": 1,
    "ABORTED": 2,
    "OPEN": 3,
  }

class LockLevel:
  DB = 1
  TABLE = 2
  PARTITION = 3

  _VALUES_TO_NAMES = {
    1: "DB",
    2: "TABLE",
    3: "PARTITION",
  }

  _NAMES_TO_VALUES = {
    "DB": 1,
    "TABLE": 2,
    "PARTITION": 3,
  }

class LockState:
  ACQUIRED = 1
  WAITING = 2
  ABORT = 3
  NOT_ACQUIRED = 4

  _VALUES_TO_NAMES = {
    1: "ACQUIRED",
    2: "WAITING",
    3: "ABORT",
    4: "NOT_ACQUIRED",
  }

  _NAMES_TO_VALUES = {
    "ACQUIRED": 1,
    "WAITING": 2,
    "ABORT": 3,
    "NOT_ACQUIRED": 4,
  }

class LockType:
  SHARED_READ = 1
  SHARED_WRITE = 2
  EXCLUSIVE = 3

  _VALUES_TO_NAMES = {
    1: "SHARED_READ",
    2: "SHARED_WRITE",
    3: "EXCLUSIVE",
  }

  _NAMES_TO_VALUES = {
    "SHARED_READ": 1,
    "SHARED_WRITE": 2,
    "EXCLUSIVE": 3,
  }

class CompactionType:
  MINOR = 1
  MAJOR = 2

  _VALUES_TO_NAMES = {
    1: "MINOR",
    2: "MAJOR",
  }

  _NAMES_TO_VALUES = {
    "MINOR": 1,
    "MAJOR": 2,
  }

class GrantRevokeType:
  GRANT = 1
  REVOKE = 2

  _VALUES_TO_NAMES = {
    1: "GRANT",
    2: "REVOKE",
  }

  _NAMES_TO_VALUES = {
    "GRANT": 1,
    "REVOKE": 2,
  }

class DataOperationType:
  SELECT = 1
  INSERT = 2
  UPDATE = 3
  DELETE = 4
  UNSET = 5
  NO_TXN = 6

  _VALUES_TO_NAMES = {
    1: "SELECT",
    2: "INSERT",
    3: "UPDATE",
    4: "DELETE",
    5: "UNSET",
    6: "NO_TXN",
  }

  _NAMES_TO_VALUES = {
    "SELECT": 1,
    "INSERT": 2,
    "UPDATE": 3,
    "DELETE": 4,
    "UNSET": 5,
    "NO_TXN": 6,
  }

class EventRequestType:
  INSERT = 1
  UPDATE = 2
  DELETE = 3

  _VALUES_TO_NAMES = {
    1: "INSERT",
    2: "UPDATE",
    3: "DELETE",
  }

  _NAMES_TO_VALUES = {
    "INSERT": 1,
    "UPDATE": 2,
    "DELETE": 3,
  }

class FunctionType:
  JAVA = 1

  _VALUES_TO_NAMES = {
    1: "JAVA",
  }

  _NAMES_TO_VALUES = {
    "JAVA": 1,
  }

class ResourceType:
  JAR = 1
  FILE = 2
  ARCHIVE = 3

  _VALUES_TO_NAMES = {
    1: "JAR",
    2: "FILE",
    3: "ARCHIVE",
  }

  _NAMES_TO_VALUES = {
    "JAR": 1,
    "FILE": 2,
    "ARCHIVE": 3,
  }

class FileMetadataExprType:
  ORC_SARG = 1

  _VALUES_TO_NAMES = {
    1: "ORC_SARG",
  }

  _NAMES_TO_VALUES = {
    "ORC_SARG": 1,
  }

class ClientCapability:
  TEST_CAPABILITY = 1

  _VALUES_TO_NAMES = {
    1: "TEST_CAPABILITY",
  }

  _NAMES_TO_VALUES = {
    "TEST_CAPABILITY": 1,
  }


class Version:
  """
  Attributes:
   - version
   - comments
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'version', None, None, ), # 1
    (2, TType.STRING, 'comments', None, None, ), # 2
  )

  def __init__(self, version=None, comments=None,):
    self.version = version
    self.comments = comments

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.version = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comments = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Version')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 1)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 2)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.comments)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FieldSchema:
  """
  Attributes:
   - name
   - type
   - comment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type', None, None, ), # 2
    (3, TType.STRING, 'comment', None, None, ), # 3
  )

  def __init__(self, name=None, type=None, comment=None,):
    self.name = name
    self.type = type
    self.comment = comment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FieldSchema')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 2)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 3)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.comment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLPrimaryKey:
  """
  Attributes:
   - table_db
   - table_name
   - column_name
   - key_seq
   - pk_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_db', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'column_name', None, None, ), # 3
    (4, TType.I32, 'key_seq', None, None, ), # 4
    (5, TType.STRING, 'pk_name', None, None, ), # 5
    (6, TType.BOOL, 'enable_cstr', None, None, ), # 6
    (7, TType.BOOL, 'validate_cstr', None, None, ), # 7
    (8, TType.BOOL, 'rely_cstr', None, None, ), # 8
  )

  def __init__(self, table_db=None, table_name=None, column_name=None, key_seq=None, pk_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
    self.table_db = table_db
    self.table_name = table_name
    self.column_name = column_name
    self.key_seq = key_seq
    self.pk_name = pk_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.key_seq = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.pk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLPrimaryKey')
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 1)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.column_name is not None:
      oprot.writeFieldBegin('column_name', TType.STRING, 3)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.key_seq is not None:
      oprot.writeFieldBegin('key_seq', TType.I32, 4)
      oprot.writeI32(self.key_seq)
      oprot.writeFieldEnd()
    if self.pk_name is not None:
      oprot.writeFieldBegin('pk_name', TType.STRING, 5)
      oprot.writeString(self.pk_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 6)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 7)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 8)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table_db)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.column_name)
    value = (value * 31) ^ hash(self.key_seq)
    value = (value * 31) ^ hash(self.pk_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLForeignKey:
  """
  Attributes:
   - pktable_db
   - pktable_name
   - pkcolumn_name
   - fktable_db
   - fktable_name
   - fkcolumn_name
   - key_seq
   - update_rule
   - delete_rule
   - fk_name
   - pk_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pktable_db', None, None, ), # 1
    (2, TType.STRING, 'pktable_name', None, None, ), # 2
    (3, TType.STRING, 'pkcolumn_name', None, None, ), # 3
    (4, TType.STRING, 'fktable_db', None, None, ), # 4
    (5, TType.STRING, 'fktable_name', None, None, ), # 5
    (6, TType.STRING, 'fkcolumn_name', None, None, ), # 6
    (7, TType.I32, 'key_seq', None, None, ), # 7
    (8, TType.I32, 'update_rule', None, None, ), # 8
    (9, TType.I32, 'delete_rule', None, None, ), # 9
    (10, TType.STRING, 'fk_name', None, None, ), # 10
    (11, TType.STRING, 'pk_name', None, None, ), # 11
    (12, TType.BOOL, 'enable_cstr', None, None, ), # 12
    (13, TType.BOOL, 'validate_cstr', None, None, ), # 13
    (14, TType.BOOL, 'rely_cstr', None, None, ), # 14
  )

  def __init__(self, pktable_db=None, pktable_name=None, pkcolumn_name=None, fktable_db=None, fktable_name=None, fkcolumn_name=None, key_seq=None, update_rule=None, delete_rule=None, fk_name=None, pk_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
    self.pktable_db = pktable_db
    self.pktable_name = pktable_name
    self.pkcolumn_name = pkcolumn_name
    self.fktable_db = fktable_db
    self.fktable_name = fktable_name
    self.fkcolumn_name = fkcolumn_name
    self.key_seq = key_seq
    self.update_rule = update_rule
    self.delete_rule = delete_rule
    self.fk_name = fk_name
    self.pk_name = pk_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pktable_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pktable_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pkcolumn_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.fktable_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.fktable_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.fkcolumn_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.key_seq = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.update_rule = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.delete_rule = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.fk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.pk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLForeignKey')
    if self.pktable_db is not None:
      oprot.writeFieldBegin('pktable_db', TType.STRING, 1)
      oprot.writeString(self.pktable_db)
      oprot.writeFieldEnd()
    if self.pktable_name is not None:
      oprot.writeFieldBegin('pktable_name', TType.STRING, 2)
      oprot.writeString(self.pktable_name)
      oprot.writeFieldEnd()
    if self.pkcolumn_name is not None:
      oprot.writeFieldBegin('pkcolumn_name', TType.STRING, 3)
      oprot.writeString(self.pkcolumn_name)
      oprot.writeFieldEnd()
    if self.fktable_db is not None:
      oprot.writeFieldBegin('fktable_db', TType.STRING, 4)
      oprot.writeString(self.fktable_db)
      oprot.writeFieldEnd()
    if self.fktable_name is not None:
      oprot.writeFieldBegin('fktable_name', TType.STRING, 5)
      oprot.writeString(self.fktable_name)
      oprot.writeFieldEnd()
    if self.fkcolumn_name is not None:
      oprot.writeFieldBegin('fkcolumn_name', TType.STRING, 6)
      oprot.writeString(self.fkcolumn_name)
      oprot.writeFieldEnd()
    if self.key_seq is not None:
      oprot.writeFieldBegin('key_seq', TType.I32, 7)
      oprot.writeI32(self.key_seq)
      oprot.writeFieldEnd()
    if self.update_rule is not None:
      oprot.writeFieldBegin('update_rule', TType.I32, 8)
      oprot.writeI32(self.update_rule)
      oprot.writeFieldEnd()
    if self.delete_rule is not None:
      oprot.writeFieldBegin('delete_rule', TType.I32, 9)
      oprot.writeI32(self.delete_rule)
      oprot.writeFieldEnd()
    if self.fk_name is not None:
      oprot.writeFieldBegin('fk_name', TType.STRING, 10)
      oprot.writeString(self.fk_name)
      oprot.writeFieldEnd()
    if self.pk_name is not None:
      oprot.writeFieldBegin('pk_name', TType.STRING, 11)
      oprot.writeString(self.pk_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 12)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 13)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 14)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pktable_db)
    value = (value * 31) ^ hash(self.pktable_name)
    value = (value * 31) ^ hash(self.pkcolumn_name)
    value = (value * 31) ^ hash(self.fktable_db)
    value = (value * 31) ^ hash(self.fktable_name)
    value = (value * 31) ^ hash(self.fkcolumn_name)
    value = (value * 31) ^ hash(self.key_seq)
    value = (value * 31) ^ hash(self.update_rule)
    value = (value * 31) ^ hash(self.delete_rule)
    value = (value * 31) ^ hash(self.fk_name)
    value = (value * 31) ^ hash(self.pk_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Type:
  """
  Attributes:
   - name
   - type1
   - type2
   - fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type1', None, None, ), # 2
    (3, TType.STRING, 'type2', None, None, ), # 3
    (4, TType.LIST, 'fields', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 4
  )

  def __init__(self, name=None, type1=None, type2=None, fields=None,):
    self.name = name
    self.type1 = type1
    self.type2 = type2
    self.fields = fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type1 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.type2 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fields = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = FieldSchema()
            _elem5.read(iprot)
            self.fields.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Type')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type1 is not None:
      oprot.writeFieldBegin('type1', TType.STRING, 2)
      oprot.writeString(self.type1)
      oprot.writeFieldEnd()
    if self.type2 is not None:
      oprot.writeFieldBegin('type2', TType.STRING, 3)
      oprot.writeString(self.type2)
      oprot.writeFieldEnd()
    if self.fields is not None:
      oprot.writeFieldBegin('fields', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter6 in self.fields:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.type1)
    value = (value * 31) ^ hash(self.type2)
    value = (value * 31) ^ hash(self.fields)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HiveObjectRef:
  """
  Attributes:
   - objectType
   - dbName
   - objectName
   - partValues
   - columnName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'objectType', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'objectName', None, None, ), # 3
    (4, TType.LIST, 'partValues', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'columnName', None, None, ), # 5
  )

  def __init__(self, objectType=None, dbName=None, objectName=None, partValues=None, columnName=None,):
    self.objectType = objectType
    self.dbName = dbName
    self.objectName = objectName
    self.partValues = partValues
    self.columnName = columnName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.objectType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.objectName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partValues = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString()
            self.partValues.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.columnName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HiveObjectRef')
    if self.objectType is not None:
      oprot.writeFieldBegin('objectType', TType.I32, 1)
      oprot.writeI32(self.objectType)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.objectName is not None:
      oprot.writeFieldBegin('objectName', TType.STRING, 3)
      oprot.writeString(self.objectName)
      oprot.writeFieldEnd()
    if self.partValues is not None:
      oprot.writeFieldBegin('partValues', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.partValues))
      for iter13 in self.partValues:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.columnName is not None:
      oprot.writeFieldBegin('columnName', TType.STRING, 5)
      oprot.writeString(self.columnName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.objectType)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.objectName)
    value = (value * 31) ^ hash(self.partValues)
    value = (value * 31) ^ hash(self.columnName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrivilegeGrantInfo:
  """
  Attributes:
   - privilege
   - createTime
   - grantor
   - grantorType
   - grantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'privilege', None, None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.STRING, 'grantor', None, None, ), # 3
    (4, TType.I32, 'grantorType', None, None, ), # 4
    (5, TType.BOOL, 'grantOption', None, None, ), # 5
  )

  def __init__(self, privilege=None, createTime=None, grantor=None, grantorType=None, grantOption=None,):
    self.privilege = privilege
    self.createTime = createTime
    self.grantor = grantor
    self.grantorType = grantorType
    self.grantOption = grantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.privilege = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.grantor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrivilegeGrantInfo')
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.STRING, 1)
      oprot.writeString(self.privilege)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 3)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 4)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 5)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privilege)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.grantor)
    value = (value * 31) ^ hash(self.grantorType)
    value = (value * 31) ^ hash(self.grantOption)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HiveObjectPrivilege:
  """
  Attributes:
   - hiveObject
   - principalName
   - principalType
   - grantInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 1
    (2, TType.STRING, 'principalName', None, None, ), # 2
    (3, TType.I32, 'principalType', None, None, ), # 3
    (4, TType.STRUCT, 'grantInfo', (PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec), None, ), # 4
  )

  def __init__(self, hiveObject=None, principalName=None, principalType=None, grantInfo=None,):
    self.hiveObject = hiveObject
    self.principalName = principalName
    self.principalType = principalType
    self.grantInfo = grantInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principalName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.grantInfo = PrivilegeGrantInfo()
          self.grantInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HiveObjectPrivilege')
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 2)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 3)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantInfo is not None:
      oprot.writeFieldBegin('grantInfo', TType.STRUCT, 4)
      self.grantInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hiveObject)
    value = (value * 31) ^ hash(self.principalName)
    value = (value * 31) ^ hash(self.principalType)
    value = (value * 31) ^ hash(self.grantInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrivilegeBag:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'privileges', (TType.STRUCT,(HiveObjectPrivilege, HiveObjectPrivilege.thrift_spec)), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.privileges = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = HiveObjectPrivilege()
            _elem19.read(iprot)
            self.privileges.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrivilegeBag')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.privileges))
      for iter20 in self.privileges:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrincipalPrivilegeSet:
  """
  Attributes:
   - userPrivileges
   - groupPrivileges
   - rolePrivileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'userPrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 1
    (2, TType.MAP, 'groupPrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 2
    (3, TType.MAP, 'rolePrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 3
  )

  def __init__(self, userPrivileges=None, groupPrivileges=None, rolePrivileges=None,):
    self.userPrivileges = userPrivileges
    self.groupPrivileges = groupPrivileges
    self.rolePrivileges = rolePrivileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.userPrivileges = {}
          (_ktype22, _vtype23, _size21 ) = iprot.readMapBegin()
          for _i25 in xrange(_size21):
            _key26 = iprot.readString()
            _val27 = []
            (_etype31, _size28) = iprot.readListBegin()
            for _i32 in xrange(_size28):
              _elem33 = PrivilegeGrantInfo()
              _elem33.read(iprot)
              _val27.append(_elem33)
            iprot.readListEnd()
            self.userPrivileges[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.groupPrivileges = {}
          (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin()
          for _i38 in xrange(_size34):
            _key39 = iprot.readString()
            _val40 = []
            (_etype44, _size41) = iprot.readListBegin()
            for _i45 in xrange(_size41):
              _elem46 = PrivilegeGrantInfo()
              _elem46.read(iprot)
              _val40.append(_elem46)
            iprot.readListEnd()
            self.groupPrivileges[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.rolePrivileges = {}
          (_ktype48, _vtype49, _size47 ) = iprot.readMapBegin()
          for _i51 in xrange(_size47):
            _key52 = iprot.readString()
            _val53 = []
            (_etype57, _size54) = iprot.readListBegin()
            for _i58 in xrange(_size54):
              _elem59 = PrivilegeGrantInfo()
              _elem59.read(iprot)
              _val53.append(_elem59)
            iprot.readListEnd()
            self.rolePrivileges[_key52] = _val53
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrincipalPrivilegeSet')
    if self.userPrivileges is not None:
      oprot.writeFieldBegin('userPrivileges', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.userPrivileges))
      for kiter60,viter61 in self.userPrivileges.items():
        oprot.writeString(kiter60)
        oprot.writeListBegin(TType.STRUCT, len(viter61))
        for iter62 in viter61:
          iter62.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.groupPrivileges is not None:
      oprot.writeFieldBegin('groupPrivileges', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.groupPrivileges))
      for kiter63,viter64 in self.groupPrivileges.items():
        oprot.writeString(kiter63)
        oprot.writeListBegin(TType.STRUCT, len(viter64))
        for iter65 in viter64:
          iter65.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.rolePrivileges is not None:
      oprot.writeFieldBegin('rolePrivileges', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.rolePrivileges))
      for kiter66,viter67 in self.rolePrivileges.items():
        oprot.writeString(kiter66)
        oprot.writeListBegin(TType.STRUCT, len(viter67))
        for iter68 in viter67:
          iter68.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.userPrivileges)
    value = (value * 31) ^ hash(self.groupPrivileges)
    value = (value * 31) ^ hash(self.rolePrivileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokePrivilegeRequest:
  """
  Attributes:
   - requestType
   - privileges
   - revokeGrantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'requestType', None, None, ), # 1
    (2, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'revokeGrantOption', None, None, ), # 3
  )

  def __init__(self, requestType=None, privileges=None, revokeGrantOption=None,):
    self.requestType = requestType
    self.privileges = privileges
    self.revokeGrantOption = revokeGrantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.requestType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.revokeGrantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokePrivilegeRequest')
    if self.requestType is not None:
      oprot.writeFieldBegin('requestType', TType.I32, 1)
      oprot.writeI32(self.requestType)
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 2)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.revokeGrantOption is not None:
      oprot.writeFieldBegin('revokeGrantOption', TType.BOOL, 3)
      oprot.writeBool(self.revokeGrantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestType)
    value = (value * 31) ^ hash(self.privileges)
    value = (value * 31) ^ hash(self.revokeGrantOption)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokePrivilegeResponse:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokePrivilegeResponse')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Role:
  """
  Attributes:
   - roleName
   - createTime
   - ownerName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.STRING, 'ownerName', None, None, ), # 3
  )

  def __init__(self, roleName=None, createTime=None, ownerName=None,):
    self.roleName = roleName
    self.createTime = createTime
    self.ownerName = ownerName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Role')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 3)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roleName)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.ownerName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RolePrincipalGrant:
  """
  Attributes:
   - roleName
   - principalName
   - principalType
   - grantOption
   - grantTime
   - grantorName
   - grantorPrincipalType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
    (2, TType.STRING, 'principalName', None, None, ), # 2
    (3, TType.I32, 'principalType', None, None, ), # 3
    (4, TType.BOOL, 'grantOption', None, None, ), # 4
    (5, TType.I32, 'grantTime', None, None, ), # 5
    (6, TType.STRING, 'grantorName', None, None, ), # 6
    (7, TType.I32, 'grantorPrincipalType', None, None, ), # 7
  )

  def __init__(self, roleName=None, principalName=None, principalType=None, grantOption=None, grantTime=None, grantorName=None, grantorPrincipalType=None,):
    self.roleName = roleName
    self.principalName = principalName
    self.principalType = principalType
    self.grantOption = grantOption
    self.grantTime = grantTime
    self.grantorName = grantorName
    self.grantorPrincipalType = grantorPrincipalType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principalName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.grantTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.grantorName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.grantorPrincipalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RolePrincipalGrant')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 2)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 3)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 4)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    if self.grantTime is not None:
      oprot.writeFieldBegin('grantTime', TType.I32, 5)
      oprot.writeI32(self.grantTime)
      oprot.writeFieldEnd()
    if self.grantorName is not None:
      oprot.writeFieldBegin('grantorName', TType.STRING, 6)
      oprot.writeString(self.grantorName)
      oprot.writeFieldEnd()
    if self.grantorPrincipalType is not None:
      oprot.writeFieldBegin('grantorPrincipalType', TType.I32, 7)
      oprot.writeI32(self.grantorPrincipalType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roleName)
    value = (value * 31) ^ hash(self.principalName)
    value = (value * 31) ^ hash(self.principalType)
    value = (value * 31) ^ hash(self.grantOption)
    value = (value * 31) ^ hash(self.grantTime)
    value = (value * 31) ^ hash(self.grantorName)
    value = (value * 31) ^ hash(self.grantorPrincipalType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRoleGrantsForPrincipalRequest:
  """
  Attributes:
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
  )

  def __init__(self, principal_name=None, principal_type=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRoleGrantsForPrincipalRequest')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.principal_name is None:
      raise TProtocol.TProtocolException(message='Required field principal_name is unset!')
    if self.principal_type is None:
      raise TProtocol.TProtocolException(message='Required field principal_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRoleGrantsForPrincipalResponse:
  """
  Attributes:
   - principalGrants
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'principalGrants', (TType.STRUCT,(RolePrincipalGrant, RolePrincipalGrant.thrift_spec)), None, ), # 1
  )

  def __init__(self, principalGrants=None,):
    self.principalGrants = principalGrants

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.principalGrants = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = RolePrincipalGrant()
            _elem74.read(iprot)
            self.principalGrants.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRoleGrantsForPrincipalResponse')
    if self.principalGrants is not None:
      oprot.writeFieldBegin('principalGrants', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.principalGrants))
      for iter75 in self.principalGrants:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.principalGrants is None:
      raise TProtocol.TProtocolException(message='Required field principalGrants is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principalGrants)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPrincipalsInRoleRequest:
  """
  Attributes:
   - roleName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
  )

  def __init__(self, roleName=None,):
    self.roleName = roleName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPrincipalsInRoleRequest')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.roleName is None:
      raise TProtocol.TProtocolException(message='Required field roleName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roleName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPrincipalsInRoleResponse:
  """
  Attributes:
   - principalGrants
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'principalGrants', (TType.STRUCT,(RolePrincipalGrant, RolePrincipalGrant.thrift_spec)), None, ), # 1
  )

  def __init__(self, principalGrants=None,):
    self.principalGrants = principalGrants

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.principalGrants = []
          (_etype79, _size76) = iprot.readListBegin()
          for _i80 in xrange(_size76):
            _elem81 = RolePrincipalGrant()
            _elem81.read(iprot)
            self.principalGrants.append(_elem81)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPrincipalsInRoleResponse')
    if self.principalGrants is not None:
      oprot.writeFieldBegin('principalGrants', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.principalGrants))
      for iter82 in self.principalGrants:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.principalGrants is None:
      raise TProtocol.TProtocolException(message='Required field principalGrants is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principalGrants)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokeRoleRequest:
  """
  Attributes:
   - requestType
   - roleName
   - principalName
   - principalType
   - grantor
   - grantorType
   - grantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'requestType', None, None, ), # 1
    (2, TType.STRING, 'roleName', None, None, ), # 2
    (3, TType.STRING, 'principalName', None, None, ), # 3
    (4, TType.I32, 'principalType', None, None, ), # 4
    (5, TType.STRING, 'grantor', None, None, ), # 5
    (6, TType.I32, 'grantorType', None, None, ), # 6
    (7, TType.BOOL, 'grantOption', None, None, ), # 7
  )

  def __init__(self, requestType=None, roleName=None, principalName=None, principalType=None, grantor=None, grantorType=None, grantOption=None,):
    self.requestType = requestType
    self.roleName = roleName
    self.principalName = principalName
    self.principalType = principalType
    self.grantor = grantor
    self.grantorType = grantorType
    self.grantOption = grantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.requestType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.principalName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.principalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.grantor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokeRoleRequest')
    if self.requestType is not None:
      oprot.writeFieldBegin('requestType', TType.I32, 1)
      oprot.writeI32(self.requestType)
      oprot.writeFieldEnd()
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 2)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 3)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 4)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 5)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 6)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 7)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestType)
    value = (value * 31) ^ hash(self.roleName)
    value = (value * 31) ^ hash(self.principalName)
    value = (value * 31) ^ hash(self.principalType)
    value = (value * 31) ^ hash(self.grantor)
    value = (value * 31) ^ hash(self.grantorType)
    value = (value * 31) ^ hash(self.grantOption)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokeRoleResponse:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokeRoleResponse')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Database:
  """
  Attributes:
   - name
   - description
   - locationUri
   - parameters
   - privileges
   - ownerName
   - ownerType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
    (3, TType.STRING, 'locationUri', None, None, ), # 3
    (4, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 4
    (5, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 5
    (6, TType.STRING, 'ownerName', None, None, ), # 6
    (7, TType.I32, 'ownerType', None, None, ), # 7
  )

  def __init__(self, name=None, description=None, locationUri=None, parameters=None, privileges=None, ownerName=None, ownerType=None,):
    self.name = name
    self.description = description
    self.locationUri = locationUri
    self.parameters = parameters
    self.privileges = privileges
    self.ownerName = ownerName
    self.ownerType = ownerType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.locationUri = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype84, _vtype85, _size83 ) = iprot.readMapBegin()
          for _i87 in xrange(_size83):
            _key88 = iprot.readString()
            _val89 = iprot.readString()
            self.parameters[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.ownerType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Database')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.locationUri is not None:
      oprot.writeFieldBegin('locationUri', TType.STRING, 3)
      oprot.writeString(self.locationUri)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter90,viter91 in self.parameters.items():
        oprot.writeString(kiter90)
        oprot.writeString(viter91)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 5)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 6)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    if self.ownerType is not None:
      oprot.writeFieldBegin('ownerType', TType.I32, 7)
      oprot.writeI32(self.ownerType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.locationUri)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.privileges)
    value = (value * 31) ^ hash(self.ownerName)
    value = (value * 31) ^ hash(self.ownerType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SerDeInfo:
  """
  Attributes:
   - name
   - serializationLib
   - parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'serializationLib', None, None, ), # 2
    (3, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, name=None, serializationLib=None, parameters=None,):
    self.name = name
    self.serializationLib = serializationLib
    self.parameters = parameters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serializationLib = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype93, _vtype94, _size92 ) = iprot.readMapBegin()
          for _i96 in xrange(_size92):
            _key97 = iprot.readString()
            _val98 = iprot.readString()
            self.parameters[_key97] = _val98
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SerDeInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.serializationLib is not None:
      oprot.writeFieldBegin('serializationLib', TType.STRING, 2)
      oprot.writeString(self.serializationLib)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter99,viter100 in self.parameters.items():
        oprot.writeString(kiter99)
        oprot.writeString(viter100)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.serializationLib)
    value = (value * 31) ^ hash(self.parameters)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Order:
  """
  Attributes:
   - col
   - order
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col', None, None, ), # 1
    (2, TType.I32, 'order', None, None, ), # 2
  )

  def __init__(self, col=None, order=None,):
    self.col = col
    self.order = order

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.order = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Order')
    if self.col is not None:
      oprot.writeFieldBegin('col', TType.STRING, 1)
      oprot.writeString(self.col)
      oprot.writeFieldEnd()
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 2)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.col)
    value = (value * 31) ^ hash(self.order)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SkewedInfo:
  """
  Attributes:
   - skewedColNames
   - skewedColValues
   - skewedColValueLocationMaps
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'skewedColNames', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'skewedColValues', (TType.LIST,(TType.STRING,None)), None, ), # 2
    (3, TType.MAP, 'skewedColValueLocationMaps', (TType.LIST,(TType.STRING,None),TType.STRING,None), None, ), # 3
  )

  def __init__(self, skewedColNames=None, skewedColValues=None, skewedColValueLocationMaps=None,):
    self.skewedColNames = skewedColNames
    self.skewedColValues = skewedColValues
    self.skewedColValueLocationMaps = skewedColValueLocationMaps

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.skewedColNames = []
          (_etype104, _size101) = iprot.readListBegin()
          for _i105 in xrange(_size101):
            _elem106 = iprot.readString()
            self.skewedColNames.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.skewedColValues = []
          (_etype110, _size107) = iprot.readListBegin()
          for _i111 in xrange(_size107):
            _elem112 = []
            (_etype116, _size113) = iprot.readListBegin()
            for _i117 in xrange(_size113):
              _elem118 = iprot.readString()
              _elem112.append(_elem118)
            iprot.readListEnd()
            self.skewedColValues.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.skewedColValueLocationMaps = {}
          (_ktype120, _vtype121, _size119 ) = iprot.readMapBegin()
          for _i123 in xrange(_size119):
            _key124 = []
            (_etype129, _size126) = iprot.readListBegin()
            for _i130 in xrange(_size126):
              _elem131 = iprot.readString()
              _key124.append(_elem131)
            iprot.readListEnd()
            _val125 = iprot.readString()
            self.skewedColValueLocationMaps[_key124] = _val125
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SkewedInfo')
    if self.skewedColNames is not None:
      oprot.writeFieldBegin('skewedColNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.skewedColNames))
      for iter132 in self.skewedColNames:
        oprot.writeString(iter132)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewedColValues is not None:
      oprot.writeFieldBegin('skewedColValues', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.skewedColValues))
      for iter133 in self.skewedColValues:
        oprot.writeListBegin(TType.STRING, len(iter133))
        for iter134 in iter133:
          oprot.writeString(iter134)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewedColValueLocationMaps is not None:
      oprot.writeFieldBegin('skewedColValueLocationMaps', TType.MAP, 3)
      oprot.writeMapBegin(TType.LIST, TType.STRING, len(self.skewedColValueLocationMaps))
      for kiter135,viter136 in self.skewedColValueLocationMaps.items():
        oprot.writeListBegin(TType.STRING, len(kiter135))
        for iter137 in kiter135:
          oprot.writeString(iter137)
        oprot.writeListEnd()
        oprot.writeString(viter136)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.skewedColNames)
    value = (value * 31) ^ hash(self.skewedColValues)
    value = (value * 31) ^ hash(self.skewedColValueLocationMaps)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StorageDescriptor:
  """
  Attributes:
   - cols
   - location
   - inputFormat
   - outputFormat
   - compressed
   - numBuckets
   - serdeInfo
   - bucketCols
   - sortCols
   - parameters
   - skewedInfo
   - storedAsSubDirectories
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cols', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'location', None, None, ), # 2
    (3, TType.STRING, 'inputFormat', None, None, ), # 3
    (4, TType.STRING, 'outputFormat', None, None, ), # 4
    (5, TType.BOOL, 'compressed', None, None, ), # 5
    (6, TType.I32, 'numBuckets', None, None, ), # 6
    (7, TType.STRUCT, 'serdeInfo', (SerDeInfo, SerDeInfo.thrift_spec), None, ), # 7
    (8, TType.LIST, 'bucketCols', (TType.STRING,None), None, ), # 8
    (9, TType.LIST, 'sortCols', (TType.STRUCT,(Order, Order.thrift_spec)), None, ), # 9
    (10, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 10
    (11, TType.STRUCT, 'skewedInfo', (SkewedInfo, SkewedInfo.thrift_spec), None, ), # 11
    (12, TType.BOOL, 'storedAsSubDirectories', None, None, ), # 12
  )

  def __init__(self, cols=None, location=None, inputFormat=None, outputFormat=None, compressed=None, numBuckets=None, serdeInfo=None, bucketCols=None, sortCols=None, parameters=None, skewedInfo=None, storedAsSubDirectories=None,):
    self.cols = cols
    self.location = location
    self.inputFormat = inputFormat
    self.outputFormat = outputFormat
    self.compressed = compressed
    self.numBuckets = numBuckets
    self.serdeInfo = serdeInfo
    self.bucketCols = bucketCols
    self.sortCols = sortCols
    self.parameters = parameters
    self.skewedInfo = skewedInfo
    self.storedAsSubDirectories = storedAsSubDirectories

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cols = []
          (_etype141, _size138) = iprot.readListBegin()
          for _i142 in xrange(_size138):
            _elem143 = FieldSchema()
            _elem143.read(iprot)
            self.cols.append(_elem143)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.location = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.inputFormat = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.outputFormat = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.compressed = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.numBuckets = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.serdeInfo = SerDeInfo()
          self.serdeInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.bucketCols = []
          (_etype147, _size144) = iprot.readListBegin()
          for _i148 in xrange(_size144):
            _elem149 = iprot.readString()
            self.bucketCols.append(_elem149)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.sortCols = []
          (_etype153, _size150) = iprot.readListBegin()
          for _i154 in xrange(_size150):
            _elem155 = Order()
            _elem155.read(iprot)
            self.sortCols.append(_elem155)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype157, _vtype158, _size156 ) = iprot.readMapBegin()
          for _i160 in xrange(_size156):
            _key161 = iprot.readString()
            _val162 = iprot.readString()
            self.parameters[_key161] = _val162
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.skewedInfo = SkewedInfo()
          self.skewedInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.storedAsSubDirectories = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StorageDescriptor')
    if self.cols is not None:
      oprot.writeFieldBegin('cols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cols))
      for iter163 in self.cols:
        iter163.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 2)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.inputFormat is not None:
      oprot.writeFieldBegin('inputFormat', TType.STRING, 3)
      oprot.writeString(self.inputFormat)
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.STRING, 4)
      oprot.writeString(self.outputFormat)
      oprot.writeFieldEnd()
    if self.compressed is not None:
      oprot.writeFieldBegin('compressed', TType.BOOL, 5)
      oprot.writeBool(self.compressed)
      oprot.writeFieldEnd()
    if self.numBuckets is not None:
      oprot.writeFieldBegin('numBuckets', TType.I32, 6)
      oprot.writeI32(self.numBuckets)
      oprot.writeFieldEnd()
    if self.serdeInfo is not None:
      oprot.writeFieldBegin('serdeInfo', TType.STRUCT, 7)
      self.serdeInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.bucketCols is not None:
      oprot.writeFieldBegin('bucketCols', TType.LIST, 8)
      oprot.writeListBegin(TType.STRING, len(self.bucketCols))
      for iter164 in self.bucketCols:
        oprot.writeString(iter164)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sortCols is not None:
      oprot.writeFieldBegin('sortCols', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.sortCols))
      for iter165 in self.sortCols:
        iter165.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter166,viter167 in self.parameters.items():
        oprot.writeString(kiter166)
        oprot.writeString(viter167)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.skewedInfo is not None:
      oprot.writeFieldBegin('skewedInfo', TType.STRUCT, 11)
      self.skewedInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.storedAsSubDirectories is not None:
      oprot.writeFieldBegin('storedAsSubDirectories', TType.BOOL, 12)
      oprot.writeBool(self.storedAsSubDirectories)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cols)
    value = (value * 31) ^ hash(self.location)
    value = (value * 31) ^ hash(self.inputFormat)
    value = (value * 31) ^ hash(self.outputFormat)
    value = (value * 31) ^ hash(self.compressed)
    value = (value * 31) ^ hash(self.numBuckets)
    value = (value * 31) ^ hash(self.serdeInfo)
    value = (value * 31) ^ hash(self.bucketCols)
    value = (value * 31) ^ hash(self.sortCols)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.skewedInfo)
    value = (value * 31) ^ hash(self.storedAsSubDirectories)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Table:
  """
  Attributes:
   - tableName
   - dbName
   - owner
   - createTime
   - lastAccessTime
   - retention
   - sd
   - partitionKeys
   - parameters
   - viewOriginalText
   - viewExpandedText
   - tableType
   - privileges
   - temporary
   - rewriteEnabled
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'owner', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.I32, 'retention', None, None, ), # 6
    (7, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 7
    (8, TType.LIST, 'partitionKeys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 8
    (9, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 9
    (10, TType.STRING, 'viewOriginalText', None, None, ), # 10
    (11, TType.STRING, 'viewExpandedText', None, None, ), # 11
    (12, TType.STRING, 'tableType', None, None, ), # 12
    (13, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 13
    (14, TType.BOOL, 'temporary', None, False, ), # 14
    (15, TType.BOOL, 'rewriteEnabled', None, None, ), # 15
  )

  def __init__(self, tableName=None, dbName=None, owner=None, createTime=None, lastAccessTime=None, retention=None, sd=None, partitionKeys=None, parameters=None, viewOriginalText=None, viewExpandedText=None, tableType=None, privileges=None, temporary=thrift_spec[14][4], rewriteEnabled=None,):
    self.tableName = tableName
    self.dbName = dbName
    self.owner = owner
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.retention = retention
    self.sd = sd
    self.partitionKeys = partitionKeys
    self.parameters = parameters
    self.viewOriginalText = viewOriginalText
    self.viewExpandedText = viewExpandedText
    self.tableType = tableType
    self.privileges = privileges
    self.temporary = temporary
    self.rewriteEnabled = rewriteEnabled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.owner = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.retention = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.partitionKeys = []
          (_etype171, _size168) = iprot.readListBegin()
          for _i172 in xrange(_size168):
            _elem173 = FieldSchema()
            _elem173.read(iprot)
            self.partitionKeys.append(_elem173)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype175, _vtype176, _size174 ) = iprot.readMapBegin()
          for _i178 in xrange(_size174):
            _key179 = iprot.readString()
            _val180 = iprot.readString()
            self.parameters[_key179] = _val180
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.viewOriginalText = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.viewExpandedText = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.tableType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.temporary = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.rewriteEnabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Table')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 3)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.retention is not None:
      oprot.writeFieldBegin('retention', TType.I32, 6)
      oprot.writeI32(self.retention)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 7)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.partitionKeys is not None:
      oprot.writeFieldBegin('partitionKeys', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionKeys))
      for iter181 in self.partitionKeys:
        iter181.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter182,viter183 in self.parameters.items():
        oprot.writeString(kiter182)
        oprot.writeString(viter183)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.viewOriginalText is not None:
      oprot.writeFieldBegin('viewOriginalText', TType.STRING, 10)
      oprot.writeString(self.viewOriginalText)
      oprot.writeFieldEnd()
    if self.viewExpandedText is not None:
      oprot.writeFieldBegin('viewExpandedText', TType.STRING, 11)
      oprot.writeString(self.viewExpandedText)
      oprot.writeFieldEnd()
    if self.tableType is not None:
      oprot.writeFieldBegin('tableType', TType.STRING, 12)
      oprot.writeString(self.tableType)
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 13)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.temporary is not None:
      oprot.writeFieldBegin('temporary', TType.BOOL, 14)
      oprot.writeBool(self.temporary)
      oprot.writeFieldEnd()
    if self.rewriteEnabled is not None:
      oprot.writeFieldBegin('rewriteEnabled', TType.BOOL, 15)
      oprot.writeBool(self.rewriteEnabled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.owner)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.retention)
    value = (value * 31) ^ hash(self.sd)
    value = (value * 31) ^ hash(self.partitionKeys)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.viewOriginalText)
    value = (value * 31) ^ hash(self.viewExpandedText)
    value = (value * 31) ^ hash(self.tableType)
    value = (value * 31) ^ hash(self.privileges)
    value = (value * 31) ^ hash(self.temporary)
    value = (value * 31) ^ hash(self.rewriteEnabled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Partition:
  """
  Attributes:
   - values
   - dbName
   - tableName
   - createTime
   - lastAccessTime
   - sd
   - parameters
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 6
    (7, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 7
    (8, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 8
  )

  def __init__(self, values=None, dbName=None, tableName=None, createTime=None, lastAccessTime=None, sd=None, parameters=None, privileges=None,):
    self.values = values
    self.dbName = dbName
    self.tableName = tableName
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.sd = sd
    self.parameters = parameters
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype187, _size184) = iprot.readListBegin()
          for _i188 in xrange(_size184):
            _elem189 = iprot.readString()
            self.values.append(_elem189)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype191, _vtype192, _size190 ) = iprot.readMapBegin()
          for _i194 in xrange(_size190):
            _key195 = iprot.readString()
            _val196 = iprot.readString()
            self.parameters[_key195] = _val196
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Partition')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter197 in self.values:
        oprot.writeString(iter197)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 6)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter198,viter199 in self.parameters.items():
        oprot.writeString(kiter198)
        oprot.writeString(viter199)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 8)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.sd)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionWithoutSD:
  """
  Attributes:
   - values
   - createTime
   - lastAccessTime
   - relativePath
   - parameters
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.I32, 'lastAccessTime', None, None, ), # 3
    (4, TType.STRING, 'relativePath', None, None, ), # 4
    (5, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 5
    (6, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 6
  )

  def __init__(self, values=None, createTime=None, lastAccessTime=None, relativePath=None, parameters=None, privileges=None,):
    self.values = values
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.relativePath = relativePath
    self.parameters = parameters
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype203, _size200) = iprot.readListBegin()
          for _i204 in xrange(_size200):
            _elem205 = iprot.readString()
            self.values.append(_elem205)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.relativePath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype207, _vtype208, _size206 ) = iprot.readMapBegin()
          for _i210 in xrange(_size206):
            _key211 = iprot.readString()
            _val212 = iprot.readString()
            self.parameters[_key211] = _val212
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionWithoutSD')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter213 in self.values:
        oprot.writeString(iter213)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 3)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.relativePath is not None:
      oprot.writeFieldBegin('relativePath', TType.STRING, 4)
      oprot.writeString(self.relativePath)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter214,viter215 in self.parameters.items():
        oprot.writeString(kiter214)
        oprot.writeString(viter215)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 6)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.relativePath)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionSpecWithSharedSD:
  """
  Attributes:
   - partitions
   - sd
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(PartitionWithoutSD, PartitionWithoutSD.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 2
  )

  def __init__(self, partitions=None, sd=None,):
    self.partitions = partitions
    self.sd = sd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype219, _size216) = iprot.readListBegin()
          for _i220 in xrange(_size216):
            _elem221 = PartitionWithoutSD()
            _elem221.read(iprot)
            self.partitions.append(_elem221)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionSpecWithSharedSD')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter222 in self.partitions:
        iter222.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 2)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    value = (value * 31) ^ hash(self.sd)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionListComposingSpec:
  """
  Attributes:
   - partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitions=None,):
    self.partitions = partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype226, _size223) = iprot.readListBegin()
          for _i227 in xrange(_size223):
            _elem228 = Partition()
            _elem228.read(iprot)
            self.partitions.append(_elem228)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionListComposingSpec')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter229 in self.partitions:
        iter229.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionSpec:
  """
  Attributes:
   - dbName
   - tableName
   - rootPath
   - sharedSDPartitionSpec
   - partitionList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'rootPath', None, None, ), # 3
    (4, TType.STRUCT, 'sharedSDPartitionSpec', (PartitionSpecWithSharedSD, PartitionSpecWithSharedSD.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'partitionList', (PartitionListComposingSpec, PartitionListComposingSpec.thrift_spec), None, ), # 5
  )

  def __init__(self, dbName=None, tableName=None, rootPath=None, sharedSDPartitionSpec=None, partitionList=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.rootPath = rootPath
    self.sharedSDPartitionSpec = sharedSDPartitionSpec
    self.partitionList = partitionList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.rootPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.sharedSDPartitionSpec = PartitionSpecWithSharedSD()
          self.sharedSDPartitionSpec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.partitionList = PartitionListComposingSpec()
          self.partitionList.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionSpec')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.rootPath is not None:
      oprot.writeFieldBegin('rootPath', TType.STRING, 3)
      oprot.writeString(self.rootPath)
      oprot.writeFieldEnd()
    if self.sharedSDPartitionSpec is not None:
      oprot.writeFieldBegin('sharedSDPartitionSpec', TType.STRUCT, 4)
      self.sharedSDPartitionSpec.write(oprot)
      oprot.writeFieldEnd()
    if self.partitionList is not None:
      oprot.writeFieldBegin('partitionList', TType.STRUCT, 5)
      self.partitionList.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.rootPath)
    value = (value * 31) ^ hash(self.sharedSDPartitionSpec)
    value = (value * 31) ^ hash(self.partitionList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Index:
  """
  Attributes:
   - indexName
   - indexHandlerClass
   - dbName
   - origTableName
   - createTime
   - lastAccessTime
   - indexTableName
   - sd
   - parameters
   - deferredRebuild
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'indexName', None, None, ), # 1
    (2, TType.STRING, 'indexHandlerClass', None, None, ), # 2
    (3, TType.STRING, 'dbName', None, None, ), # 3
    (4, TType.STRING, 'origTableName', None, None, ), # 4
    (5, TType.I32, 'createTime', None, None, ), # 5
    (6, TType.I32, 'lastAccessTime', None, None, ), # 6
    (7, TType.STRING, 'indexTableName', None, None, ), # 7
    (8, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 8
    (9, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 9
    (10, TType.BOOL, 'deferredRebuild', None, None, ), # 10
  )

  def __init__(self, indexName=None, indexHandlerClass=None, dbName=None, origTableName=None, createTime=None, lastAccessTime=None, indexTableName=None, sd=None, parameters=None, deferredRebuild=None,):
    self.indexName = indexName
    self.indexHandlerClass = indexHandlerClass
    self.dbName = dbName
    self.origTableName = origTableName
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.indexTableName = indexTableName
    self.sd = sd
    self.parameters = parameters
    self.deferredRebuild = deferredRebuild

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.indexName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.indexHandlerClass = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.origTableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.indexTableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype231, _vtype232, _size230 ) = iprot.readMapBegin()
          for _i234 in xrange(_size230):
            _key235 = iprot.readString()
            _val236 = iprot.readString()
            self.parameters[_key235] = _val236
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.deferredRebuild = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Index')
    if self.indexName is not None:
      oprot.writeFieldBegin('indexName', TType.STRING, 1)
      oprot.writeString(self.indexName)
      oprot.writeFieldEnd()
    if self.indexHandlerClass is not None:
      oprot.writeFieldBegin('indexHandlerClass', TType.STRING, 2)
      oprot.writeString(self.indexHandlerClass)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 3)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.origTableName is not None:
      oprot.writeFieldBegin('origTableName', TType.STRING, 4)
      oprot.writeString(self.origTableName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 5)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 6)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.indexTableName is not None:
      oprot.writeFieldBegin('indexTableName', TType.STRING, 7)
      oprot.writeString(self.indexTableName)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 8)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter237,viter238 in self.parameters.items():
        oprot.writeString(kiter237)
        oprot.writeString(viter238)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.deferredRebuild is not None:
      oprot.writeFieldBegin('deferredRebuild', TType.BOOL, 10)
      oprot.writeBool(self.deferredRebuild)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.indexName)
    value = (value * 31) ^ hash(self.indexHandlerClass)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.origTableName)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.indexTableName)
    value = (value * 31) ^ hash(self.sd)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.deferredRebuild)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BooleanColumnStatsData:
  """
  Attributes:
   - numTrues
   - numFalses
   - numNulls
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'numTrues', None, None, ), # 1
    (2, TType.I64, 'numFalses', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.STRING, 'bitVectors', None, None, ), # 4
  )

  def __init__(self, numTrues=None, numFalses=None, numNulls=None, bitVectors=None,):
    self.numTrues = numTrues
    self.numFalses = numFalses
    self.numNulls = numNulls
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.numTrues = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.numFalses = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BooleanColumnStatsData')
    if self.numTrues is not None:
      oprot.writeFieldBegin('numTrues', TType.I64, 1)
      oprot.writeI64(self.numTrues)
      oprot.writeFieldEnd()
    if self.numFalses is not None:
      oprot.writeFieldBegin('numFalses', TType.I64, 2)
      oprot.writeI64(self.numFalses)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 4)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numTrues is None:
      raise TProtocol.TProtocolException(message='Required field numTrues is unset!')
    if self.numFalses is None:
      raise TProtocol.TProtocolException(message='Required field numFalses is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.numTrues)
    value = (value * 31) ^ hash(self.numFalses)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DoubleColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'lowValue', None, None, ), # 1
    (2, TType.DOUBLE, 'highValue', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.lowValue = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.highValue = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DoubleColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.DOUBLE, 1)
      oprot.writeDouble(self.lowValue)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.DOUBLE, 2)
      oprot.writeDouble(self.highValue)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LongColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lowValue', None, None, ), # 1
    (2, TType.I64, 'highValue', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lowValue = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.highValue = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LongColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.I64, 1)
      oprot.writeI64(self.lowValue)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.I64, 2)
      oprot.writeI64(self.highValue)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StringColumnStatsData:
  """
  Attributes:
   - maxColLen
   - avgColLen
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxColLen', None, None, ), # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, maxColLen=None, avgColLen=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.maxColLen = maxColLen
    self.avgColLen = avgColLen
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxColLen = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.avgColLen = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StringColumnStatsData')
    if self.maxColLen is not None:
      oprot.writeFieldBegin('maxColLen', TType.I64, 1)
      oprot.writeI64(self.maxColLen)
      oprot.writeFieldEnd()
    if self.avgColLen is not None:
      oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
      oprot.writeDouble(self.avgColLen)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.maxColLen is None:
      raise TProtocol.TProtocolException(message='Required field maxColLen is unset!')
    if self.avgColLen is None:
      raise TProtocol.TProtocolException(message='Required field avgColLen is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.maxColLen)
    value = (value * 31) ^ hash(self.avgColLen)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BinaryColumnStatsData:
  """
  Attributes:
   - maxColLen
   - avgColLen
   - numNulls
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxColLen', None, None, ), # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.STRING, 'bitVectors', None, None, ), # 4
  )

  def __init__(self, maxColLen=None, avgColLen=None, numNulls=None, bitVectors=None,):
    self.maxColLen = maxColLen
    self.avgColLen = avgColLen
    self.numNulls = numNulls
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxColLen = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.avgColLen = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BinaryColumnStatsData')
    if self.maxColLen is not None:
      oprot.writeFieldBegin('maxColLen', TType.I64, 1)
      oprot.writeI64(self.maxColLen)
      oprot.writeFieldEnd()
    if self.avgColLen is not None:
      oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
      oprot.writeDouble(self.avgColLen)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 4)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.maxColLen is None:
      raise TProtocol.TProtocolException(message='Required field maxColLen is unset!')
    if self.avgColLen is None:
      raise TProtocol.TProtocolException(message='Required field avgColLen is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.maxColLen)
    value = (value * 31) ^ hash(self.avgColLen)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Decimal:
  """
  Attributes:
   - unscaled
   - scale
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'unscaled', None, None, ), # 1
    None, # 2
    (3, TType.I16, 'scale', None, None, ), # 3
  )

  def __init__(self, unscaled=None, scale=None,):
    self.unscaled = unscaled
    self.scale = scale

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.unscaled = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.scale = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Decimal')
    if self.unscaled is not None:
      oprot.writeFieldBegin('unscaled', TType.STRING, 1)
      oprot.writeString(self.unscaled)
      oprot.writeFieldEnd()
    if self.scale is not None:
      oprot.writeFieldBegin('scale', TType.I16, 3)
      oprot.writeI16(self.scale)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.unscaled is None:
      raise TProtocol.TProtocolException(message='Required field unscaled is unset!')
    if self.scale is None:
      raise TProtocol.TProtocolException(message='Required field scale is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.unscaled)
    value = (value * 31) ^ hash(self.scale)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DecimalColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'lowValue', (Decimal, Decimal.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'highValue', (Decimal, Decimal.thrift_spec), None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.lowValue = Decimal()
          self.lowValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.highValue = Decimal()
          self.highValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DecimalColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.STRUCT, 1)
      self.lowValue.write(oprot)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.STRUCT, 2)
      self.highValue.write(oprot)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Date:
  """
  Attributes:
   - daysSinceEpoch
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'daysSinceEpoch', None, None, ), # 1
  )

  def __init__(self, daysSinceEpoch=None,):
    self.daysSinceEpoch = daysSinceEpoch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.daysSinceEpoch = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Date')
    if self.daysSinceEpoch is not None:
      oprot.writeFieldBegin('daysSinceEpoch', TType.I64, 1)
      oprot.writeI64(self.daysSinceEpoch)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.daysSinceEpoch is None:
      raise TProtocol.TProtocolException(message='Required field daysSinceEpoch is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.daysSinceEpoch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DateColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'lowValue', (Date, Date.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'highValue', (Date, Date.thrift_spec), None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.lowValue = Date()
          self.lowValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.highValue = Date()
          self.highValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DateColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.STRUCT, 1)
      self.lowValue.write(oprot)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.STRUCT, 2)
      self.highValue.write(oprot)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsData:
  """
  Attributes:
   - booleanStats
   - longStats
   - doubleStats
   - stringStats
   - binaryStats
   - decimalStats
   - dateStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'booleanStats', (BooleanColumnStatsData, BooleanColumnStatsData.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'longStats', (LongColumnStatsData, LongColumnStatsData.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'doubleStats', (DoubleColumnStatsData, DoubleColumnStatsData.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'stringStats', (StringColumnStatsData, StringColumnStatsData.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'binaryStats', (BinaryColumnStatsData, BinaryColumnStatsData.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'decimalStats', (DecimalColumnStatsData, DecimalColumnStatsData.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'dateStats', (DateColumnStatsData, DateColumnStatsData.thrift_spec), None, ), # 7
  )

  def __init__(self, booleanStats=None, longStats=None, doubleStats=None, stringStats=None, binaryStats=None, decimalStats=None, dateStats=None,):
    self.booleanStats = booleanStats
    self.longStats = longStats
    self.doubleStats = doubleStats
    self.stringStats = stringStats
    self.binaryStats = binaryStats
    self.decimalStats = decimalStats
    self.dateStats = dateStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.booleanStats = BooleanColumnStatsData()
          self.booleanStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.longStats = LongColumnStatsData()
          self.longStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.doubleStats = DoubleColumnStatsData()
          self.doubleStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.stringStats = StringColumnStatsData()
          self.stringStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.binaryStats = BinaryColumnStatsData()
          self.binaryStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.decimalStats = DecimalColumnStatsData()
          self.decimalStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.dateStats = DateColumnStatsData()
          self.dateStats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsData')
    if self.booleanStats is not None:
      oprot.writeFieldBegin('booleanStats', TType.STRUCT, 1)
      self.booleanStats.write(oprot)
      oprot.writeFieldEnd()
    if self.longStats is not None:
      oprot.writeFieldBegin('longStats', TType.STRUCT, 2)
      self.longStats.write(oprot)
      oprot.writeFieldEnd()
    if self.doubleStats is not None:
      oprot.writeFieldBegin('doubleStats', TType.STRUCT, 3)
      self.doubleStats.write(oprot)
      oprot.writeFieldEnd()
    if self.stringStats is not None:
      oprot.writeFieldBegin('stringStats', TType.STRUCT, 4)
      self.stringStats.write(oprot)
      oprot.writeFieldEnd()
    if self.binaryStats is not None:
      oprot.writeFieldBegin('binaryStats', TType.STRUCT, 5)
      self.binaryStats.write(oprot)
      oprot.writeFieldEnd()
    if self.decimalStats is not None:
      oprot.writeFieldBegin('decimalStats', TType.STRUCT, 6)
      self.decimalStats.write(oprot)
      oprot.writeFieldEnd()
    if self.dateStats is not None:
      oprot.writeFieldBegin('dateStats', TType.STRUCT, 7)
      self.dateStats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.booleanStats)
    value = (value * 31) ^ hash(self.longStats)
    value = (value * 31) ^ hash(self.doubleStats)
    value = (value * 31) ^ hash(self.stringStats)
    value = (value * 31) ^ hash(self.binaryStats)
    value = (value * 31) ^ hash(self.decimalStats)
    value = (value * 31) ^ hash(self.dateStats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsObj:
  """
  Attributes:
   - colName
   - colType
   - statsData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'colName', None, None, ), # 1
    (2, TType.STRING, 'colType', None, None, ), # 2
    (3, TType.STRUCT, 'statsData', (ColumnStatisticsData, ColumnStatisticsData.thrift_spec), None, ), # 3
  )

  def __init__(self, colName=None, colType=None, statsData=None,):
    self.colName = colName
    self.colType = colType
    self.statsData = statsData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.colName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.statsData = ColumnStatisticsData()
          self.statsData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsObj')
    if self.colName is not None:
      oprot.writeFieldBegin('colName', TType.STRING, 1)
      oprot.writeString(self.colName)
      oprot.writeFieldEnd()
    if self.colType is not None:
      oprot.writeFieldBegin('colType', TType.STRING, 2)
      oprot.writeString(self.colType)
      oprot.writeFieldEnd()
    if self.statsData is not None:
      oprot.writeFieldBegin('statsData', TType.STRUCT, 3)
      self.statsData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colName is None:
      raise TProtocol.TProtocolException(message='Required field colName is unset!')
    if self.colType is None:
      raise TProtocol.TProtocolException(message='Required field colType is unset!')
    if self.statsData is None:
      raise TProtocol.TProtocolException(message='Required field statsData is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.colName)
    value = (value * 31) ^ hash(self.colType)
    value = (value * 31) ^ hash(self.statsData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsDesc:
  """
  Attributes:
   - isTblLevel
   - dbName
   - tableName
   - partName
   - lastAnalyzed
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isTblLevel', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.STRING, 'partName', None, None, ), # 4
    (5, TType.I64, 'lastAnalyzed', None, None, ), # 5
  )

  def __init__(self, isTblLevel=None, dbName=None, tableName=None, partName=None, lastAnalyzed=None,):
    self.isTblLevel = isTblLevel
    self.dbName = dbName
    self.tableName = tableName
    self.partName = partName
    self.lastAnalyzed = lastAnalyzed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isTblLevel = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.partName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.lastAnalyzed = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsDesc')
    if self.isTblLevel is not None:
      oprot.writeFieldBegin('isTblLevel', TType.BOOL, 1)
      oprot.writeBool(self.isTblLevel)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partName is not None:
      oprot.writeFieldBegin('partName', TType.STRING, 4)
      oprot.writeString(self.partName)
      oprot.writeFieldEnd()
    if self.lastAnalyzed is not None:
      oprot.writeFieldBegin('lastAnalyzed', TType.I64, 5)
      oprot.writeI64(self.lastAnalyzed)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isTblLevel is None:
      raise TProtocol.TProtocolException(message='Required field isTblLevel is unset!')
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isTblLevel)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partName)
    value = (value * 31) ^ hash(self.lastAnalyzed)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatistics:
  """
  Attributes:
   - statsDesc
   - statsObj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'statsDesc', (ColumnStatisticsDesc, ColumnStatisticsDesc.thrift_spec), None, ), # 1
    (2, TType.LIST, 'statsObj', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 2
  )

  def __init__(self, statsDesc=None, statsObj=None,):
    self.statsDesc = statsDesc
    self.statsObj = statsObj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.statsDesc = ColumnStatisticsDesc()
          self.statsDesc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.statsObj = []
          (_etype242, _size239) = iprot.readListBegin()
          for _i243 in xrange(_size239):
            _elem244 = ColumnStatisticsObj()
            _elem244.read(iprot)
            self.statsObj.append(_elem244)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatistics')
    if self.statsDesc is not None:
      oprot.writeFieldBegin('statsDesc', TType.STRUCT, 1)
      self.statsDesc.write(oprot)
      oprot.writeFieldEnd()
    if self.statsObj is not None:
      oprot.writeFieldBegin('statsObj', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.statsObj))
      for iter245 in self.statsObj:
        iter245.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.statsDesc is None:
      raise TProtocol.TProtocolException(message='Required field statsDesc is unset!')
    if self.statsObj is None:
      raise TProtocol.TProtocolException(message='Required field statsObj is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.statsDesc)
    value = (value * 31) ^ hash(self.statsObj)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AggrStats:
  """
  Attributes:
   - colStats
   - partsFound
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'colStats', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 1
    (2, TType.I64, 'partsFound', None, None, ), # 2
  )

  def __init__(self, colStats=None, partsFound=None,):
    self.colStats = colStats
    self.partsFound = partsFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.colStats = []
          (_etype249, _size246) = iprot.readListBegin()
          for _i250 in xrange(_size246):
            _elem251 = ColumnStatisticsObj()
            _elem251.read(iprot)
            self.colStats.append(_elem251)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.partsFound = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AggrStats')
    if self.colStats is not None:
      oprot.writeFieldBegin('colStats', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.colStats))
      for iter252 in self.colStats:
        iter252.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partsFound is not None:
      oprot.writeFieldBegin('partsFound', TType.I64, 2)
      oprot.writeI64(self.partsFound)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colStats is None:
      raise TProtocol.TProtocolException(message='Required field colStats is unset!')
    if self.partsFound is None:
      raise TProtocol.TProtocolException(message='Required field partsFound is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.colStats)
    value = (value * 31) ^ hash(self.partsFound)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPartitionsStatsRequest:
  """
  Attributes:
   - colStats
   - needMerge
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'colStats', (TType.STRUCT,(ColumnStatistics, ColumnStatistics.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'needMerge', None, None, ), # 2
  )

  def __init__(self, colStats=None, needMerge=None,):
    self.colStats = colStats
    self.needMerge = needMerge

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.colStats = []
          (_etype256, _size253) = iprot.readListBegin()
          for _i257 in xrange(_size253):
            _elem258 = ColumnStatistics()
            _elem258.read(iprot)
            self.colStats.append(_elem258)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.needMerge = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPartitionsStatsRequest')
    if self.colStats is not None:
      oprot.writeFieldBegin('colStats', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.colStats))
      for iter259 in self.colStats:
        iter259.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.needMerge is not None:
      oprot.writeFieldBegin('needMerge', TType.BOOL, 2)
      oprot.writeBool(self.needMerge)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colStats is None:
      raise TProtocol.TProtocolException(message='Required field colStats is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.colStats)
    value = (value * 31) ^ hash(self.needMerge)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Schema:
  """
  Attributes:
   - fieldSchemas
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fieldSchemas', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, fieldSchemas=None, properties=None,):
    self.fieldSchemas = fieldSchemas
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fieldSchemas = []
          (_etype263, _size260) = iprot.readListBegin()
          for _i264 in xrange(_size260):
            _elem265 = FieldSchema()
            _elem265.read(iprot)
            self.fieldSchemas.append(_elem265)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype267, _vtype268, _size266 ) = iprot.readMapBegin()
          for _i270 in xrange(_size266):
            _key271 = iprot.readString()
            _val272 = iprot.readString()
            self.properties[_key271] = _val272
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Schema')
    if self.fieldSchemas is not None:
      oprot.writeFieldBegin('fieldSchemas', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.fieldSchemas))
      for iter273 in self.fieldSchemas:
        iter273.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter274,viter275 in self.properties.items():
        oprot.writeString(kiter274)
        oprot.writeString(viter275)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fieldSchemas)
    value = (value * 31) ^ hash(self.properties)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EnvironmentContext:
  """
  Attributes:
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, properties=None,):
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype277, _vtype278, _size276 ) = iprot.readMapBegin()
          for _i280 in xrange(_size276):
            _key281 = iprot.readString()
            _val282 = iprot.readString()
            self.properties[_key281] = _val282
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EnvironmentContext')
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter283,viter284 in self.properties.items():
        oprot.writeString(kiter283)
        oprot.writeString(viter284)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.properties)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrimaryKeysRequest:
  """
  Attributes:
   - db_name
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, tbl_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrimaryKeysRequest')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrimaryKeysResponse:
  """
  Attributes:
   - primaryKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'primaryKeys', (TType.STRUCT,(SQLPrimaryKey, SQLPrimaryKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, primaryKeys=None,):
    self.primaryKeys = primaryKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.primaryKeys = []
          (_etype288, _size285) = iprot.readListBegin()
          for _i289 in xrange(_size285):
            _elem290 = SQLPrimaryKey()
            _elem290.read(iprot)
            self.primaryKeys.append(_elem290)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrimaryKeysResponse')
    if self.primaryKeys is not None:
      oprot.writeFieldBegin('primaryKeys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryKeys))
      for iter291 in self.primaryKeys:
        iter291.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.primaryKeys is None:
      raise TProtocol.TProtocolException(message='Required field primaryKeys is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.primaryKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ForeignKeysRequest:
  """
  Attributes:
   - parent_db_name
   - parent_tbl_name
   - foreign_db_name
   - foreign_tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'parent_db_name', None, None, ), # 1
    (2, TType.STRING, 'parent_tbl_name', None, None, ), # 2
    (3, TType.STRING, 'foreign_db_name', None, None, ), # 3
    (4, TType.STRING, 'foreign_tbl_name', None, None, ), # 4
  )

  def __init__(self, parent_db_name=None, parent_tbl_name=None, foreign_db_name=None, foreign_tbl_name=None,):
    self.parent_db_name = parent_db_name
    self.parent_tbl_name = parent_tbl_name
    self.foreign_db_name = foreign_db_name
    self.foreign_tbl_name = foreign_tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.parent_db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.parent_tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.foreign_db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.foreign_tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ForeignKeysRequest')
    if self.parent_db_name is not None:
      oprot.writeFieldBegin('parent_db_name', TType.STRING, 1)
      oprot.writeString(self.parent_db_name)
      oprot.writeFieldEnd()
    if self.parent_tbl_name is not None:
      oprot.writeFieldBegin('parent_tbl_name', TType.STRING, 2)
      oprot.writeString(self.parent_tbl_name)
      oprot.writeFieldEnd()
    if self.foreign_db_name is not None:
      oprot.writeFieldBegin('foreign_db_name', TType.STRING, 3)
      oprot.writeString(self.foreign_db_name)
      oprot.writeFieldEnd()
    if self.foreign_tbl_name is not None:
      oprot.writeFieldBegin('foreign_tbl_name', TType.STRING, 4)
      oprot.writeString(self.foreign_tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.parent_db_name)
    value = (value * 31) ^ hash(self.parent_tbl_name)
    value = (value * 31) ^ hash(self.foreign_db_name)
    value = (value * 31) ^ hash(self.foreign_tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ForeignKeysResponse:
  """
  Attributes:
   - foreignKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'foreignKeys', (TType.STRUCT,(SQLForeignKey, SQLForeignKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, foreignKeys=None,):
    self.foreignKeys = foreignKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.foreignKeys = []
          (_etype295, _size292) = iprot.readListBegin()
          for _i296 in xrange(_size292):
            _elem297 = SQLForeignKey()
            _elem297.read(iprot)
            self.foreignKeys.append(_elem297)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ForeignKeysResponse')
    if self.foreignKeys is not None:
      oprot.writeFieldBegin('foreignKeys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.foreignKeys))
      for iter298 in self.foreignKeys:
        iter298.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.foreignKeys is None:
      raise TProtocol.TProtocolException(message='Required field foreignKeys is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.foreignKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropConstraintRequest:
  """
  Attributes:
   - dbname
   - tablename
   - constraintname
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'constraintname', None, None, ), # 3
  )

  def __init__(self, dbname=None, tablename=None, constraintname=None,):
    self.dbname = dbname
    self.tablename = tablename
    self.constraintname = constraintname

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.constraintname = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropConstraintRequest')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.constraintname is not None:
      oprot.writeFieldBegin('constraintname', TType.STRING, 3)
      oprot.writeString(self.constraintname)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.constraintname is None:
      raise TProtocol.TProtocolException(message='Required field constraintname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.constraintname)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddPrimaryKeyRequest:
  """
  Attributes:
   - primaryKeyCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'primaryKeyCols', (TType.STRUCT,(SQLPrimaryKey, SQLPrimaryKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, primaryKeyCols=None,):
    self.primaryKeyCols = primaryKeyCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.primaryKeyCols = []
          (_etype302, _size299) = iprot.readListBegin()
          for _i303 in xrange(_size299):
            _elem304 = SQLPrimaryKey()
            _elem304.read(iprot)
            self.primaryKeyCols.append(_elem304)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddPrimaryKeyRequest')
    if self.primaryKeyCols is not None:
      oprot.writeFieldBegin('primaryKeyCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryKeyCols))
      for iter305 in self.primaryKeyCols:
        iter305.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.primaryKeyCols is None:
      raise TProtocol.TProtocolException(message='Required field primaryKeyCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.primaryKeyCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddForeignKeyRequest:
  """
  Attributes:
   - foreignKeyCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'foreignKeyCols', (TType.STRUCT,(SQLForeignKey, SQLForeignKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, foreignKeyCols=None,):
    self.foreignKeyCols = foreignKeyCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.foreignKeyCols = []
          (_etype309, _size306) = iprot.readListBegin()
          for _i310 in xrange(_size306):
            _elem311 = SQLForeignKey()
            _elem311.read(iprot)
            self.foreignKeyCols.append(_elem311)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddForeignKeyRequest')
    if self.foreignKeyCols is not None:
      oprot.writeFieldBegin('foreignKeyCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.foreignKeyCols))
      for iter312 in self.foreignKeyCols:
        iter312.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.foreignKeyCols is None:
      raise TProtocol.TProtocolException(message='Required field foreignKeyCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.foreignKeyCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsByExprResult:
  """
  Attributes:
   - partitions
   - hasUnknownPartitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'hasUnknownPartitions', None, None, ), # 2
  )

  def __init__(self, partitions=None, hasUnknownPartitions=None,):
    self.partitions = partitions
    self.hasUnknownPartitions = hasUnknownPartitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype316, _size313) = iprot.readListBegin()
          for _i317 in xrange(_size313):
            _elem318 = Partition()
            _elem318.read(iprot)
            self.partitions.append(_elem318)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.hasUnknownPartitions = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsByExprResult')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter319 in self.partitions:
        iter319.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.hasUnknownPartitions is not None:
      oprot.writeFieldBegin('hasUnknownPartitions', TType.BOOL, 2)
      oprot.writeBool(self.hasUnknownPartitions)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partitions is None:
      raise TProtocol.TProtocolException(message='Required field partitions is unset!')
    if self.hasUnknownPartitions is None:
      raise TProtocol.TProtocolException(message='Required field hasUnknownPartitions is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    value = (value * 31) ^ hash(self.hasUnknownPartitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsByExprRequest:
  """
  Attributes:
   - dbName
   - tblName
   - expr
   - defaultPartitionName
   - maxParts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRING, 'expr', None, None, ), # 3
    (4, TType.STRING, 'defaultPartitionName', None, None, ), # 4
    (5, TType.I16, 'maxParts', None, -1, ), # 5
  )

  def __init__(self, dbName=None, tblName=None, expr=None, defaultPartitionName=None, maxParts=thrift_spec[5][4],):
    self.dbName = dbName
    self.tblName = tblName
    self.expr = expr
    self.defaultPartitionName = defaultPartitionName
    self.maxParts = maxParts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.defaultPartitionName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.maxParts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsByExprRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.expr is not None:
      oprot.writeFieldBegin('expr', TType.STRING, 3)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    if self.defaultPartitionName is not None:
      oprot.writeFieldBegin('defaultPartitionName', TType.STRING, 4)
      oprot.writeString(self.defaultPartitionName)
      oprot.writeFieldEnd()
    if self.maxParts is not None:
      oprot.writeFieldBegin('maxParts', TType.I16, 5)
      oprot.writeI16(self.maxParts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.expr is None:
      raise TProtocol.TProtocolException(message='Required field expr is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.expr)
    value = (value * 31) ^ hash(self.defaultPartitionName)
    value = (value * 31) ^ hash(self.maxParts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableStatsResult:
  """
  Attributes:
   - tableStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tableStats', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 1
  )

  def __init__(self, tableStats=None,):
    self.tableStats = tableStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tableStats = []
          (_etype323, _size320) = iprot.readListBegin()
          for _i324 in xrange(_size320):
            _elem325 = ColumnStatisticsObj()
            _elem325.read(iprot)
            self.tableStats.append(_elem325)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableStatsResult')
    if self.tableStats is not None:
      oprot.writeFieldBegin('tableStats', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tableStats))
      for iter326 in self.tableStats:
        iter326.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tableStats is None:
      raise TProtocol.TProtocolException(message='Required field tableStats is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableStats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsStatsResult:
  """
  Attributes:
   - partStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'partStats', (TType.STRING,None,TType.LIST,(TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec))), None, ), # 1
  )

  def __init__(self, partStats=None,):
    self.partStats = partStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.partStats = {}
          (_ktype328, _vtype329, _size327 ) = iprot.readMapBegin()
          for _i331 in xrange(_size327):
            _key332 = iprot.readString()
            _val333 = []
            (_etype337, _size334) = iprot.readListBegin()
            for _i338 in xrange(_size334):
              _elem339 = ColumnStatisticsObj()
              _elem339.read(iprot)
              _val333.append(_elem339)
            iprot.readListEnd()
            self.partStats[_key332] = _val333
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsStatsResult')
    if self.partStats is not None:
      oprot.writeFieldBegin('partStats', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.partStats))
      for kiter340,viter341 in self.partStats.items():
        oprot.writeString(kiter340)
        oprot.writeListBegin(TType.STRUCT, len(viter341))
        for iter342 in viter341:
          iter342.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partStats is None:
      raise TProtocol.TProtocolException(message='Required field partStats is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partStats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableStatsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - colNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'colNames', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, dbName=None, tblName=None, colNames=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.colNames = colNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.colNames = []
          (_etype346, _size343) = iprot.readListBegin()
          for _i347 in xrange(_size343):
            _elem348 = iprot.readString()
            self.colNames.append(_elem348)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableStatsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.colNames is not None:
      oprot.writeFieldBegin('colNames', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.colNames))
      for iter349 in self.colNames:
        oprot.writeString(iter349)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.colNames is None:
      raise TProtocol.TProtocolException(message='Required field colNames is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.colNames)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsStatsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - colNames
   - partNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'colNames', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'partNames', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, dbName=None, tblName=None, colNames=None, partNames=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.colNames = colNames
    self.partNames = partNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.colNames = []
          (_etype353, _size350) = iprot.readListBegin()
          for _i354 in xrange(_size350):
            _elem355 = iprot.readString()
            self.colNames.append(_elem355)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partNames = []
          (_etype359, _size356) = iprot.readListBegin()
          for _i360 in xrange(_size356):
            _elem361 = iprot.readString()
            self.partNames.append(_elem361)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsStatsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.colNames is not None:
      oprot.writeFieldBegin('colNames', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.colNames))
      for iter362 in self.colNames:
        oprot.writeString(iter362)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partNames is not None:
      oprot.writeFieldBegin('partNames', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.partNames))
      for iter363 in self.partNames:
        oprot.writeString(iter363)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.colNames is None:
      raise TProtocol.TProtocolException(message='Required field colNames is unset!')
    if self.partNames is None:
      raise TProtocol.TProtocolException(message='Required field partNames is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.colNames)
    value = (value * 31) ^ hash(self.partNames)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddPartitionsResult:
  """
  Attributes:
   - partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitions=None,):
    self.partitions = partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype367, _size364) = iprot.readListBegin()
          for _i368 in xrange(_size364):
            _elem369 = Partition()
            _elem369.read(iprot)
            self.partitions.append(_elem369)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddPartitionsResult')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter370 in self.partitions:
        iter370.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddPartitionsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - parts
   - ifNotExists
   - needResult
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 3
    (4, TType.BOOL, 'ifNotExists', None, None, ), # 4
    (5, TType.BOOL, 'needResult', None, True, ), # 5
  )

  def __init__(self, dbName=None, tblName=None, parts=None, ifNotExists=None, needResult=thrift_spec[5][4],):
    self.dbName = dbName
    self.tblName = tblName
    self.parts = parts
    self.ifNotExists = ifNotExists
    self.needResult = needResult

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.parts = []
          (_etype374, _size371) = iprot.readListBegin()
          for _i375 in xrange(_size371):
            _elem376 = Partition()
            _elem376.read(iprot)
            self.parts.append(_elem376)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.ifNotExists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.needResult = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddPartitionsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.parts is not None:
      oprot.writeFieldBegin('parts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.parts))
      for iter377 in self.parts:
        iter377.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ifNotExists is not None:
      oprot.writeFieldBegin('ifNotExists', TType.BOOL, 4)
      oprot.writeBool(self.ifNotExists)
      oprot.writeFieldEnd()
    if self.needResult is not None:
      oprot.writeFieldBegin('needResult', TType.BOOL, 5)
      oprot.writeBool(self.needResult)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.parts is None:
      raise TProtocol.TProtocolException(message='Required field parts is unset!')
    if self.ifNotExists is None:
      raise TProtocol.TProtocolException(message='Required field ifNotExists is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.parts)
    value = (value * 31) ^ hash(self.ifNotExists)
    value = (value * 31) ^ hash(self.needResult)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropPartitionsResult:
  """
  Attributes:
   - partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitions=None,):
    self.partitions = partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype381, _size378) = iprot.readListBegin()
          for _i382 in xrange(_size378):
            _elem383 = Partition()
            _elem383.read(iprot)
            self.partitions.append(_elem383)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropPartitionsResult')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter384 in self.partitions:
        iter384.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropPartitionsExpr:
  """
  Attributes:
   - expr
   - partArchiveLevel
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'expr', None, None, ), # 1
    (2, TType.I32, 'partArchiveLevel', None, None, ), # 2
  )

  def __init__(self, expr=None, partArchiveLevel=None,):
    self.expr = expr
    self.partArchiveLevel = partArchiveLevel

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.partArchiveLevel = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropPartitionsExpr')
    if self.expr is not None:
      oprot.writeFieldBegin('expr', TType.STRING, 1)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    if self.partArchiveLevel is not None:
      oprot.writeFieldBegin('partArchiveLevel', TType.I32, 2)
      oprot.writeI32(self.partArchiveLevel)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.expr is None:
      raise TProtocol.TProtocolException(message='Required field expr is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.expr)
    value = (value * 31) ^ hash(self.partArchiveLevel)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestPartsSpec:
  """
  Attributes:
   - names
   - exprs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'names', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'exprs', (TType.STRUCT,(DropPartitionsExpr, DropPartitionsExpr.thrift_spec)), None, ), # 2
  )

  def __init__(self, names=None, exprs=None,):
    self.names = names
    self.exprs = exprs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.names = []
          (_etype388, _size385) = iprot.readListBegin()
          for _i389 in xrange(_size385):
            _elem390 = iprot.readString()
            self.names.append(_elem390)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.exprs = []
          (_etype394, _size391) = iprot.readListBegin()
          for _i395 in xrange(_size391):
            _elem396 = DropPartitionsExpr()
            _elem396.read(iprot)
            self.exprs.append(_elem396)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestPartsSpec')
    if self.names is not None:
      oprot.writeFieldBegin('names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.names))
      for iter397 in self.names:
        oprot.writeString(iter397)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exprs is not None:
      oprot.writeFieldBegin('exprs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.exprs))
      for iter398 in self.exprs:
        iter398.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.names)
    value = (value * 31) ^ hash(self.exprs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropPartitionsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - parts
   - deleteData
   - ifExists
   - ignoreProtection
   - environmentContext
   - needResult
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRUCT, 'parts', (RequestPartsSpec, RequestPartsSpec.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
    (5, TType.BOOL, 'ifExists', None, True, ), # 5
    (6, TType.BOOL, 'ignoreProtection', None, None, ), # 6
    (7, TType.STRUCT, 'environmentContext', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 7
    (8, TType.BOOL, 'needResult', None, True, ), # 8
  )

  def __init__(self, dbName=None, tblName=None, parts=None, deleteData=None, ifExists=thrift_spec[5][4], ignoreProtection=None, environmentContext=None, needResult=thrift_spec[8][4],):
    self.dbName = dbName
    self.tblName = tblName
    self.parts = parts
    self.deleteData = deleteData
    self.ifExists = ifExists
    self.ignoreProtection = ignoreProtection
    self.environmentContext = environmentContext
    self.needResult = needResult

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.parts = RequestPartsSpec()
          self.parts.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.ifExists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.ignoreProtection = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.environmentContext = EnvironmentContext()
          self.environmentContext.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.needResult = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropPartitionsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.parts is not None:
      oprot.writeFieldBegin('parts', TType.STRUCT, 3)
      self.parts.write(oprot)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.ifExists is not None:
      oprot.writeFieldBegin('ifExists', TType.BOOL, 5)
      oprot.writeBool(self.ifExists)
      oprot.writeFieldEnd()
    if self.ignoreProtection is not None:
      oprot.writeFieldBegin('ignoreProtection', TType.BOOL, 6)
      oprot.writeBool(self.ignoreProtection)
      oprot.writeFieldEnd()
    if self.environmentContext is not None:
      oprot.writeFieldBegin('environmentContext', TType.STRUCT, 7)
      self.environmentContext.write(oprot)
      oprot.writeFieldEnd()
    if self.needResult is not None:
      oprot.writeFieldBegin('needResult', TType.BOOL, 8)
      oprot.writeBool(self.needResult)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.parts is None:
      raise TProtocol.TProtocolException(message='Required field parts is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.parts)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.ifExists)
    value = (value * 31) ^ hash(self.ignoreProtection)
    value = (value * 31) ^ hash(self.environmentContext)
    value = (value * 31) ^ hash(self.needResult)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResourceUri:
  """
  Attributes:
   - resourceType
   - uri
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'resourceType', None, None, ), # 1
    (2, TType.STRING, 'uri', None, None, ), # 2
  )

  def __init__(self, resourceType=None, uri=None,):
    self.resourceType = resourceType
    self.uri = uri

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.resourceType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.uri = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResourceUri')
    if self.resourceType is not None:
      oprot.writeFieldBegin('resourceType', TType.I32, 1)
      oprot.writeI32(self.resourceType)
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 2)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourceType)
    value = (value * 31) ^ hash(self.uri)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Function:
  """
  Attributes:
   - functionName
   - dbName
   - className
   - ownerName
   - ownerType
   - createTime
   - functionType
   - resourceUris
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'functionName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'className', None, None, ), # 3
    (4, TType.STRING, 'ownerName', None, None, ), # 4
    (5, TType.I32, 'ownerType', None, None, ), # 5
    (6, TType.I32, 'createTime', None, None, ), # 6
    (7, TType.I32, 'functionType', None, None, ), # 7
    (8, TType.LIST, 'resourceUris', (TType.STRUCT,(ResourceUri, ResourceUri.thrift_spec)), None, ), # 8
  )

  def __init__(self, functionName=None, dbName=None, className=None, ownerName=None, ownerType=None, createTime=None, functionType=None, resourceUris=None,):
    self.functionName = functionName
    self.dbName = dbName
    self.className = className
    self.ownerName = ownerName
    self.ownerType = ownerType
    self.createTime = createTime
    self.functionType = functionType
    self.resourceUris = resourceUris

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.functionName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.className = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ownerType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.functionType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.resourceUris = []
          (_etype402, _size399) = iprot.readListBegin()
          for _i403 in xrange(_size399):
            _elem404 = ResourceUri()
            _elem404.read(iprot)
            self.resourceUris.append(_elem404)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Function')
    if self.functionName is not None:
      oprot.writeFieldBegin('functionName', TType.STRING, 1)
      oprot.writeString(self.functionName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.className is not None:
      oprot.writeFieldBegin('className', TType.STRING, 3)
      oprot.writeString(self.className)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 4)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    if self.ownerType is not None:
      oprot.writeFieldBegin('ownerType', TType.I32, 5)
      oprot.writeI32(self.ownerType)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 6)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.functionType is not None:
      oprot.writeFieldBegin('functionType', TType.I32, 7)
      oprot.writeI32(self.functionType)
      oprot.writeFieldEnd()
    if self.resourceUris is not None:
      oprot.writeFieldBegin('resourceUris', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.resourceUris))
      for iter405 in self.resourceUris:
        iter405.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.functionName)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.className)
    value = (value * 31) ^ hash(self.ownerName)
    value = (value * 31) ^ hash(self.ownerType)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.functionType)
    value = (value * 31) ^ hash(self.resourceUris)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TxnInfo:
  """
  Attributes:
   - id
   - state
   - user
   - hostname
   - agentInfo
   - heartbeatCount
   - metaInfo
   - startedTime
   - lastHeartbeatTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I32, 'state', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRING, 'hostname', None, None, ), # 4
    (5, TType.STRING, 'agentInfo', None, "Unknown", ), # 5
    (6, TType.I32, 'heartbeatCount', None, 0, ), # 6
    (7, TType.STRING, 'metaInfo', None, None, ), # 7
    (8, TType.I64, 'startedTime', None, None, ), # 8
    (9, TType.I64, 'lastHeartbeatTime', None, None, ), # 9
  )

  def __init__(self, id=None, state=None, user=None, hostname=None, agentInfo=thrift_spec[5][4], heartbeatCount=thrift_spec[6][4], metaInfo=None, startedTime=None, lastHeartbeatTime=None,):
    self.id = id
    self.state = state
    self.user = user
    self.hostname = hostname
    self.agentInfo = agentInfo
    self.heartbeatCount = heartbeatCount
    self.metaInfo = metaInfo
    self.startedTime = startedTime
    self.lastHeartbeatTime = lastHeartbeatTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.heartbeatCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.metaInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.startedTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.lastHeartbeatTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TxnInfo')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 2)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 4)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 5)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    if self.heartbeatCount is not None:
      oprot.writeFieldBegin('heartbeatCount', TType.I32, 6)
      oprot.writeI32(self.heartbeatCount)
      oprot.writeFieldEnd()
    if self.metaInfo is not None:
      oprot.writeFieldBegin('metaInfo', TType.STRING, 7)
      oprot.writeString(self.metaInfo)
      oprot.writeFieldEnd()
    if self.startedTime is not None:
      oprot.writeFieldBegin('startedTime', TType.I64, 8)
      oprot.writeI64(self.startedTime)
      oprot.writeFieldEnd()
    if self.lastHeartbeatTime is not None:
      oprot.writeFieldBegin('lastHeartbeatTime', TType.I64, 9)
      oprot.writeI64(self.lastHeartbeatTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.agentInfo)
    value = (value * 31) ^ hash(self.heartbeatCount)
    value = (value * 31) ^ hash(self.metaInfo)
    value = (value * 31) ^ hash(self.startedTime)
    value = (value * 31) ^ hash(self.lastHeartbeatTime)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetOpenTxnsInfoResponse:
  """
  Attributes:
   - txn_high_water_mark
   - open_txns
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txn_high_water_mark', None, None, ), # 1
    (2, TType.LIST, 'open_txns', (TType.STRUCT,(TxnInfo, TxnInfo.thrift_spec)), None, ), # 2
  )

  def __init__(self, txn_high_water_mark=None, open_txns=None,):
    self.txn_high_water_mark = txn_high_water_mark
    self.open_txns = open_txns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txn_high_water_mark = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.open_txns = []
          (_etype409, _size406) = iprot.readListBegin()
          for _i410 in xrange(_size406):
            _elem411 = TxnInfo()
            _elem411.read(iprot)
            self.open_txns.append(_elem411)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetOpenTxnsInfoResponse')
    if self.txn_high_water_mark is not None:
      oprot.writeFieldBegin('txn_high_water_mark', TType.I64, 1)
      oprot.writeI64(self.txn_high_water_mark)
      oprot.writeFieldEnd()
    if self.open_txns is not None:
      oprot.writeFieldBegin('open_txns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.open_txns))
      for iter412 in self.open_txns:
        iter412.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_high_water_mark is None:
      raise TProtocol.TProtocolException(message='Required field txn_high_water_mark is unset!')
    if self.open_txns is None:
      raise TProtocol.TProtocolException(message='Required field open_txns is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_high_water_mark)
    value = (value * 31) ^ hash(self.open_txns)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetOpenTxnsResponse:
  """
  Attributes:
   - txn_high_water_mark
   - open_txns
   - min_open_txn
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txn_high_water_mark', None, None, ), # 1
    (2, TType.SET, 'open_txns', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'min_open_txn', None, None, ), # 3
  )

  def __init__(self, txn_high_water_mark=None, open_txns=None, min_open_txn=None,):
    self.txn_high_water_mark = txn_high_water_mark
    self.open_txns = open_txns
    self.min_open_txn = min_open_txn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txn_high_water_mark = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.open_txns = set()
          (_etype416, _size413) = iprot.readSetBegin()
          for _i417 in xrange(_size413):
            _elem418 = iprot.readI64()
            self.open_txns.add(_elem418)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.min_open_txn = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetOpenTxnsResponse')
    if self.txn_high_water_mark is not None:
      oprot.writeFieldBegin('txn_high_water_mark', TType.I64, 1)
      oprot.writeI64(self.txn_high_water_mark)
      oprot.writeFieldEnd()
    if self.open_txns is not None:
      oprot.writeFieldBegin('open_txns', TType.SET, 2)
      oprot.writeSetBegin(TType.I64, len(self.open_txns))
      for iter419 in self.open_txns:
        oprot.writeI64(iter419)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.min_open_txn is not None:
      oprot.writeFieldBegin('min_open_txn', TType.I64, 3)
      oprot.writeI64(self.min_open_txn)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_high_water_mark is None:
      raise TProtocol.TProtocolException(message='Required field txn_high_water_mark is unset!')
    if self.open_txns is None:
      raise TProtocol.TProtocolException(message='Required field open_txns is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_high_water_mark)
    value = (value * 31) ^ hash(self.open_txns)
    value = (value * 31) ^ hash(self.min_open_txn)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class OpenTxnRequest:
  """
  Attributes:
   - num_txns
   - user
   - hostname
   - agentInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'num_txns', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.STRING, 'hostname', None, None, ), # 3
    (4, TType.STRING, 'agentInfo', None, "Unknown", ), # 4
  )

  def __init__(self, num_txns=None, user=None, hostname=None, agentInfo=thrift_spec[4][4],):
    self.num_txns = num_txns
    self.user = user
    self.hostname = hostname
    self.agentInfo = agentInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.num_txns = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('OpenTxnRequest')
    if self.num_txns is not None:
      oprot.writeFieldBegin('num_txns', TType.I32, 1)
      oprot.writeI32(self.num_txns)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 3)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 4)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.num_txns is None:
      raise TProtocol.TProtocolException(message='Required field num_txns is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.num_txns)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.agentInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class OpenTxnsResponse:
  """
  Attributes:
   - txn_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'txn_ids', (TType.I64,None), None, ), # 1
  )

  def __init__(self, txn_ids=None,):
    self.txn_ids = txn_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.txn_ids = []
          (_etype423, _size420) = iprot.readListBegin()
          for _i424 in xrange(_size420):
            _elem425 = iprot.readI64()
            self.txn_ids.append(_elem425)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('OpenTxnsResponse')
    if self.txn_ids is not None:
      oprot.writeFieldBegin('txn_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.txn_ids))
      for iter426 in self.txn_ids:
        oprot.writeI64(iter426)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_ids is None:
      raise TProtocol.TProtocolException(message='Required field txn_ids is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AbortTxnRequest:
  """
  Attributes:
   - txnid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txnid', None, None, ), # 1
  )

  def __init__(self, txnid=None,):
    self.txnid = txnid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AbortTxnRequest')
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 1)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnid is None:
      raise TProtocol.TProtocolException(message='Required field txnid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AbortTxnsRequest:
  """
  Attributes:
   - txn_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'txn_ids', (TType.I64,None), None, ), # 1
  )

  def __init__(self, txn_ids=None,):
    self.txn_ids = txn_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.txn_ids = []
          (_etype430, _size427) = iprot.readListBegin()
          for _i431 in xrange(_size427):
            _elem432 = iprot.readI64()
            self.txn_ids.append(_elem432)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AbortTxnsRequest')
    if self.txn_ids is not None:
      oprot.writeFieldBegin('txn_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.txn_ids))
      for iter433 in self.txn_ids:
        oprot.writeI64(iter433)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_ids is None:
      raise TProtocol.TProtocolException(message='Required field txn_ids is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CommitTxnRequest:
  """
  Attributes:
   - txnid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txnid', None, None, ), # 1
  )

  def __init__(self, txnid=None,):
    self.txnid = txnid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CommitTxnRequest')
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 1)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnid is None:
      raise TProtocol.TProtocolException(message='Required field txnid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LockComponent:
  """
  Attributes:
   - type
   - level
   - dbname
   - tablename
   - partitionname
   - operationType
   - isAcid
   - isDynamicPartitionWrite
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I32, 'level', None, None, ), # 2
    (3, TType.STRING, 'dbname', None, None, ), # 3
    (4, TType.STRING, 'tablename', None, None, ), # 4
    (5, TType.STRING, 'partitionname', None, None, ), # 5
    (6, TType.I32, 'operationType', None,     5, ), # 6
    (7, TType.BOOL, 'isAcid', None, False, ), # 7
    (8, TType.BOOL, 'isDynamicPartitionWrite', None, False, ), # 8
  )

  def __init__(self, type=None, level=None, dbname=None, tablename=None, partitionname=None, operationType=thrift_spec[6][4], isAcid=thrift_spec[7][4], isDynamicPartitionWrite=thrift_spec[8][4],):
    self.type = type
    self.level = level
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname
    self.operationType = operationType
    self.isAcid = isAcid
    self.isDynamicPartitionWrite = isDynamicPartitionWrite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.level = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.operationType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.isAcid = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.isDynamicPartitionWrite = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockComponent')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.level is not None:
      oprot.writeFieldBegin('level', TType.I32, 2)
      oprot.writeI32(self.level)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 3)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 4)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 5)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    if self.operationType is not None:
      oprot.writeFieldBegin('operationType', TType.I32, 6)
      oprot.writeI32(self.operationType)
      oprot.writeFieldEnd()
    if self.isAcid is not None:
      oprot.writeFieldBegin('isAcid', TType.BOOL, 7)
      oprot.writeBool(self.isAcid)
      oprot.writeFieldEnd()
    if self.isDynamicPartitionWrite is not None:
      oprot.writeFieldBegin('isDynamicPartitionWrite', TType.BOOL, 8)
      oprot.writeBool(self.isDynamicPartitionWrite)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.level is None:
      raise TProtocol.TProtocolException(message='Required field level is unset!')
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.level)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    value = (value * 31) ^ hash(self.operationType)
    value = (value * 31) ^ hash(self.isAcid)
    value = (value * 31) ^ hash(self.isDynamicPartitionWrite)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LockRequest:
  """
  Attributes:
   - component
   - txnid
   - user
   - hostname
   - agentInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'component', (TType.STRUCT,(LockComponent, LockComponent.thrift_spec)), None, ), # 1
    (2, TType.I64, 'txnid', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRING, 'hostname', None, None, ), # 4
    (5, TType.STRING, 'agentInfo', None, "Unknown", ), # 5
  )

  def __init__(self, component=None, txnid=None, user=None, hostname=None, agentInfo=thrift_spec[5][4],):
    self.component = component
    self.txnid = txnid
    self.user = user
    self.hostname = hostname
    self.agentInfo = agentInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.component = []
          (_etype437, _size434) = iprot.readListBegin()
          for _i438 in xrange(_size434):
            _elem439 = LockComponent()
            _elem439.read(iprot)
            self.component.append(_elem439)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockRequest')
    if self.component is not None:
      oprot.writeFieldBegin('component', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.component))
      for iter440 in self.component:
        iter440.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 2)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 4)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 5)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.component is None:
      raise TProtocol.TProtocolException(message='Required field component is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.component)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.agentInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LockResponse:
  """
  Attributes:
   - lockid
   - state
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.I32, 'state', None, None, ), # 2
  )

  def __init__(self, lockid=None, state=None,):
    self.lockid = lockid
    self.state = state

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockResponse')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 2)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.state)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckLockRequest:
  """
  Attributes:
   - lockid
   - txnid
   - elapsed_ms
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.I64, 'txnid', None, None, ), # 2
    (3, TType.I64, 'elapsed_ms', None, None, ), # 3
  )

  def __init__(self, lockid=None, txnid=None, elapsed_ms=None,):
    self.lockid = lockid
    self.txnid = txnid
    self.elapsed_ms = elapsed_ms

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.elapsed_ms = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckLockRequest')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 2)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.elapsed_ms is not None:
      oprot.writeFieldBegin('elapsed_ms', TType.I64, 3)
      oprot.writeI64(self.elapsed_ms)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.elapsed_ms)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnlockRequest:
  """
  Attributes:
   - lockid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
  )

  def __init__(self, lockid=None,):
    self.lockid = lockid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnlockRequest')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowLocksRequest:
  """
  Attributes:
   - dbname
   - tablename
   - partname
   - isExtended
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'partname', None, None, ), # 3
    (4, TType.BOOL, 'isExtended', None, False, ), # 4
  )

  def __init__(self, dbname=None, tablename=None, partname=None, isExtended=thrift_spec[4][4],):
    self.dbname = dbname
    self.tablename = tablename
    self.partname = partname
    self.isExtended = isExtended

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isExtended = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowLocksRequest')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partname is not None:
      oprot.writeFieldBegin('partname', TType.STRING, 3)
      oprot.writeString(self.partname)
      oprot.writeFieldEnd()
    if self.isExtended is not None:
      oprot.writeFieldBegin('isExtended', TType.BOOL, 4)
      oprot.writeBool(self.isExtended)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partname)
    value = (value * 31) ^ hash(self.isExtended)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowLocksResponseElement:
  """
  Attributes:
   - lockid
   - dbname
   - tablename
   - partname
   - state
   - type
   - txnid
   - lastheartbeat
   - acquiredat
   - user
   - hostname
   - heartbeatCount
   - agentInfo
   - blockedByExtId
   - blockedByIntId
   - lockIdInternal
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.STRING, 'dbname', None, None, ), # 2
    (3, TType.STRING, 'tablename', None, None, ), # 3
    (4, TType.STRING, 'partname', None, None, ), # 4
    (5, TType.I32, 'state', None, None, ), # 5
    (6, TType.I32, 'type', None, None, ), # 6
    (7, TType.I64, 'txnid', None, None, ), # 7
    (8, TType.I64, 'lastheartbeat', None, None, ), # 8
    (9, TType.I64, 'acquiredat', None, None, ), # 9
    (10, TType.STRING, 'user', None, None, ), # 10
    (11, TType.STRING, 'hostname', None, None, ), # 11
    (12, TType.I32, 'heartbeatCount', None, 0, ), # 12
    (13, TType.STRING, 'agentInfo', None, None, ), # 13
    (14, TType.I64, 'blockedByExtId', None, None, ), # 14
    (15, TType.I64, 'blockedByIntId', None, None, ), # 15
    (16, TType.I64, 'lockIdInternal', None, None, ), # 16
  )

  def __init__(self, lockid=None, dbname=None, tablename=None, partname=None, state=None, type=None, txnid=None, lastheartbeat=None, acquiredat=None, user=None, hostname=None, heartbeatCount=thrift_spec[12][4], agentInfo=None, blockedByExtId=None, blockedByIntId=None, lockIdInternal=None,):
    self.lockid = lockid
    self.dbname = dbname
    self.tablename = tablename
    self.partname = partname
    self.state = state
    self.type = type
    self.txnid = txnid
    self.lastheartbeat = lastheartbeat
    self.acquiredat = acquiredat
    self.user = user
    self.hostname = hostname
    self.heartbeatCount = heartbeatCount
    self.agentInfo = agentInfo
    self.blockedByExtId = blockedByExtId
    self.blockedByIntId = blockedByIntId
    self.lockIdInternal = lockIdInternal

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.partname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.lastheartbeat = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.acquiredat = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.heartbeatCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I64:
          self.blockedByExtId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.blockedByIntId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I64:
          self.lockIdInternal = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowLocksResponseElement')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 2)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 3)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partname is not None:
      oprot.writeFieldBegin('partname', TType.STRING, 4)
      oprot.writeString(self.partname)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 5)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 6)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 7)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.lastheartbeat is not None:
      oprot.writeFieldBegin('lastheartbeat', TType.I64, 8)
      oprot.writeI64(self.lastheartbeat)
      oprot.writeFieldEnd()
    if self.acquiredat is not None:
      oprot.writeFieldBegin('acquiredat', TType.I64, 9)
      oprot.writeI64(self.acquiredat)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 10)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 11)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.heartbeatCount is not None:
      oprot.writeFieldBegin('heartbeatCount', TType.I32, 12)
      oprot.writeI32(self.heartbeatCount)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 13)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    if self.blockedByExtId is not None:
      oprot.writeFieldBegin('blockedByExtId', TType.I64, 14)
      oprot.writeI64(self.blockedByExtId)
      oprot.writeFieldEnd()
    if self.blockedByIntId is not None:
      oprot.writeFieldBegin('blockedByIntId', TType.I64, 15)
      oprot.writeI64(self.blockedByIntId)
      oprot.writeFieldEnd()
    if self.lockIdInternal is not None:
      oprot.writeFieldBegin('lockIdInternal', TType.I64, 16)
      oprot.writeI64(self.lockIdInternal)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.lastheartbeat is None:
      raise TProtocol.TProtocolException(message='Required field lastheartbeat is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partname)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.lastheartbeat)
    value = (value * 31) ^ hash(self.acquiredat)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.heartbeatCount)
    value = (value * 31) ^ hash(self.agentInfo)
    value = (value * 31) ^ hash(self.blockedByExtId)
    value = (value * 31) ^ hash(self.blockedByIntId)
    value = (value * 31) ^ hash(self.lockIdInternal)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowLocksResponse:
  """
  Attributes:
   - locks
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'locks', (TType.STRUCT,(ShowLocksResponseElement, ShowLocksResponseElement.thrift_spec)), None, ), # 1
  )

  def __init__(self, locks=None,):
    self.locks = locks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.locks = []
          (_etype444, _size441) = iprot.readListBegin()
          for _i445 in xrange(_size441):
            _elem446 = ShowLocksResponseElement()
            _elem446.read(iprot)
            self.locks.append(_elem446)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowLocksResponse')
    if self.locks is not None:
      oprot.writeFieldBegin('locks', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.locks))
      for iter447 in self.locks:
        iter447.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.locks)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HeartbeatRequest:
  """
  Attributes:
   - lockid
   - txnid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.I64, 'txnid', None, None, ), # 2
  )

  def __init__(self, lockid=None, txnid=None,):
    self.lockid = lockid
    self.txnid = txnid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HeartbeatRequest')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 2)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.txnid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HeartbeatTxnRangeRequest:
  """
  Attributes:
   - min
   - max
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'min', None, None, ), # 1
    (2, TType.I64, 'max', None, None, ), # 2
  )

  def __init__(self, min=None, max=None,):
    self.min = min
    self.max = max

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.min = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.max = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HeartbeatTxnRangeRequest')
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I64, 1)
      oprot.writeI64(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I64, 2)
      oprot.writeI64(self.max)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.min is None:
      raise TProtocol.TProtocolException(message='Required field min is unset!')
    if self.max is None:
      raise TProtocol.TProtocolException(message='Required field max is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.min)
    value = (value * 31) ^ hash(self.max)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HeartbeatTxnRangeResponse:
  """
  Attributes:
   - aborted
   - nosuch
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'aborted', (TType.I64,None), None, ), # 1
    (2, TType.SET, 'nosuch', (TType.I64,None), None, ), # 2
  )

  def __init__(self, aborted=None, nosuch=None,):
    self.aborted = aborted
    self.nosuch = nosuch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.aborted = set()
          (_etype451, _size448) = iprot.readSetBegin()
          for _i452 in xrange(_size448):
            _elem453 = iprot.readI64()
            self.aborted.add(_elem453)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.nosuch = set()
          (_etype457, _size454) = iprot.readSetBegin()
          for _i458 in xrange(_size454):
            _elem459 = iprot.readI64()
            self.nosuch.add(_elem459)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HeartbeatTxnRangeResponse')
    if self.aborted is not None:
      oprot.writeFieldBegin('aborted', TType.SET, 1)
      oprot.writeSetBegin(TType.I64, len(self.aborted))
      for iter460 in self.aborted:
        oprot.writeI64(iter460)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.nosuch is not None:
      oprot.writeFieldBegin('nosuch', TType.SET, 2)
      oprot.writeSetBegin(TType.I64, len(self.nosuch))
      for iter461 in self.nosuch:
        oprot.writeI64(iter461)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.aborted is None:
      raise TProtocol.TProtocolException(message='Required field aborted is unset!')
    if self.nosuch is None:
      raise TProtocol.TProtocolException(message='Required field nosuch is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.aborted)
    value = (value * 31) ^ hash(self.nosuch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CompactionRequest:
  """
  Attributes:
   - dbname
   - tablename
   - partitionname
   - type
   - runas
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'partitionname', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
    (5, TType.STRING, 'runas', None, None, ), # 5
    (6, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 6
  )

  def __init__(self, dbname=None, tablename=None, partitionname=None, type=None, runas=None, properties=None,):
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname
    self.type = type
    self.runas = runas
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.runas = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype463, _vtype464, _size462 ) = iprot.readMapBegin()
          for _i466 in xrange(_size462):
            _key467 = iprot.readString()
            _val468 = iprot.readString()
            self.properties[_key467] = _val468
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CompactionRequest')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 3)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.runas is not None:
      oprot.writeFieldBegin('runas', TType.STRING, 5)
      oprot.writeString(self.runas)
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter469,viter470 in self.properties.items():
        oprot.writeString(kiter469)
        oprot.writeString(viter470)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.runas)
    value = (value * 31) ^ hash(self.properties)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CompactionResponse:
  """
  Attributes:
   - id
   - state
   - accepted
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRING, 'state', None, None, ), # 2
    (3, TType.BOOL, 'accepted', None, None, ), # 3
  )

  def __init__(self, id=None, state=None, accepted=None,):
    self.id = id
    self.state = state
    self.accepted = accepted

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.state = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.accepted = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CompactionResponse')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRING, 2)
      oprot.writeString(self.state)
      oprot.writeFieldEnd()
    if self.accepted is not None:
      oprot.writeFieldBegin('accepted', TType.BOOL, 3)
      oprot.writeBool(self.accepted)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    if self.accepted is None:
      raise TProtocol.TProtocolException(message='Required field accepted is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.accepted)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowCompactRequest:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowCompactRequest')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowCompactResponseElement:
  """
  Attributes:
   - dbname
   - tablename
   - partitionname
   - type
   - state
   - workerid
   - start
   - runAs
   - hightestTxnId
   - metaInfo
   - endTime
   - hadoopJobId
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'partitionname', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
    (5, TType.STRING, 'state', None, None, ), # 5
    (6, TType.STRING, 'workerid', None, None, ), # 6
    (7, TType.I64, 'start', None, None, ), # 7
    (8, TType.STRING, 'runAs', None, None, ), # 8
    (9, TType.I64, 'hightestTxnId', None, None, ), # 9
    (10, TType.STRING, 'metaInfo', None, None, ), # 10
    (11, TType.I64, 'endTime', None, None, ), # 11
    (12, TType.STRING, 'hadoopJobId', None, "None", ), # 12
    (13, TType.I64, 'id', None, None, ), # 13
  )

  def __init__(self, dbname=None, tablename=None, partitionname=None, type=None, state=None, workerid=None, start=None, runAs=None, hightestTxnId=None, metaInfo=None, endTime=None, hadoopJobId=thrift_spec[12][4], id=None,):
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname
    self.type = type
    self.state = state
    self.workerid = workerid
    self.start = start
    self.runAs = runAs
    self.hightestTxnId = hightestTxnId
    self.metaInfo = metaInfo
    self.endTime = endTime
    self.hadoopJobId = hadoopJobId
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.state = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.workerid = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.runAs = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.hightestTxnId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.metaInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.endTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.hadoopJobId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowCompactResponseElement')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 3)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRING, 5)
      oprot.writeString(self.state)
      oprot.writeFieldEnd()
    if self.workerid is not None:
      oprot.writeFieldBegin('workerid', TType.STRING, 6)
      oprot.writeString(self.workerid)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 7)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.runAs is not None:
      oprot.writeFieldBegin('runAs', TType.STRING, 8)
      oprot.writeString(self.runAs)
      oprot.writeFieldEnd()
    if self.hightestTxnId is not None:
      oprot.writeFieldBegin('hightestTxnId', TType.I64, 9)
      oprot.writeI64(self.hightestTxnId)
      oprot.writeFieldEnd()
    if self.metaInfo is not None:
      oprot.writeFieldBegin('metaInfo', TType.STRING, 10)
      oprot.writeString(self.metaInfo)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.I64, 11)
      oprot.writeI64(self.endTime)
      oprot.writeFieldEnd()
    if self.hadoopJobId is not None:
      oprot.writeFieldBegin('hadoopJobId', TType.STRING, 12)
      oprot.writeString(self.hadoopJobId)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 13)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.workerid)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.runAs)
    value = (value * 31) ^ hash(self.hightestTxnId)
    value = (value * 31) ^ hash(self.metaInfo)
    value = (value * 31) ^ hash(self.endTime)
    value = (value * 31) ^ hash(self.hadoopJobId)
    value = (value * 31) ^ hash(self.id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowCompactResponse:
  """
  Attributes:
   - compacts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'compacts', (TType.STRUCT,(ShowCompactResponseElement, ShowCompactResponseElement.thrift_spec)), None, ), # 1
  )

  def __init__(self, compacts=None,):
    self.compacts = compacts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.compacts = []
          (_etype474, _size471) = iprot.readListBegin()
          for _i475 in xrange(_size471):
            _elem476 = ShowCompactResponseElement()
            _elem476.read(iprot)
            self.compacts.append(_elem476)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowCompactResponse')
    if self.compacts is not None:
      oprot.writeFieldBegin('compacts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.compacts))
      for iter477 in self.compacts:
        iter477.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.compacts is None:
      raise TProtocol.TProtocolException(message='Required field compacts is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.compacts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddDynamicPartitions:
  """
  Attributes:
   - txnid
   - dbname
   - tablename
   - partitionnames
   - operationType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txnid', None, None, ), # 1
    (2, TType.STRING, 'dbname', None, None, ), # 2
    (3, TType.STRING, 'tablename', None, None, ), # 3
    (4, TType.LIST, 'partitionnames', (TType.STRING,None), None, ), # 4
    (5, TType.I32, 'operationType', None,     5, ), # 5
  )

  def __init__(self, txnid=None, dbname=None, tablename=None, partitionnames=None, operationType=thrift_spec[5][4],):
    self.txnid = txnid
    self.dbname = dbname
    self.tablename = tablename
    self.partitionnames = partitionnames
    self.operationType = operationType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partitionnames = []
          (_etype481, _size478) = iprot.readListBegin()
          for _i482 in xrange(_size478):
            _elem483 = iprot.readString()
            self.partitionnames.append(_elem483)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.operationType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddDynamicPartitions')
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 1)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 2)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 3)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionnames is not None:
      oprot.writeFieldBegin('partitionnames', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.partitionnames))
      for iter484 in self.partitionnames:
        oprot.writeString(iter484)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.operationType is not None:
      oprot.writeFieldBegin('operationType', TType.I32, 5)
      oprot.writeI32(self.operationType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnid is None:
      raise TProtocol.TProtocolException(message='Required field txnid is unset!')
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.partitionnames is None:
      raise TProtocol.TProtocolException(message='Required field partitionnames is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionnames)
    value = (value * 31) ^ hash(self.operationType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEventRequest:
  """
  Attributes:
   - lastEvent
   - maxEvents
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lastEvent', None, None, ), # 1
    (2, TType.I32, 'maxEvents', None, None, ), # 2
  )

  def __init__(self, lastEvent=None, maxEvents=None,):
    self.lastEvent = lastEvent
    self.maxEvents = maxEvents

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lastEvent = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxEvents = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEventRequest')
    if self.lastEvent is not None:
      oprot.writeFieldBegin('lastEvent', TType.I64, 1)
      oprot.writeI64(self.lastEvent)
      oprot.writeFieldEnd()
    if self.maxEvents is not None:
      oprot.writeFieldBegin('maxEvents', TType.I32, 2)
      oprot.writeI32(self.maxEvents)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lastEvent is None:
      raise TProtocol.TProtocolException(message='Required field lastEvent is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lastEvent)
    value = (value * 31) ^ hash(self.maxEvents)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEvent:
  """
  Attributes:
   - eventId
   - eventTime
   - eventType
   - dbName
   - tableName
   - message
   - messageFormat
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'eventId', None, None, ), # 1
    (2, TType.I32, 'eventTime', None, None, ), # 2
    (3, TType.STRING, 'eventType', None, None, ), # 3
    (4, TType.STRING, 'dbName', None, None, ), # 4
    (5, TType.STRING, 'tableName', None, None, ), # 5
    (6, TType.STRING, 'message', None, None, ), # 6
    (7, TType.STRING, 'messageFormat', None, None, ), # 7
  )

  def __init__(self, eventId=None, eventTime=None, eventType=None, dbName=None, tableName=None, message=None, messageFormat=None,):
    self.eventId = eventId
    self.eventTime = eventTime
    self.eventType = eventType
    self.dbName = dbName
    self.tableName = tableName
    self.message = message
    self.messageFormat = messageFormat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.eventId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.eventTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.eventType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.messageFormat = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEvent')
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I64, 1)
      oprot.writeI64(self.eventId)
      oprot.writeFieldEnd()
    if self.eventTime is not None:
      oprot.writeFieldBegin('eventTime', TType.I32, 2)
      oprot.writeI32(self.eventTime)
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.STRING, 3)
      oprot.writeString(self.eventType)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 4)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 5)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 6)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.messageFormat is not None:
      oprot.writeFieldBegin('messageFormat', TType.STRING, 7)
      oprot.writeString(self.messageFormat)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.eventId is None:
      raise TProtocol.TProtocolException(message='Required field eventId is unset!')
    if self.eventTime is None:
      raise TProtocol.TProtocolException(message='Required field eventTime is unset!')
    if self.eventType is None:
      raise TProtocol.TProtocolException(message='Required field eventType is unset!')
    if self.message is None:
      raise TProtocol.TProtocolException(message='Required field message is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.eventId)
    value = (value * 31) ^ hash(self.eventTime)
    value = (value * 31) ^ hash(self.eventType)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.message)
    value = (value * 31) ^ hash(self.messageFormat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEventResponse:
  """
  Attributes:
   - events
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'events', (TType.STRUCT,(NotificationEvent, NotificationEvent.thrift_spec)), None, ), # 1
  )

  def __init__(self, events=None,):
    self.events = events

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.events = []
          (_etype488, _size485) = iprot.readListBegin()
          for _i489 in xrange(_size485):
            _elem490 = NotificationEvent()
            _elem490.read(iprot)
            self.events.append(_elem490)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEventResponse')
    if self.events is not None:
      oprot.writeFieldBegin('events', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.events))
      for iter491 in self.events:
        iter491.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.events is None:
      raise TProtocol.TProtocolException(message='Required field events is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.events)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CurrentNotificationEventId:
  """
  Attributes:
   - eventId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'eventId', None, None, ), # 1
  )

  def __init__(self, eventId=None,):
    self.eventId = eventId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.eventId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CurrentNotificationEventId')
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I64, 1)
      oprot.writeI64(self.eventId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.eventId is None:
      raise TProtocol.TProtocolException(message='Required field eventId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.eventId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InsertEventRequestData:
  """
  Attributes:
   - filesAdded
   - filesAddedChecksum
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'filesAdded', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'filesAddedChecksum', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, filesAdded=None, filesAddedChecksum=None,):
    self.filesAdded = filesAdded
    self.filesAddedChecksum = filesAddedChecksum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.filesAdded = []
          (_etype495, _size492) = iprot.readListBegin()
          for _i496 in xrange(_size492):
            _elem497 = iprot.readString()
            self.filesAdded.append(_elem497)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.filesAddedChecksum = []
          (_etype501, _size498) = iprot.readListBegin()
          for _i502 in xrange(_size498):
            _elem503 = iprot.readString()
            self.filesAddedChecksum.append(_elem503)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InsertEventRequestData')
    if self.filesAdded is not None:
      oprot.writeFieldBegin('filesAdded', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.filesAdded))
      for iter504 in self.filesAdded:
        oprot.writeString(iter504)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.filesAddedChecksum is not None:
      oprot.writeFieldBegin('filesAddedChecksum', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.filesAddedChecksum))
      for iter505 in self.filesAddedChecksum:
        oprot.writeString(iter505)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.filesAdded is None:
      raise TProtocol.TProtocolException(message='Required field filesAdded is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.filesAdded)
    value = (value * 31) ^ hash(self.filesAddedChecksum)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FireEventRequestData:
  """
  Attributes:
   - insertData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'insertData', (InsertEventRequestData, InsertEventRequestData.thrift_spec), None, ), # 1
  )

  def __init__(self, insertData=None,):
    self.insertData = insertData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.insertData = InsertEventRequestData()
          self.insertData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FireEventRequestData')
    if self.insertData is not None:
      oprot.writeFieldBegin('insertData', TType.STRUCT, 1)
      self.insertData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.insertData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FireEventRequest:
  """
  Attributes:
   - successful
   - data
   - dbName
   - tableName
   - partitionVals
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'successful', None, None, ), # 1
    (2, TType.STRUCT, 'data', (FireEventRequestData, FireEventRequestData.thrift_spec), None, ), # 2
    (3, TType.STRING, 'dbName', None, None, ), # 3
    (4, TType.STRING, 'tableName', None, None, ), # 4
    (5, TType.LIST, 'partitionVals', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, successful=None, data=None, dbName=None, tableName=None, partitionVals=None,):
    self.successful = successful
    self.data = data
    self.dbName = dbName
    self.tableName = tableName
    self.partitionVals = partitionVals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.successful = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data = FireEventRequestData()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.partitionVals = []
          (_etype509, _size506) = iprot.readListBegin()
          for _i510 in xrange(_size506):
            _elem511 = iprot.readString()
            self.partitionVals.append(_elem511)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FireEventRequest')
    if self.successful is not None:
      oprot.writeFieldBegin('successful', TType.BOOL, 1)
      oprot.writeBool(self.successful)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRUCT, 2)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 3)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 4)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partitionVals is not None:
      oprot.writeFieldBegin('partitionVals', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.partitionVals))
      for iter512 in self.partitionVals:
        oprot.writeString(iter512)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.successful is None:
      raise TProtocol.TProtocolException(message='Required field successful is unset!')
    if self.data is None:
      raise TProtocol.TProtocolException(message='Required field data is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.successful)
    value = (value * 31) ^ hash(self.data)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partitionVals)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FireEventResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FireEventResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetadataPpdResult:
  """
  Attributes:
   - metadata
   - includeBitset
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'metadata', None, None, ), # 1
    (2, TType.STRING, 'includeBitset', None, None, ), # 2
  )

  def __init__(self, metadata=None, includeBitset=None,):
    self.metadata = metadata
    self.includeBitset = includeBitset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.metadata = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.includeBitset = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetadataPpdResult')
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRING, 1)
      oprot.writeString(self.metadata)
      oprot.writeFieldEnd()
    if self.includeBitset is not None:
      oprot.writeFieldBegin('includeBitset', TType.STRING, 2)
      oprot.writeString(self.includeBitset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.includeBitset)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataByExprResult:
  """
  Attributes:
   - metadata
   - isSupported
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metadata', (TType.I64,None,TType.STRUCT,(MetadataPpdResult, MetadataPpdResult.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'isSupported', None, None, ), # 2
  )

  def __init__(self, metadata=None, isSupported=None,):
    self.metadata = metadata
    self.isSupported = isSupported

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metadata = {}
          (_ktype514, _vtype515, _size513 ) = iprot.readMapBegin()
          for _i517 in xrange(_size513):
            _key518 = iprot.readI64()
            _val519 = MetadataPpdResult()
            _val519.read(iprot)
            self.metadata[_key518] = _val519
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isSupported = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataByExprResult')
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.MAP, 1)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.metadata))
      for kiter520,viter521 in self.metadata.items():
        oprot.writeI64(kiter520)
        viter521.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.isSupported is not None:
      oprot.writeFieldBegin('isSupported', TType.BOOL, 2)
      oprot.writeBool(self.isSupported)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.isSupported is None:
      raise TProtocol.TProtocolException(message='Required field isSupported is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.isSupported)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataByExprRequest:
  """
  Attributes:
   - fileIds
   - expr
   - doGetFooters
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'expr', None, None, ), # 2
    (3, TType.BOOL, 'doGetFooters', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
  )

  def __init__(self, fileIds=None, expr=None, doGetFooters=None, type=None,):
    self.fileIds = fileIds
    self.expr = expr
    self.doGetFooters = doGetFooters
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype525, _size522) = iprot.readListBegin()
          for _i526 in xrange(_size522):
            _elem527 = iprot.readI64()
            self.fileIds.append(_elem527)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.doGetFooters = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataByExprRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter528 in self.fileIds:
        oprot.writeI64(iter528)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expr is not None:
      oprot.writeFieldBegin('expr', TType.STRING, 2)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    if self.doGetFooters is not None:
      oprot.writeFieldBegin('doGetFooters', TType.BOOL, 3)
      oprot.writeBool(self.doGetFooters)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    if self.expr is None:
      raise TProtocol.TProtocolException(message='Required field expr is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    value = (value * 31) ^ hash(self.expr)
    value = (value * 31) ^ hash(self.doGetFooters)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataResult:
  """
  Attributes:
   - metadata
   - isSupported
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metadata', (TType.I64,None,TType.STRING,None), None, ), # 1
    (2, TType.BOOL, 'isSupported', None, None, ), # 2
  )

  def __init__(self, metadata=None, isSupported=None,):
    self.metadata = metadata
    self.isSupported = isSupported

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metadata = {}
          (_ktype530, _vtype531, _size529 ) = iprot.readMapBegin()
          for _i533 in xrange(_size529):
            _key534 = iprot.readI64()
            _val535 = iprot.readString()
            self.metadata[_key534] = _val535
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isSupported = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataResult')
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.MAP, 1)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.metadata))
      for kiter536,viter537 in self.metadata.items():
        oprot.writeI64(kiter536)
        oprot.writeString(viter537)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.isSupported is not None:
      oprot.writeFieldBegin('isSupported', TType.BOOL, 2)
      oprot.writeBool(self.isSupported)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.isSupported is None:
      raise TProtocol.TProtocolException(message='Required field isSupported is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.isSupported)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataRequest:
  """
  Attributes:
   - fileIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
  )

  def __init__(self, fileIds=None,):
    self.fileIds = fileIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype541, _size538) = iprot.readListBegin()
          for _i542 in xrange(_size538):
            _elem543 = iprot.readI64()
            self.fileIds.append(_elem543)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter544 in self.fileIds:
        oprot.writeI64(iter544)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutFileMetadataResult:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutFileMetadataResult')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutFileMetadataRequest:
  """
  Attributes:
   - fileIds
   - metadata
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
    (2, TType.LIST, 'metadata', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
  )

  def __init__(self, fileIds=None, metadata=None, type=None,):
    self.fileIds = fileIds
    self.metadata = metadata
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype548, _size545) = iprot.readListBegin()
          for _i549 in xrange(_size545):
            _elem550 = iprot.readI64()
            self.fileIds.append(_elem550)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.metadata = []
          (_etype554, _size551) = iprot.readListBegin()
          for _i555 in xrange(_size551):
            _elem556 = iprot.readString()
            self.metadata.append(_elem556)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutFileMetadataRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter557 in self.fileIds:
        oprot.writeI64(iter557)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.metadata))
      for iter558 in self.metadata:
        oprot.writeString(iter558)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClearFileMetadataResult:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClearFileMetadataResult')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClearFileMetadataRequest:
  """
  Attributes:
   - fileIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
  )

  def __init__(self, fileIds=None,):
    self.fileIds = fileIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype562, _size559) = iprot.readListBegin()
          for _i563 in xrange(_size559):
            _elem564 = iprot.readI64()
            self.fileIds.append(_elem564)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClearFileMetadataRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter565 in self.fileIds:
        oprot.writeI64(iter565)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CacheFileMetadataResult:
  """
  Attributes:
   - isSupported
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isSupported', None, None, ), # 1
  )

  def __init__(self, isSupported=None,):
    self.isSupported = isSupported

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isSupported = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CacheFileMetadataResult')
    if self.isSupported is not None:
      oprot.writeFieldBegin('isSupported', TType.BOOL, 1)
      oprot.writeBool(self.isSupported)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isSupported is None:
      raise TProtocol.TProtocolException(message='Required field isSupported is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isSupported)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CacheFileMetadataRequest:
  """
  Attributes:
   - dbName
   - tblName
   - partName
   - isAllParts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRING, 'partName', None, None, ), # 3
    (4, TType.BOOL, 'isAllParts', None, None, ), # 4
  )

  def __init__(self, dbName=None, tblName=None, partName=None, isAllParts=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.partName = partName
    self.isAllParts = isAllParts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isAllParts = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CacheFileMetadataRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.partName is not None:
      oprot.writeFieldBegin('partName', TType.STRING, 3)
      oprot.writeString(self.partName)
      oprot.writeFieldEnd()
    if self.isAllParts is not None:
      oprot.writeFieldBegin('isAllParts', TType.BOOL, 4)
      oprot.writeBool(self.isAllParts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.partName)
    value = (value * 31) ^ hash(self.isAllParts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllFunctionsResponse:
  """
  Attributes:
   - functions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'functions', (TType.STRUCT,(Function, Function.thrift_spec)), None, ), # 1
  )

  def __init__(self, functions=None,):
    self.functions = functions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.functions = []
          (_etype569, _size566) = iprot.readListBegin()
          for _i570 in xrange(_size566):
            _elem571 = Function()
            _elem571.read(iprot)
            self.functions.append(_elem571)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllFunctionsResponse')
    if self.functions is not None:
      oprot.writeFieldBegin('functions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.functions))
      for iter572 in self.functions:
        iter572.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.functions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClientCapabilities:
  """
  Attributes:
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.I32,None), None, ), # 1
  )

  def __init__(self, values=None,):
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype576, _size573) = iprot.readListBegin()
          for _i577 in xrange(_size573):
            _elem578 = iprot.readI32()
            self.values.append(_elem578)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClientCapabilities')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.values))
      for iter579 in self.values:
        oprot.writeI32(iter579)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.values is None:
      raise TProtocol.TProtocolException(message='Required field values is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTableRequest:
  """
  Attributes:
   - dbName
   - tblName
   - capabilities
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRUCT, 'capabilities', (ClientCapabilities, ClientCapabilities.thrift_spec), None, ), # 3
  )

  def __init__(self, dbName=None, tblName=None, capabilities=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.capabilities = capabilities

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.capabilities = ClientCapabilities()
          self.capabilities.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTableRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.capabilities is not None:
      oprot.writeFieldBegin('capabilities', TType.STRUCT, 3)
      self.capabilities.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.capabilities)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTableResult:
  """
  Attributes:
   - table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table', (Table, Table.thrift_spec), None, ), # 1
  )

  def __init__(self, table=None,):
    self.table = table

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table = Table()
          self.table.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTableResult')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRUCT, 1)
      self.table.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTablesRequest:
  """
  Attributes:
   - dbName
   - tblNames
   - capabilities
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.LIST, 'tblNames', (TType.STRING,None), None, ), # 2
    (3, TType.STRUCT, 'capabilities', (ClientCapabilities, ClientCapabilities.thrift_spec), None, ), # 3
  )

  def __init__(self, dbName=None, tblNames=None, capabilities=None,):
    self.dbName = dbName
    self.tblNames = tblNames
    self.capabilities = capabilities

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tblNames = []
          (_etype583, _size580) = iprot.readListBegin()
          for _i584 in xrange(_size580):
            _elem585 = iprot.readString()
            self.tblNames.append(_elem585)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.capabilities = ClientCapabilities()
          self.capabilities.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTablesRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblNames is not None:
      oprot.writeFieldBegin('tblNames', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.tblNames))
      for iter586 in self.tblNames:
        oprot.writeString(iter586)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.capabilities is not None:
      oprot.writeFieldBegin('capabilities', TType.STRUCT, 3)
      self.capabilities.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblNames)
    value = (value * 31) ^ hash(self.capabilities)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTablesResult:
  """
  Attributes:
   - tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tables', (TType.STRUCT,(Table, Table.thrift_spec)), None, ), # 1
  )

  def __init__(self, tables=None,):
    self.tables = tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tables = []
          (_etype590, _size587) = iprot.readListBegin()
          for _i591 in xrange(_size587):
            _elem592 = Table()
            _elem592.read(iprot)
            self.tables.append(_elem592)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTablesResult')
    if self.tables is not None:
      oprot.writeFieldBegin('tables', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tables))
      for iter593 in self.tables:
        iter593.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tables is None:
      raise TProtocol.TProtocolException(message='Required field tables is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tables)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableMeta:
  """
  Attributes:
   - dbName
   - tableName
   - tableType
   - comments
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'tableType', None, None, ), # 3
    (4, TType.STRING, 'comments', None, None, ), # 4
  )

  def __init__(self, dbName=None, tableName=None, tableType=None, comments=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.tableType = tableType
    self.comments = comments

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.comments = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableMeta')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.tableType is not None:
      oprot.writeFieldBegin('tableType', TType.STRING, 3)
      oprot.writeString(self.tableType)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 4)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    if self.tableType is None:
      raise TProtocol.TProtocolException(message='Required field tableType is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.tableType)
    value = (value * 31) ^ hash(self.comments)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetaException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetaException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownTableException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownTableException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownDBException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownDBException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AlreadyExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AlreadyExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidPartitionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidPartitionException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownPartitionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownPartitionException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidObjectException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidObjectException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchObjectException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchObjectException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndexAlreadyExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndexAlreadyExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidOperationException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidOperationException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigValSecurityException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigValSecurityException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidInputException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidInputException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchTxnException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchTxnException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TxnAbortedException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TxnAbortedException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TxnOpenException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TxnOpenException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchLockException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchLockException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
