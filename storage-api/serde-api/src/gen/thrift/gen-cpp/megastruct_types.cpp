/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "megastruct_types.h"

#include <algorithm>



int _kMyEnumValues[] = {
  MyEnum::LLAMA,
  MyEnum::ALPACA
};
const char* _kMyEnumNames[] = {
  "LLAMA",
  "ALPACA"
};
const std::map<int, const char*> _MyEnum_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMyEnumValues, _kMyEnumNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* MiniStruct::ascii_fingerprint = "4ED2B10931906B61ED0B1592EE860A37";
const uint8_t MiniStruct::binary_fingerprint[16] = {0x4E,0xD2,0xB1,0x09,0x31,0x90,0x6B,0x61,0xED,0x0B,0x15,0x92,0xEE,0x86,0x0A,0x37};

uint32_t MiniStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->my_string);
          this->__isset.my_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->my_enum = (MyEnum::type)ecast0;
          this->__isset.my_enum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MiniStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MiniStruct");

  if (this->__isset.my_string) {
    xfer += oprot->writeFieldBegin("my_string", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->my_string);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_enum) {
    xfer += oprot->writeFieldBegin("my_enum", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->my_enum);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MiniStruct &a, MiniStruct &b) {
  using ::std::swap;
  swap(a.my_string, b.my_string);
  swap(a.my_enum, b.my_enum);
  swap(a.__isset, b.__isset);
}

const char* MegaStruct::ascii_fingerprint = "9979EEF0CA19988228E64220A3AA9120";
const uint8_t MegaStruct::binary_fingerprint[16] = {0x99,0x79,0xEE,0xF0,0xCA,0x19,0x98,0x82,0x28,0xE6,0x42,0x20,0xA3,0xAA,0x91,0x20};

uint32_t MegaStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->my_bool);
          this->__isset.my_bool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->my_byte);
          this->__isset.my_byte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->my_16bit_int);
          this->__isset.my_16bit_int = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->my_32bit_int);
          this->__isset.my_32bit_int = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->my_64bit_int);
          this->__isset.my_64bit_int = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->my_double);
          this->__isset.my_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->my_string);
          this->__isset.my_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->my_binary);
          this->__isset.my_binary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->my_string_string_map.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              std::string _key6;
              xfer += iprot->readString(_key6);
              std::string& _val7 = this->my_string_string_map[_key6];
              xfer += iprot->readString(_val7);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.my_string_string_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->my_string_enum_map.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _ktype9;
            ::apache::thrift::protocol::TType _vtype10;
            xfer += iprot->readMapBegin(_ktype9, _vtype10, _size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              std::string _key13;
              xfer += iprot->readString(_key13);
              MyEnum::type& _val14 = this->my_string_enum_map[_key13];
              int32_t ecast15;
              xfer += iprot->readI32(ecast15);
              _val14 = (MyEnum::type)ecast15;
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.my_string_enum_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->my_enum_string_map.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _ktype17;
            ::apache::thrift::protocol::TType _vtype18;
            xfer += iprot->readMapBegin(_ktype17, _vtype18, _size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              MyEnum::type _key21;
              int32_t ecast23;
              xfer += iprot->readI32(ecast23);
              _key21 = (MyEnum::type)ecast23;
              std::string& _val22 = this->my_enum_string_map[_key21];
              xfer += iprot->readString(_val22);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.my_enum_string_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->my_enum_struct_map.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _ktype25;
            ::apache::thrift::protocol::TType _vtype26;
            xfer += iprot->readMapBegin(_ktype25, _vtype26, _size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              MyEnum::type _key29;
              int32_t ecast31;
              xfer += iprot->readI32(ecast31);
              _key29 = (MyEnum::type)ecast31;
              MiniStruct& _val30 = this->my_enum_struct_map[_key29];
              xfer += _val30.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.my_enum_struct_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->my_enum_stringlist_map.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _ktype33;
            ::apache::thrift::protocol::TType _vtype34;
            xfer += iprot->readMapBegin(_ktype33, _vtype34, _size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              MyEnum::type _key37;
              int32_t ecast39;
              xfer += iprot->readI32(ecast39);
              _key37 = (MyEnum::type)ecast39;
              std::vector<std::string> & _val38 = this->my_enum_stringlist_map[_key37];
              {
                _val38.clear();
                uint32_t _size40;
                ::apache::thrift::protocol::TType _etype43;
                xfer += iprot->readListBegin(_etype43, _size40);
                _val38.resize(_size40);
                uint32_t _i44;
                for (_i44 = 0; _i44 < _size40; ++_i44)
                {
                  xfer += iprot->readString(_val38[_i44]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.my_enum_stringlist_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->my_enum_structlist_map.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _ktype46;
            ::apache::thrift::protocol::TType _vtype47;
            xfer += iprot->readMapBegin(_ktype46, _vtype47, _size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              MyEnum::type _key50;
              int32_t ecast52;
              xfer += iprot->readI32(ecast52);
              _key50 = (MyEnum::type)ecast52;
              std::vector<MiniStruct> & _val51 = this->my_enum_structlist_map[_key50];
              {
                _val51.clear();
                uint32_t _size53;
                ::apache::thrift::protocol::TType _etype56;
                xfer += iprot->readListBegin(_etype56, _size53);
                _val51.resize(_size53);
                uint32_t _i57;
                for (_i57 = 0; _i57 < _size53; ++_i57)
                {
                  xfer += _val51[_i57].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.my_enum_structlist_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->my_stringlist.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->my_stringlist.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += iprot->readString(this->my_stringlist[_i62]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.my_stringlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->my_structlist.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readListBegin(_etype66, _size63);
            this->my_structlist.resize(_size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              xfer += this->my_structlist[_i67].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.my_structlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->my_enumlist.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _etype71;
            xfer += iprot->readListBegin(_etype71, _size68);
            this->my_enumlist.resize(_size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              int32_t ecast73;
              xfer += iprot->readI32(ecast73);
              this->my_enumlist[_i72] = (MyEnum::type)ecast73;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.my_enumlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->my_stringset.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readSetBegin(_etype77, _size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              std::string _elem79;
              xfer += iprot->readString(_elem79);
              this->my_stringset.insert(_elem79);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.my_stringset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->my_enumset.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readSetBegin(_etype83, _size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              MyEnum::type _elem85;
              int32_t ecast86;
              xfer += iprot->readI32(ecast86);
              _elem85 = (MyEnum::type)ecast86;
              this->my_enumset.insert(_elem85);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.my_enumset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->my_structset.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readSetBegin(_etype90, _size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              MiniStruct _elem92;
              xfer += _elem92.read(iprot);
              this->my_structset.insert(_elem92);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.my_structset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MegaStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MegaStruct");

  if (this->__isset.my_bool) {
    xfer += oprot->writeFieldBegin("my_bool", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->my_bool);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_byte) {
    xfer += oprot->writeFieldBegin("my_byte", ::apache::thrift::protocol::T_BYTE, 2);
    xfer += oprot->writeByte(this->my_byte);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_16bit_int) {
    xfer += oprot->writeFieldBegin("my_16bit_int", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->my_16bit_int);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_32bit_int) {
    xfer += oprot->writeFieldBegin("my_32bit_int", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->my_32bit_int);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_64bit_int) {
    xfer += oprot->writeFieldBegin("my_64bit_int", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->my_64bit_int);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_double) {
    xfer += oprot->writeFieldBegin("my_double", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->my_double);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_string) {
    xfer += oprot->writeFieldBegin("my_string", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->my_string);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_binary) {
    xfer += oprot->writeFieldBegin("my_binary", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeBinary(this->my_binary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_string_string_map) {
    xfer += oprot->writeFieldBegin("my_string_string_map", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->my_string_string_map.size()));
      std::map<std::string, std::string> ::const_iterator _iter93;
      for (_iter93 = this->my_string_string_map.begin(); _iter93 != this->my_string_string_map.end(); ++_iter93)
      {
        xfer += oprot->writeString(_iter93->first);
        xfer += oprot->writeString(_iter93->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_string_enum_map) {
    xfer += oprot->writeFieldBegin("my_string_enum_map", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->my_string_enum_map.size()));
      std::map<std::string, MyEnum::type> ::const_iterator _iter94;
      for (_iter94 = this->my_string_enum_map.begin(); _iter94 != this->my_string_enum_map.end(); ++_iter94)
      {
        xfer += oprot->writeString(_iter94->first);
        xfer += oprot->writeI32((int32_t)_iter94->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_enum_string_map) {
    xfer += oprot->writeFieldBegin("my_enum_string_map", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->my_enum_string_map.size()));
      std::map<MyEnum::type, std::string> ::const_iterator _iter95;
      for (_iter95 = this->my_enum_string_map.begin(); _iter95 != this->my_enum_string_map.end(); ++_iter95)
      {
        xfer += oprot->writeI32((int32_t)_iter95->first);
        xfer += oprot->writeString(_iter95->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_enum_struct_map) {
    xfer += oprot->writeFieldBegin("my_enum_struct_map", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->my_enum_struct_map.size()));
      std::map<MyEnum::type, MiniStruct> ::const_iterator _iter96;
      for (_iter96 = this->my_enum_struct_map.begin(); _iter96 != this->my_enum_struct_map.end(); ++_iter96)
      {
        xfer += oprot->writeI32((int32_t)_iter96->first);
        xfer += _iter96->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_enum_stringlist_map) {
    xfer += oprot->writeFieldBegin("my_enum_stringlist_map", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->my_enum_stringlist_map.size()));
      std::map<MyEnum::type, std::vector<std::string> > ::const_iterator _iter97;
      for (_iter97 = this->my_enum_stringlist_map.begin(); _iter97 != this->my_enum_stringlist_map.end(); ++_iter97)
      {
        xfer += oprot->writeI32((int32_t)_iter97->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter97->second.size()));
          std::vector<std::string> ::const_iterator _iter98;
          for (_iter98 = _iter97->second.begin(); _iter98 != _iter97->second.end(); ++_iter98)
          {
            xfer += oprot->writeString((*_iter98));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_enum_structlist_map) {
    xfer += oprot->writeFieldBegin("my_enum_structlist_map", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->my_enum_structlist_map.size()));
      std::map<MyEnum::type, std::vector<MiniStruct> > ::const_iterator _iter99;
      for (_iter99 = this->my_enum_structlist_map.begin(); _iter99 != this->my_enum_structlist_map.end(); ++_iter99)
      {
        xfer += oprot->writeI32((int32_t)_iter99->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter99->second.size()));
          std::vector<MiniStruct> ::const_iterator _iter100;
          for (_iter100 = _iter99->second.begin(); _iter100 != _iter99->second.end(); ++_iter100)
          {
            xfer += (*_iter100).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_stringlist) {
    xfer += oprot->writeFieldBegin("my_stringlist", ::apache::thrift::protocol::T_LIST, 15);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->my_stringlist.size()));
      std::vector<std::string> ::const_iterator _iter101;
      for (_iter101 = this->my_stringlist.begin(); _iter101 != this->my_stringlist.end(); ++_iter101)
      {
        xfer += oprot->writeString((*_iter101));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_structlist) {
    xfer += oprot->writeFieldBegin("my_structlist", ::apache::thrift::protocol::T_LIST, 16);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->my_structlist.size()));
      std::vector<MiniStruct> ::const_iterator _iter102;
      for (_iter102 = this->my_structlist.begin(); _iter102 != this->my_structlist.end(); ++_iter102)
      {
        xfer += (*_iter102).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_enumlist) {
    xfer += oprot->writeFieldBegin("my_enumlist", ::apache::thrift::protocol::T_LIST, 17);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->my_enumlist.size()));
      std::vector<MyEnum::type> ::const_iterator _iter103;
      for (_iter103 = this->my_enumlist.begin(); _iter103 != this->my_enumlist.end(); ++_iter103)
      {
        xfer += oprot->writeI32((int32_t)(*_iter103));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_stringset) {
    xfer += oprot->writeFieldBegin("my_stringset", ::apache::thrift::protocol::T_SET, 18);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->my_stringset.size()));
      std::set<std::string> ::const_iterator _iter104;
      for (_iter104 = this->my_stringset.begin(); _iter104 != this->my_stringset.end(); ++_iter104)
      {
        xfer += oprot->writeString((*_iter104));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_enumset) {
    xfer += oprot->writeFieldBegin("my_enumset", ::apache::thrift::protocol::T_SET, 19);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->my_enumset.size()));
      std::set<MyEnum::type> ::const_iterator _iter105;
      for (_iter105 = this->my_enumset.begin(); _iter105 != this->my_enumset.end(); ++_iter105)
      {
        xfer += oprot->writeI32((int32_t)(*_iter105));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.my_structset) {
    xfer += oprot->writeFieldBegin("my_structset", ::apache::thrift::protocol::T_SET, 20);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->my_structset.size()));
      std::set<MiniStruct> ::const_iterator _iter106;
      for (_iter106 = this->my_structset.begin(); _iter106 != this->my_structset.end(); ++_iter106)
      {
        xfer += (*_iter106).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MegaStruct &a, MegaStruct &b) {
  using ::std::swap;
  swap(a.my_bool, b.my_bool);
  swap(a.my_byte, b.my_byte);
  swap(a.my_16bit_int, b.my_16bit_int);
  swap(a.my_32bit_int, b.my_32bit_int);
  swap(a.my_64bit_int, b.my_64bit_int);
  swap(a.my_double, b.my_double);
  swap(a.my_string, b.my_string);
  swap(a.my_binary, b.my_binary);
  swap(a.my_string_string_map, b.my_string_string_map);
  swap(a.my_string_enum_map, b.my_string_enum_map);
  swap(a.my_enum_string_map, b.my_enum_string_map);
  swap(a.my_enum_struct_map, b.my_enum_struct_map);
  swap(a.my_enum_stringlist_map, b.my_enum_stringlist_map);
  swap(a.my_enum_structlist_map, b.my_enum_structlist_map);
  swap(a.my_stringlist, b.my_stringlist);
  swap(a.my_structlist, b.my_structlist);
  swap(a.my_enumlist, b.my_enumlist);
  swap(a.my_stringset, b.my_stringset);
  swap(a.my_enumset, b.my_enumset);
  swap(a.my_structset, b.my_structset);
  swap(a.__isset, b.__isset);
}


