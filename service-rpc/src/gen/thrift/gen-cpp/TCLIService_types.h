/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef TCLIService_TYPES_H
#define TCLIService_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace apache { namespace hive { namespace service { namespace rpc { namespace thrift {

struct TProtocolVersion {
  enum type {
    HIVE_CLI_SERVICE_PROTOCOL_V1 = 0,
    HIVE_CLI_SERVICE_PROTOCOL_V2 = 1,
    HIVE_CLI_SERVICE_PROTOCOL_V3 = 2,
    HIVE_CLI_SERVICE_PROTOCOL_V4 = 3,
    HIVE_CLI_SERVICE_PROTOCOL_V5 = 4,
    HIVE_CLI_SERVICE_PROTOCOL_V6 = 5,
    HIVE_CLI_SERVICE_PROTOCOL_V7 = 6,
    HIVE_CLI_SERVICE_PROTOCOL_V8 = 7,
    HIVE_CLI_SERVICE_PROTOCOL_V9 = 8,
    HIVE_CLI_SERVICE_PROTOCOL_V10 = 9,
    HIVE_CLI_SERVICE_PROTOCOL_V11 = 10
  };
};

extern const std::map<int, const char*> _TProtocolVersion_VALUES_TO_NAMES;

struct TTypeId {
  enum type {
    BOOLEAN_TYPE = 0,
    TINYINT_TYPE = 1,
    SMALLINT_TYPE = 2,
    INT_TYPE = 3,
    BIGINT_TYPE = 4,
    FLOAT_TYPE = 5,
    DOUBLE_TYPE = 6,
    STRING_TYPE = 7,
    TIMESTAMP_TYPE = 8,
    BINARY_TYPE = 9,
    ARRAY_TYPE = 10,
    MAP_TYPE = 11,
    STRUCT_TYPE = 12,
    UNION_TYPE = 13,
    USER_DEFINED_TYPE = 14,
    DECIMAL_TYPE = 15,
    NULL_TYPE = 16,
    DATE_TYPE = 17,
    VARCHAR_TYPE = 18,
    CHAR_TYPE = 19,
    INTERVAL_YEAR_MONTH_TYPE = 20,
    INTERVAL_DAY_TIME_TYPE = 21,
    TIMESTAMPLOCALTZ_TYPE = 22
  };
};

extern const std::map<int, const char*> _TTypeId_VALUES_TO_NAMES;

struct TStatusCode {
  enum type {
    SUCCESS_STATUS = 0,
    SUCCESS_WITH_INFO_STATUS = 1,
    STILL_EXECUTING_STATUS = 2,
    ERROR_STATUS = 3,
    INVALID_HANDLE_STATUS = 4
  };
};

extern const std::map<int, const char*> _TStatusCode_VALUES_TO_NAMES;

struct TOperationState {
  enum type {
    INITIALIZED_STATE = 0,
    RUNNING_STATE = 1,
    FINISHED_STATE = 2,
    CANCELED_STATE = 3,
    CLOSED_STATE = 4,
    ERROR_STATE = 5,
    UKNOWN_STATE = 6,
    PENDING_STATE = 7,
    TIMEDOUT_STATE = 8
  };
};

extern const std::map<int, const char*> _TOperationState_VALUES_TO_NAMES;

struct TOperationType {
  enum type {
    EXECUTE_STATEMENT = 0,
    GET_TYPE_INFO = 1,
    GET_CATALOGS = 2,
    GET_SCHEMAS = 3,
    GET_TABLES = 4,
    GET_TABLE_TYPES = 5,
    GET_COLUMNS = 6,
    GET_FUNCTIONS = 7,
    UNKNOWN = 8
  };
};

extern const std::map<int, const char*> _TOperationType_VALUES_TO_NAMES;

struct TGetInfoType {
  enum type {
    CLI_MAX_DRIVER_CONNECTIONS = 0,
    CLI_MAX_CONCURRENT_ACTIVITIES = 1,
    CLI_DATA_SOURCE_NAME = 2,
    CLI_FETCH_DIRECTION = 8,
    CLI_SERVER_NAME = 13,
    CLI_SEARCH_PATTERN_ESCAPE = 14,
    CLI_DBMS_NAME = 17,
    CLI_DBMS_VER = 18,
    CLI_ACCESSIBLE_TABLES = 19,
    CLI_ACCESSIBLE_PROCEDURES = 20,
    CLI_CURSOR_COMMIT_BEHAVIOR = 23,
    CLI_DATA_SOURCE_READ_ONLY = 25,
    CLI_DEFAULT_TXN_ISOLATION = 26,
    CLI_IDENTIFIER_CASE = 28,
    CLI_IDENTIFIER_QUOTE_CHAR = 29,
    CLI_MAX_COLUMN_NAME_LEN = 30,
    CLI_MAX_CURSOR_NAME_LEN = 31,
    CLI_MAX_SCHEMA_NAME_LEN = 32,
    CLI_MAX_CATALOG_NAME_LEN = 34,
    CLI_MAX_TABLE_NAME_LEN = 35,
    CLI_SCROLL_CONCURRENCY = 43,
    CLI_TXN_CAPABLE = 46,
    CLI_USER_NAME = 47,
    CLI_TXN_ISOLATION_OPTION = 72,
    CLI_INTEGRITY = 73,
    CLI_GETDATA_EXTENSIONS = 81,
    CLI_NULL_COLLATION = 85,
    CLI_ALTER_TABLE = 86,
    CLI_ORDER_BY_COLUMNS_IN_SELECT = 90,
    CLI_SPECIAL_CHARACTERS = 94,
    CLI_MAX_COLUMNS_IN_GROUP_BY = 97,
    CLI_MAX_COLUMNS_IN_INDEX = 98,
    CLI_MAX_COLUMNS_IN_ORDER_BY = 99,
    CLI_MAX_COLUMNS_IN_SELECT = 100,
    CLI_MAX_COLUMNS_IN_TABLE = 101,
    CLI_MAX_INDEX_SIZE = 102,
    CLI_MAX_ROW_SIZE = 104,
    CLI_MAX_STATEMENT_LEN = 105,
    CLI_MAX_TABLES_IN_SELECT = 106,
    CLI_MAX_USER_NAME_LEN = 107,
    CLI_OJ_CAPABILITIES = 115,
    CLI_XOPEN_CLI_YEAR = 10000,
    CLI_CURSOR_SENSITIVITY = 10001,
    CLI_DESCRIBE_PARAMETER = 10002,
    CLI_CATALOG_NAME = 10003,
    CLI_COLLATION_SEQ = 10004,
    CLI_MAX_IDENTIFIER_LEN = 10005
  };
};

extern const std::map<int, const char*> _TGetInfoType_VALUES_TO_NAMES;

struct TFetchOrientation {
  enum type {
    FETCH_NEXT = 0,
    FETCH_PRIOR = 1,
    FETCH_RELATIVE = 2,
    FETCH_ABSOLUTE = 3,
    FETCH_FIRST = 4,
    FETCH_LAST = 5
  };
};

extern const std::map<int, const char*> _TFetchOrientation_VALUES_TO_NAMES;

struct TJobExecutionStatus {
  enum type {
    IN_PROGRESS = 0,
    COMPLETE = 1,
    NOT_AVAILABLE = 2
  };
};

extern const std::map<int, const char*> _TJobExecutionStatus_VALUES_TO_NAMES;

typedef int32_t TTypeEntryPtr;

typedef std::string TIdentifier;

typedef std::string TPattern;

typedef std::string TPatternOrIdentifier;

class TTypeQualifierValue;

class TTypeQualifiers;

class TPrimitiveTypeEntry;

class TArrayTypeEntry;

class TMapTypeEntry;

class TStructTypeEntry;

class TUnionTypeEntry;

class TUserDefinedTypeEntry;

class TTypeEntry;

class TTypeDesc;

class TColumnDesc;

class TTableSchema;

class TBoolValue;

class TByteValue;

class TI16Value;

class TI32Value;

class TI64Value;

class TDoubleValue;

class TStringValue;

class TColumnValue;

class TRow;

class TBoolColumn;

class TByteColumn;

class TI16Column;

class TI32Column;

class TI64Column;

class TDoubleColumn;

class TStringColumn;

class TBinaryColumn;

class TColumn;

class TRowSet;

class TStatus;

class THandleIdentifier;

class TSessionHandle;

class TOperationHandle;

class TOpenSessionReq;

class TOpenSessionResp;

class TCloseSessionReq;

class TCloseSessionResp;

class TGetInfoValue;

class TGetInfoReq;

class TGetInfoResp;

class TExecuteStatementReq;

class TExecuteStatementResp;

class TGetTypeInfoReq;

class TGetTypeInfoResp;

class TGetCatalogsReq;

class TGetCatalogsResp;

class TGetSchemasReq;

class TGetSchemasResp;

class TGetTablesReq;

class TGetTablesResp;

class TGetTableTypesReq;

class TGetTableTypesResp;

class TGetColumnsReq;

class TGetColumnsResp;

class TGetFunctionsReq;

class TGetFunctionsResp;

class TGetPrimaryKeysReq;

class TGetPrimaryKeysResp;

class TGetCrossReferenceReq;

class TGetCrossReferenceResp;

class TGetOperationStatusReq;

class TGetOperationStatusResp;

class TCancelOperationReq;

class TCancelOperationResp;

class TCloseOperationReq;

class TCloseOperationResp;

class TGetResultSetMetadataReq;

class TGetResultSetMetadataResp;

class TFetchResultsReq;

class TFetchResultsResp;

class TGetDelegationTokenReq;

class TGetDelegationTokenResp;

class TCancelDelegationTokenReq;

class TCancelDelegationTokenResp;

class TRenewDelegationTokenReq;

class TRenewDelegationTokenResp;

class TProgressUpdateResp;

typedef struct _TTypeQualifierValue__isset {
  _TTypeQualifierValue__isset() : i32Value(false), stringValue(false) {}
  bool i32Value :1;
  bool stringValue :1;
} _TTypeQualifierValue__isset;

class TTypeQualifierValue {
 public:

  TTypeQualifierValue(const TTypeQualifierValue&);
  TTypeQualifierValue& operator=(const TTypeQualifierValue&);
  TTypeQualifierValue() : i32Value(0), stringValue() {
  }

  virtual ~TTypeQualifierValue() throw();
  int32_t i32Value;
  std::string stringValue;

  _TTypeQualifierValue__isset __isset;

  void __set_i32Value(const int32_t val);

  void __set_stringValue(const std::string& val);

  bool operator == (const TTypeQualifierValue & rhs) const
  {
    if (__isset.i32Value != rhs.__isset.i32Value)
      return false;
    else if (__isset.i32Value && !(i32Value == rhs.i32Value))
      return false;
    if (__isset.stringValue != rhs.__isset.stringValue)
      return false;
    else if (__isset.stringValue && !(stringValue == rhs.stringValue))
      return false;
    return true;
  }
  bool operator != (const TTypeQualifierValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeQualifierValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTypeQualifierValue &a, TTypeQualifierValue &b);

inline std::ostream& operator<<(std::ostream& out, const TTypeQualifierValue& obj)
{
  obj.printTo(out);
  return out;
}


class TTypeQualifiers {
 public:

  TTypeQualifiers(const TTypeQualifiers&);
  TTypeQualifiers& operator=(const TTypeQualifiers&);
  TTypeQualifiers() {
  }

  virtual ~TTypeQualifiers() throw();
  std::map<std::string, TTypeQualifierValue>  qualifiers;

  void __set_qualifiers(const std::map<std::string, TTypeQualifierValue> & val);

  bool operator == (const TTypeQualifiers & rhs) const
  {
    if (!(qualifiers == rhs.qualifiers))
      return false;
    return true;
  }
  bool operator != (const TTypeQualifiers &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeQualifiers & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTypeQualifiers &a, TTypeQualifiers &b);

inline std::ostream& operator<<(std::ostream& out, const TTypeQualifiers& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TPrimitiveTypeEntry__isset {
  _TPrimitiveTypeEntry__isset() : typeQualifiers(false) {}
  bool typeQualifiers :1;
} _TPrimitiveTypeEntry__isset;

class TPrimitiveTypeEntry {
 public:

  TPrimitiveTypeEntry(const TPrimitiveTypeEntry&);
  TPrimitiveTypeEntry& operator=(const TPrimitiveTypeEntry&);
  TPrimitiveTypeEntry() : type((TTypeId::type)0) {
  }

  virtual ~TPrimitiveTypeEntry() throw();
  TTypeId::type type;
  TTypeQualifiers typeQualifiers;

  _TPrimitiveTypeEntry__isset __isset;

  void __set_type(const TTypeId::type val);

  void __set_typeQualifiers(const TTypeQualifiers& val);

  bool operator == (const TPrimitiveTypeEntry & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.typeQualifiers != rhs.__isset.typeQualifiers)
      return false;
    else if (__isset.typeQualifiers && !(typeQualifiers == rhs.typeQualifiers))
      return false;
    return true;
  }
  bool operator != (const TPrimitiveTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPrimitiveTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPrimitiveTypeEntry &a, TPrimitiveTypeEntry &b);

inline std::ostream& operator<<(std::ostream& out, const TPrimitiveTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


class TArrayTypeEntry {
 public:

  TArrayTypeEntry(const TArrayTypeEntry&);
  TArrayTypeEntry& operator=(const TArrayTypeEntry&);
  TArrayTypeEntry() : objectTypePtr(0) {
  }

  virtual ~TArrayTypeEntry() throw();
  TTypeEntryPtr objectTypePtr;

  void __set_objectTypePtr(const TTypeEntryPtr val);

  bool operator == (const TArrayTypeEntry & rhs) const
  {
    if (!(objectTypePtr == rhs.objectTypePtr))
      return false;
    return true;
  }
  bool operator != (const TArrayTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TArrayTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TArrayTypeEntry &a, TArrayTypeEntry &b);

inline std::ostream& operator<<(std::ostream& out, const TArrayTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


class TMapTypeEntry {
 public:

  TMapTypeEntry(const TMapTypeEntry&);
  TMapTypeEntry& operator=(const TMapTypeEntry&);
  TMapTypeEntry() : keyTypePtr(0), valueTypePtr(0) {
  }

  virtual ~TMapTypeEntry() throw();
  TTypeEntryPtr keyTypePtr;
  TTypeEntryPtr valueTypePtr;

  void __set_keyTypePtr(const TTypeEntryPtr val);

  void __set_valueTypePtr(const TTypeEntryPtr val);

  bool operator == (const TMapTypeEntry & rhs) const
  {
    if (!(keyTypePtr == rhs.keyTypePtr))
      return false;
    if (!(valueTypePtr == rhs.valueTypePtr))
      return false;
    return true;
  }
  bool operator != (const TMapTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMapTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMapTypeEntry &a, TMapTypeEntry &b);

inline std::ostream& operator<<(std::ostream& out, const TMapTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


class TStructTypeEntry {
 public:

  TStructTypeEntry(const TStructTypeEntry&);
  TStructTypeEntry& operator=(const TStructTypeEntry&);
  TStructTypeEntry() {
  }

  virtual ~TStructTypeEntry() throw();
  std::map<std::string, TTypeEntryPtr>  nameToTypePtr;

  void __set_nameToTypePtr(const std::map<std::string, TTypeEntryPtr> & val);

  bool operator == (const TStructTypeEntry & rhs) const
  {
    if (!(nameToTypePtr == rhs.nameToTypePtr))
      return false;
    return true;
  }
  bool operator != (const TStructTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStructTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStructTypeEntry &a, TStructTypeEntry &b);

inline std::ostream& operator<<(std::ostream& out, const TStructTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


class TUnionTypeEntry {
 public:

  TUnionTypeEntry(const TUnionTypeEntry&);
  TUnionTypeEntry& operator=(const TUnionTypeEntry&);
  TUnionTypeEntry() {
  }

  virtual ~TUnionTypeEntry() throw();
  std::map<std::string, TTypeEntryPtr>  nameToTypePtr;

  void __set_nameToTypePtr(const std::map<std::string, TTypeEntryPtr> & val);

  bool operator == (const TUnionTypeEntry & rhs) const
  {
    if (!(nameToTypePtr == rhs.nameToTypePtr))
      return false;
    return true;
  }
  bool operator != (const TUnionTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUnionTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUnionTypeEntry &a, TUnionTypeEntry &b);

inline std::ostream& operator<<(std::ostream& out, const TUnionTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


class TUserDefinedTypeEntry {
 public:

  TUserDefinedTypeEntry(const TUserDefinedTypeEntry&);
  TUserDefinedTypeEntry& operator=(const TUserDefinedTypeEntry&);
  TUserDefinedTypeEntry() : typeClassName() {
  }

  virtual ~TUserDefinedTypeEntry() throw();
  std::string typeClassName;

  void __set_typeClassName(const std::string& val);

  bool operator == (const TUserDefinedTypeEntry & rhs) const
  {
    if (!(typeClassName == rhs.typeClassName))
      return false;
    return true;
  }
  bool operator != (const TUserDefinedTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUserDefinedTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUserDefinedTypeEntry &a, TUserDefinedTypeEntry &b);

inline std::ostream& operator<<(std::ostream& out, const TUserDefinedTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TTypeEntry__isset {
  _TTypeEntry__isset() : primitiveEntry(false), arrayEntry(false), mapEntry(false), structEntry(false), unionEntry(false), userDefinedTypeEntry(false) {}
  bool primitiveEntry :1;
  bool arrayEntry :1;
  bool mapEntry :1;
  bool structEntry :1;
  bool unionEntry :1;
  bool userDefinedTypeEntry :1;
} _TTypeEntry__isset;

class TTypeEntry {
 public:

  TTypeEntry(const TTypeEntry&);
  TTypeEntry& operator=(const TTypeEntry&);
  TTypeEntry() {
  }

  virtual ~TTypeEntry() throw();
  TPrimitiveTypeEntry primitiveEntry;
  TArrayTypeEntry arrayEntry;
  TMapTypeEntry mapEntry;
  TStructTypeEntry structEntry;
  TUnionTypeEntry unionEntry;
  TUserDefinedTypeEntry userDefinedTypeEntry;

  _TTypeEntry__isset __isset;

  void __set_primitiveEntry(const TPrimitiveTypeEntry& val);

  void __set_arrayEntry(const TArrayTypeEntry& val);

  void __set_mapEntry(const TMapTypeEntry& val);

  void __set_structEntry(const TStructTypeEntry& val);

  void __set_unionEntry(const TUnionTypeEntry& val);

  void __set_userDefinedTypeEntry(const TUserDefinedTypeEntry& val);

  bool operator == (const TTypeEntry & rhs) const
  {
    if (!(primitiveEntry == rhs.primitiveEntry))
      return false;
    if (!(arrayEntry == rhs.arrayEntry))
      return false;
    if (!(mapEntry == rhs.mapEntry))
      return false;
    if (!(structEntry == rhs.structEntry))
      return false;
    if (!(unionEntry == rhs.unionEntry))
      return false;
    if (!(userDefinedTypeEntry == rhs.userDefinedTypeEntry))
      return false;
    return true;
  }
  bool operator != (const TTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTypeEntry &a, TTypeEntry &b);

inline std::ostream& operator<<(std::ostream& out, const TTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


class TTypeDesc {
 public:

  TTypeDesc(const TTypeDesc&);
  TTypeDesc& operator=(const TTypeDesc&);
  TTypeDesc() {
  }

  virtual ~TTypeDesc() throw();
  std::vector<TTypeEntry>  types;

  void __set_types(const std::vector<TTypeEntry> & val);

  bool operator == (const TTypeDesc & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const TTypeDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTypeDesc &a, TTypeDesc &b);

inline std::ostream& operator<<(std::ostream& out, const TTypeDesc& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TColumnDesc__isset {
  _TColumnDesc__isset() : comment(false) {}
  bool comment :1;
} _TColumnDesc__isset;

class TColumnDesc {
 public:

  TColumnDesc(const TColumnDesc&);
  TColumnDesc& operator=(const TColumnDesc&);
  TColumnDesc() : columnName(), position(0), comment() {
  }

  virtual ~TColumnDesc() throw();
  std::string columnName;
  TTypeDesc typeDesc;
  int32_t position;
  std::string comment;

  _TColumnDesc__isset __isset;

  void __set_columnName(const std::string& val);

  void __set_typeDesc(const TTypeDesc& val);

  void __set_position(const int32_t val);

  void __set_comment(const std::string& val);

  bool operator == (const TColumnDesc & rhs) const
  {
    if (!(columnName == rhs.columnName))
      return false;
    if (!(typeDesc == rhs.typeDesc))
      return false;
    if (!(position == rhs.position))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TColumnDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumnDesc &a, TColumnDesc &b);

inline std::ostream& operator<<(std::ostream& out, const TColumnDesc& obj)
{
  obj.printTo(out);
  return out;
}


class TTableSchema {
 public:

  TTableSchema(const TTableSchema&);
  TTableSchema& operator=(const TTableSchema&);
  TTableSchema() {
  }

  virtual ~TTableSchema() throw();
  std::vector<TColumnDesc>  columns;

  void __set_columns(const std::vector<TColumnDesc> & val);

  bool operator == (const TTableSchema & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const TTableSchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableSchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableSchema &a, TTableSchema &b);

inline std::ostream& operator<<(std::ostream& out, const TTableSchema& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TBoolValue__isset {
  _TBoolValue__isset() : value(false) {}
  bool value :1;
} _TBoolValue__isset;

class TBoolValue {
 public:

  TBoolValue(const TBoolValue&);
  TBoolValue& operator=(const TBoolValue&);
  TBoolValue() : value(0) {
  }

  virtual ~TBoolValue() throw();
  bool value;

  _TBoolValue__isset __isset;

  void __set_value(const bool val);

  bool operator == (const TBoolValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TBoolValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBoolValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBoolValue &a, TBoolValue &b);

inline std::ostream& operator<<(std::ostream& out, const TBoolValue& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TByteValue__isset {
  _TByteValue__isset() : value(false) {}
  bool value :1;
} _TByteValue__isset;

class TByteValue {
 public:

  TByteValue(const TByteValue&);
  TByteValue& operator=(const TByteValue&);
  TByteValue() : value(0) {
  }

  virtual ~TByteValue() throw();
  int8_t value;

  _TByteValue__isset __isset;

  void __set_value(const int8_t val);

  bool operator == (const TByteValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TByteValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TByteValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TByteValue &a, TByteValue &b);

inline std::ostream& operator<<(std::ostream& out, const TByteValue& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TI16Value__isset {
  _TI16Value__isset() : value(false) {}
  bool value :1;
} _TI16Value__isset;

class TI16Value {
 public:

  TI16Value(const TI16Value&);
  TI16Value& operator=(const TI16Value&);
  TI16Value() : value(0) {
  }

  virtual ~TI16Value() throw();
  int16_t value;

  _TI16Value__isset __isset;

  void __set_value(const int16_t val);

  bool operator == (const TI16Value & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TI16Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI16Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TI16Value &a, TI16Value &b);

inline std::ostream& operator<<(std::ostream& out, const TI16Value& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TI32Value__isset {
  _TI32Value__isset() : value(false) {}
  bool value :1;
} _TI32Value__isset;

class TI32Value {
 public:

  TI32Value(const TI32Value&);
  TI32Value& operator=(const TI32Value&);
  TI32Value() : value(0) {
  }

  virtual ~TI32Value() throw();
  int32_t value;

  _TI32Value__isset __isset;

  void __set_value(const int32_t val);

  bool operator == (const TI32Value & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TI32Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI32Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TI32Value &a, TI32Value &b);

inline std::ostream& operator<<(std::ostream& out, const TI32Value& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TI64Value__isset {
  _TI64Value__isset() : value(false) {}
  bool value :1;
} _TI64Value__isset;

class TI64Value {
 public:

  TI64Value(const TI64Value&);
  TI64Value& operator=(const TI64Value&);
  TI64Value() : value(0) {
  }

  virtual ~TI64Value() throw();
  int64_t value;

  _TI64Value__isset __isset;

  void __set_value(const int64_t val);

  bool operator == (const TI64Value & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TI64Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI64Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TI64Value &a, TI64Value &b);

inline std::ostream& operator<<(std::ostream& out, const TI64Value& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TDoubleValue__isset {
  _TDoubleValue__isset() : value(false) {}
  bool value :1;
} _TDoubleValue__isset;

class TDoubleValue {
 public:

  TDoubleValue(const TDoubleValue&);
  TDoubleValue& operator=(const TDoubleValue&);
  TDoubleValue() : value(0) {
  }

  virtual ~TDoubleValue() throw();
  double value;

  _TDoubleValue__isset __isset;

  void __set_value(const double val);

  bool operator == (const TDoubleValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TDoubleValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDoubleValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDoubleValue &a, TDoubleValue &b);

inline std::ostream& operator<<(std::ostream& out, const TDoubleValue& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TStringValue__isset {
  _TStringValue__isset() : value(false) {}
  bool value :1;
} _TStringValue__isset;

class TStringValue {
 public:

  TStringValue(const TStringValue&);
  TStringValue& operator=(const TStringValue&);
  TStringValue() : value() {
  }

  virtual ~TStringValue() throw();
  std::string value;

  _TStringValue__isset __isset;

  void __set_value(const std::string& val);

  bool operator == (const TStringValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TStringValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStringValue &a, TStringValue &b);

inline std::ostream& operator<<(std::ostream& out, const TStringValue& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TColumnValue__isset {
  _TColumnValue__isset() : boolVal(false), byteVal(false), i16Val(false), i32Val(false), i64Val(false), doubleVal(false), stringVal(false) {}
  bool boolVal :1;
  bool byteVal :1;
  bool i16Val :1;
  bool i32Val :1;
  bool i64Val :1;
  bool doubleVal :1;
  bool stringVal :1;
} _TColumnValue__isset;

class TColumnValue {
 public:

  TColumnValue(const TColumnValue&);
  TColumnValue& operator=(const TColumnValue&);
  TColumnValue() {
  }

  virtual ~TColumnValue() throw();
  TBoolValue boolVal;
  TByteValue byteVal;
  TI16Value i16Val;
  TI32Value i32Val;
  TI64Value i64Val;
  TDoubleValue doubleVal;
  TStringValue stringVal;

  _TColumnValue__isset __isset;

  void __set_boolVal(const TBoolValue& val);

  void __set_byteVal(const TByteValue& val);

  void __set_i16Val(const TI16Value& val);

  void __set_i32Val(const TI32Value& val);

  void __set_i64Val(const TI64Value& val);

  void __set_doubleVal(const TDoubleValue& val);

  void __set_stringVal(const TStringValue& val);

  bool operator == (const TColumnValue & rhs) const
  {
    if (!(boolVal == rhs.boolVal))
      return false;
    if (!(byteVal == rhs.byteVal))
      return false;
    if (!(i16Val == rhs.i16Val))
      return false;
    if (!(i32Val == rhs.i32Val))
      return false;
    if (!(i64Val == rhs.i64Val))
      return false;
    if (!(doubleVal == rhs.doubleVal))
      return false;
    if (!(stringVal == rhs.stringVal))
      return false;
    return true;
  }
  bool operator != (const TColumnValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumnValue &a, TColumnValue &b);

inline std::ostream& operator<<(std::ostream& out, const TColumnValue& obj)
{
  obj.printTo(out);
  return out;
}


class TRow {
 public:

  TRow(const TRow&);
  TRow& operator=(const TRow&);
  TRow() {
  }

  virtual ~TRow() throw();
  std::vector<TColumnValue>  colVals;

  void __set_colVals(const std::vector<TColumnValue> & val);

  bool operator == (const TRow & rhs) const
  {
    if (!(colVals == rhs.colVals))
      return false;
    return true;
  }
  bool operator != (const TRow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRow &a, TRow &b);

inline std::ostream& operator<<(std::ostream& out, const TRow& obj)
{
  obj.printTo(out);
  return out;
}


class TBoolColumn {
 public:

  TBoolColumn(const TBoolColumn&);
  TBoolColumn& operator=(const TBoolColumn&);
  TBoolColumn() : nulls() {
  }

  virtual ~TBoolColumn() throw();
  std::vector<bool>  values;
  std::string nulls;

  void __set_values(const std::vector<bool> & val);

  void __set_nulls(const std::string& val);

  bool operator == (const TBoolColumn & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TBoolColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBoolColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBoolColumn &a, TBoolColumn &b);

inline std::ostream& operator<<(std::ostream& out, const TBoolColumn& obj)
{
  obj.printTo(out);
  return out;
}


class TByteColumn {
 public:

  TByteColumn(const TByteColumn&);
  TByteColumn& operator=(const TByteColumn&);
  TByteColumn() : nulls() {
  }

  virtual ~TByteColumn() throw();
  std::vector<int8_t>  values;
  std::string nulls;

  void __set_values(const std::vector<int8_t> & val);

  void __set_nulls(const std::string& val);

  bool operator == (const TByteColumn & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TByteColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TByteColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TByteColumn &a, TByteColumn &b);

inline std::ostream& operator<<(std::ostream& out, const TByteColumn& obj)
{
  obj.printTo(out);
  return out;
}


class TI16Column {
 public:

  TI16Column(const TI16Column&);
  TI16Column& operator=(const TI16Column&);
  TI16Column() : nulls() {
  }

  virtual ~TI16Column() throw();
  std::vector<int16_t>  values;
  std::string nulls;

  void __set_values(const std::vector<int16_t> & val);

  void __set_nulls(const std::string& val);

  bool operator == (const TI16Column & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TI16Column &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI16Column & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TI16Column &a, TI16Column &b);

inline std::ostream& operator<<(std::ostream& out, const TI16Column& obj)
{
  obj.printTo(out);
  return out;
}


class TI32Column {
 public:

  TI32Column(const TI32Column&);
  TI32Column& operator=(const TI32Column&);
  TI32Column() : nulls() {
  }

  virtual ~TI32Column() throw();
  std::vector<int32_t>  values;
  std::string nulls;

  void __set_values(const std::vector<int32_t> & val);

  void __set_nulls(const std::string& val);

  bool operator == (const TI32Column & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TI32Column &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI32Column & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TI32Column &a, TI32Column &b);

inline std::ostream& operator<<(std::ostream& out, const TI32Column& obj)
{
  obj.printTo(out);
  return out;
}


class TI64Column {
 public:

  TI64Column(const TI64Column&);
  TI64Column& operator=(const TI64Column&);
  TI64Column() : nulls() {
  }

  virtual ~TI64Column() throw();
  std::vector<int64_t>  values;
  std::string nulls;

  void __set_values(const std::vector<int64_t> & val);

  void __set_nulls(const std::string& val);

  bool operator == (const TI64Column & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TI64Column &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI64Column & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TI64Column &a, TI64Column &b);

inline std::ostream& operator<<(std::ostream& out, const TI64Column& obj)
{
  obj.printTo(out);
  return out;
}


class TDoubleColumn {
 public:

  TDoubleColumn(const TDoubleColumn&);
  TDoubleColumn& operator=(const TDoubleColumn&);
  TDoubleColumn() : nulls() {
  }

  virtual ~TDoubleColumn() throw();
  std::vector<double>  values;
  std::string nulls;

  void __set_values(const std::vector<double> & val);

  void __set_nulls(const std::string& val);

  bool operator == (const TDoubleColumn & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TDoubleColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDoubleColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDoubleColumn &a, TDoubleColumn &b);

inline std::ostream& operator<<(std::ostream& out, const TDoubleColumn& obj)
{
  obj.printTo(out);
  return out;
}


class TStringColumn {
 public:

  TStringColumn(const TStringColumn&);
  TStringColumn& operator=(const TStringColumn&);
  TStringColumn() : nulls() {
  }

  virtual ~TStringColumn() throw();
  std::vector<std::string>  values;
  std::string nulls;

  void __set_values(const std::vector<std::string> & val);

  void __set_nulls(const std::string& val);

  bool operator == (const TStringColumn & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TStringColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStringColumn &a, TStringColumn &b);

inline std::ostream& operator<<(std::ostream& out, const TStringColumn& obj)
{
  obj.printTo(out);
  return out;
}


class TBinaryColumn {
 public:

  TBinaryColumn(const TBinaryColumn&);
  TBinaryColumn& operator=(const TBinaryColumn&);
  TBinaryColumn() : nulls() {
  }

  virtual ~TBinaryColumn() throw();
  std::vector<std::string>  values;
  std::string nulls;

  void __set_values(const std::vector<std::string> & val);

  void __set_nulls(const std::string& val);

  bool operator == (const TBinaryColumn & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TBinaryColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBinaryColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBinaryColumn &a, TBinaryColumn &b);

inline std::ostream& operator<<(std::ostream& out, const TBinaryColumn& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TColumn__isset {
  _TColumn__isset() : boolVal(false), byteVal(false), i16Val(false), i32Val(false), i64Val(false), doubleVal(false), stringVal(false), binaryVal(false) {}
  bool boolVal :1;
  bool byteVal :1;
  bool i16Val :1;
  bool i32Val :1;
  bool i64Val :1;
  bool doubleVal :1;
  bool stringVal :1;
  bool binaryVal :1;
} _TColumn__isset;

class TColumn {
 public:

  TColumn(const TColumn&);
  TColumn& operator=(const TColumn&);
  TColumn() {
  }

  virtual ~TColumn() throw();
  TBoolColumn boolVal;
  TByteColumn byteVal;
  TI16Column i16Val;
  TI32Column i32Val;
  TI64Column i64Val;
  TDoubleColumn doubleVal;
  TStringColumn stringVal;
  TBinaryColumn binaryVal;

  _TColumn__isset __isset;

  void __set_boolVal(const TBoolColumn& val);

  void __set_byteVal(const TByteColumn& val);

  void __set_i16Val(const TI16Column& val);

  void __set_i32Val(const TI32Column& val);

  void __set_i64Val(const TI64Column& val);

  void __set_doubleVal(const TDoubleColumn& val);

  void __set_stringVal(const TStringColumn& val);

  void __set_binaryVal(const TBinaryColumn& val);

  bool operator == (const TColumn & rhs) const
  {
    if (!(boolVal == rhs.boolVal))
      return false;
    if (!(byteVal == rhs.byteVal))
      return false;
    if (!(i16Val == rhs.i16Val))
      return false;
    if (!(i32Val == rhs.i32Val))
      return false;
    if (!(i64Val == rhs.i64Val))
      return false;
    if (!(doubleVal == rhs.doubleVal))
      return false;
    if (!(stringVal == rhs.stringVal))
      return false;
    if (!(binaryVal == rhs.binaryVal))
      return false;
    return true;
  }
  bool operator != (const TColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumn &a, TColumn &b);

inline std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TRowSet__isset {
  _TRowSet__isset() : columns(false), binaryColumns(false), columnCount(false) {}
  bool columns :1;
  bool binaryColumns :1;
  bool columnCount :1;
} _TRowSet__isset;

class TRowSet {
 public:

  TRowSet(const TRowSet&);
  TRowSet& operator=(const TRowSet&);
  TRowSet() : startRowOffset(0), binaryColumns(), columnCount(0) {
  }

  virtual ~TRowSet() throw();
  int64_t startRowOffset;
  std::vector<TRow>  rows;
  std::vector<TColumn>  columns;
  std::string binaryColumns;
  int32_t columnCount;

  _TRowSet__isset __isset;

  void __set_startRowOffset(const int64_t val);

  void __set_rows(const std::vector<TRow> & val);

  void __set_columns(const std::vector<TColumn> & val);

  void __set_binaryColumns(const std::string& val);

  void __set_columnCount(const int32_t val);

  bool operator == (const TRowSet & rhs) const
  {
    if (!(startRowOffset == rhs.startRowOffset))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.binaryColumns != rhs.__isset.binaryColumns)
      return false;
    else if (__isset.binaryColumns && !(binaryColumns == rhs.binaryColumns))
      return false;
    if (__isset.columnCount != rhs.__isset.columnCount)
      return false;
    else if (__isset.columnCount && !(columnCount == rhs.columnCount))
      return false;
    return true;
  }
  bool operator != (const TRowSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRowSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRowSet &a, TRowSet &b);

inline std::ostream& operator<<(std::ostream& out, const TRowSet& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TStatus__isset {
  _TStatus__isset() : infoMessages(false), sqlState(false), errorCode(false), errorMessage(false) {}
  bool infoMessages :1;
  bool sqlState :1;
  bool errorCode :1;
  bool errorMessage :1;
} _TStatus__isset;

class TStatus {
 public:

  TStatus(const TStatus&);
  TStatus& operator=(const TStatus&);
  TStatus() : statusCode((TStatusCode::type)0), sqlState(), errorCode(0), errorMessage() {
  }

  virtual ~TStatus() throw();
  TStatusCode::type statusCode;
  std::vector<std::string>  infoMessages;
  std::string sqlState;
  int32_t errorCode;
  std::string errorMessage;

  _TStatus__isset __isset;

  void __set_statusCode(const TStatusCode::type val);

  void __set_infoMessages(const std::vector<std::string> & val);

  void __set_sqlState(const std::string& val);

  void __set_errorCode(const int32_t val);

  void __set_errorMessage(const std::string& val);

  bool operator == (const TStatus & rhs) const
  {
    if (!(statusCode == rhs.statusCode))
      return false;
    if (__isset.infoMessages != rhs.__isset.infoMessages)
      return false;
    else if (__isset.infoMessages && !(infoMessages == rhs.infoMessages))
      return false;
    if (__isset.sqlState != rhs.__isset.sqlState)
      return false;
    else if (__isset.sqlState && !(sqlState == rhs.sqlState))
      return false;
    if (__isset.errorCode != rhs.__isset.errorCode)
      return false;
    else if (__isset.errorCode && !(errorCode == rhs.errorCode))
      return false;
    if (__isset.errorMessage != rhs.__isset.errorMessage)
      return false;
    else if (__isset.errorMessage && !(errorMessage == rhs.errorMessage))
      return false;
    return true;
  }
  bool operator != (const TStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStatus &a, TStatus &b);

inline std::ostream& operator<<(std::ostream& out, const TStatus& obj)
{
  obj.printTo(out);
  return out;
}


class THandleIdentifier {
 public:

  THandleIdentifier(const THandleIdentifier&);
  THandleIdentifier& operator=(const THandleIdentifier&);
  THandleIdentifier() : guid(), secret() {
  }

  virtual ~THandleIdentifier() throw();
  std::string guid;
  std::string secret;

  void __set_guid(const std::string& val);

  void __set_secret(const std::string& val);

  bool operator == (const THandleIdentifier & rhs) const
  {
    if (!(guid == rhs.guid))
      return false;
    if (!(secret == rhs.secret))
      return false;
    return true;
  }
  bool operator != (const THandleIdentifier &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THandleIdentifier & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THandleIdentifier &a, THandleIdentifier &b);

inline std::ostream& operator<<(std::ostream& out, const THandleIdentifier& obj)
{
  obj.printTo(out);
  return out;
}


class TSessionHandle {
 public:

  TSessionHandle(const TSessionHandle&);
  TSessionHandle& operator=(const TSessionHandle&);
  TSessionHandle() {
  }

  virtual ~TSessionHandle() throw();
  THandleIdentifier sessionId;

  void __set_sessionId(const THandleIdentifier& val);

  bool operator == (const TSessionHandle & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    return true;
  }
  bool operator != (const TSessionHandle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSessionHandle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSessionHandle &a, TSessionHandle &b);

inline std::ostream& operator<<(std::ostream& out, const TSessionHandle& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TOperationHandle__isset {
  _TOperationHandle__isset() : modifiedRowCount(false) {}
  bool modifiedRowCount :1;
} _TOperationHandle__isset;

class TOperationHandle {
 public:

  TOperationHandle(const TOperationHandle&);
  TOperationHandle& operator=(const TOperationHandle&);
  TOperationHandle() : operationType((TOperationType::type)0), hasResultSet(0), modifiedRowCount(0) {
  }

  virtual ~TOperationHandle() throw();
  THandleIdentifier operationId;
  TOperationType::type operationType;
  bool hasResultSet;
  double modifiedRowCount;

  _TOperationHandle__isset __isset;

  void __set_operationId(const THandleIdentifier& val);

  void __set_operationType(const TOperationType::type val);

  void __set_hasResultSet(const bool val);

  void __set_modifiedRowCount(const double val);

  bool operator == (const TOperationHandle & rhs) const
  {
    if (!(operationId == rhs.operationId))
      return false;
    if (!(operationType == rhs.operationType))
      return false;
    if (!(hasResultSet == rhs.hasResultSet))
      return false;
    if (__isset.modifiedRowCount != rhs.__isset.modifiedRowCount)
      return false;
    else if (__isset.modifiedRowCount && !(modifiedRowCount == rhs.modifiedRowCount))
      return false;
    return true;
  }
  bool operator != (const TOperationHandle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOperationHandle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TOperationHandle &a, TOperationHandle &b);

inline std::ostream& operator<<(std::ostream& out, const TOperationHandle& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TOpenSessionReq__isset {
  _TOpenSessionReq__isset() : username(false), password(false), configuration(false) {}
  bool username :1;
  bool password :1;
  bool configuration :1;
} _TOpenSessionReq__isset;

class TOpenSessionReq {
 public:

  TOpenSessionReq(const TOpenSessionReq&);
  TOpenSessionReq& operator=(const TOpenSessionReq&);
  TOpenSessionReq() : client_protocol((TProtocolVersion::type)9), username(), password() {
    client_protocol = (TProtocolVersion::type)9;

  }

  virtual ~TOpenSessionReq() throw();
  TProtocolVersion::type client_protocol;
  std::string username;
  std::string password;
  std::map<std::string, std::string>  configuration;

  _TOpenSessionReq__isset __isset;

  void __set_client_protocol(const TProtocolVersion::type val);

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  void __set_configuration(const std::map<std::string, std::string> & val);

  bool operator == (const TOpenSessionReq & rhs) const
  {
    if (!(client_protocol == rhs.client_protocol))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.configuration != rhs.__isset.configuration)
      return false;
    else if (__isset.configuration && !(configuration == rhs.configuration))
      return false;
    return true;
  }
  bool operator != (const TOpenSessionReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOpenSessionReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TOpenSessionReq &a, TOpenSessionReq &b);

inline std::ostream& operator<<(std::ostream& out, const TOpenSessionReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TOpenSessionResp__isset {
  _TOpenSessionResp__isset() : sessionHandle(false), configuration(false) {}
  bool sessionHandle :1;
  bool configuration :1;
} _TOpenSessionResp__isset;

class TOpenSessionResp {
 public:

  TOpenSessionResp(const TOpenSessionResp&);
  TOpenSessionResp& operator=(const TOpenSessionResp&);
  TOpenSessionResp() : serverProtocolVersion((TProtocolVersion::type)9) {
    serverProtocolVersion = (TProtocolVersion::type)9;

  }

  virtual ~TOpenSessionResp() throw();
  TStatus status;
  TProtocolVersion::type serverProtocolVersion;
  TSessionHandle sessionHandle;
  std::map<std::string, std::string>  configuration;

  _TOpenSessionResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_serverProtocolVersion(const TProtocolVersion::type val);

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_configuration(const std::map<std::string, std::string> & val);

  bool operator == (const TOpenSessionResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(serverProtocolVersion == rhs.serverProtocolVersion))
      return false;
    if (__isset.sessionHandle != rhs.__isset.sessionHandle)
      return false;
    else if (__isset.sessionHandle && !(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.configuration != rhs.__isset.configuration)
      return false;
    else if (__isset.configuration && !(configuration == rhs.configuration))
      return false;
    return true;
  }
  bool operator != (const TOpenSessionResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOpenSessionResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TOpenSessionResp &a, TOpenSessionResp &b);

inline std::ostream& operator<<(std::ostream& out, const TOpenSessionResp& obj)
{
  obj.printTo(out);
  return out;
}


class TCloseSessionReq {
 public:

  TCloseSessionReq(const TCloseSessionReq&);
  TCloseSessionReq& operator=(const TCloseSessionReq&);
  TCloseSessionReq() {
  }

  virtual ~TCloseSessionReq() throw();
  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val);

  bool operator == (const TCloseSessionReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TCloseSessionReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseSessionReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCloseSessionReq &a, TCloseSessionReq &b);

inline std::ostream& operator<<(std::ostream& out, const TCloseSessionReq& obj)
{
  obj.printTo(out);
  return out;
}


class TCloseSessionResp {
 public:

  TCloseSessionResp(const TCloseSessionResp&);
  TCloseSessionResp& operator=(const TCloseSessionResp&);
  TCloseSessionResp() {
  }

  virtual ~TCloseSessionResp() throw();
  TStatus status;

  void __set_status(const TStatus& val);

  bool operator == (const TCloseSessionResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCloseSessionResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseSessionResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCloseSessionResp &a, TCloseSessionResp &b);

inline std::ostream& operator<<(std::ostream& out, const TCloseSessionResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetInfoValue__isset {
  _TGetInfoValue__isset() : stringValue(false), smallIntValue(false), integerBitmask(false), integerFlag(false), binaryValue(false), lenValue(false) {}
  bool stringValue :1;
  bool smallIntValue :1;
  bool integerBitmask :1;
  bool integerFlag :1;
  bool binaryValue :1;
  bool lenValue :1;
} _TGetInfoValue__isset;

class TGetInfoValue {
 public:

  TGetInfoValue(const TGetInfoValue&);
  TGetInfoValue& operator=(const TGetInfoValue&);
  TGetInfoValue() : stringValue(), smallIntValue(0), integerBitmask(0), integerFlag(0), binaryValue(0), lenValue(0) {
  }

  virtual ~TGetInfoValue() throw();
  std::string stringValue;
  int16_t smallIntValue;
  int32_t integerBitmask;
  int32_t integerFlag;
  int32_t binaryValue;
  int64_t lenValue;

  _TGetInfoValue__isset __isset;

  void __set_stringValue(const std::string& val);

  void __set_smallIntValue(const int16_t val);

  void __set_integerBitmask(const int32_t val);

  void __set_integerFlag(const int32_t val);

  void __set_binaryValue(const int32_t val);

  void __set_lenValue(const int64_t val);

  bool operator == (const TGetInfoValue & rhs) const
  {
    if (!(stringValue == rhs.stringValue))
      return false;
    if (!(smallIntValue == rhs.smallIntValue))
      return false;
    if (!(integerBitmask == rhs.integerBitmask))
      return false;
    if (!(integerFlag == rhs.integerFlag))
      return false;
    if (!(binaryValue == rhs.binaryValue))
      return false;
    if (!(lenValue == rhs.lenValue))
      return false;
    return true;
  }
  bool operator != (const TGetInfoValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetInfoValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetInfoValue &a, TGetInfoValue &b);

inline std::ostream& operator<<(std::ostream& out, const TGetInfoValue& obj)
{
  obj.printTo(out);
  return out;
}


class TGetInfoReq {
 public:

  TGetInfoReq(const TGetInfoReq&);
  TGetInfoReq& operator=(const TGetInfoReq&);
  TGetInfoReq() : infoType((TGetInfoType::type)0) {
  }

  virtual ~TGetInfoReq() throw();
  TSessionHandle sessionHandle;
  TGetInfoType::type infoType;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_infoType(const TGetInfoType::type val);

  bool operator == (const TGetInfoReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(infoType == rhs.infoType))
      return false;
    return true;
  }
  bool operator != (const TGetInfoReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetInfoReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetInfoReq &a, TGetInfoReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetInfoReq& obj)
{
  obj.printTo(out);
  return out;
}


class TGetInfoResp {
 public:

  TGetInfoResp(const TGetInfoResp&);
  TGetInfoResp& operator=(const TGetInfoResp&);
  TGetInfoResp() {
  }

  virtual ~TGetInfoResp() throw();
  TStatus status;
  TGetInfoValue infoValue;

  void __set_status(const TStatus& val);

  void __set_infoValue(const TGetInfoValue& val);

  bool operator == (const TGetInfoResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(infoValue == rhs.infoValue))
      return false;
    return true;
  }
  bool operator != (const TGetInfoResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetInfoResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetInfoResp &a, TGetInfoResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetInfoResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TExecuteStatementReq__isset {
  _TExecuteStatementReq__isset() : confOverlay(false), runAsync(true), queryTimeout(true) {}
  bool confOverlay :1;
  bool runAsync :1;
  bool queryTimeout :1;
} _TExecuteStatementReq__isset;

class TExecuteStatementReq {
 public:

  TExecuteStatementReq(const TExecuteStatementReq&);
  TExecuteStatementReq& operator=(const TExecuteStatementReq&);
  TExecuteStatementReq() : statement(), runAsync(false), queryTimeout(0LL) {
  }

  virtual ~TExecuteStatementReq() throw();
  TSessionHandle sessionHandle;
  std::string statement;
  std::map<std::string, std::string>  confOverlay;
  bool runAsync;
  int64_t queryTimeout;

  _TExecuteStatementReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_statement(const std::string& val);

  void __set_confOverlay(const std::map<std::string, std::string> & val);

  void __set_runAsync(const bool val);

  void __set_queryTimeout(const int64_t val);

  bool operator == (const TExecuteStatementReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(statement == rhs.statement))
      return false;
    if (__isset.confOverlay != rhs.__isset.confOverlay)
      return false;
    else if (__isset.confOverlay && !(confOverlay == rhs.confOverlay))
      return false;
    if (__isset.runAsync != rhs.__isset.runAsync)
      return false;
    else if (__isset.runAsync && !(runAsync == rhs.runAsync))
      return false;
    if (__isset.queryTimeout != rhs.__isset.queryTimeout)
      return false;
    else if (__isset.queryTimeout && !(queryTimeout == rhs.queryTimeout))
      return false;
    return true;
  }
  bool operator != (const TExecuteStatementReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecuteStatementReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExecuteStatementReq &a, TExecuteStatementReq &b);

inline std::ostream& operator<<(std::ostream& out, const TExecuteStatementReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TExecuteStatementResp__isset {
  _TExecuteStatementResp__isset() : operationHandle(false) {}
  bool operationHandle :1;
} _TExecuteStatementResp__isset;

class TExecuteStatementResp {
 public:

  TExecuteStatementResp(const TExecuteStatementResp&);
  TExecuteStatementResp& operator=(const TExecuteStatementResp&);
  TExecuteStatementResp() {
  }

  virtual ~TExecuteStatementResp() throw();
  TStatus status;
  TOperationHandle operationHandle;

  _TExecuteStatementResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TExecuteStatementResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TExecuteStatementResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecuteStatementResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExecuteStatementResp &a, TExecuteStatementResp &b);

inline std::ostream& operator<<(std::ostream& out, const TExecuteStatementResp& obj)
{
  obj.printTo(out);
  return out;
}


class TGetTypeInfoReq {
 public:

  TGetTypeInfoReq(const TGetTypeInfoReq&);
  TGetTypeInfoReq& operator=(const TGetTypeInfoReq&);
  TGetTypeInfoReq() {
  }

  virtual ~TGetTypeInfoReq() throw();
  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val);

  bool operator == (const TGetTypeInfoReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTypeInfoReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTypeInfoReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTypeInfoReq &a, TGetTypeInfoReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetTypeInfoReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetTypeInfoResp__isset {
  _TGetTypeInfoResp__isset() : operationHandle(false) {}
  bool operationHandle :1;
} _TGetTypeInfoResp__isset;

class TGetTypeInfoResp {
 public:

  TGetTypeInfoResp(const TGetTypeInfoResp&);
  TGetTypeInfoResp& operator=(const TGetTypeInfoResp&);
  TGetTypeInfoResp() {
  }

  virtual ~TGetTypeInfoResp() throw();
  TStatus status;
  TOperationHandle operationHandle;

  _TGetTypeInfoResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TGetTypeInfoResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTypeInfoResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTypeInfoResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTypeInfoResp &a, TGetTypeInfoResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetTypeInfoResp& obj)
{
  obj.printTo(out);
  return out;
}


class TGetCatalogsReq {
 public:

  TGetCatalogsReq(const TGetCatalogsReq&);
  TGetCatalogsReq& operator=(const TGetCatalogsReq&);
  TGetCatalogsReq() {
  }

  virtual ~TGetCatalogsReq() throw();
  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val);

  bool operator == (const TGetCatalogsReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TGetCatalogsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetCatalogsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetCatalogsReq &a, TGetCatalogsReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetCatalogsReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetCatalogsResp__isset {
  _TGetCatalogsResp__isset() : operationHandle(false) {}
  bool operationHandle :1;
} _TGetCatalogsResp__isset;

class TGetCatalogsResp {
 public:

  TGetCatalogsResp(const TGetCatalogsResp&);
  TGetCatalogsResp& operator=(const TGetCatalogsResp&);
  TGetCatalogsResp() {
  }

  virtual ~TGetCatalogsResp() throw();
  TStatus status;
  TOperationHandle operationHandle;

  _TGetCatalogsResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TGetCatalogsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetCatalogsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetCatalogsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetCatalogsResp &a, TGetCatalogsResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetCatalogsResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetSchemasReq__isset {
  _TGetSchemasReq__isset() : catalogName(false), schemaName(false) {}
  bool catalogName :1;
  bool schemaName :1;
} _TGetSchemasReq__isset;

class TGetSchemasReq {
 public:

  TGetSchemasReq(const TGetSchemasReq&);
  TGetSchemasReq& operator=(const TGetSchemasReq&);
  TGetSchemasReq() : catalogName(), schemaName() {
  }

  virtual ~TGetSchemasReq() throw();
  TSessionHandle sessionHandle;
  TIdentifier catalogName;
  TPatternOrIdentifier schemaName;

  _TGetSchemasReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_catalogName(const TIdentifier& val);

  void __set_schemaName(const TPatternOrIdentifier& val);

  bool operator == (const TGetSchemasReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    return true;
  }
  bool operator != (const TGetSchemasReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetSchemasReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetSchemasReq &a, TGetSchemasReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetSchemasReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetSchemasResp__isset {
  _TGetSchemasResp__isset() : operationHandle(false) {}
  bool operationHandle :1;
} _TGetSchemasResp__isset;

class TGetSchemasResp {
 public:

  TGetSchemasResp(const TGetSchemasResp&);
  TGetSchemasResp& operator=(const TGetSchemasResp&);
  TGetSchemasResp() {
  }

  virtual ~TGetSchemasResp() throw();
  TStatus status;
  TOperationHandle operationHandle;

  _TGetSchemasResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TGetSchemasResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetSchemasResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetSchemasResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetSchemasResp &a, TGetSchemasResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetSchemasResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetTablesReq__isset {
  _TGetTablesReq__isset() : catalogName(false), schemaName(false), tableName(false), tableTypes(false) {}
  bool catalogName :1;
  bool schemaName :1;
  bool tableName :1;
  bool tableTypes :1;
} _TGetTablesReq__isset;

class TGetTablesReq {
 public:

  TGetTablesReq(const TGetTablesReq&);
  TGetTablesReq& operator=(const TGetTablesReq&);
  TGetTablesReq() : catalogName(), schemaName(), tableName() {
  }

  virtual ~TGetTablesReq() throw();
  TSessionHandle sessionHandle;
  TPatternOrIdentifier catalogName;
  TPatternOrIdentifier schemaName;
  TPatternOrIdentifier tableName;
  std::vector<std::string>  tableTypes;

  _TGetTablesReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_catalogName(const TPatternOrIdentifier& val);

  void __set_schemaName(const TPatternOrIdentifier& val);

  void __set_tableName(const TPatternOrIdentifier& val);

  void __set_tableTypes(const std::vector<std::string> & val);

  bool operator == (const TGetTablesReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (__isset.tableTypes != rhs.__isset.tableTypes)
      return false;
    else if (__isset.tableTypes && !(tableTypes == rhs.tableTypes))
      return false;
    return true;
  }
  bool operator != (const TGetTablesReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTablesReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTablesReq &a, TGetTablesReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetTablesReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetTablesResp__isset {
  _TGetTablesResp__isset() : operationHandle(false) {}
  bool operationHandle :1;
} _TGetTablesResp__isset;

class TGetTablesResp {
 public:

  TGetTablesResp(const TGetTablesResp&);
  TGetTablesResp& operator=(const TGetTablesResp&);
  TGetTablesResp() {
  }

  virtual ~TGetTablesResp() throw();
  TStatus status;
  TOperationHandle operationHandle;

  _TGetTablesResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TGetTablesResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTablesResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTablesResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTablesResp &a, TGetTablesResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetTablesResp& obj)
{
  obj.printTo(out);
  return out;
}


class TGetTableTypesReq {
 public:

  TGetTableTypesReq(const TGetTableTypesReq&);
  TGetTableTypesReq& operator=(const TGetTableTypesReq&);
  TGetTableTypesReq() {
  }

  virtual ~TGetTableTypesReq() throw();
  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val);

  bool operator == (const TGetTableTypesReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTableTypesReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTableTypesReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTableTypesReq &a, TGetTableTypesReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetTableTypesReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetTableTypesResp__isset {
  _TGetTableTypesResp__isset() : operationHandle(false) {}
  bool operationHandle :1;
} _TGetTableTypesResp__isset;

class TGetTableTypesResp {
 public:

  TGetTableTypesResp(const TGetTableTypesResp&);
  TGetTableTypesResp& operator=(const TGetTableTypesResp&);
  TGetTableTypesResp() {
  }

  virtual ~TGetTableTypesResp() throw();
  TStatus status;
  TOperationHandle operationHandle;

  _TGetTableTypesResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TGetTableTypesResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTableTypesResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTableTypesResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTableTypesResp &a, TGetTableTypesResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetTableTypesResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetColumnsReq__isset {
  _TGetColumnsReq__isset() : catalogName(false), schemaName(false), tableName(false), columnName(false) {}
  bool catalogName :1;
  bool schemaName :1;
  bool tableName :1;
  bool columnName :1;
} _TGetColumnsReq__isset;

class TGetColumnsReq {
 public:

  TGetColumnsReq(const TGetColumnsReq&);
  TGetColumnsReq& operator=(const TGetColumnsReq&);
  TGetColumnsReq() : catalogName(), schemaName(), tableName(), columnName() {
  }

  virtual ~TGetColumnsReq() throw();
  TSessionHandle sessionHandle;
  TIdentifier catalogName;
  TPatternOrIdentifier schemaName;
  TPatternOrIdentifier tableName;
  TPatternOrIdentifier columnName;

  _TGetColumnsReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_catalogName(const TIdentifier& val);

  void __set_schemaName(const TPatternOrIdentifier& val);

  void __set_tableName(const TPatternOrIdentifier& val);

  void __set_columnName(const TPatternOrIdentifier& val);

  bool operator == (const TGetColumnsReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (__isset.columnName != rhs.__isset.columnName)
      return false;
    else if (__isset.columnName && !(columnName == rhs.columnName))
      return false;
    return true;
  }
  bool operator != (const TGetColumnsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetColumnsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetColumnsReq &a, TGetColumnsReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetColumnsReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetColumnsResp__isset {
  _TGetColumnsResp__isset() : operationHandle(false) {}
  bool operationHandle :1;
} _TGetColumnsResp__isset;

class TGetColumnsResp {
 public:

  TGetColumnsResp(const TGetColumnsResp&);
  TGetColumnsResp& operator=(const TGetColumnsResp&);
  TGetColumnsResp() {
  }

  virtual ~TGetColumnsResp() throw();
  TStatus status;
  TOperationHandle operationHandle;

  _TGetColumnsResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TGetColumnsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetColumnsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetColumnsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetColumnsResp &a, TGetColumnsResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetColumnsResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetFunctionsReq__isset {
  _TGetFunctionsReq__isset() : catalogName(false), schemaName(false) {}
  bool catalogName :1;
  bool schemaName :1;
} _TGetFunctionsReq__isset;

class TGetFunctionsReq {
 public:

  TGetFunctionsReq(const TGetFunctionsReq&);
  TGetFunctionsReq& operator=(const TGetFunctionsReq&);
  TGetFunctionsReq() : catalogName(), schemaName(), functionName() {
  }

  virtual ~TGetFunctionsReq() throw();
  TSessionHandle sessionHandle;
  TIdentifier catalogName;
  TPatternOrIdentifier schemaName;
  TPatternOrIdentifier functionName;

  _TGetFunctionsReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_catalogName(const TIdentifier& val);

  void __set_schemaName(const TPatternOrIdentifier& val);

  void __set_functionName(const TPatternOrIdentifier& val);

  bool operator == (const TGetFunctionsReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    if (!(functionName == rhs.functionName))
      return false;
    return true;
  }
  bool operator != (const TGetFunctionsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetFunctionsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetFunctionsReq &a, TGetFunctionsReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetFunctionsReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetFunctionsResp__isset {
  _TGetFunctionsResp__isset() : operationHandle(false) {}
  bool operationHandle :1;
} _TGetFunctionsResp__isset;

class TGetFunctionsResp {
 public:

  TGetFunctionsResp(const TGetFunctionsResp&);
  TGetFunctionsResp& operator=(const TGetFunctionsResp&);
  TGetFunctionsResp() {
  }

  virtual ~TGetFunctionsResp() throw();
  TStatus status;
  TOperationHandle operationHandle;

  _TGetFunctionsResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TGetFunctionsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetFunctionsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetFunctionsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetFunctionsResp &a, TGetFunctionsResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetFunctionsResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetPrimaryKeysReq__isset {
  _TGetPrimaryKeysReq__isset() : catalogName(false), schemaName(false), tableName(false) {}
  bool catalogName :1;
  bool schemaName :1;
  bool tableName :1;
} _TGetPrimaryKeysReq__isset;

class TGetPrimaryKeysReq {
 public:

  TGetPrimaryKeysReq(const TGetPrimaryKeysReq&);
  TGetPrimaryKeysReq& operator=(const TGetPrimaryKeysReq&);
  TGetPrimaryKeysReq() : catalogName(), schemaName(), tableName() {
  }

  virtual ~TGetPrimaryKeysReq() throw();
  TSessionHandle sessionHandle;
  TIdentifier catalogName;
  TIdentifier schemaName;
  TIdentifier tableName;

  _TGetPrimaryKeysReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_catalogName(const TIdentifier& val);

  void __set_schemaName(const TIdentifier& val);

  void __set_tableName(const TIdentifier& val);

  bool operator == (const TGetPrimaryKeysReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const TGetPrimaryKeysReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetPrimaryKeysReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetPrimaryKeysReq &a, TGetPrimaryKeysReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetPrimaryKeysReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetPrimaryKeysResp__isset {
  _TGetPrimaryKeysResp__isset() : operationHandle(false) {}
  bool operationHandle :1;
} _TGetPrimaryKeysResp__isset;

class TGetPrimaryKeysResp {
 public:

  TGetPrimaryKeysResp(const TGetPrimaryKeysResp&);
  TGetPrimaryKeysResp& operator=(const TGetPrimaryKeysResp&);
  TGetPrimaryKeysResp() {
  }

  virtual ~TGetPrimaryKeysResp() throw();
  TStatus status;
  TOperationHandle operationHandle;

  _TGetPrimaryKeysResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TGetPrimaryKeysResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetPrimaryKeysResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetPrimaryKeysResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetPrimaryKeysResp &a, TGetPrimaryKeysResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetPrimaryKeysResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetCrossReferenceReq__isset {
  _TGetCrossReferenceReq__isset() : parentCatalogName(false), parentSchemaName(false), parentTableName(false), foreignCatalogName(false), foreignSchemaName(false), foreignTableName(false) {}
  bool parentCatalogName :1;
  bool parentSchemaName :1;
  bool parentTableName :1;
  bool foreignCatalogName :1;
  bool foreignSchemaName :1;
  bool foreignTableName :1;
} _TGetCrossReferenceReq__isset;

class TGetCrossReferenceReq {
 public:

  TGetCrossReferenceReq(const TGetCrossReferenceReq&);
  TGetCrossReferenceReq& operator=(const TGetCrossReferenceReq&);
  TGetCrossReferenceReq() : parentCatalogName(), parentSchemaName(), parentTableName(), foreignCatalogName(), foreignSchemaName(), foreignTableName() {
  }

  virtual ~TGetCrossReferenceReq() throw();
  TSessionHandle sessionHandle;
  TIdentifier parentCatalogName;
  TIdentifier parentSchemaName;
  TIdentifier parentTableName;
  TIdentifier foreignCatalogName;
  TIdentifier foreignSchemaName;
  TIdentifier foreignTableName;

  _TGetCrossReferenceReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_parentCatalogName(const TIdentifier& val);

  void __set_parentSchemaName(const TIdentifier& val);

  void __set_parentTableName(const TIdentifier& val);

  void __set_foreignCatalogName(const TIdentifier& val);

  void __set_foreignSchemaName(const TIdentifier& val);

  void __set_foreignTableName(const TIdentifier& val);

  bool operator == (const TGetCrossReferenceReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.parentCatalogName != rhs.__isset.parentCatalogName)
      return false;
    else if (__isset.parentCatalogName && !(parentCatalogName == rhs.parentCatalogName))
      return false;
    if (__isset.parentSchemaName != rhs.__isset.parentSchemaName)
      return false;
    else if (__isset.parentSchemaName && !(parentSchemaName == rhs.parentSchemaName))
      return false;
    if (__isset.parentTableName != rhs.__isset.parentTableName)
      return false;
    else if (__isset.parentTableName && !(parentTableName == rhs.parentTableName))
      return false;
    if (__isset.foreignCatalogName != rhs.__isset.foreignCatalogName)
      return false;
    else if (__isset.foreignCatalogName && !(foreignCatalogName == rhs.foreignCatalogName))
      return false;
    if (__isset.foreignSchemaName != rhs.__isset.foreignSchemaName)
      return false;
    else if (__isset.foreignSchemaName && !(foreignSchemaName == rhs.foreignSchemaName))
      return false;
    if (__isset.foreignTableName != rhs.__isset.foreignTableName)
      return false;
    else if (__isset.foreignTableName && !(foreignTableName == rhs.foreignTableName))
      return false;
    return true;
  }
  bool operator != (const TGetCrossReferenceReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetCrossReferenceReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetCrossReferenceReq &a, TGetCrossReferenceReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetCrossReferenceReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetCrossReferenceResp__isset {
  _TGetCrossReferenceResp__isset() : operationHandle(false) {}
  bool operationHandle :1;
} _TGetCrossReferenceResp__isset;

class TGetCrossReferenceResp {
 public:

  TGetCrossReferenceResp(const TGetCrossReferenceResp&);
  TGetCrossReferenceResp& operator=(const TGetCrossReferenceResp&);
  TGetCrossReferenceResp() {
  }

  virtual ~TGetCrossReferenceResp() throw();
  TStatus status;
  TOperationHandle operationHandle;

  _TGetCrossReferenceResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TGetCrossReferenceResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetCrossReferenceResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetCrossReferenceResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetCrossReferenceResp &a, TGetCrossReferenceResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetCrossReferenceResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetOperationStatusReq__isset {
  _TGetOperationStatusReq__isset() : getProgressUpdate(false) {}
  bool getProgressUpdate :1;
} _TGetOperationStatusReq__isset;

class TGetOperationStatusReq {
 public:

  TGetOperationStatusReq(const TGetOperationStatusReq&);
  TGetOperationStatusReq& operator=(const TGetOperationStatusReq&);
  TGetOperationStatusReq() : getProgressUpdate(0) {
  }

  virtual ~TGetOperationStatusReq() throw();
  TOperationHandle operationHandle;
  bool getProgressUpdate;

  _TGetOperationStatusReq__isset __isset;

  void __set_operationHandle(const TOperationHandle& val);

  void __set_getProgressUpdate(const bool val);

  bool operator == (const TGetOperationStatusReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    if (__isset.getProgressUpdate != rhs.__isset.getProgressUpdate)
      return false;
    else if (__isset.getProgressUpdate && !(getProgressUpdate == rhs.getProgressUpdate))
      return false;
    return true;
  }
  bool operator != (const TGetOperationStatusReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetOperationStatusReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetOperationStatusReq &a, TGetOperationStatusReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetOperationStatusReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetOperationStatusResp__isset {
  _TGetOperationStatusResp__isset() : operationState(false), sqlState(false), errorCode(false), errorMessage(false), taskStatus(false), operationStarted(false), operationCompleted(false), hasResultSet(false), progressUpdateResponse(false) {}
  bool operationState :1;
  bool sqlState :1;
  bool errorCode :1;
  bool errorMessage :1;
  bool taskStatus :1;
  bool operationStarted :1;
  bool operationCompleted :1;
  bool hasResultSet :1;
  bool progressUpdateResponse :1;
} _TGetOperationStatusResp__isset;

class TGetOperationStatusResp {
 public:

  TGetOperationStatusResp(const TGetOperationStatusResp&);
  TGetOperationStatusResp& operator=(const TGetOperationStatusResp&);
  TGetOperationStatusResp() : operationState((TOperationState::type)0), sqlState(), errorCode(0), errorMessage(), taskStatus(), operationStarted(0), operationCompleted(0), hasResultSet(0) {
  }

  virtual ~TGetOperationStatusResp() throw();
  TStatus status;
  TOperationState::type operationState;
  std::string sqlState;
  int32_t errorCode;
  std::string errorMessage;
  std::string taskStatus;
  int64_t operationStarted;
  int64_t operationCompleted;
  bool hasResultSet;
  TProgressUpdateResp progressUpdateResponse;

  _TGetOperationStatusResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_operationState(const TOperationState::type val);

  void __set_sqlState(const std::string& val);

  void __set_errorCode(const int32_t val);

  void __set_errorMessage(const std::string& val);

  void __set_taskStatus(const std::string& val);

  void __set_operationStarted(const int64_t val);

  void __set_operationCompleted(const int64_t val);

  void __set_hasResultSet(const bool val);

  void __set_progressUpdateResponse(const TProgressUpdateResp& val);

  bool operator == (const TGetOperationStatusResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationState != rhs.__isset.operationState)
      return false;
    else if (__isset.operationState && !(operationState == rhs.operationState))
      return false;
    if (__isset.sqlState != rhs.__isset.sqlState)
      return false;
    else if (__isset.sqlState && !(sqlState == rhs.sqlState))
      return false;
    if (__isset.errorCode != rhs.__isset.errorCode)
      return false;
    else if (__isset.errorCode && !(errorCode == rhs.errorCode))
      return false;
    if (__isset.errorMessage != rhs.__isset.errorMessage)
      return false;
    else if (__isset.errorMessage && !(errorMessage == rhs.errorMessage))
      return false;
    if (__isset.taskStatus != rhs.__isset.taskStatus)
      return false;
    else if (__isset.taskStatus && !(taskStatus == rhs.taskStatus))
      return false;
    if (__isset.operationStarted != rhs.__isset.operationStarted)
      return false;
    else if (__isset.operationStarted && !(operationStarted == rhs.operationStarted))
      return false;
    if (__isset.operationCompleted != rhs.__isset.operationCompleted)
      return false;
    else if (__isset.operationCompleted && !(operationCompleted == rhs.operationCompleted))
      return false;
    if (__isset.hasResultSet != rhs.__isset.hasResultSet)
      return false;
    else if (__isset.hasResultSet && !(hasResultSet == rhs.hasResultSet))
      return false;
    if (__isset.progressUpdateResponse != rhs.__isset.progressUpdateResponse)
      return false;
    else if (__isset.progressUpdateResponse && !(progressUpdateResponse == rhs.progressUpdateResponse))
      return false;
    return true;
  }
  bool operator != (const TGetOperationStatusResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetOperationStatusResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetOperationStatusResp &a, TGetOperationStatusResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetOperationStatusResp& obj)
{
  obj.printTo(out);
  return out;
}


class TCancelOperationReq {
 public:

  TCancelOperationReq(const TCancelOperationReq&);
  TCancelOperationReq& operator=(const TCancelOperationReq&);
  TCancelOperationReq() {
  }

  virtual ~TCancelOperationReq() throw();
  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TCancelOperationReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TCancelOperationReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelOperationReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCancelOperationReq &a, TCancelOperationReq &b);

inline std::ostream& operator<<(std::ostream& out, const TCancelOperationReq& obj)
{
  obj.printTo(out);
  return out;
}


class TCancelOperationResp {
 public:

  TCancelOperationResp(const TCancelOperationResp&);
  TCancelOperationResp& operator=(const TCancelOperationResp&);
  TCancelOperationResp() {
  }

  virtual ~TCancelOperationResp() throw();
  TStatus status;

  void __set_status(const TStatus& val);

  bool operator == (const TCancelOperationResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCancelOperationResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelOperationResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCancelOperationResp &a, TCancelOperationResp &b);

inline std::ostream& operator<<(std::ostream& out, const TCancelOperationResp& obj)
{
  obj.printTo(out);
  return out;
}


class TCloseOperationReq {
 public:

  TCloseOperationReq(const TCloseOperationReq&);
  TCloseOperationReq& operator=(const TCloseOperationReq&);
  TCloseOperationReq() {
  }

  virtual ~TCloseOperationReq() throw();
  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TCloseOperationReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TCloseOperationReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseOperationReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCloseOperationReq &a, TCloseOperationReq &b);

inline std::ostream& operator<<(std::ostream& out, const TCloseOperationReq& obj)
{
  obj.printTo(out);
  return out;
}


class TCloseOperationResp {
 public:

  TCloseOperationResp(const TCloseOperationResp&);
  TCloseOperationResp& operator=(const TCloseOperationResp&);
  TCloseOperationResp() {
  }

  virtual ~TCloseOperationResp() throw();
  TStatus status;

  void __set_status(const TStatus& val);

  bool operator == (const TCloseOperationResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCloseOperationResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseOperationResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCloseOperationResp &a, TCloseOperationResp &b);

inline std::ostream& operator<<(std::ostream& out, const TCloseOperationResp& obj)
{
  obj.printTo(out);
  return out;
}


class TGetResultSetMetadataReq {
 public:

  TGetResultSetMetadataReq(const TGetResultSetMetadataReq&);
  TGetResultSetMetadataReq& operator=(const TGetResultSetMetadataReq&);
  TGetResultSetMetadataReq() {
  }

  virtual ~TGetResultSetMetadataReq() throw();
  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val);

  bool operator == (const TGetResultSetMetadataReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetResultSetMetadataReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetResultSetMetadataReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetResultSetMetadataReq &a, TGetResultSetMetadataReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetResultSetMetadataReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetResultSetMetadataResp__isset {
  _TGetResultSetMetadataResp__isset() : schema(false) {}
  bool schema :1;
} _TGetResultSetMetadataResp__isset;

class TGetResultSetMetadataResp {
 public:

  TGetResultSetMetadataResp(const TGetResultSetMetadataResp&);
  TGetResultSetMetadataResp& operator=(const TGetResultSetMetadataResp&);
  TGetResultSetMetadataResp() {
  }

  virtual ~TGetResultSetMetadataResp() throw();
  TStatus status;
  TTableSchema schema;

  _TGetResultSetMetadataResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_schema(const TTableSchema& val);

  bool operator == (const TGetResultSetMetadataResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.schema != rhs.__isset.schema)
      return false;
    else if (__isset.schema && !(schema == rhs.schema))
      return false;
    return true;
  }
  bool operator != (const TGetResultSetMetadataResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetResultSetMetadataResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetResultSetMetadataResp &a, TGetResultSetMetadataResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetResultSetMetadataResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TFetchResultsReq__isset {
  _TFetchResultsReq__isset() : fetchType(true) {}
  bool fetchType :1;
} _TFetchResultsReq__isset;

class TFetchResultsReq {
 public:

  TFetchResultsReq(const TFetchResultsReq&);
  TFetchResultsReq& operator=(const TFetchResultsReq&);
  TFetchResultsReq() : orientation((TFetchOrientation::type)0), maxRows(0), fetchType(0) {
    orientation = (TFetchOrientation::type)0;

  }

  virtual ~TFetchResultsReq() throw();
  TOperationHandle operationHandle;
  TFetchOrientation::type orientation;
  int64_t maxRows;
  int16_t fetchType;

  _TFetchResultsReq__isset __isset;

  void __set_operationHandle(const TOperationHandle& val);

  void __set_orientation(const TFetchOrientation::type val);

  void __set_maxRows(const int64_t val);

  void __set_fetchType(const int16_t val);

  bool operator == (const TFetchResultsReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    if (!(orientation == rhs.orientation))
      return false;
    if (!(maxRows == rhs.maxRows))
      return false;
    if (__isset.fetchType != rhs.__isset.fetchType)
      return false;
    else if (__isset.fetchType && !(fetchType == rhs.fetchType))
      return false;
    return true;
  }
  bool operator != (const TFetchResultsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchResultsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFetchResultsReq &a, TFetchResultsReq &b);

inline std::ostream& operator<<(std::ostream& out, const TFetchResultsReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TFetchResultsResp__isset {
  _TFetchResultsResp__isset() : hasMoreRows(false), results(false) {}
  bool hasMoreRows :1;
  bool results :1;
} _TFetchResultsResp__isset;

class TFetchResultsResp {
 public:

  TFetchResultsResp(const TFetchResultsResp&);
  TFetchResultsResp& operator=(const TFetchResultsResp&);
  TFetchResultsResp() : hasMoreRows(0) {
  }

  virtual ~TFetchResultsResp() throw();
  TStatus status;
  bool hasMoreRows;
  TRowSet results;

  _TFetchResultsResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_hasMoreRows(const bool val);

  void __set_results(const TRowSet& val);

  bool operator == (const TFetchResultsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.hasMoreRows != rhs.__isset.hasMoreRows)
      return false;
    else if (__isset.hasMoreRows && !(hasMoreRows == rhs.hasMoreRows))
      return false;
    if (__isset.results != rhs.__isset.results)
      return false;
    else if (__isset.results && !(results == rhs.results))
      return false;
    return true;
  }
  bool operator != (const TFetchResultsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchResultsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFetchResultsResp &a, TFetchResultsResp &b);

inline std::ostream& operator<<(std::ostream& out, const TFetchResultsResp& obj)
{
  obj.printTo(out);
  return out;
}


class TGetDelegationTokenReq {
 public:

  TGetDelegationTokenReq(const TGetDelegationTokenReq&);
  TGetDelegationTokenReq& operator=(const TGetDelegationTokenReq&);
  TGetDelegationTokenReq() : owner(), renewer() {
  }

  virtual ~TGetDelegationTokenReq() throw();
  TSessionHandle sessionHandle;
  std::string owner;
  std::string renewer;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_owner(const std::string& val);

  void __set_renewer(const std::string& val);

  bool operator == (const TGetDelegationTokenReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(renewer == rhs.renewer))
      return false;
    return true;
  }
  bool operator != (const TGetDelegationTokenReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetDelegationTokenReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetDelegationTokenReq &a, TGetDelegationTokenReq &b);

inline std::ostream& operator<<(std::ostream& out, const TGetDelegationTokenReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TGetDelegationTokenResp__isset {
  _TGetDelegationTokenResp__isset() : delegationToken(false) {}
  bool delegationToken :1;
} _TGetDelegationTokenResp__isset;

class TGetDelegationTokenResp {
 public:

  TGetDelegationTokenResp(const TGetDelegationTokenResp&);
  TGetDelegationTokenResp& operator=(const TGetDelegationTokenResp&);
  TGetDelegationTokenResp() : delegationToken() {
  }

  virtual ~TGetDelegationTokenResp() throw();
  TStatus status;
  std::string delegationToken;

  _TGetDelegationTokenResp__isset __isset;

  void __set_status(const TStatus& val);

  void __set_delegationToken(const std::string& val);

  bool operator == (const TGetDelegationTokenResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.delegationToken != rhs.__isset.delegationToken)
      return false;
    else if (__isset.delegationToken && !(delegationToken == rhs.delegationToken))
      return false;
    return true;
  }
  bool operator != (const TGetDelegationTokenResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetDelegationTokenResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetDelegationTokenResp &a, TGetDelegationTokenResp &b);

inline std::ostream& operator<<(std::ostream& out, const TGetDelegationTokenResp& obj)
{
  obj.printTo(out);
  return out;
}


class TCancelDelegationTokenReq {
 public:

  TCancelDelegationTokenReq(const TCancelDelegationTokenReq&);
  TCancelDelegationTokenReq& operator=(const TCancelDelegationTokenReq&);
  TCancelDelegationTokenReq() : delegationToken() {
  }

  virtual ~TCancelDelegationTokenReq() throw();
  TSessionHandle sessionHandle;
  std::string delegationToken;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_delegationToken(const std::string& val);

  bool operator == (const TCancelDelegationTokenReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(delegationToken == rhs.delegationToken))
      return false;
    return true;
  }
  bool operator != (const TCancelDelegationTokenReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelDelegationTokenReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCancelDelegationTokenReq &a, TCancelDelegationTokenReq &b);

inline std::ostream& operator<<(std::ostream& out, const TCancelDelegationTokenReq& obj)
{
  obj.printTo(out);
  return out;
}


class TCancelDelegationTokenResp {
 public:

  TCancelDelegationTokenResp(const TCancelDelegationTokenResp&);
  TCancelDelegationTokenResp& operator=(const TCancelDelegationTokenResp&);
  TCancelDelegationTokenResp() {
  }

  virtual ~TCancelDelegationTokenResp() throw();
  TStatus status;

  void __set_status(const TStatus& val);

  bool operator == (const TCancelDelegationTokenResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCancelDelegationTokenResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelDelegationTokenResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCancelDelegationTokenResp &a, TCancelDelegationTokenResp &b);

inline std::ostream& operator<<(std::ostream& out, const TCancelDelegationTokenResp& obj)
{
  obj.printTo(out);
  return out;
}


class TRenewDelegationTokenReq {
 public:

  TRenewDelegationTokenReq(const TRenewDelegationTokenReq&);
  TRenewDelegationTokenReq& operator=(const TRenewDelegationTokenReq&);
  TRenewDelegationTokenReq() : delegationToken() {
  }

  virtual ~TRenewDelegationTokenReq() throw();
  TSessionHandle sessionHandle;
  std::string delegationToken;

  void __set_sessionHandle(const TSessionHandle& val);

  void __set_delegationToken(const std::string& val);

  bool operator == (const TRenewDelegationTokenReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(delegationToken == rhs.delegationToken))
      return false;
    return true;
  }
  bool operator != (const TRenewDelegationTokenReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRenewDelegationTokenReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRenewDelegationTokenReq &a, TRenewDelegationTokenReq &b);

inline std::ostream& operator<<(std::ostream& out, const TRenewDelegationTokenReq& obj)
{
  obj.printTo(out);
  return out;
}


class TRenewDelegationTokenResp {
 public:

  TRenewDelegationTokenResp(const TRenewDelegationTokenResp&);
  TRenewDelegationTokenResp& operator=(const TRenewDelegationTokenResp&);
  TRenewDelegationTokenResp() {
  }

  virtual ~TRenewDelegationTokenResp() throw();
  TStatus status;

  void __set_status(const TStatus& val);

  bool operator == (const TRenewDelegationTokenResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TRenewDelegationTokenResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRenewDelegationTokenResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRenewDelegationTokenResp &a, TRenewDelegationTokenResp &b);

inline std::ostream& operator<<(std::ostream& out, const TRenewDelegationTokenResp& obj)
{
  obj.printTo(out);
  return out;
}


class TProgressUpdateResp {
 public:

  TProgressUpdateResp(const TProgressUpdateResp&);
  TProgressUpdateResp& operator=(const TProgressUpdateResp&);
  TProgressUpdateResp() : progressedPercentage(0), status((TJobExecutionStatus::type)0), footerSummary(), startTime(0) {
  }

  virtual ~TProgressUpdateResp() throw();
  std::vector<std::string>  headerNames;
  std::vector<std::vector<std::string> >  rows;
  double progressedPercentage;
  TJobExecutionStatus::type status;
  std::string footerSummary;
  int64_t startTime;

  void __set_headerNames(const std::vector<std::string> & val);

  void __set_rows(const std::vector<std::vector<std::string> > & val);

  void __set_progressedPercentage(const double val);

  void __set_status(const TJobExecutionStatus::type val);

  void __set_footerSummary(const std::string& val);

  void __set_startTime(const int64_t val);

  bool operator == (const TProgressUpdateResp & rhs) const
  {
    if (!(headerNames == rhs.headerNames))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(progressedPercentage == rhs.progressedPercentage))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(footerSummary == rhs.footerSummary))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    return true;
  }
  bool operator != (const TProgressUpdateResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TProgressUpdateResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TProgressUpdateResp &a, TProgressUpdateResp &b);

inline std::ostream& operator<<(std::ostream& out, const TProgressUpdateResp& obj)
{
  obj.printTo(out);
  return out;
}

}}}}} // namespace

#endif
