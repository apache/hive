/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "TCLIService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace hive { namespace service { namespace rpc { namespace thrift {

int _kTProtocolVersionValues[] = {
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V1,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V2,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V3,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V4,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V5,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V6,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V7,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V8,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V9,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V10,
  TProtocolVersion::HIVE_CLI_SERVICE_PROTOCOL_V11
};
const char* _kTProtocolVersionNames[] = {
  "HIVE_CLI_SERVICE_PROTOCOL_V1",
  "HIVE_CLI_SERVICE_PROTOCOL_V2",
  "HIVE_CLI_SERVICE_PROTOCOL_V3",
  "HIVE_CLI_SERVICE_PROTOCOL_V4",
  "HIVE_CLI_SERVICE_PROTOCOL_V5",
  "HIVE_CLI_SERVICE_PROTOCOL_V6",
  "HIVE_CLI_SERVICE_PROTOCOL_V7",
  "HIVE_CLI_SERVICE_PROTOCOL_V8",
  "HIVE_CLI_SERVICE_PROTOCOL_V9",
  "HIVE_CLI_SERVICE_PROTOCOL_V10",
  "HIVE_CLI_SERVICE_PROTOCOL_V11"
};
const std::map<int, const char*> _TProtocolVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(11, _kTProtocolVersionValues, _kTProtocolVersionNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TProtocolVersion::type& val) {
  std::map<int, const char*>::const_iterator it = _TProtocolVersion_VALUES_TO_NAMES.find(val);
  if (it != _TProtocolVersion_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TProtocolVersion::type& val) {
  std::map<int, const char*>::const_iterator it = _TProtocolVersion_VALUES_TO_NAMES.find(val);
  if (it != _TProtocolVersion_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTTypeIdValues[] = {
  TTypeId::BOOLEAN_TYPE,
  TTypeId::TINYINT_TYPE,
  TTypeId::SMALLINT_TYPE,
  TTypeId::INT_TYPE,
  TTypeId::BIGINT_TYPE,
  TTypeId::FLOAT_TYPE,
  TTypeId::DOUBLE_TYPE,
  TTypeId::STRING_TYPE,
  TTypeId::TIMESTAMP_TYPE,
  TTypeId::BINARY_TYPE,
  TTypeId::ARRAY_TYPE,
  TTypeId::MAP_TYPE,
  TTypeId::STRUCT_TYPE,
  TTypeId::UNION_TYPE,
  TTypeId::USER_DEFINED_TYPE,
  TTypeId::DECIMAL_TYPE,
  TTypeId::NULL_TYPE,
  TTypeId::DATE_TYPE,
  TTypeId::VARCHAR_TYPE,
  TTypeId::CHAR_TYPE,
  TTypeId::INTERVAL_YEAR_MONTH_TYPE,
  TTypeId::INTERVAL_DAY_TIME_TYPE,
  TTypeId::TIMESTAMPLOCALTZ_TYPE
};
const char* _kTTypeIdNames[] = {
  "BOOLEAN_TYPE",
  "TINYINT_TYPE",
  "SMALLINT_TYPE",
  "INT_TYPE",
  "BIGINT_TYPE",
  "FLOAT_TYPE",
  "DOUBLE_TYPE",
  "STRING_TYPE",
  "TIMESTAMP_TYPE",
  "BINARY_TYPE",
  "ARRAY_TYPE",
  "MAP_TYPE",
  "STRUCT_TYPE",
  "UNION_TYPE",
  "USER_DEFINED_TYPE",
  "DECIMAL_TYPE",
  "NULL_TYPE",
  "DATE_TYPE",
  "VARCHAR_TYPE",
  "CHAR_TYPE",
  "INTERVAL_YEAR_MONTH_TYPE",
  "INTERVAL_DAY_TIME_TYPE",
  "TIMESTAMPLOCALTZ_TYPE"
};
const std::map<int, const char*> _TTypeId_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(23, _kTTypeIdValues, _kTTypeIdNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TTypeId::type& val) {
  std::map<int, const char*>::const_iterator it = _TTypeId_VALUES_TO_NAMES.find(val);
  if (it != _TTypeId_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TTypeId::type& val) {
  std::map<int, const char*>::const_iterator it = _TTypeId_VALUES_TO_NAMES.find(val);
  if (it != _TTypeId_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTStatusCodeValues[] = {
  TStatusCode::SUCCESS_STATUS,
  TStatusCode::SUCCESS_WITH_INFO_STATUS,
  TStatusCode::STILL_EXECUTING_STATUS,
  TStatusCode::ERROR_STATUS,
  TStatusCode::INVALID_HANDLE_STATUS
};
const char* _kTStatusCodeNames[] = {
  "SUCCESS_STATUS",
  "SUCCESS_WITH_INFO_STATUS",
  "STILL_EXECUTING_STATUS",
  "ERROR_STATUS",
  "INVALID_HANDLE_STATUS"
};
const std::map<int, const char*> _TStatusCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTStatusCodeValues, _kTStatusCodeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TStatusCode::type& val) {
  std::map<int, const char*>::const_iterator it = _TStatusCode_VALUES_TO_NAMES.find(val);
  if (it != _TStatusCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TStatusCode::type& val) {
  std::map<int, const char*>::const_iterator it = _TStatusCode_VALUES_TO_NAMES.find(val);
  if (it != _TStatusCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTOperationStateValues[] = {
  TOperationState::INITIALIZED_STATE,
  TOperationState::RUNNING_STATE,
  TOperationState::FINISHED_STATE,
  TOperationState::CANCELED_STATE,
  TOperationState::CLOSED_STATE,
  TOperationState::ERROR_STATE,
  TOperationState::UKNOWN_STATE,
  TOperationState::PENDING_STATE,
  TOperationState::TIMEDOUT_STATE
};
const char* _kTOperationStateNames[] = {
  "INITIALIZED_STATE",
  "RUNNING_STATE",
  "FINISHED_STATE",
  "CANCELED_STATE",
  "CLOSED_STATE",
  "ERROR_STATE",
  "UKNOWN_STATE",
  "PENDING_STATE",
  "TIMEDOUT_STATE"
};
const std::map<int, const char*> _TOperationState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kTOperationStateValues, _kTOperationStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TOperationState::type& val) {
  std::map<int, const char*>::const_iterator it = _TOperationState_VALUES_TO_NAMES.find(val);
  if (it != _TOperationState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TOperationState::type& val) {
  std::map<int, const char*>::const_iterator it = _TOperationState_VALUES_TO_NAMES.find(val);
  if (it != _TOperationState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTOperationTypeValues[] = {
  TOperationType::EXECUTE_STATEMENT,
  TOperationType::GET_TYPE_INFO,
  TOperationType::GET_CATALOGS,
  TOperationType::GET_SCHEMAS,
  TOperationType::GET_TABLES,
  TOperationType::GET_TABLE_TYPES,
  TOperationType::GET_COLUMNS,
  TOperationType::GET_FUNCTIONS,
  TOperationType::UNKNOWN,
  TOperationType::PROCEDURAL_SQL
};
const char* _kTOperationTypeNames[] = {
  "EXECUTE_STATEMENT",
  "GET_TYPE_INFO",
  "GET_CATALOGS",
  "GET_SCHEMAS",
  "GET_TABLES",
  "GET_TABLE_TYPES",
  "GET_COLUMNS",
  "GET_FUNCTIONS",
  "UNKNOWN",
  "PROCEDURAL_SQL"
};
const std::map<int, const char*> _TOperationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kTOperationTypeValues, _kTOperationTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _TOperationType_VALUES_TO_NAMES.find(val);
  if (it != _TOperationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _TOperationType_VALUES_TO_NAMES.find(val);
  if (it != _TOperationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTGetInfoTypeValues[] = {
  TGetInfoType::CLI_MAX_DRIVER_CONNECTIONS,
  TGetInfoType::CLI_MAX_CONCURRENT_ACTIVITIES,
  TGetInfoType::CLI_DATA_SOURCE_NAME,
  TGetInfoType::CLI_FETCH_DIRECTION,
  TGetInfoType::CLI_SERVER_NAME,
  TGetInfoType::CLI_SEARCH_PATTERN_ESCAPE,
  TGetInfoType::CLI_DBMS_NAME,
  TGetInfoType::CLI_DBMS_VER,
  TGetInfoType::CLI_ACCESSIBLE_TABLES,
  TGetInfoType::CLI_ACCESSIBLE_PROCEDURES,
  TGetInfoType::CLI_CURSOR_COMMIT_BEHAVIOR,
  TGetInfoType::CLI_DATA_SOURCE_READ_ONLY,
  TGetInfoType::CLI_DEFAULT_TXN_ISOLATION,
  TGetInfoType::CLI_IDENTIFIER_CASE,
  TGetInfoType::CLI_IDENTIFIER_QUOTE_CHAR,
  TGetInfoType::CLI_MAX_COLUMN_NAME_LEN,
  TGetInfoType::CLI_MAX_CURSOR_NAME_LEN,
  TGetInfoType::CLI_MAX_SCHEMA_NAME_LEN,
  TGetInfoType::CLI_MAX_CATALOG_NAME_LEN,
  TGetInfoType::CLI_MAX_TABLE_NAME_LEN,
  TGetInfoType::CLI_SCROLL_CONCURRENCY,
  TGetInfoType::CLI_TXN_CAPABLE,
  TGetInfoType::CLI_USER_NAME,
  TGetInfoType::CLI_TXN_ISOLATION_OPTION,
  TGetInfoType::CLI_INTEGRITY,
  TGetInfoType::CLI_GETDATA_EXTENSIONS,
  TGetInfoType::CLI_NULL_COLLATION,
  TGetInfoType::CLI_ALTER_TABLE,
  TGetInfoType::CLI_ORDER_BY_COLUMNS_IN_SELECT,
  TGetInfoType::CLI_SPECIAL_CHARACTERS,
  TGetInfoType::CLI_MAX_COLUMNS_IN_GROUP_BY,
  TGetInfoType::CLI_MAX_COLUMNS_IN_INDEX,
  TGetInfoType::CLI_MAX_COLUMNS_IN_ORDER_BY,
  TGetInfoType::CLI_MAX_COLUMNS_IN_SELECT,
  TGetInfoType::CLI_MAX_COLUMNS_IN_TABLE,
  TGetInfoType::CLI_MAX_INDEX_SIZE,
  TGetInfoType::CLI_MAX_ROW_SIZE,
  TGetInfoType::CLI_MAX_STATEMENT_LEN,
  TGetInfoType::CLI_MAX_TABLES_IN_SELECT,
  TGetInfoType::CLI_MAX_USER_NAME_LEN,
  TGetInfoType::CLI_OJ_CAPABILITIES,
  TGetInfoType::CLI_XOPEN_CLI_YEAR,
  TGetInfoType::CLI_CURSOR_SENSITIVITY,
  TGetInfoType::CLI_DESCRIBE_PARAMETER,
  TGetInfoType::CLI_CATALOG_NAME,
  TGetInfoType::CLI_COLLATION_SEQ,
  TGetInfoType::CLI_MAX_IDENTIFIER_LEN,
  TGetInfoType::CLI_ODBC_KEYWORDS
};
const char* _kTGetInfoTypeNames[] = {
  "CLI_MAX_DRIVER_CONNECTIONS",
  "CLI_MAX_CONCURRENT_ACTIVITIES",
  "CLI_DATA_SOURCE_NAME",
  "CLI_FETCH_DIRECTION",
  "CLI_SERVER_NAME",
  "CLI_SEARCH_PATTERN_ESCAPE",
  "CLI_DBMS_NAME",
  "CLI_DBMS_VER",
  "CLI_ACCESSIBLE_TABLES",
  "CLI_ACCESSIBLE_PROCEDURES",
  "CLI_CURSOR_COMMIT_BEHAVIOR",
  "CLI_DATA_SOURCE_READ_ONLY",
  "CLI_DEFAULT_TXN_ISOLATION",
  "CLI_IDENTIFIER_CASE",
  "CLI_IDENTIFIER_QUOTE_CHAR",
  "CLI_MAX_COLUMN_NAME_LEN",
  "CLI_MAX_CURSOR_NAME_LEN",
  "CLI_MAX_SCHEMA_NAME_LEN",
  "CLI_MAX_CATALOG_NAME_LEN",
  "CLI_MAX_TABLE_NAME_LEN",
  "CLI_SCROLL_CONCURRENCY",
  "CLI_TXN_CAPABLE",
  "CLI_USER_NAME",
  "CLI_TXN_ISOLATION_OPTION",
  "CLI_INTEGRITY",
  "CLI_GETDATA_EXTENSIONS",
  "CLI_NULL_COLLATION",
  "CLI_ALTER_TABLE",
  "CLI_ORDER_BY_COLUMNS_IN_SELECT",
  "CLI_SPECIAL_CHARACTERS",
  "CLI_MAX_COLUMNS_IN_GROUP_BY",
  "CLI_MAX_COLUMNS_IN_INDEX",
  "CLI_MAX_COLUMNS_IN_ORDER_BY",
  "CLI_MAX_COLUMNS_IN_SELECT",
  "CLI_MAX_COLUMNS_IN_TABLE",
  "CLI_MAX_INDEX_SIZE",
  "CLI_MAX_ROW_SIZE",
  "CLI_MAX_STATEMENT_LEN",
  "CLI_MAX_TABLES_IN_SELECT",
  "CLI_MAX_USER_NAME_LEN",
  "CLI_OJ_CAPABILITIES",
  "CLI_XOPEN_CLI_YEAR",
  "CLI_CURSOR_SENSITIVITY",
  "CLI_DESCRIBE_PARAMETER",
  "CLI_CATALOG_NAME",
  "CLI_COLLATION_SEQ",
  "CLI_MAX_IDENTIFIER_LEN",
  "CLI_ODBC_KEYWORDS"
};
const std::map<int, const char*> _TGetInfoType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(48, _kTGetInfoTypeValues, _kTGetInfoTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TGetInfoType::type& val) {
  std::map<int, const char*>::const_iterator it = _TGetInfoType_VALUES_TO_NAMES.find(val);
  if (it != _TGetInfoType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TGetInfoType::type& val) {
  std::map<int, const char*>::const_iterator it = _TGetInfoType_VALUES_TO_NAMES.find(val);
  if (it != _TGetInfoType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTFetchOrientationValues[] = {
  TFetchOrientation::FETCH_NEXT,
  TFetchOrientation::FETCH_PRIOR,
  TFetchOrientation::FETCH_RELATIVE,
  TFetchOrientation::FETCH_ABSOLUTE,
  TFetchOrientation::FETCH_FIRST,
  TFetchOrientation::FETCH_LAST
};
const char* _kTFetchOrientationNames[] = {
  "FETCH_NEXT",
  "FETCH_PRIOR",
  "FETCH_RELATIVE",
  "FETCH_ABSOLUTE",
  "FETCH_FIRST",
  "FETCH_LAST"
};
const std::map<int, const char*> _TFetchOrientation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTFetchOrientationValues, _kTFetchOrientationNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TFetchOrientation::type& val) {
  std::map<int, const char*>::const_iterator it = _TFetchOrientation_VALUES_TO_NAMES.find(val);
  if (it != _TFetchOrientation_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TFetchOrientation::type& val) {
  std::map<int, const char*>::const_iterator it = _TFetchOrientation_VALUES_TO_NAMES.find(val);
  if (it != _TFetchOrientation_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTJobExecutionStatusValues[] = {
  TJobExecutionStatus::IN_PROGRESS,
  TJobExecutionStatus::COMPLETE,
  TJobExecutionStatus::NOT_AVAILABLE
};
const char* _kTJobExecutionStatusNames[] = {
  "IN_PROGRESS",
  "COMPLETE",
  "NOT_AVAILABLE"
};
const std::map<int, const char*> _TJobExecutionStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTJobExecutionStatusValues, _kTJobExecutionStatusNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TJobExecutionStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _TJobExecutionStatus_VALUES_TO_NAMES.find(val);
  if (it != _TJobExecutionStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TJobExecutionStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _TJobExecutionStatus_VALUES_TO_NAMES.find(val);
  if (it != _TJobExecutionStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


TTypeQualifierValue::~TTypeQualifierValue() noexcept {
}


void TTypeQualifierValue::__set_i32Value(const int32_t val) {
  this->i32Value = val;
__isset.i32Value = true;
}

void TTypeQualifierValue::__set_stringValue(const std::string& val) {
  this->stringValue = val;
__isset.stringValue = true;
}
std::ostream& operator<<(std::ostream& out, const TTypeQualifierValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTypeQualifierValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i32Value);
          this->__isset.i32Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stringValue);
          this->__isset.stringValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTypeQualifierValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTypeQualifierValue");

  if (this->__isset.i32Value) {
    xfer += oprot->writeFieldBegin("i32Value", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->i32Value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stringValue) {
    xfer += oprot->writeFieldBegin("stringValue", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->stringValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeQualifierValue &a, TTypeQualifierValue &b) {
  using ::std::swap;
  swap(a.i32Value, b.i32Value);
  swap(a.stringValue, b.stringValue);
  swap(a.__isset, b.__isset);
}

TTypeQualifierValue::TTypeQualifierValue(const TTypeQualifierValue& other0) {
  i32Value = other0.i32Value;
  stringValue = other0.stringValue;
  __isset = other0.__isset;
}
TTypeQualifierValue& TTypeQualifierValue::operator=(const TTypeQualifierValue& other1) {
  i32Value = other1.i32Value;
  stringValue = other1.stringValue;
  __isset = other1.__isset;
  return *this;
}
void TTypeQualifierValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTypeQualifierValue(";
  out << "i32Value="; (__isset.i32Value ? (out << to_string(i32Value)) : (out << "<null>"));
  out << ", " << "stringValue="; (__isset.stringValue ? (out << to_string(stringValue)) : (out << "<null>"));
  out << ")";
}


TTypeQualifiers::~TTypeQualifiers() noexcept {
}


void TTypeQualifiers::__set_qualifiers(const std::map<std::string, TTypeQualifierValue> & val) {
  this->qualifiers = val;
}
std::ostream& operator<<(std::ostream& out, const TTypeQualifiers& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTypeQualifiers::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_qualifiers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->qualifiers.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _ktype3;
            ::apache::thrift::protocol::TType _vtype4;
            xfer += iprot->readMapBegin(_ktype3, _vtype4, _size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              std::string _key7;
              xfer += iprot->readString(_key7);
              TTypeQualifierValue& _val8 = this->qualifiers[_key7];
              xfer += _val8.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_qualifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_qualifiers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTypeQualifiers::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTypeQualifiers");

  xfer += oprot->writeFieldBegin("qualifiers", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->qualifiers.size()));
    std::map<std::string, TTypeQualifierValue> ::const_iterator _iter9;
    for (_iter9 = this->qualifiers.begin(); _iter9 != this->qualifiers.end(); ++_iter9)
    {
      xfer += oprot->writeString(_iter9->first);
      xfer += _iter9->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeQualifiers &a, TTypeQualifiers &b) {
  using ::std::swap;
  swap(a.qualifiers, b.qualifiers);
}

TTypeQualifiers::TTypeQualifiers(const TTypeQualifiers& other10) {
  qualifiers = other10.qualifiers;
}
TTypeQualifiers& TTypeQualifiers::operator=(const TTypeQualifiers& other11) {
  qualifiers = other11.qualifiers;
  return *this;
}
void TTypeQualifiers::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTypeQualifiers(";
  out << "qualifiers=" << to_string(qualifiers);
  out << ")";
}


TPrimitiveTypeEntry::~TPrimitiveTypeEntry() noexcept {
}


void TPrimitiveTypeEntry::__set_type(const TTypeId::type val) {
  this->type = val;
}

void TPrimitiveTypeEntry::__set_typeQualifiers(const TTypeQualifiers& val) {
  this->typeQualifiers = val;
__isset.typeQualifiers = true;
}
std::ostream& operator<<(std::ostream& out, const TPrimitiveTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPrimitiveTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->type = static_cast<TTypeId::type>(ecast12);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->typeQualifiers.read(iprot);
          this->__isset.typeQualifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPrimitiveTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPrimitiveTypeEntry");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.typeQualifiers) {
    xfer += oprot->writeFieldBegin("typeQualifiers", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->typeQualifiers.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPrimitiveTypeEntry &a, TPrimitiveTypeEntry &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.typeQualifiers, b.typeQualifiers);
  swap(a.__isset, b.__isset);
}

TPrimitiveTypeEntry::TPrimitiveTypeEntry(const TPrimitiveTypeEntry& other13) {
  type = other13.type;
  typeQualifiers = other13.typeQualifiers;
  __isset = other13.__isset;
}
TPrimitiveTypeEntry& TPrimitiveTypeEntry::operator=(const TPrimitiveTypeEntry& other14) {
  type = other14.type;
  typeQualifiers = other14.typeQualifiers;
  __isset = other14.__isset;
  return *this;
}
void TPrimitiveTypeEntry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPrimitiveTypeEntry(";
  out << "type=" << to_string(type);
  out << ", " << "typeQualifiers="; (__isset.typeQualifiers ? (out << to_string(typeQualifiers)) : (out << "<null>"));
  out << ")";
}


TArrayTypeEntry::~TArrayTypeEntry() noexcept {
}


void TArrayTypeEntry::__set_objectTypePtr(const TTypeEntryPtr val) {
  this->objectTypePtr = val;
}
std::ostream& operator<<(std::ostream& out, const TArrayTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TArrayTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_objectTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->objectTypePtr);
          isset_objectTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_objectTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TArrayTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TArrayTypeEntry");

  xfer += oprot->writeFieldBegin("objectTypePtr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->objectTypePtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TArrayTypeEntry &a, TArrayTypeEntry &b) {
  using ::std::swap;
  swap(a.objectTypePtr, b.objectTypePtr);
}

TArrayTypeEntry::TArrayTypeEntry(const TArrayTypeEntry& other15) noexcept {
  objectTypePtr = other15.objectTypePtr;
}
TArrayTypeEntry& TArrayTypeEntry::operator=(const TArrayTypeEntry& other16) noexcept {
  objectTypePtr = other16.objectTypePtr;
  return *this;
}
void TArrayTypeEntry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TArrayTypeEntry(";
  out << "objectTypePtr=" << to_string(objectTypePtr);
  out << ")";
}


TMapTypeEntry::~TMapTypeEntry() noexcept {
}


void TMapTypeEntry::__set_keyTypePtr(const TTypeEntryPtr val) {
  this->keyTypePtr = val;
}

void TMapTypeEntry::__set_valueTypePtr(const TTypeEntryPtr val) {
  this->valueTypePtr = val;
}
std::ostream& operator<<(std::ostream& out, const TMapTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMapTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_keyTypePtr = false;
  bool isset_valueTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->keyTypePtr);
          isset_keyTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->valueTypePtr);
          isset_valueTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_keyTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valueTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMapTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMapTypeEntry");

  xfer += oprot->writeFieldBegin("keyTypePtr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->keyTypePtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valueTypePtr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->valueTypePtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMapTypeEntry &a, TMapTypeEntry &b) {
  using ::std::swap;
  swap(a.keyTypePtr, b.keyTypePtr);
  swap(a.valueTypePtr, b.valueTypePtr);
}

TMapTypeEntry::TMapTypeEntry(const TMapTypeEntry& other17) noexcept {
  keyTypePtr = other17.keyTypePtr;
  valueTypePtr = other17.valueTypePtr;
}
TMapTypeEntry& TMapTypeEntry::operator=(const TMapTypeEntry& other18) noexcept {
  keyTypePtr = other18.keyTypePtr;
  valueTypePtr = other18.valueTypePtr;
  return *this;
}
void TMapTypeEntry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMapTypeEntry(";
  out << "keyTypePtr=" << to_string(keyTypePtr);
  out << ", " << "valueTypePtr=" << to_string(valueTypePtr);
  out << ")";
}


TStructTypeEntry::~TStructTypeEntry() noexcept {
}


void TStructTypeEntry::__set_nameToTypePtr(const std::map<std::string, TTypeEntryPtr> & val) {
  this->nameToTypePtr = val;
}
std::ostream& operator<<(std::ostream& out, const TStructTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStructTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nameToTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->nameToTypePtr.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _ktype20;
            ::apache::thrift::protocol::TType _vtype21;
            xfer += iprot->readMapBegin(_ktype20, _vtype21, _size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              std::string _key24;
              xfer += iprot->readString(_key24);
              TTypeEntryPtr& _val25 = this->nameToTypePtr[_key24];
              xfer += iprot->readI32(_val25);
            }
            xfer += iprot->readMapEnd();
          }
          isset_nameToTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nameToTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStructTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStructTypeEntry");

  xfer += oprot->writeFieldBegin("nameToTypePtr", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->nameToTypePtr.size()));
    std::map<std::string, TTypeEntryPtr> ::const_iterator _iter26;
    for (_iter26 = this->nameToTypePtr.begin(); _iter26 != this->nameToTypePtr.end(); ++_iter26)
    {
      xfer += oprot->writeString(_iter26->first);
      xfer += oprot->writeI32(_iter26->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStructTypeEntry &a, TStructTypeEntry &b) {
  using ::std::swap;
  swap(a.nameToTypePtr, b.nameToTypePtr);
}

TStructTypeEntry::TStructTypeEntry(const TStructTypeEntry& other27) {
  nameToTypePtr = other27.nameToTypePtr;
}
TStructTypeEntry& TStructTypeEntry::operator=(const TStructTypeEntry& other28) {
  nameToTypePtr = other28.nameToTypePtr;
  return *this;
}
void TStructTypeEntry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStructTypeEntry(";
  out << "nameToTypePtr=" << to_string(nameToTypePtr);
  out << ")";
}


TUnionTypeEntry::~TUnionTypeEntry() noexcept {
}


void TUnionTypeEntry::__set_nameToTypePtr(const std::map<std::string, TTypeEntryPtr> & val) {
  this->nameToTypePtr = val;
}
std::ostream& operator<<(std::ostream& out, const TUnionTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUnionTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nameToTypePtr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->nameToTypePtr.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _ktype30;
            ::apache::thrift::protocol::TType _vtype31;
            xfer += iprot->readMapBegin(_ktype30, _vtype31, _size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              std::string _key34;
              xfer += iprot->readString(_key34);
              TTypeEntryPtr& _val35 = this->nameToTypePtr[_key34];
              xfer += iprot->readI32(_val35);
            }
            xfer += iprot->readMapEnd();
          }
          isset_nameToTypePtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nameToTypePtr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUnionTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUnionTypeEntry");

  xfer += oprot->writeFieldBegin("nameToTypePtr", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->nameToTypePtr.size()));
    std::map<std::string, TTypeEntryPtr> ::const_iterator _iter36;
    for (_iter36 = this->nameToTypePtr.begin(); _iter36 != this->nameToTypePtr.end(); ++_iter36)
    {
      xfer += oprot->writeString(_iter36->first);
      xfer += oprot->writeI32(_iter36->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUnionTypeEntry &a, TUnionTypeEntry &b) {
  using ::std::swap;
  swap(a.nameToTypePtr, b.nameToTypePtr);
}

TUnionTypeEntry::TUnionTypeEntry(const TUnionTypeEntry& other37) {
  nameToTypePtr = other37.nameToTypePtr;
}
TUnionTypeEntry& TUnionTypeEntry::operator=(const TUnionTypeEntry& other38) {
  nameToTypePtr = other38.nameToTypePtr;
  return *this;
}
void TUnionTypeEntry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUnionTypeEntry(";
  out << "nameToTypePtr=" << to_string(nameToTypePtr);
  out << ")";
}


TUserDefinedTypeEntry::~TUserDefinedTypeEntry() noexcept {
}


void TUserDefinedTypeEntry::__set_typeClassName(const std::string& val) {
  this->typeClassName = val;
}
std::ostream& operator<<(std::ostream& out, const TUserDefinedTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUserDefinedTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_typeClassName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typeClassName);
          isset_typeClassName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_typeClassName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUserDefinedTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUserDefinedTypeEntry");

  xfer += oprot->writeFieldBegin("typeClassName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->typeClassName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUserDefinedTypeEntry &a, TUserDefinedTypeEntry &b) {
  using ::std::swap;
  swap(a.typeClassName, b.typeClassName);
}

TUserDefinedTypeEntry::TUserDefinedTypeEntry(const TUserDefinedTypeEntry& other39) {
  typeClassName = other39.typeClassName;
}
TUserDefinedTypeEntry& TUserDefinedTypeEntry::operator=(const TUserDefinedTypeEntry& other40) {
  typeClassName = other40.typeClassName;
  return *this;
}
void TUserDefinedTypeEntry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUserDefinedTypeEntry(";
  out << "typeClassName=" << to_string(typeClassName);
  out << ")";
}


TTypeEntry::~TTypeEntry() noexcept {
}


void TTypeEntry::__set_primitiveEntry(const TPrimitiveTypeEntry& val) {
  this->primitiveEntry = val;
__isset.primitiveEntry = true;
}

void TTypeEntry::__set_arrayEntry(const TArrayTypeEntry& val) {
  this->arrayEntry = val;
__isset.arrayEntry = true;
}

void TTypeEntry::__set_mapEntry(const TMapTypeEntry& val) {
  this->mapEntry = val;
__isset.mapEntry = true;
}

void TTypeEntry::__set_structEntry(const TStructTypeEntry& val) {
  this->structEntry = val;
__isset.structEntry = true;
}

void TTypeEntry::__set_unionEntry(const TUnionTypeEntry& val) {
  this->unionEntry = val;
__isset.unionEntry = true;
}

void TTypeEntry::__set_userDefinedTypeEntry(const TUserDefinedTypeEntry& val) {
  this->userDefinedTypeEntry = val;
__isset.userDefinedTypeEntry = true;
}
std::ostream& operator<<(std::ostream& out, const TTypeEntry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTypeEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->primitiveEntry.read(iprot);
          this->__isset.primitiveEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->arrayEntry.read(iprot);
          this->__isset.arrayEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mapEntry.read(iprot);
          this->__isset.mapEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->structEntry.read(iprot);
          this->__isset.structEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->unionEntry.read(iprot);
          this->__isset.unionEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userDefinedTypeEntry.read(iprot);
          this->__isset.userDefinedTypeEntry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTypeEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTypeEntry");

  if (this->__isset.primitiveEntry) {
    xfer += oprot->writeFieldBegin("primitiveEntry", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->primitiveEntry.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.arrayEntry) {
    xfer += oprot->writeFieldBegin("arrayEntry", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->arrayEntry.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mapEntry) {
    xfer += oprot->writeFieldBegin("mapEntry", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->mapEntry.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.structEntry) {
    xfer += oprot->writeFieldBegin("structEntry", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->structEntry.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unionEntry) {
    xfer += oprot->writeFieldBegin("unionEntry", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->unionEntry.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userDefinedTypeEntry) {
    xfer += oprot->writeFieldBegin("userDefinedTypeEntry", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->userDefinedTypeEntry.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeEntry &a, TTypeEntry &b) {
  using ::std::swap;
  swap(a.primitiveEntry, b.primitiveEntry);
  swap(a.arrayEntry, b.arrayEntry);
  swap(a.mapEntry, b.mapEntry);
  swap(a.structEntry, b.structEntry);
  swap(a.unionEntry, b.unionEntry);
  swap(a.userDefinedTypeEntry, b.userDefinedTypeEntry);
  swap(a.__isset, b.__isset);
}

TTypeEntry::TTypeEntry(const TTypeEntry& other41) {
  primitiveEntry = other41.primitiveEntry;
  arrayEntry = other41.arrayEntry;
  mapEntry = other41.mapEntry;
  structEntry = other41.structEntry;
  unionEntry = other41.unionEntry;
  userDefinedTypeEntry = other41.userDefinedTypeEntry;
  __isset = other41.__isset;
}
TTypeEntry& TTypeEntry::operator=(const TTypeEntry& other42) {
  primitiveEntry = other42.primitiveEntry;
  arrayEntry = other42.arrayEntry;
  mapEntry = other42.mapEntry;
  structEntry = other42.structEntry;
  unionEntry = other42.unionEntry;
  userDefinedTypeEntry = other42.userDefinedTypeEntry;
  __isset = other42.__isset;
  return *this;
}
void TTypeEntry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTypeEntry(";
  out << "primitiveEntry="; (__isset.primitiveEntry ? (out << to_string(primitiveEntry)) : (out << "<null>"));
  out << ", " << "arrayEntry="; (__isset.arrayEntry ? (out << to_string(arrayEntry)) : (out << "<null>"));
  out << ", " << "mapEntry="; (__isset.mapEntry ? (out << to_string(mapEntry)) : (out << "<null>"));
  out << ", " << "structEntry="; (__isset.structEntry ? (out << to_string(structEntry)) : (out << "<null>"));
  out << ", " << "unionEntry="; (__isset.unionEntry ? (out << to_string(unionEntry)) : (out << "<null>"));
  out << ", " << "userDefinedTypeEntry="; (__isset.userDefinedTypeEntry ? (out << to_string(userDefinedTypeEntry)) : (out << "<null>"));
  out << ")";
}


TTypeDesc::~TTypeDesc() noexcept {
}


void TTypeDesc::__set_types(const std::vector<TTypeEntry> & val) {
  this->types = val;
}
std::ostream& operator<<(std::ostream& out, const TTypeDesc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTypeDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_types = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->types.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->types[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTypeDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTypeDesc");

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->types.size()));
    std::vector<TTypeEntry> ::const_iterator _iter48;
    for (_iter48 = this->types.begin(); _iter48 != this->types.end(); ++_iter48)
    {
      xfer += (*_iter48).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeDesc &a, TTypeDesc &b) {
  using ::std::swap;
  swap(a.types, b.types);
}

TTypeDesc::TTypeDesc(const TTypeDesc& other49) {
  types = other49.types;
}
TTypeDesc& TTypeDesc::operator=(const TTypeDesc& other50) {
  types = other50.types;
  return *this;
}
void TTypeDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTypeDesc(";
  out << "types=" << to_string(types);
  out << ")";
}


TColumnDesc::~TColumnDesc() noexcept {
}


void TColumnDesc::__set_columnName(const std::string& val) {
  this->columnName = val;
}

void TColumnDesc::__set_typeDesc(const TTypeDesc& val) {
  this->typeDesc = val;
}

void TColumnDesc::__set_position(const int32_t val) {
  this->position = val;
}

void TColumnDesc::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}
std::ostream& operator<<(std::ostream& out, const TColumnDesc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnName = false;
  bool isset_typeDesc = false;
  bool isset_position = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          isset_columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->typeDesc.read(iprot);
          isset_typeDesc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->position);
          isset_position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typeDesc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_position)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnDesc");

  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeDesc", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->typeDesc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->position);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnDesc &a, TColumnDesc &b) {
  using ::std::swap;
  swap(a.columnName, b.columnName);
  swap(a.typeDesc, b.typeDesc);
  swap(a.position, b.position);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

TColumnDesc::TColumnDesc(const TColumnDesc& other51) {
  columnName = other51.columnName;
  typeDesc = other51.typeDesc;
  position = other51.position;
  comment = other51.comment;
  __isset = other51.__isset;
}
TColumnDesc& TColumnDesc::operator=(const TColumnDesc& other52) {
  columnName = other52.columnName;
  typeDesc = other52.typeDesc;
  position = other52.position;
  comment = other52.comment;
  __isset = other52.__isset;
  return *this;
}
void TColumnDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnDesc(";
  out << "columnName=" << to_string(columnName);
  out << ", " << "typeDesc=" << to_string(typeDesc);
  out << ", " << "position=" << to_string(position);
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ")";
}


TTableSchema::~TTableSchema() noexcept {
}


void TTableSchema::__set_columns(const std::vector<TColumnDesc> & val) {
  this->columns = val;
}
std::ostream& operator<<(std::ostream& out, const TTableSchema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->columns.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += this->columns[_i57].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableSchema");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnDesc> ::const_iterator _iter58;
    for (_iter58 = this->columns.begin(); _iter58 != this->columns.end(); ++_iter58)
    {
      xfer += (*_iter58).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableSchema &a, TTableSchema &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
}

TTableSchema::TTableSchema(const TTableSchema& other59) {
  columns = other59.columns;
}
TTableSchema& TTableSchema::operator=(const TTableSchema& other60) {
  columns = other60.columns;
  return *this;
}
void TTableSchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableSchema(";
  out << "columns=" << to_string(columns);
  out << ")";
}


TBoolValue::~TBoolValue() noexcept {
}


void TBoolValue::__set_value(const bool val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const TBoolValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TBoolValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TBoolValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBoolValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBoolValue &a, TBoolValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TBoolValue::TBoolValue(const TBoolValue& other61) noexcept {
  value = other61.value;
  __isset = other61.__isset;
}
TBoolValue& TBoolValue::operator=(const TBoolValue& other62) noexcept {
  value = other62.value;
  __isset = other62.__isset;
  return *this;
}
void TBoolValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBoolValue(";
  out << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


TByteValue::~TByteValue() noexcept {
}


void TByteValue::__set_value(const int8_t val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const TByteValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TByteValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TByteValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TByteValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BYTE, 1);
    xfer += oprot->writeByte(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TByteValue &a, TByteValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TByteValue::TByteValue(const TByteValue& other63) noexcept {
  value = other63.value;
  __isset = other63.__isset;
}
TByteValue& TByteValue::operator=(const TByteValue& other64) noexcept {
  value = other64.value;
  __isset = other64.__isset;
  return *this;
}
void TByteValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TByteValue(";
  out << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


TI16Value::~TI16Value() noexcept {
}


void TI16Value::__set_value(const int16_t val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const TI16Value& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TI16Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TI16Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TI16Value");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I16, 1);
    xfer += oprot->writeI16(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TI16Value &a, TI16Value &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TI16Value::TI16Value(const TI16Value& other65) noexcept {
  value = other65.value;
  __isset = other65.__isset;
}
TI16Value& TI16Value::operator=(const TI16Value& other66) noexcept {
  value = other66.value;
  __isset = other66.__isset;
  return *this;
}
void TI16Value::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TI16Value(";
  out << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


TI32Value::~TI32Value() noexcept {
}


void TI32Value::__set_value(const int32_t val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const TI32Value& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TI32Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TI32Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TI32Value");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TI32Value &a, TI32Value &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TI32Value::TI32Value(const TI32Value& other67) noexcept {
  value = other67.value;
  __isset = other67.__isset;
}
TI32Value& TI32Value::operator=(const TI32Value& other68) noexcept {
  value = other68.value;
  __isset = other68.__isset;
  return *this;
}
void TI32Value::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TI32Value(";
  out << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


TI64Value::~TI64Value() noexcept {
}


void TI64Value::__set_value(const int64_t val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const TI64Value& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TI64Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TI64Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TI64Value");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TI64Value &a, TI64Value &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TI64Value::TI64Value(const TI64Value& other69) noexcept {
  value = other69.value;
  __isset = other69.__isset;
}
TI64Value& TI64Value::operator=(const TI64Value& other70) noexcept {
  value = other70.value;
  __isset = other70.__isset;
  return *this;
}
void TI64Value::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TI64Value(";
  out << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


TDoubleValue::~TDoubleValue() noexcept {
}


void TDoubleValue::__set_value(const double val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const TDoubleValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDoubleValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDoubleValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDoubleValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 1);
    xfer += oprot->writeDouble(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDoubleValue &a, TDoubleValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TDoubleValue::TDoubleValue(const TDoubleValue& other71) noexcept {
  value = other71.value;
  __isset = other71.__isset;
}
TDoubleValue& TDoubleValue::operator=(const TDoubleValue& other72) noexcept {
  value = other72.value;
  __isset = other72.__isset;
  return *this;
}
void TDoubleValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDoubleValue(";
  out << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


TStringValue::~TStringValue() noexcept {
}


void TStringValue::__set_value(const std::string& val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const TStringValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringValue &a, TStringValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TStringValue::TStringValue(const TStringValue& other73) {
  value = other73.value;
  __isset = other73.__isset;
}
TStringValue& TStringValue::operator=(const TStringValue& other74) {
  value = other74.value;
  __isset = other74.__isset;
  return *this;
}
void TStringValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringValue(";
  out << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


TColumnValue::~TColumnValue() noexcept {
}


void TColumnValue::__set_boolVal(const TBoolValue& val) {
  this->boolVal = val;
__isset.boolVal = true;
}

void TColumnValue::__set_byteVal(const TByteValue& val) {
  this->byteVal = val;
__isset.byteVal = true;
}

void TColumnValue::__set_i16Val(const TI16Value& val) {
  this->i16Val = val;
__isset.i16Val = true;
}

void TColumnValue::__set_i32Val(const TI32Value& val) {
  this->i32Val = val;
__isset.i32Val = true;
}

void TColumnValue::__set_i64Val(const TI64Value& val) {
  this->i64Val = val;
__isset.i64Val = true;
}

void TColumnValue::__set_doubleVal(const TDoubleValue& val) {
  this->doubleVal = val;
__isset.doubleVal = true;
}

void TColumnValue::__set_stringVal(const TStringValue& val) {
  this->stringVal = val;
__isset.stringVal = true;
}
std::ostream& operator<<(std::ostream& out, const TColumnValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->boolVal.read(iprot);
          this->__isset.boolVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->byteVal.read(iprot);
          this->__isset.byteVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i16Val.read(iprot);
          this->__isset.i16Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i32Val.read(iprot);
          this->__isset.i32Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i64Val.read(iprot);
          this->__isset.i64Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->doubleVal.read(iprot);
          this->__isset.doubleVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringVal.read(iprot);
          this->__isset.stringVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnValue");

  if (this->__isset.boolVal) {
    xfer += oprot->writeFieldBegin("boolVal", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->boolVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.byteVal) {
    xfer += oprot->writeFieldBegin("byteVal", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->byteVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i16Val) {
    xfer += oprot->writeFieldBegin("i16Val", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->i16Val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i32Val) {
    xfer += oprot->writeFieldBegin("i32Val", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->i32Val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i64Val) {
    xfer += oprot->writeFieldBegin("i64Val", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->i64Val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.doubleVal) {
    xfer += oprot->writeFieldBegin("doubleVal", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->doubleVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stringVal) {
    xfer += oprot->writeFieldBegin("stringVal", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->stringVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnValue &a, TColumnValue &b) {
  using ::std::swap;
  swap(a.boolVal, b.boolVal);
  swap(a.byteVal, b.byteVal);
  swap(a.i16Val, b.i16Val);
  swap(a.i32Val, b.i32Val);
  swap(a.i64Val, b.i64Val);
  swap(a.doubleVal, b.doubleVal);
  swap(a.stringVal, b.stringVal);
  swap(a.__isset, b.__isset);
}

TColumnValue::TColumnValue(const TColumnValue& other75) {
  boolVal = other75.boolVal;
  byteVal = other75.byteVal;
  i16Val = other75.i16Val;
  i32Val = other75.i32Val;
  i64Val = other75.i64Val;
  doubleVal = other75.doubleVal;
  stringVal = other75.stringVal;
  __isset = other75.__isset;
}
TColumnValue& TColumnValue::operator=(const TColumnValue& other76) {
  boolVal = other76.boolVal;
  byteVal = other76.byteVal;
  i16Val = other76.i16Val;
  i32Val = other76.i32Val;
  i64Val = other76.i64Val;
  doubleVal = other76.doubleVal;
  stringVal = other76.stringVal;
  __isset = other76.__isset;
  return *this;
}
void TColumnValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnValue(";
  out << "boolVal="; (__isset.boolVal ? (out << to_string(boolVal)) : (out << "<null>"));
  out << ", " << "byteVal="; (__isset.byteVal ? (out << to_string(byteVal)) : (out << "<null>"));
  out << ", " << "i16Val="; (__isset.i16Val ? (out << to_string(i16Val)) : (out << "<null>"));
  out << ", " << "i32Val="; (__isset.i32Val ? (out << to_string(i32Val)) : (out << "<null>"));
  out << ", " << "i64Val="; (__isset.i64Val ? (out << to_string(i64Val)) : (out << "<null>"));
  out << ", " << "doubleVal="; (__isset.doubleVal ? (out << to_string(doubleVal)) : (out << "<null>"));
  out << ", " << "stringVal="; (__isset.stringVal ? (out << to_string(stringVal)) : (out << "<null>"));
  out << ")";
}


TRow::~TRow() noexcept {
}


void TRow::__set_colVals(const std::vector<TColumnValue> & val) {
  this->colVals = val;
}
std::ostream& operator<<(std::ostream& out, const TRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colVals = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colVals.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->colVals.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->colVals[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colVals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRow");

  xfer += oprot->writeFieldBegin("colVals", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colVals.size()));
    std::vector<TColumnValue> ::const_iterator _iter82;
    for (_iter82 = this->colVals.begin(); _iter82 != this->colVals.end(); ++_iter82)
    {
      xfer += (*_iter82).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRow &a, TRow &b) {
  using ::std::swap;
  swap(a.colVals, b.colVals);
}

TRow::TRow(const TRow& other83) {
  colVals = other83.colVals;
}
TRow& TRow::operator=(const TRow& other84) {
  colVals = other84.colVals;
  return *this;
}
void TRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRow(";
  out << "colVals=" << to_string(colVals);
  out << ")";
}


TBoolColumn::~TBoolColumn() noexcept {
}


void TBoolColumn::__set_values(const std::vector<bool> & val) {
  this->values = val;
}

void TBoolColumn::__set_nulls(const std::string& val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TBoolColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TBoolColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->values.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += iprot->readBool(this->values[_i89]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBoolColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBoolColumn");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->values.size()));
    std::vector<bool> ::const_iterator _iter90;
    for (_iter90 = this->values.begin(); _iter90 != this->values.end(); ++_iter90)
    {
      xfer += oprot->writeBool((*_iter90));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBoolColumn &a, TBoolColumn &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

TBoolColumn::TBoolColumn(const TBoolColumn& other91) {
  values = other91.values;
  nulls = other91.nulls;
}
TBoolColumn& TBoolColumn::operator=(const TBoolColumn& other92) {
  values = other92.values;
  nulls = other92.nulls;
  return *this;
}
void TBoolColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBoolColumn(";
  out << "values=" << to_string(values);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TByteColumn::~TByteColumn() noexcept {
}


void TByteColumn::__set_values(const std::vector<int8_t> & val) {
  this->values = val;
}

void TByteColumn::__set_nulls(const std::string& val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TByteColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TByteColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->values.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += iprot->readByte(this->values[_i97]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TByteColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TByteColumn");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->values.size()));
    std::vector<int8_t> ::const_iterator _iter98;
    for (_iter98 = this->values.begin(); _iter98 != this->values.end(); ++_iter98)
    {
      xfer += oprot->writeByte((*_iter98));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TByteColumn &a, TByteColumn &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

TByteColumn::TByteColumn(const TByteColumn& other99) {
  values = other99.values;
  nulls = other99.nulls;
}
TByteColumn& TByteColumn::operator=(const TByteColumn& other100) {
  values = other100.values;
  nulls = other100.nulls;
  return *this;
}
void TByteColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TByteColumn(";
  out << "values=" << to_string(values);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TI16Column::~TI16Column() noexcept {
}


void TI16Column::__set_values(const std::vector<int16_t> & val) {
  this->values = val;
}

void TI16Column::__set_nulls(const std::string& val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TI16Column& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TI16Column::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            xfer += iprot->readListBegin(_etype104, _size101);
            this->values.resize(_size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              xfer += iprot->readI16(this->values[_i105]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TI16Column::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TI16Column");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->values.size()));
    std::vector<int16_t> ::const_iterator _iter106;
    for (_iter106 = this->values.begin(); _iter106 != this->values.end(); ++_iter106)
    {
      xfer += oprot->writeI16((*_iter106));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TI16Column &a, TI16Column &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

TI16Column::TI16Column(const TI16Column& other107) {
  values = other107.values;
  nulls = other107.nulls;
}
TI16Column& TI16Column::operator=(const TI16Column& other108) {
  values = other108.values;
  nulls = other108.nulls;
  return *this;
}
void TI16Column::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TI16Column(";
  out << "values=" << to_string(values);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TI32Column::~TI32Column() noexcept {
}


void TI32Column::__set_values(const std::vector<int32_t> & val) {
  this->values = val;
}

void TI32Column::__set_nulls(const std::string& val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TI32Column& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TI32Column::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size109;
            ::apache::thrift::protocol::TType _etype112;
            xfer += iprot->readListBegin(_etype112, _size109);
            this->values.resize(_size109);
            uint32_t _i113;
            for (_i113 = 0; _i113 < _size109; ++_i113)
            {
              xfer += iprot->readI32(this->values[_i113]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TI32Column::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TI32Column");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->values.size()));
    std::vector<int32_t> ::const_iterator _iter114;
    for (_iter114 = this->values.begin(); _iter114 != this->values.end(); ++_iter114)
    {
      xfer += oprot->writeI32((*_iter114));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TI32Column &a, TI32Column &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

TI32Column::TI32Column(const TI32Column& other115) {
  values = other115.values;
  nulls = other115.nulls;
}
TI32Column& TI32Column::operator=(const TI32Column& other116) {
  values = other116.values;
  nulls = other116.nulls;
  return *this;
}
void TI32Column::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TI32Column(";
  out << "values=" << to_string(values);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TI64Column::~TI64Column() noexcept {
}


void TI64Column::__set_values(const std::vector<int64_t> & val) {
  this->values = val;
}

void TI64Column::__set_nulls(const std::string& val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TI64Column& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TI64Column::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size117;
            ::apache::thrift::protocol::TType _etype120;
            xfer += iprot->readListBegin(_etype120, _size117);
            this->values.resize(_size117);
            uint32_t _i121;
            for (_i121 = 0; _i121 < _size117; ++_i121)
            {
              xfer += iprot->readI64(this->values[_i121]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TI64Column::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TI64Column");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->values.size()));
    std::vector<int64_t> ::const_iterator _iter122;
    for (_iter122 = this->values.begin(); _iter122 != this->values.end(); ++_iter122)
    {
      xfer += oprot->writeI64((*_iter122));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TI64Column &a, TI64Column &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

TI64Column::TI64Column(const TI64Column& other123) {
  values = other123.values;
  nulls = other123.nulls;
}
TI64Column& TI64Column::operator=(const TI64Column& other124) {
  values = other124.values;
  nulls = other124.nulls;
  return *this;
}
void TI64Column::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TI64Column(";
  out << "values=" << to_string(values);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TDoubleColumn::~TDoubleColumn() noexcept {
}


void TDoubleColumn::__set_values(const std::vector<double> & val) {
  this->values = val;
}

void TDoubleColumn::__set_nulls(const std::string& val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TDoubleColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDoubleColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _etype128;
            xfer += iprot->readListBegin(_etype128, _size125);
            this->values.resize(_size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              xfer += iprot->readDouble(this->values[_i129]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDoubleColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDoubleColumn");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->values.size()));
    std::vector<double> ::const_iterator _iter130;
    for (_iter130 = this->values.begin(); _iter130 != this->values.end(); ++_iter130)
    {
      xfer += oprot->writeDouble((*_iter130));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDoubleColumn &a, TDoubleColumn &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

TDoubleColumn::TDoubleColumn(const TDoubleColumn& other131) {
  values = other131.values;
  nulls = other131.nulls;
}
TDoubleColumn& TDoubleColumn::operator=(const TDoubleColumn& other132) {
  values = other132.values;
  nulls = other132.nulls;
  return *this;
}
void TDoubleColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDoubleColumn(";
  out << "values=" << to_string(values);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TStringColumn::~TStringColumn() noexcept {
}


void TStringColumn::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void TStringColumn::__set_nulls(const std::string& val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TStringColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _etype136;
            xfer += iprot->readListBegin(_etype136, _size133);
            this->values.resize(_size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              xfer += iprot->readString(this->values[_i137]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStringColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringColumn");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter138;
    for (_iter138 = this->values.begin(); _iter138 != this->values.end(); ++_iter138)
    {
      xfer += oprot->writeString((*_iter138));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringColumn &a, TStringColumn &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

TStringColumn::TStringColumn(const TStringColumn& other139) {
  values = other139.values;
  nulls = other139.nulls;
}
TStringColumn& TStringColumn::operator=(const TStringColumn& other140) {
  values = other140.values;
  nulls = other140.nulls;
  return *this;
}
void TStringColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringColumn(";
  out << "values=" << to_string(values);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TBinaryColumn::~TBinaryColumn() noexcept {
}


void TBinaryColumn::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void TBinaryColumn::__set_nulls(const std::string& val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TBinaryColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TBinaryColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;
  bool isset_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _etype144;
            xfer += iprot->readListBegin(_etype144, _size141);
            this->values.resize(_size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              xfer += iprot->readBinary(this->values[_i145]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->nulls);
          isset_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBinaryColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBinaryColumn");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter146;
    for (_iter146 = this->values.begin(); _iter146 != this->values.end(); ++_iter146)
    {
      xfer += oprot->writeBinary((*_iter146));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBinaryColumn &a, TBinaryColumn &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.nulls, b.nulls);
}

TBinaryColumn::TBinaryColumn(const TBinaryColumn& other147) {
  values = other147.values;
  nulls = other147.nulls;
}
TBinaryColumn& TBinaryColumn::operator=(const TBinaryColumn& other148) {
  values = other148.values;
  nulls = other148.nulls;
  return *this;
}
void TBinaryColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBinaryColumn(";
  out << "values=" << to_string(values);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TColumn::~TColumn() noexcept {
}


void TColumn::__set_boolVal(const TBoolColumn& val) {
  this->boolVal = val;
__isset.boolVal = true;
}

void TColumn::__set_byteVal(const TByteColumn& val) {
  this->byteVal = val;
__isset.byteVal = true;
}

void TColumn::__set_i16Val(const TI16Column& val) {
  this->i16Val = val;
__isset.i16Val = true;
}

void TColumn::__set_i32Val(const TI32Column& val) {
  this->i32Val = val;
__isset.i32Val = true;
}

void TColumn::__set_i64Val(const TI64Column& val) {
  this->i64Val = val;
__isset.i64Val = true;
}

void TColumn::__set_doubleVal(const TDoubleColumn& val) {
  this->doubleVal = val;
__isset.doubleVal = true;
}

void TColumn::__set_stringVal(const TStringColumn& val) {
  this->stringVal = val;
__isset.stringVal = true;
}

void TColumn::__set_binaryVal(const TBinaryColumn& val) {
  this->binaryVal = val;
__isset.binaryVal = true;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->boolVal.read(iprot);
          this->__isset.boolVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->byteVal.read(iprot);
          this->__isset.byteVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i16Val.read(iprot);
          this->__isset.i16Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i32Val.read(iprot);
          this->__isset.i32Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->i64Val.read(iprot);
          this->__isset.i64Val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->doubleVal.read(iprot);
          this->__isset.doubleVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringVal.read(iprot);
          this->__isset.stringVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->binaryVal.read(iprot);
          this->__isset.binaryVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  if (this->__isset.boolVal) {
    xfer += oprot->writeFieldBegin("boolVal", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->boolVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.byteVal) {
    xfer += oprot->writeFieldBegin("byteVal", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->byteVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i16Val) {
    xfer += oprot->writeFieldBegin("i16Val", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->i16Val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i32Val) {
    xfer += oprot->writeFieldBegin("i32Val", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->i32Val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i64Val) {
    xfer += oprot->writeFieldBegin("i64Val", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->i64Val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.doubleVal) {
    xfer += oprot->writeFieldBegin("doubleVal", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->doubleVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stringVal) {
    xfer += oprot->writeFieldBegin("stringVal", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->stringVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.binaryVal) {
    xfer += oprot->writeFieldBegin("binaryVal", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->binaryVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.boolVal, b.boolVal);
  swap(a.byteVal, b.byteVal);
  swap(a.i16Val, b.i16Val);
  swap(a.i32Val, b.i32Val);
  swap(a.i64Val, b.i64Val);
  swap(a.doubleVal, b.doubleVal);
  swap(a.stringVal, b.stringVal);
  swap(a.binaryVal, b.binaryVal);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other149) {
  boolVal = other149.boolVal;
  byteVal = other149.byteVal;
  i16Val = other149.i16Val;
  i32Val = other149.i32Val;
  i64Val = other149.i64Val;
  doubleVal = other149.doubleVal;
  stringVal = other149.stringVal;
  binaryVal = other149.binaryVal;
  __isset = other149.__isset;
}
TColumn& TColumn::operator=(const TColumn& other150) {
  boolVal = other150.boolVal;
  byteVal = other150.byteVal;
  i16Val = other150.i16Val;
  i32Val = other150.i32Val;
  i64Val = other150.i64Val;
  doubleVal = other150.doubleVal;
  stringVal = other150.stringVal;
  binaryVal = other150.binaryVal;
  __isset = other150.__isset;
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "boolVal="; (__isset.boolVal ? (out << to_string(boolVal)) : (out << "<null>"));
  out << ", " << "byteVal="; (__isset.byteVal ? (out << to_string(byteVal)) : (out << "<null>"));
  out << ", " << "i16Val="; (__isset.i16Val ? (out << to_string(i16Val)) : (out << "<null>"));
  out << ", " << "i32Val="; (__isset.i32Val ? (out << to_string(i32Val)) : (out << "<null>"));
  out << ", " << "i64Val="; (__isset.i64Val ? (out << to_string(i64Val)) : (out << "<null>"));
  out << ", " << "doubleVal="; (__isset.doubleVal ? (out << to_string(doubleVal)) : (out << "<null>"));
  out << ", " << "stringVal="; (__isset.stringVal ? (out << to_string(stringVal)) : (out << "<null>"));
  out << ", " << "binaryVal="; (__isset.binaryVal ? (out << to_string(binaryVal)) : (out << "<null>"));
  out << ")";
}


TRowSet::~TRowSet() noexcept {
}


void TRowSet::__set_startRowOffset(const int64_t val) {
  this->startRowOffset = val;
}

void TRowSet::__set_rows(const std::vector<TRow> & val) {
  this->rows = val;
}

void TRowSet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TRowSet::__set_binaryColumns(const std::string& val) {
  this->binaryColumns = val;
__isset.binaryColumns = true;
}

void TRowSet::__set_columnCount(const int32_t val) {
  this->columnCount = val;
__isset.columnCount = true;
}
std::ostream& operator<<(std::ostream& out, const TRowSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRowSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_startRowOffset = false;
  bool isset_rows = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startRowOffset);
          isset_startRowOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size151;
            ::apache::thrift::protocol::TType _etype154;
            xfer += iprot->readListBegin(_etype154, _size151);
            this->rows.resize(_size151);
            uint32_t _i155;
            for (_i155 = 0; _i155 < _size151; ++_i155)
            {
              xfer += this->rows[_i155].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _etype159;
            xfer += iprot->readListBegin(_etype159, _size156);
            this->columns.resize(_size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              xfer += this->columns[_i160].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->binaryColumns);
          this->__isset.binaryColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->columnCount);
          this->__isset.columnCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_startRowOffset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRowSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRowSet");

  xfer += oprot->writeFieldBegin("startRowOffset", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->startRowOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rows.size()));
    std::vector<TRow> ::const_iterator _iter161;
    for (_iter161 = this->rows.begin(); _iter161 != this->rows.end(); ++_iter161)
    {
      xfer += (*_iter161).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter162;
      for (_iter162 = this->columns.begin(); _iter162 != this->columns.end(); ++_iter162)
      {
        xfer += (*_iter162).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.binaryColumns) {
    xfer += oprot->writeFieldBegin("binaryColumns", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->binaryColumns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnCount) {
    xfer += oprot->writeFieldBegin("columnCount", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->columnCount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowSet &a, TRowSet &b) {
  using ::std::swap;
  swap(a.startRowOffset, b.startRowOffset);
  swap(a.rows, b.rows);
  swap(a.columns, b.columns);
  swap(a.binaryColumns, b.binaryColumns);
  swap(a.columnCount, b.columnCount);
  swap(a.__isset, b.__isset);
}

TRowSet::TRowSet(const TRowSet& other163) {
  startRowOffset = other163.startRowOffset;
  rows = other163.rows;
  columns = other163.columns;
  binaryColumns = other163.binaryColumns;
  columnCount = other163.columnCount;
  __isset = other163.__isset;
}
TRowSet& TRowSet::operator=(const TRowSet& other164) {
  startRowOffset = other164.startRowOffset;
  rows = other164.rows;
  columns = other164.columns;
  binaryColumns = other164.binaryColumns;
  columnCount = other164.columnCount;
  __isset = other164.__isset;
  return *this;
}
void TRowSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRowSet(";
  out << "startRowOffset=" << to_string(startRowOffset);
  out << ", " << "rows=" << to_string(rows);
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "binaryColumns="; (__isset.binaryColumns ? (out << to_string(binaryColumns)) : (out << "<null>"));
  out << ", " << "columnCount="; (__isset.columnCount ? (out << to_string(columnCount)) : (out << "<null>"));
  out << ")";
}


TStatus::~TStatus() noexcept {
}


void TStatus::__set_statusCode(const TStatusCode::type val) {
  this->statusCode = val;
}

void TStatus::__set_infoMessages(const std::vector<std::string> & val) {
  this->infoMessages = val;
__isset.infoMessages = true;
}

void TStatus::__set_sqlState(const std::string& val) {
  this->sqlState = val;
__isset.sqlState = true;
}

void TStatus::__set_errorCode(const int32_t val) {
  this->errorCode = val;
__isset.errorCode = true;
}

void TStatus::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}
std::ostream& operator<<(std::ostream& out, const TStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_statusCode = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast165;
          xfer += iprot->readI32(ecast165);
          this->statusCode = static_cast<TStatusCode::type>(ecast165);
          isset_statusCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->infoMessages.clear();
            uint32_t _size166;
            ::apache::thrift::protocol::TType _etype169;
            xfer += iprot->readListBegin(_etype169, _size166);
            this->infoMessages.resize(_size166);
            uint32_t _i170;
            for (_i170 = 0; _i170 < _size166; ++_i170)
            {
              xfer += iprot->readString(this->infoMessages[_i170]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.infoMessages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sqlState);
          this->__isset.sqlState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_statusCode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStatus");

  xfer += oprot->writeFieldBegin("statusCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->statusCode));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.infoMessages) {
    xfer += oprot->writeFieldBegin("infoMessages", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->infoMessages.size()));
      std::vector<std::string> ::const_iterator _iter171;
      for (_iter171 = this->infoMessages.begin(); _iter171 != this->infoMessages.end(); ++_iter171)
      {
        xfer += oprot->writeString((*_iter171));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sqlState) {
    xfer += oprot->writeFieldBegin("sqlState", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->sqlState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorCode) {
    xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->errorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStatus &a, TStatus &b) {
  using ::std::swap;
  swap(a.statusCode, b.statusCode);
  swap(a.infoMessages, b.infoMessages);
  swap(a.sqlState, b.sqlState);
  swap(a.errorCode, b.errorCode);
  swap(a.errorMessage, b.errorMessage);
  swap(a.__isset, b.__isset);
}

TStatus::TStatus(const TStatus& other172) {
  statusCode = other172.statusCode;
  infoMessages = other172.infoMessages;
  sqlState = other172.sqlState;
  errorCode = other172.errorCode;
  errorMessage = other172.errorMessage;
  __isset = other172.__isset;
}
TStatus& TStatus::operator=(const TStatus& other173) {
  statusCode = other173.statusCode;
  infoMessages = other173.infoMessages;
  sqlState = other173.sqlState;
  errorCode = other173.errorCode;
  errorMessage = other173.errorMessage;
  __isset = other173.__isset;
  return *this;
}
void TStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStatus(";
  out << "statusCode=" << to_string(statusCode);
  out << ", " << "infoMessages="; (__isset.infoMessages ? (out << to_string(infoMessages)) : (out << "<null>"));
  out << ", " << "sqlState="; (__isset.sqlState ? (out << to_string(sqlState)) : (out << "<null>"));
  out << ", " << "errorCode="; (__isset.errorCode ? (out << to_string(errorCode)) : (out << "<null>"));
  out << ", " << "errorMessage="; (__isset.errorMessage ? (out << to_string(errorMessage)) : (out << "<null>"));
  out << ")";
}


THandleIdentifier::~THandleIdentifier() noexcept {
}


void THandleIdentifier::__set_guid(const std::string& val) {
  this->guid = val;
}

void THandleIdentifier::__set_secret(const std::string& val) {
  this->secret = val;
}
std::ostream& operator<<(std::ostream& out, const THandleIdentifier& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THandleIdentifier::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_guid = false;
  bool isset_secret = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->guid);
          isset_guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->secret);
          isset_secret = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_guid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_secret)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THandleIdentifier::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THandleIdentifier");

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secret", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->secret);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THandleIdentifier &a, THandleIdentifier &b) {
  using ::std::swap;
  swap(a.guid, b.guid);
  swap(a.secret, b.secret);
}

THandleIdentifier::THandleIdentifier(const THandleIdentifier& other174) {
  guid = other174.guid;
  secret = other174.secret;
}
THandleIdentifier& THandleIdentifier::operator=(const THandleIdentifier& other175) {
  guid = other175.guid;
  secret = other175.secret;
  return *this;
}
void THandleIdentifier::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THandleIdentifier(";
  out << "guid=" << to_string(guid);
  out << ", " << "secret=" << to_string(secret);
  out << ")";
}


TSessionHandle::~TSessionHandle() noexcept {
}


void TSessionHandle::__set_sessionId(const THandleIdentifier& val) {
  this->sessionId = val;
}
std::ostream& operator<<(std::ostream& out, const TSessionHandle& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSessionHandle::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionId.read(iprot);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSessionHandle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSessionHandle");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSessionHandle &a, TSessionHandle &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
}

TSessionHandle::TSessionHandle(const TSessionHandle& other176) {
  sessionId = other176.sessionId;
}
TSessionHandle& TSessionHandle::operator=(const TSessionHandle& other177) {
  sessionId = other177.sessionId;
  return *this;
}
void TSessionHandle::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSessionHandle(";
  out << "sessionId=" << to_string(sessionId);
  out << ")";
}


TOperationHandle::~TOperationHandle() noexcept {
}


void TOperationHandle::__set_operationId(const THandleIdentifier& val) {
  this->operationId = val;
}

void TOperationHandle::__set_operationType(const TOperationType::type val) {
  this->operationType = val;
}

void TOperationHandle::__set_hasResultSet(const bool val) {
  this->hasResultSet = val;
}

void TOperationHandle::__set_modifiedRowCount(const double val) {
  this->modifiedRowCount = val;
__isset.modifiedRowCount = true;
}
std::ostream& operator<<(std::ostream& out, const TOperationHandle& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TOperationHandle::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationId = false;
  bool isset_operationType = false;
  bool isset_hasResultSet = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationId.read(iprot);
          isset_operationId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast178;
          xfer += iprot->readI32(ecast178);
          this->operationType = static_cast<TOperationType::type>(ecast178);
          isset_operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasResultSet);
          isset_hasResultSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->modifiedRowCount);
          this->__isset.modifiedRowCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_operationType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasResultSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOperationHandle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TOperationHandle");

  xfer += oprot->writeFieldBegin("operationId", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->operationType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasResultSet", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->hasResultSet);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.modifiedRowCount) {
    xfer += oprot->writeFieldBegin("modifiedRowCount", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->modifiedRowCount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOperationHandle &a, TOperationHandle &b) {
  using ::std::swap;
  swap(a.operationId, b.operationId);
  swap(a.operationType, b.operationType);
  swap(a.hasResultSet, b.hasResultSet);
  swap(a.modifiedRowCount, b.modifiedRowCount);
  swap(a.__isset, b.__isset);
}

TOperationHandle::TOperationHandle(const TOperationHandle& other179) {
  operationId = other179.operationId;
  operationType = other179.operationType;
  hasResultSet = other179.hasResultSet;
  modifiedRowCount = other179.modifiedRowCount;
  __isset = other179.__isset;
}
TOperationHandle& TOperationHandle::operator=(const TOperationHandle& other180) {
  operationId = other180.operationId;
  operationType = other180.operationType;
  hasResultSet = other180.hasResultSet;
  modifiedRowCount = other180.modifiedRowCount;
  __isset = other180.__isset;
  return *this;
}
void TOperationHandle::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TOperationHandle(";
  out << "operationId=" << to_string(operationId);
  out << ", " << "operationType=" << to_string(operationType);
  out << ", " << "hasResultSet=" << to_string(hasResultSet);
  out << ", " << "modifiedRowCount="; (__isset.modifiedRowCount ? (out << to_string(modifiedRowCount)) : (out << "<null>"));
  out << ")";
}


TOpenSessionReq::~TOpenSessionReq() noexcept {
}


void TOpenSessionReq::__set_client_protocol(const TProtocolVersion::type val) {
  this->client_protocol = val;
}

void TOpenSessionReq::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void TOpenSessionReq::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void TOpenSessionReq::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}
std::ostream& operator<<(std::ostream& out, const TOpenSessionReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TOpenSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_client_protocol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast181;
          xfer += iprot->readI32(ecast181);
          this->client_protocol = static_cast<TProtocolVersion::type>(ecast181);
          isset_client_protocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size182;
            ::apache::thrift::protocol::TType _ktype183;
            ::apache::thrift::protocol::TType _vtype184;
            xfer += iprot->readMapBegin(_ktype183, _vtype184, _size182);
            uint32_t _i186;
            for (_i186 = 0; _i186 < _size182; ++_i186)
            {
              std::string _key187;
              xfer += iprot->readString(_key187);
              std::string& _val188 = this->configuration[_key187];
              xfer += iprot->readString(_val188);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_client_protocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOpenSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TOpenSessionReq");

  xfer += oprot->writeFieldBegin("client_protocol", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->client_protocol));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter189;
      for (_iter189 = this->configuration.begin(); _iter189 != this->configuration.end(); ++_iter189)
      {
        xfer += oprot->writeString(_iter189->first);
        xfer += oprot->writeString(_iter189->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOpenSessionReq &a, TOpenSessionReq &b) {
  using ::std::swap;
  swap(a.client_protocol, b.client_protocol);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TOpenSessionReq::TOpenSessionReq(const TOpenSessionReq& other190) {
  client_protocol = other190.client_protocol;
  username = other190.username;
  password = other190.password;
  configuration = other190.configuration;
  __isset = other190.__isset;
}
TOpenSessionReq& TOpenSessionReq::operator=(const TOpenSessionReq& other191) {
  client_protocol = other191.client_protocol;
  username = other191.username;
  password = other191.password;
  configuration = other191.configuration;
  __isset = other191.__isset;
  return *this;
}
void TOpenSessionReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TOpenSessionReq(";
  out << "client_protocol=" << to_string(client_protocol);
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ")";
}


TOpenSessionResp::~TOpenSessionResp() noexcept {
}


void TOpenSessionResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TOpenSessionResp::__set_serverProtocolVersion(const TProtocolVersion::type val) {
  this->serverProtocolVersion = val;
}

void TOpenSessionResp::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
__isset.sessionHandle = true;
}

void TOpenSessionResp::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}
std::ostream& operator<<(std::ostream& out, const TOpenSessionResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TOpenSessionResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_serverProtocolVersion = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast192;
          xfer += iprot->readI32(ecast192);
          this->serverProtocolVersion = static_cast<TProtocolVersion::type>(ecast192);
          isset_serverProtocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          this->__isset.sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size193;
            ::apache::thrift::protocol::TType _ktype194;
            ::apache::thrift::protocol::TType _vtype195;
            xfer += iprot->readMapBegin(_ktype194, _vtype195, _size193);
            uint32_t _i197;
            for (_i197 = 0; _i197 < _size193; ++_i197)
            {
              std::string _key198;
              xfer += iprot->readString(_key198);
              std::string& _val199 = this->configuration[_key198];
              xfer += iprot->readString(_val199);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_serverProtocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOpenSessionResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TOpenSessionResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverProtocolVersion", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->serverProtocolVersion));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sessionHandle) {
    xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->sessionHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter200;
      for (_iter200 = this->configuration.begin(); _iter200 != this->configuration.end(); ++_iter200)
      {
        xfer += oprot->writeString(_iter200->first);
        xfer += oprot->writeString(_iter200->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOpenSessionResp &a, TOpenSessionResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.serverProtocolVersion, b.serverProtocolVersion);
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TOpenSessionResp::TOpenSessionResp(const TOpenSessionResp& other201) {
  status = other201.status;
  serverProtocolVersion = other201.serverProtocolVersion;
  sessionHandle = other201.sessionHandle;
  configuration = other201.configuration;
  __isset = other201.__isset;
}
TOpenSessionResp& TOpenSessionResp::operator=(const TOpenSessionResp& other202) {
  status = other202.status;
  serverProtocolVersion = other202.serverProtocolVersion;
  sessionHandle = other202.sessionHandle;
  configuration = other202.configuration;
  __isset = other202.__isset;
  return *this;
}
void TOpenSessionResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TOpenSessionResp(";
  out << "status=" << to_string(status);
  out << ", " << "serverProtocolVersion=" << to_string(serverProtocolVersion);
  out << ", " << "sessionHandle="; (__isset.sessionHandle ? (out << to_string(sessionHandle)) : (out << "<null>"));
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ")";
}


TSetClientInfoReq::~TSetClientInfoReq() noexcept {
}


void TSetClientInfoReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TSetClientInfoReq::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}
std::ostream& operator<<(std::ostream& out, const TSetClientInfoReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSetClientInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size203;
            ::apache::thrift::protocol::TType _ktype204;
            ::apache::thrift::protocol::TType _vtype205;
            xfer += iprot->readMapBegin(_ktype204, _vtype205, _size203);
            uint32_t _i207;
            for (_i207 = 0; _i207 < _size203; ++_i207)
            {
              std::string _key208;
              xfer += iprot->readString(_key208);
              std::string& _val209 = this->configuration[_key208];
              xfer += iprot->readString(_val209);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSetClientInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetClientInfoReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter210;
      for (_iter210 = this->configuration.begin(); _iter210 != this->configuration.end(); ++_iter210)
      {
        xfer += oprot->writeString(_iter210->first);
        xfer += oprot->writeString(_iter210->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSetClientInfoReq &a, TSetClientInfoReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TSetClientInfoReq::TSetClientInfoReq(const TSetClientInfoReq& other211) {
  sessionHandle = other211.sessionHandle;
  configuration = other211.configuration;
  __isset = other211.__isset;
}
TSetClientInfoReq& TSetClientInfoReq::operator=(const TSetClientInfoReq& other212) {
  sessionHandle = other212.sessionHandle;
  configuration = other212.configuration;
  __isset = other212.__isset;
  return *this;
}
void TSetClientInfoReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSetClientInfoReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ")";
}


TSetClientInfoResp::~TSetClientInfoResp() noexcept {
}


void TSetClientInfoResp::__set_status(const TStatus& val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const TSetClientInfoResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSetClientInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSetClientInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetClientInfoResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSetClientInfoResp &a, TSetClientInfoResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TSetClientInfoResp::TSetClientInfoResp(const TSetClientInfoResp& other213) {
  status = other213.status;
}
TSetClientInfoResp& TSetClientInfoResp::operator=(const TSetClientInfoResp& other214) {
  status = other214.status;
  return *this;
}
void TSetClientInfoResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSetClientInfoResp(";
  out << "status=" << to_string(status);
  out << ")";
}


TCloseSessionReq::~TCloseSessionReq() noexcept {
}


void TCloseSessionReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}
std::ostream& operator<<(std::ostream& out, const TCloseSessionReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCloseSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCloseSessionReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCloseSessionReq &a, TCloseSessionReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

TCloseSessionReq::TCloseSessionReq(const TCloseSessionReq& other215) {
  sessionHandle = other215.sessionHandle;
}
TCloseSessionReq& TCloseSessionReq::operator=(const TCloseSessionReq& other216) {
  sessionHandle = other216.sessionHandle;
  return *this;
}
void TCloseSessionReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCloseSessionReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ")";
}


TCloseSessionResp::~TCloseSessionResp() noexcept {
}


void TCloseSessionResp::__set_status(const TStatus& val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const TCloseSessionResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCloseSessionResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseSessionResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCloseSessionResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCloseSessionResp &a, TCloseSessionResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TCloseSessionResp::TCloseSessionResp(const TCloseSessionResp& other217) {
  status = other217.status;
}
TCloseSessionResp& TCloseSessionResp::operator=(const TCloseSessionResp& other218) {
  status = other218.status;
  return *this;
}
void TCloseSessionResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCloseSessionResp(";
  out << "status=" << to_string(status);
  out << ")";
}


TGetInfoValue::~TGetInfoValue() noexcept {
}


void TGetInfoValue::__set_stringValue(const std::string& val) {
  this->stringValue = val;
__isset.stringValue = true;
}

void TGetInfoValue::__set_smallIntValue(const int16_t val) {
  this->smallIntValue = val;
__isset.smallIntValue = true;
}

void TGetInfoValue::__set_integerBitmask(const int32_t val) {
  this->integerBitmask = val;
__isset.integerBitmask = true;
}

void TGetInfoValue::__set_integerFlag(const int32_t val) {
  this->integerFlag = val;
__isset.integerFlag = true;
}

void TGetInfoValue::__set_binaryValue(const int32_t val) {
  this->binaryValue = val;
__isset.binaryValue = true;
}

void TGetInfoValue::__set_lenValue(const int64_t val) {
  this->lenValue = val;
__isset.lenValue = true;
}
std::ostream& operator<<(std::ostream& out, const TGetInfoValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetInfoValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stringValue);
          this->__isset.stringValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->smallIntValue);
          this->__isset.smallIntValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->integerBitmask);
          this->__isset.integerBitmask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->integerFlag);
          this->__isset.integerFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->binaryValue);
          this->__isset.binaryValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lenValue);
          this->__isset.lenValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetInfoValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetInfoValue");

  if (this->__isset.stringValue) {
    xfer += oprot->writeFieldBegin("stringValue", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->stringValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.smallIntValue) {
    xfer += oprot->writeFieldBegin("smallIntValue", ::apache::thrift::protocol::T_I16, 2);
    xfer += oprot->writeI16(this->smallIntValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.integerBitmask) {
    xfer += oprot->writeFieldBegin("integerBitmask", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->integerBitmask);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.integerFlag) {
    xfer += oprot->writeFieldBegin("integerFlag", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->integerFlag);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.binaryValue) {
    xfer += oprot->writeFieldBegin("binaryValue", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->binaryValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lenValue) {
    xfer += oprot->writeFieldBegin("lenValue", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->lenValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetInfoValue &a, TGetInfoValue &b) {
  using ::std::swap;
  swap(a.stringValue, b.stringValue);
  swap(a.smallIntValue, b.smallIntValue);
  swap(a.integerBitmask, b.integerBitmask);
  swap(a.integerFlag, b.integerFlag);
  swap(a.binaryValue, b.binaryValue);
  swap(a.lenValue, b.lenValue);
  swap(a.__isset, b.__isset);
}

TGetInfoValue::TGetInfoValue(const TGetInfoValue& other219) {
  stringValue = other219.stringValue;
  smallIntValue = other219.smallIntValue;
  integerBitmask = other219.integerBitmask;
  integerFlag = other219.integerFlag;
  binaryValue = other219.binaryValue;
  lenValue = other219.lenValue;
  __isset = other219.__isset;
}
TGetInfoValue& TGetInfoValue::operator=(const TGetInfoValue& other220) {
  stringValue = other220.stringValue;
  smallIntValue = other220.smallIntValue;
  integerBitmask = other220.integerBitmask;
  integerFlag = other220.integerFlag;
  binaryValue = other220.binaryValue;
  lenValue = other220.lenValue;
  __isset = other220.__isset;
  return *this;
}
void TGetInfoValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetInfoValue(";
  out << "stringValue="; (__isset.stringValue ? (out << to_string(stringValue)) : (out << "<null>"));
  out << ", " << "smallIntValue="; (__isset.smallIntValue ? (out << to_string(smallIntValue)) : (out << "<null>"));
  out << ", " << "integerBitmask="; (__isset.integerBitmask ? (out << to_string(integerBitmask)) : (out << "<null>"));
  out << ", " << "integerFlag="; (__isset.integerFlag ? (out << to_string(integerFlag)) : (out << "<null>"));
  out << ", " << "binaryValue="; (__isset.binaryValue ? (out << to_string(binaryValue)) : (out << "<null>"));
  out << ", " << "lenValue="; (__isset.lenValue ? (out << to_string(lenValue)) : (out << "<null>"));
  out << ")";
}


TGetInfoReq::~TGetInfoReq() noexcept {
}


void TGetInfoReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetInfoReq::__set_infoType(const TGetInfoType::type val) {
  this->infoType = val;
}
std::ostream& operator<<(std::ostream& out, const TGetInfoReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_infoType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast221;
          xfer += iprot->readI32(ecast221);
          this->infoType = static_cast<TGetInfoType::type>(ecast221);
          isset_infoType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_infoType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetInfoReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infoType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->infoType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetInfoReq &a, TGetInfoReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.infoType, b.infoType);
}

TGetInfoReq::TGetInfoReq(const TGetInfoReq& other222) {
  sessionHandle = other222.sessionHandle;
  infoType = other222.infoType;
}
TGetInfoReq& TGetInfoReq::operator=(const TGetInfoReq& other223) {
  sessionHandle = other223.sessionHandle;
  infoType = other223.infoType;
  return *this;
}
void TGetInfoReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetInfoReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "infoType=" << to_string(infoType);
  out << ")";
}


TGetInfoResp::~TGetInfoResp() noexcept {
}


void TGetInfoResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetInfoResp::__set_infoValue(const TGetInfoValue& val) {
  this->infoValue = val;
}
std::ostream& operator<<(std::ostream& out, const TGetInfoResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_infoValue = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->infoValue.read(iprot);
          isset_infoValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_infoValue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetInfoResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infoValue", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->infoValue.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetInfoResp &a, TGetInfoResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.infoValue, b.infoValue);
}

TGetInfoResp::TGetInfoResp(const TGetInfoResp& other224) {
  status = other224.status;
  infoValue = other224.infoValue;
}
TGetInfoResp& TGetInfoResp::operator=(const TGetInfoResp& other225) {
  status = other225.status;
  infoValue = other225.infoValue;
  return *this;
}
void TGetInfoResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetInfoResp(";
  out << "status=" << to_string(status);
  out << ", " << "infoValue=" << to_string(infoValue);
  out << ")";
}


TExecuteStatementReq::~TExecuteStatementReq() noexcept {
}


void TExecuteStatementReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TExecuteStatementReq::__set_statement(const std::string& val) {
  this->statement = val;
}

void TExecuteStatementReq::__set_confOverlay(const std::map<std::string, std::string> & val) {
  this->confOverlay = val;
__isset.confOverlay = true;
}

void TExecuteStatementReq::__set_runAsync(const bool val) {
  this->runAsync = val;
__isset.runAsync = true;
}

void TExecuteStatementReq::__set_queryTimeout(const int64_t val) {
  this->queryTimeout = val;
__isset.queryTimeout = true;
}
std::ostream& operator<<(std::ostream& out, const TExecuteStatementReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TExecuteStatementReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_statement = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statement);
          isset_statement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->confOverlay.clear();
            uint32_t _size226;
            ::apache::thrift::protocol::TType _ktype227;
            ::apache::thrift::protocol::TType _vtype228;
            xfer += iprot->readMapBegin(_ktype227, _vtype228, _size226);
            uint32_t _i230;
            for (_i230 = 0; _i230 < _size226; ++_i230)
            {
              std::string _key231;
              xfer += iprot->readString(_key231);
              std::string& _val232 = this->confOverlay[_key231];
              xfer += iprot->readString(_val232);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.confOverlay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->runAsync);
          this->__isset.runAsync = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryTimeout);
          this->__isset.queryTimeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecuteStatementReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecuteStatementReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statement", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->statement);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.confOverlay) {
    xfer += oprot->writeFieldBegin("confOverlay", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->confOverlay.size()));
      std::map<std::string, std::string> ::const_iterator _iter233;
      for (_iter233 = this->confOverlay.begin(); _iter233 != this->confOverlay.end(); ++_iter233)
      {
        xfer += oprot->writeString(_iter233->first);
        xfer += oprot->writeString(_iter233->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.runAsync) {
    xfer += oprot->writeFieldBegin("runAsync", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->runAsync);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryTimeout) {
    xfer += oprot->writeFieldBegin("queryTimeout", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->queryTimeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecuteStatementReq &a, TExecuteStatementReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.statement, b.statement);
  swap(a.confOverlay, b.confOverlay);
  swap(a.runAsync, b.runAsync);
  swap(a.queryTimeout, b.queryTimeout);
  swap(a.__isset, b.__isset);
}

TExecuteStatementReq::TExecuteStatementReq(const TExecuteStatementReq& other234) {
  sessionHandle = other234.sessionHandle;
  statement = other234.statement;
  confOverlay = other234.confOverlay;
  runAsync = other234.runAsync;
  queryTimeout = other234.queryTimeout;
  __isset = other234.__isset;
}
TExecuteStatementReq& TExecuteStatementReq::operator=(const TExecuteStatementReq& other235) {
  sessionHandle = other235.sessionHandle;
  statement = other235.statement;
  confOverlay = other235.confOverlay;
  runAsync = other235.runAsync;
  queryTimeout = other235.queryTimeout;
  __isset = other235.__isset;
  return *this;
}
void TExecuteStatementReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecuteStatementReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "statement=" << to_string(statement);
  out << ", " << "confOverlay="; (__isset.confOverlay ? (out << to_string(confOverlay)) : (out << "<null>"));
  out << ", " << "runAsync="; (__isset.runAsync ? (out << to_string(runAsync)) : (out << "<null>"));
  out << ", " << "queryTimeout="; (__isset.queryTimeout ? (out << to_string(queryTimeout)) : (out << "<null>"));
  out << ")";
}


TExecuteStatementResp::~TExecuteStatementResp() noexcept {
}


void TExecuteStatementResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TExecuteStatementResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}
std::ostream& operator<<(std::ostream& out, const TExecuteStatementResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TExecuteStatementResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecuteStatementResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecuteStatementResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecuteStatementResp &a, TExecuteStatementResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TExecuteStatementResp::TExecuteStatementResp(const TExecuteStatementResp& other236) {
  status = other236.status;
  operationHandle = other236.operationHandle;
  __isset = other236.__isset;
}
TExecuteStatementResp& TExecuteStatementResp::operator=(const TExecuteStatementResp& other237) {
  status = other237.status;
  operationHandle = other237.operationHandle;
  __isset = other237.__isset;
  return *this;
}
void TExecuteStatementResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecuteStatementResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle="; (__isset.operationHandle ? (out << to_string(operationHandle)) : (out << "<null>"));
  out << ")";
}


TGetTypeInfoReq::~TGetTypeInfoReq() noexcept {
}


void TGetTypeInfoReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}
std::ostream& operator<<(std::ostream& out, const TGetTypeInfoReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetTypeInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTypeInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTypeInfoReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTypeInfoReq &a, TGetTypeInfoReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

TGetTypeInfoReq::TGetTypeInfoReq(const TGetTypeInfoReq& other238) {
  sessionHandle = other238.sessionHandle;
}
TGetTypeInfoReq& TGetTypeInfoReq::operator=(const TGetTypeInfoReq& other239) {
  sessionHandle = other239.sessionHandle;
  return *this;
}
void TGetTypeInfoReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetTypeInfoReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ")";
}


TGetTypeInfoResp::~TGetTypeInfoResp() noexcept {
}


void TGetTypeInfoResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetTypeInfoResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}
std::ostream& operator<<(std::ostream& out, const TGetTypeInfoResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetTypeInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTypeInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTypeInfoResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTypeInfoResp &a, TGetTypeInfoResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetTypeInfoResp::TGetTypeInfoResp(const TGetTypeInfoResp& other240) {
  status = other240.status;
  operationHandle = other240.operationHandle;
  __isset = other240.__isset;
}
TGetTypeInfoResp& TGetTypeInfoResp::operator=(const TGetTypeInfoResp& other241) {
  status = other241.status;
  operationHandle = other241.operationHandle;
  __isset = other241.__isset;
  return *this;
}
void TGetTypeInfoResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetTypeInfoResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle="; (__isset.operationHandle ? (out << to_string(operationHandle)) : (out << "<null>"));
  out << ")";
}


TUploadDataReq::~TUploadDataReq() noexcept {
}


void TUploadDataReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TUploadDataReq::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}

void TUploadDataReq::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void TUploadDataReq::__set_values(const std::string& val) {
  this->values = val;
}
std::ostream& operator<<(std::ostream& out, const TUploadDataReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUploadDataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->values);
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUploadDataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUploadDataReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->values);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUploadDataReq &a, TUploadDataReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.tableName, b.tableName);
  swap(a.path, b.path);
  swap(a.values, b.values);
  swap(a.__isset, b.__isset);
}

TUploadDataReq::TUploadDataReq(const TUploadDataReq& other242) {
  sessionHandle = other242.sessionHandle;
  tableName = other242.tableName;
  path = other242.path;
  values = other242.values;
  __isset = other242.__isset;
}
TUploadDataReq& TUploadDataReq::operator=(const TUploadDataReq& other243) {
  sessionHandle = other243.sessionHandle;
  tableName = other243.tableName;
  path = other243.path;
  values = other243.values;
  __isset = other243.__isset;
  return *this;
}
void TUploadDataReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUploadDataReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "values=" << to_string(values);
  out << ")";
}


TUploadDataResp::~TUploadDataResp() noexcept {
}


void TUploadDataResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TUploadDataResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}
std::ostream& operator<<(std::ostream& out, const TUploadDataResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUploadDataResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUploadDataResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUploadDataResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUploadDataResp &a, TUploadDataResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
}

TUploadDataResp::TUploadDataResp(const TUploadDataResp& other244) {
  status = other244.status;
  operationHandle = other244.operationHandle;
}
TUploadDataResp& TUploadDataResp::operator=(const TUploadDataResp& other245) {
  status = other245.status;
  operationHandle = other245.operationHandle;
  return *this;
}
void TUploadDataResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUploadDataResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle=" << to_string(operationHandle);
  out << ")";
}


TDownloadDataReq::~TDownloadDataReq() noexcept {
}


void TDownloadDataReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TDownloadDataReq::__set_tableName(const TPatternOrIdentifier& val) {
  this->tableName = val;
__isset.tableName = true;
}

void TDownloadDataReq::__set_query(const std::string& val) {
  this->query = val;
__isset.query = true;
}

void TDownloadDataReq::__set_format(const std::string& val) {
  this->format = val;
__isset.format = true;
}

void TDownloadDataReq::__set_downloadOptions(const std::map<std::string, std::string> & val) {
  this->downloadOptions = val;
__isset.downloadOptions = true;
}
std::ostream& operator<<(std::ostream& out, const TDownloadDataReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDownloadDataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query);
          this->__isset.query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->format);
          this->__isset.format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->downloadOptions.clear();
            uint32_t _size246;
            ::apache::thrift::protocol::TType _ktype247;
            ::apache::thrift::protocol::TType _vtype248;
            xfer += iprot->readMapBegin(_ktype247, _vtype248, _size246);
            uint32_t _i250;
            for (_i250 = 0; _i250 < _size246; ++_i250)
            {
              std::string _key251;
              xfer += iprot->readString(_key251);
              std::string& _val252 = this->downloadOptions[_key251];
              xfer += iprot->readString(_val252);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.downloadOptions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDownloadDataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDownloadDataReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query) {
    xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->query);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.format) {
    xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.downloadOptions) {
    xfer += oprot->writeFieldBegin("downloadOptions", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->downloadOptions.size()));
      std::map<std::string, std::string> ::const_iterator _iter253;
      for (_iter253 = this->downloadOptions.begin(); _iter253 != this->downloadOptions.end(); ++_iter253)
      {
        xfer += oprot->writeString(_iter253->first);
        xfer += oprot->writeString(_iter253->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDownloadDataReq &a, TDownloadDataReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.tableName, b.tableName);
  swap(a.query, b.query);
  swap(a.format, b.format);
  swap(a.downloadOptions, b.downloadOptions);
  swap(a.__isset, b.__isset);
}

TDownloadDataReq::TDownloadDataReq(const TDownloadDataReq& other254) {
  sessionHandle = other254.sessionHandle;
  tableName = other254.tableName;
  query = other254.query;
  format = other254.format;
  downloadOptions = other254.downloadOptions;
  __isset = other254.__isset;
}
TDownloadDataReq& TDownloadDataReq::operator=(const TDownloadDataReq& other255) {
  sessionHandle = other255.sessionHandle;
  tableName = other255.tableName;
  query = other255.query;
  format = other255.format;
  downloadOptions = other255.downloadOptions;
  __isset = other255.__isset;
  return *this;
}
void TDownloadDataReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDownloadDataReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "query="; (__isset.query ? (out << to_string(query)) : (out << "<null>"));
  out << ", " << "format="; (__isset.format ? (out << to_string(format)) : (out << "<null>"));
  out << ", " << "downloadOptions="; (__isset.downloadOptions ? (out << to_string(downloadOptions)) : (out << "<null>"));
  out << ")";
}


TDownloadDataResp::~TDownloadDataResp() noexcept {
}


void TDownloadDataResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TDownloadDataResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}
std::ostream& operator<<(std::ostream& out, const TDownloadDataResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDownloadDataResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDownloadDataResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDownloadDataResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDownloadDataResp &a, TDownloadDataResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
}

TDownloadDataResp::TDownloadDataResp(const TDownloadDataResp& other256) {
  status = other256.status;
  operationHandle = other256.operationHandle;
}
TDownloadDataResp& TDownloadDataResp::operator=(const TDownloadDataResp& other257) {
  status = other257.status;
  operationHandle = other257.operationHandle;
  return *this;
}
void TDownloadDataResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDownloadDataResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle=" << to_string(operationHandle);
  out << ")";
}


TGetCatalogsReq::~TGetCatalogsReq() noexcept {
}


void TGetCatalogsReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}
std::ostream& operator<<(std::ostream& out, const TGetCatalogsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetCatalogsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetCatalogsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetCatalogsReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetCatalogsReq &a, TGetCatalogsReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

TGetCatalogsReq::TGetCatalogsReq(const TGetCatalogsReq& other258) {
  sessionHandle = other258.sessionHandle;
}
TGetCatalogsReq& TGetCatalogsReq::operator=(const TGetCatalogsReq& other259) {
  sessionHandle = other259.sessionHandle;
  return *this;
}
void TGetCatalogsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetCatalogsReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ")";
}


TGetCatalogsResp::~TGetCatalogsResp() noexcept {
}


void TGetCatalogsResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetCatalogsResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}
std::ostream& operator<<(std::ostream& out, const TGetCatalogsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetCatalogsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetCatalogsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetCatalogsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetCatalogsResp &a, TGetCatalogsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetCatalogsResp::TGetCatalogsResp(const TGetCatalogsResp& other260) {
  status = other260.status;
  operationHandle = other260.operationHandle;
  __isset = other260.__isset;
}
TGetCatalogsResp& TGetCatalogsResp::operator=(const TGetCatalogsResp& other261) {
  status = other261.status;
  operationHandle = other261.operationHandle;
  __isset = other261.__isset;
  return *this;
}
void TGetCatalogsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetCatalogsResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle="; (__isset.operationHandle ? (out << to_string(operationHandle)) : (out << "<null>"));
  out << ")";
}


TGetSchemasReq::~TGetSchemasReq() noexcept {
}


void TGetSchemasReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetSchemasReq::__set_catalogName(const TIdentifier& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void TGetSchemasReq::__set_schemaName(const TPatternOrIdentifier& val) {
  this->schemaName = val;
__isset.schemaName = true;
}
std::ostream& operator<<(std::ostream& out, const TGetSchemasReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetSchemasReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetSchemasReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetSchemasReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetSchemasReq &a, TGetSchemasReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.__isset, b.__isset);
}

TGetSchemasReq::TGetSchemasReq(const TGetSchemasReq& other262) {
  sessionHandle = other262.sessionHandle;
  catalogName = other262.catalogName;
  schemaName = other262.schemaName;
  __isset = other262.__isset;
}
TGetSchemasReq& TGetSchemasReq::operator=(const TGetSchemasReq& other263) {
  sessionHandle = other263.sessionHandle;
  catalogName = other263.catalogName;
  schemaName = other263.schemaName;
  __isset = other263.__isset;
  return *this;
}
void TGetSchemasReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetSchemasReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "schemaName="; (__isset.schemaName ? (out << to_string(schemaName)) : (out << "<null>"));
  out << ")";
}


TGetSchemasResp::~TGetSchemasResp() noexcept {
}


void TGetSchemasResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetSchemasResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}
std::ostream& operator<<(std::ostream& out, const TGetSchemasResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetSchemasResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetSchemasResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetSchemasResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetSchemasResp &a, TGetSchemasResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetSchemasResp::TGetSchemasResp(const TGetSchemasResp& other264) {
  status = other264.status;
  operationHandle = other264.operationHandle;
  __isset = other264.__isset;
}
TGetSchemasResp& TGetSchemasResp::operator=(const TGetSchemasResp& other265) {
  status = other265.status;
  operationHandle = other265.operationHandle;
  __isset = other265.__isset;
  return *this;
}
void TGetSchemasResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetSchemasResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle="; (__isset.operationHandle ? (out << to_string(operationHandle)) : (out << "<null>"));
  out << ")";
}


TGetTablesReq::~TGetTablesReq() noexcept {
}


void TGetTablesReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetTablesReq::__set_catalogName(const TPatternOrIdentifier& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void TGetTablesReq::__set_schemaName(const TPatternOrIdentifier& val) {
  this->schemaName = val;
__isset.schemaName = true;
}

void TGetTablesReq::__set_tableName(const TPatternOrIdentifier& val) {
  this->tableName = val;
__isset.tableName = true;
}

void TGetTablesReq::__set_tableTypes(const std::vector<std::string> & val) {
  this->tableTypes = val;
__isset.tableTypes = true;
}
std::ostream& operator<<(std::ostream& out, const TGetTablesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetTablesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tableTypes.clear();
            uint32_t _size266;
            ::apache::thrift::protocol::TType _etype269;
            xfer += iprot->readListBegin(_etype269, _size266);
            this->tableTypes.resize(_size266);
            uint32_t _i270;
            for (_i270 = 0; _i270 < _size266; ++_i270)
            {
              xfer += iprot->readString(this->tableTypes[_i270]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tableTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTablesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTablesReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableTypes) {
    xfer += oprot->writeFieldBegin("tableTypes", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tableTypes.size()));
      std::vector<std::string> ::const_iterator _iter271;
      for (_iter271 = this->tableTypes.begin(); _iter271 != this->tableTypes.end(); ++_iter271)
      {
        xfer += oprot->writeString((*_iter271));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTablesReq &a, TGetTablesReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.tableName, b.tableName);
  swap(a.tableTypes, b.tableTypes);
  swap(a.__isset, b.__isset);
}

TGetTablesReq::TGetTablesReq(const TGetTablesReq& other272) {
  sessionHandle = other272.sessionHandle;
  catalogName = other272.catalogName;
  schemaName = other272.schemaName;
  tableName = other272.tableName;
  tableTypes = other272.tableTypes;
  __isset = other272.__isset;
}
TGetTablesReq& TGetTablesReq::operator=(const TGetTablesReq& other273) {
  sessionHandle = other273.sessionHandle;
  catalogName = other273.catalogName;
  schemaName = other273.schemaName;
  tableName = other273.tableName;
  tableTypes = other273.tableTypes;
  __isset = other273.__isset;
  return *this;
}
void TGetTablesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetTablesReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "schemaName="; (__isset.schemaName ? (out << to_string(schemaName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "tableTypes="; (__isset.tableTypes ? (out << to_string(tableTypes)) : (out << "<null>"));
  out << ")";
}


TGetTablesResp::~TGetTablesResp() noexcept {
}


void TGetTablesResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetTablesResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}
std::ostream& operator<<(std::ostream& out, const TGetTablesResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetTablesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTablesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTablesResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTablesResp &a, TGetTablesResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetTablesResp::TGetTablesResp(const TGetTablesResp& other274) {
  status = other274.status;
  operationHandle = other274.operationHandle;
  __isset = other274.__isset;
}
TGetTablesResp& TGetTablesResp::operator=(const TGetTablesResp& other275) {
  status = other275.status;
  operationHandle = other275.operationHandle;
  __isset = other275.__isset;
  return *this;
}
void TGetTablesResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetTablesResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle="; (__isset.operationHandle ? (out << to_string(operationHandle)) : (out << "<null>"));
  out << ")";
}


TGetTableTypesReq::~TGetTableTypesReq() noexcept {
}


void TGetTableTypesReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}
std::ostream& operator<<(std::ostream& out, const TGetTableTypesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetTableTypesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTableTypesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTableTypesReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTableTypesReq &a, TGetTableTypesReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
}

TGetTableTypesReq::TGetTableTypesReq(const TGetTableTypesReq& other276) {
  sessionHandle = other276.sessionHandle;
}
TGetTableTypesReq& TGetTableTypesReq::operator=(const TGetTableTypesReq& other277) {
  sessionHandle = other277.sessionHandle;
  return *this;
}
void TGetTableTypesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetTableTypesReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ")";
}


TGetTableTypesResp::~TGetTableTypesResp() noexcept {
}


void TGetTableTypesResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetTableTypesResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}
std::ostream& operator<<(std::ostream& out, const TGetTableTypesResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetTableTypesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetTableTypesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTableTypesResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTableTypesResp &a, TGetTableTypesResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetTableTypesResp::TGetTableTypesResp(const TGetTableTypesResp& other278) {
  status = other278.status;
  operationHandle = other278.operationHandle;
  __isset = other278.__isset;
}
TGetTableTypesResp& TGetTableTypesResp::operator=(const TGetTableTypesResp& other279) {
  status = other279.status;
  operationHandle = other279.operationHandle;
  __isset = other279.__isset;
  return *this;
}
void TGetTableTypesResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetTableTypesResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle="; (__isset.operationHandle ? (out << to_string(operationHandle)) : (out << "<null>"));
  out << ")";
}


TGetColumnsReq::~TGetColumnsReq() noexcept {
}


void TGetColumnsReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetColumnsReq::__set_catalogName(const TIdentifier& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void TGetColumnsReq::__set_schemaName(const TPatternOrIdentifier& val) {
  this->schemaName = val;
__isset.schemaName = true;
}

void TGetColumnsReq::__set_tableName(const TPatternOrIdentifier& val) {
  this->tableName = val;
__isset.tableName = true;
}

void TGetColumnsReq::__set_columnName(const TPatternOrIdentifier& val) {
  this->columnName = val;
__isset.columnName = true;
}
std::ostream& operator<<(std::ostream& out, const TGetColumnsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetColumnsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          this->__isset.columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetColumnsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetColumnsReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnName) {
    xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->columnName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetColumnsReq &a, TGetColumnsReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.tableName, b.tableName);
  swap(a.columnName, b.columnName);
  swap(a.__isset, b.__isset);
}

TGetColumnsReq::TGetColumnsReq(const TGetColumnsReq& other280) {
  sessionHandle = other280.sessionHandle;
  catalogName = other280.catalogName;
  schemaName = other280.schemaName;
  tableName = other280.tableName;
  columnName = other280.columnName;
  __isset = other280.__isset;
}
TGetColumnsReq& TGetColumnsReq::operator=(const TGetColumnsReq& other281) {
  sessionHandle = other281.sessionHandle;
  catalogName = other281.catalogName;
  schemaName = other281.schemaName;
  tableName = other281.tableName;
  columnName = other281.columnName;
  __isset = other281.__isset;
  return *this;
}
void TGetColumnsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetColumnsReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "schemaName="; (__isset.schemaName ? (out << to_string(schemaName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "columnName="; (__isset.columnName ? (out << to_string(columnName)) : (out << "<null>"));
  out << ")";
}


TGetColumnsResp::~TGetColumnsResp() noexcept {
}


void TGetColumnsResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetColumnsResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}
std::ostream& operator<<(std::ostream& out, const TGetColumnsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetColumnsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetColumnsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetColumnsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetColumnsResp &a, TGetColumnsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetColumnsResp::TGetColumnsResp(const TGetColumnsResp& other282) {
  status = other282.status;
  operationHandle = other282.operationHandle;
  __isset = other282.__isset;
}
TGetColumnsResp& TGetColumnsResp::operator=(const TGetColumnsResp& other283) {
  status = other283.status;
  operationHandle = other283.operationHandle;
  __isset = other283.__isset;
  return *this;
}
void TGetColumnsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetColumnsResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle="; (__isset.operationHandle ? (out << to_string(operationHandle)) : (out << "<null>"));
  out << ")";
}


TGetFunctionsReq::~TGetFunctionsReq() noexcept {
}


void TGetFunctionsReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetFunctionsReq::__set_catalogName(const TIdentifier& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void TGetFunctionsReq::__set_schemaName(const TPatternOrIdentifier& val) {
  this->schemaName = val;
__isset.schemaName = true;
}

void TGetFunctionsReq::__set_functionName(const TPatternOrIdentifier& val) {
  this->functionName = val;
}
std::ostream& operator<<(std::ostream& out, const TGetFunctionsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetFunctionsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_functionName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->functionName);
          isset_functionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_functionName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetFunctionsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetFunctionsReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("functionName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->functionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetFunctionsReq &a, TGetFunctionsReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.functionName, b.functionName);
  swap(a.__isset, b.__isset);
}

TGetFunctionsReq::TGetFunctionsReq(const TGetFunctionsReq& other284) {
  sessionHandle = other284.sessionHandle;
  catalogName = other284.catalogName;
  schemaName = other284.schemaName;
  functionName = other284.functionName;
  __isset = other284.__isset;
}
TGetFunctionsReq& TGetFunctionsReq::operator=(const TGetFunctionsReq& other285) {
  sessionHandle = other285.sessionHandle;
  catalogName = other285.catalogName;
  schemaName = other285.schemaName;
  functionName = other285.functionName;
  __isset = other285.__isset;
  return *this;
}
void TGetFunctionsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetFunctionsReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "schemaName="; (__isset.schemaName ? (out << to_string(schemaName)) : (out << "<null>"));
  out << ", " << "functionName=" << to_string(functionName);
  out << ")";
}


TGetFunctionsResp::~TGetFunctionsResp() noexcept {
}


void TGetFunctionsResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetFunctionsResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}
std::ostream& operator<<(std::ostream& out, const TGetFunctionsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetFunctionsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetFunctionsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetFunctionsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetFunctionsResp &a, TGetFunctionsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetFunctionsResp::TGetFunctionsResp(const TGetFunctionsResp& other286) {
  status = other286.status;
  operationHandle = other286.operationHandle;
  __isset = other286.__isset;
}
TGetFunctionsResp& TGetFunctionsResp::operator=(const TGetFunctionsResp& other287) {
  status = other287.status;
  operationHandle = other287.operationHandle;
  __isset = other287.__isset;
  return *this;
}
void TGetFunctionsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetFunctionsResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle="; (__isset.operationHandle ? (out << to_string(operationHandle)) : (out << "<null>"));
  out << ")";
}


TGetPrimaryKeysReq::~TGetPrimaryKeysReq() noexcept {
}


void TGetPrimaryKeysReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetPrimaryKeysReq::__set_catalogName(const TIdentifier& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void TGetPrimaryKeysReq::__set_schemaName(const TIdentifier& val) {
  this->schemaName = val;
__isset.schemaName = true;
}

void TGetPrimaryKeysReq::__set_tableName(const TIdentifier& val) {
  this->tableName = val;
__isset.tableName = true;
}
std::ostream& operator<<(std::ostream& out, const TGetPrimaryKeysReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetPrimaryKeysReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetPrimaryKeysReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetPrimaryKeysReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetPrimaryKeysReq &a, TGetPrimaryKeysReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.tableName, b.tableName);
  swap(a.__isset, b.__isset);
}

TGetPrimaryKeysReq::TGetPrimaryKeysReq(const TGetPrimaryKeysReq& other288) {
  sessionHandle = other288.sessionHandle;
  catalogName = other288.catalogName;
  schemaName = other288.schemaName;
  tableName = other288.tableName;
  __isset = other288.__isset;
}
TGetPrimaryKeysReq& TGetPrimaryKeysReq::operator=(const TGetPrimaryKeysReq& other289) {
  sessionHandle = other289.sessionHandle;
  catalogName = other289.catalogName;
  schemaName = other289.schemaName;
  tableName = other289.tableName;
  __isset = other289.__isset;
  return *this;
}
void TGetPrimaryKeysReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetPrimaryKeysReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "schemaName="; (__isset.schemaName ? (out << to_string(schemaName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ")";
}


TGetPrimaryKeysResp::~TGetPrimaryKeysResp() noexcept {
}


void TGetPrimaryKeysResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetPrimaryKeysResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}
std::ostream& operator<<(std::ostream& out, const TGetPrimaryKeysResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetPrimaryKeysResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetPrimaryKeysResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetPrimaryKeysResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetPrimaryKeysResp &a, TGetPrimaryKeysResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetPrimaryKeysResp::TGetPrimaryKeysResp(const TGetPrimaryKeysResp& other290) {
  status = other290.status;
  operationHandle = other290.operationHandle;
  __isset = other290.__isset;
}
TGetPrimaryKeysResp& TGetPrimaryKeysResp::operator=(const TGetPrimaryKeysResp& other291) {
  status = other291.status;
  operationHandle = other291.operationHandle;
  __isset = other291.__isset;
  return *this;
}
void TGetPrimaryKeysResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetPrimaryKeysResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle="; (__isset.operationHandle ? (out << to_string(operationHandle)) : (out << "<null>"));
  out << ")";
}


TGetCrossReferenceReq::~TGetCrossReferenceReq() noexcept {
}


void TGetCrossReferenceReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetCrossReferenceReq::__set_parentCatalogName(const TIdentifier& val) {
  this->parentCatalogName = val;
__isset.parentCatalogName = true;
}

void TGetCrossReferenceReq::__set_parentSchemaName(const TIdentifier& val) {
  this->parentSchemaName = val;
__isset.parentSchemaName = true;
}

void TGetCrossReferenceReq::__set_parentTableName(const TIdentifier& val) {
  this->parentTableName = val;
__isset.parentTableName = true;
}

void TGetCrossReferenceReq::__set_foreignCatalogName(const TIdentifier& val) {
  this->foreignCatalogName = val;
__isset.foreignCatalogName = true;
}

void TGetCrossReferenceReq::__set_foreignSchemaName(const TIdentifier& val) {
  this->foreignSchemaName = val;
__isset.foreignSchemaName = true;
}

void TGetCrossReferenceReq::__set_foreignTableName(const TIdentifier& val) {
  this->foreignTableName = val;
__isset.foreignTableName = true;
}
std::ostream& operator<<(std::ostream& out, const TGetCrossReferenceReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetCrossReferenceReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parentCatalogName);
          this->__isset.parentCatalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parentSchemaName);
          this->__isset.parentSchemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parentTableName);
          this->__isset.parentTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->foreignCatalogName);
          this->__isset.foreignCatalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->foreignSchemaName);
          this->__isset.foreignSchemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->foreignTableName);
          this->__isset.foreignTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetCrossReferenceReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetCrossReferenceReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.parentCatalogName) {
    xfer += oprot->writeFieldBegin("parentCatalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->parentCatalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parentSchemaName) {
    xfer += oprot->writeFieldBegin("parentSchemaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->parentSchemaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parentTableName) {
    xfer += oprot->writeFieldBegin("parentTableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->parentTableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.foreignCatalogName) {
    xfer += oprot->writeFieldBegin("foreignCatalogName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->foreignCatalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.foreignSchemaName) {
    xfer += oprot->writeFieldBegin("foreignSchemaName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->foreignSchemaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.foreignTableName) {
    xfer += oprot->writeFieldBegin("foreignTableName", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->foreignTableName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetCrossReferenceReq &a, TGetCrossReferenceReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.parentCatalogName, b.parentCatalogName);
  swap(a.parentSchemaName, b.parentSchemaName);
  swap(a.parentTableName, b.parentTableName);
  swap(a.foreignCatalogName, b.foreignCatalogName);
  swap(a.foreignSchemaName, b.foreignSchemaName);
  swap(a.foreignTableName, b.foreignTableName);
  swap(a.__isset, b.__isset);
}

TGetCrossReferenceReq::TGetCrossReferenceReq(const TGetCrossReferenceReq& other292) {
  sessionHandle = other292.sessionHandle;
  parentCatalogName = other292.parentCatalogName;
  parentSchemaName = other292.parentSchemaName;
  parentTableName = other292.parentTableName;
  foreignCatalogName = other292.foreignCatalogName;
  foreignSchemaName = other292.foreignSchemaName;
  foreignTableName = other292.foreignTableName;
  __isset = other292.__isset;
}
TGetCrossReferenceReq& TGetCrossReferenceReq::operator=(const TGetCrossReferenceReq& other293) {
  sessionHandle = other293.sessionHandle;
  parentCatalogName = other293.parentCatalogName;
  parentSchemaName = other293.parentSchemaName;
  parentTableName = other293.parentTableName;
  foreignCatalogName = other293.foreignCatalogName;
  foreignSchemaName = other293.foreignSchemaName;
  foreignTableName = other293.foreignTableName;
  __isset = other293.__isset;
  return *this;
}
void TGetCrossReferenceReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetCrossReferenceReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "parentCatalogName="; (__isset.parentCatalogName ? (out << to_string(parentCatalogName)) : (out << "<null>"));
  out << ", " << "parentSchemaName="; (__isset.parentSchemaName ? (out << to_string(parentSchemaName)) : (out << "<null>"));
  out << ", " << "parentTableName="; (__isset.parentTableName ? (out << to_string(parentTableName)) : (out << "<null>"));
  out << ", " << "foreignCatalogName="; (__isset.foreignCatalogName ? (out << to_string(foreignCatalogName)) : (out << "<null>"));
  out << ", " << "foreignSchemaName="; (__isset.foreignSchemaName ? (out << to_string(foreignSchemaName)) : (out << "<null>"));
  out << ", " << "foreignTableName="; (__isset.foreignTableName ? (out << to_string(foreignTableName)) : (out << "<null>"));
  out << ")";
}


TGetCrossReferenceResp::~TGetCrossReferenceResp() noexcept {
}


void TGetCrossReferenceResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetCrossReferenceResp::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
__isset.operationHandle = true;
}
std::ostream& operator<<(std::ostream& out, const TGetCrossReferenceResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetCrossReferenceResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          this->__isset.operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetCrossReferenceResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetCrossReferenceResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationHandle) {
    xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->operationHandle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetCrossReferenceResp &a, TGetCrossReferenceResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationHandle, b.operationHandle);
  swap(a.__isset, b.__isset);
}

TGetCrossReferenceResp::TGetCrossReferenceResp(const TGetCrossReferenceResp& other294) {
  status = other294.status;
  operationHandle = other294.operationHandle;
  __isset = other294.__isset;
}
TGetCrossReferenceResp& TGetCrossReferenceResp::operator=(const TGetCrossReferenceResp& other295) {
  status = other295.status;
  operationHandle = other295.operationHandle;
  __isset = other295.__isset;
  return *this;
}
void TGetCrossReferenceResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetCrossReferenceResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationHandle="; (__isset.operationHandle ? (out << to_string(operationHandle)) : (out << "<null>"));
  out << ")";
}


TGetOperationStatusReq::~TGetOperationStatusReq() noexcept {
}


void TGetOperationStatusReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}

void TGetOperationStatusReq::__set_getProgressUpdate(const bool val) {
  this->getProgressUpdate = val;
__isset.getProgressUpdate = true;
}
std::ostream& operator<<(std::ostream& out, const TGetOperationStatusReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetOperationStatusReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->getProgressUpdate);
          this->__isset.getProgressUpdate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetOperationStatusReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetOperationStatusReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.getProgressUpdate) {
    xfer += oprot->writeFieldBegin("getProgressUpdate", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->getProgressUpdate);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetOperationStatusReq &a, TGetOperationStatusReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
  swap(a.getProgressUpdate, b.getProgressUpdate);
  swap(a.__isset, b.__isset);
}

TGetOperationStatusReq::TGetOperationStatusReq(const TGetOperationStatusReq& other296) {
  operationHandle = other296.operationHandle;
  getProgressUpdate = other296.getProgressUpdate;
  __isset = other296.__isset;
}
TGetOperationStatusReq& TGetOperationStatusReq::operator=(const TGetOperationStatusReq& other297) {
  operationHandle = other297.operationHandle;
  getProgressUpdate = other297.getProgressUpdate;
  __isset = other297.__isset;
  return *this;
}
void TGetOperationStatusReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetOperationStatusReq(";
  out << "operationHandle=" << to_string(operationHandle);
  out << ", " << "getProgressUpdate="; (__isset.getProgressUpdate ? (out << to_string(getProgressUpdate)) : (out << "<null>"));
  out << ")";
}


TGetOperationStatusResp::~TGetOperationStatusResp() noexcept {
}


void TGetOperationStatusResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetOperationStatusResp::__set_operationState(const TOperationState::type val) {
  this->operationState = val;
__isset.operationState = true;
}

void TGetOperationStatusResp::__set_sqlState(const std::string& val) {
  this->sqlState = val;
__isset.sqlState = true;
}

void TGetOperationStatusResp::__set_errorCode(const int32_t val) {
  this->errorCode = val;
__isset.errorCode = true;
}

void TGetOperationStatusResp::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}

void TGetOperationStatusResp::__set_taskStatus(const std::string& val) {
  this->taskStatus = val;
__isset.taskStatus = true;
}

void TGetOperationStatusResp::__set_operationStarted(const int64_t val) {
  this->operationStarted = val;
__isset.operationStarted = true;
}

void TGetOperationStatusResp::__set_operationCompleted(const int64_t val) {
  this->operationCompleted = val;
__isset.operationCompleted = true;
}

void TGetOperationStatusResp::__set_hasResultSet(const bool val) {
  this->hasResultSet = val;
__isset.hasResultSet = true;
}

void TGetOperationStatusResp::__set_progressUpdateResponse(const TProgressUpdateResp& val) {
  this->progressUpdateResponse = val;
__isset.progressUpdateResponse = true;
}

void TGetOperationStatusResp::__set_numModifiedRows(const int64_t val) {
  this->numModifiedRows = val;
__isset.numModifiedRows = true;
}
std::ostream& operator<<(std::ostream& out, const TGetOperationStatusResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetOperationStatusResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast298;
          xfer += iprot->readI32(ecast298);
          this->operationState = static_cast<TOperationState::type>(ecast298);
          this->__isset.operationState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sqlState);
          this->__isset.sqlState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->taskStatus);
          this->__isset.taskStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->operationStarted);
          this->__isset.operationStarted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->operationCompleted);
          this->__isset.operationCompleted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasResultSet);
          this->__isset.hasResultSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->progressUpdateResponse.read(iprot);
          this->__isset.progressUpdateResponse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numModifiedRows);
          this->__isset.numModifiedRows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetOperationStatusResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetOperationStatusResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationState) {
    xfer += oprot->writeFieldBegin("operationState", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(static_cast<int32_t>(this->operationState));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sqlState) {
    xfer += oprot->writeFieldBegin("sqlState", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->sqlState);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorCode) {
    xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->errorCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.taskStatus) {
    xfer += oprot->writeFieldBegin("taskStatus", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->taskStatus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationStarted) {
    xfer += oprot->writeFieldBegin("operationStarted", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->operationStarted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationCompleted) {
    xfer += oprot->writeFieldBegin("operationCompleted", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->operationCompleted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hasResultSet) {
    xfer += oprot->writeFieldBegin("hasResultSet", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->hasResultSet);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progressUpdateResponse) {
    xfer += oprot->writeFieldBegin("progressUpdateResponse", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->progressUpdateResponse.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.numModifiedRows) {
    xfer += oprot->writeFieldBegin("numModifiedRows", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->numModifiedRows);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetOperationStatusResp &a, TGetOperationStatusResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.operationState, b.operationState);
  swap(a.sqlState, b.sqlState);
  swap(a.errorCode, b.errorCode);
  swap(a.errorMessage, b.errorMessage);
  swap(a.taskStatus, b.taskStatus);
  swap(a.operationStarted, b.operationStarted);
  swap(a.operationCompleted, b.operationCompleted);
  swap(a.hasResultSet, b.hasResultSet);
  swap(a.progressUpdateResponse, b.progressUpdateResponse);
  swap(a.numModifiedRows, b.numModifiedRows);
  swap(a.__isset, b.__isset);
}

TGetOperationStatusResp::TGetOperationStatusResp(const TGetOperationStatusResp& other299) {
  status = other299.status;
  operationState = other299.operationState;
  sqlState = other299.sqlState;
  errorCode = other299.errorCode;
  errorMessage = other299.errorMessage;
  taskStatus = other299.taskStatus;
  operationStarted = other299.operationStarted;
  operationCompleted = other299.operationCompleted;
  hasResultSet = other299.hasResultSet;
  progressUpdateResponse = other299.progressUpdateResponse;
  numModifiedRows = other299.numModifiedRows;
  __isset = other299.__isset;
}
TGetOperationStatusResp& TGetOperationStatusResp::operator=(const TGetOperationStatusResp& other300) {
  status = other300.status;
  operationState = other300.operationState;
  sqlState = other300.sqlState;
  errorCode = other300.errorCode;
  errorMessage = other300.errorMessage;
  taskStatus = other300.taskStatus;
  operationStarted = other300.operationStarted;
  operationCompleted = other300.operationCompleted;
  hasResultSet = other300.hasResultSet;
  progressUpdateResponse = other300.progressUpdateResponse;
  numModifiedRows = other300.numModifiedRows;
  __isset = other300.__isset;
  return *this;
}
void TGetOperationStatusResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetOperationStatusResp(";
  out << "status=" << to_string(status);
  out << ", " << "operationState="; (__isset.operationState ? (out << to_string(operationState)) : (out << "<null>"));
  out << ", " << "sqlState="; (__isset.sqlState ? (out << to_string(sqlState)) : (out << "<null>"));
  out << ", " << "errorCode="; (__isset.errorCode ? (out << to_string(errorCode)) : (out << "<null>"));
  out << ", " << "errorMessage="; (__isset.errorMessage ? (out << to_string(errorMessage)) : (out << "<null>"));
  out << ", " << "taskStatus="; (__isset.taskStatus ? (out << to_string(taskStatus)) : (out << "<null>"));
  out << ", " << "operationStarted="; (__isset.operationStarted ? (out << to_string(operationStarted)) : (out << "<null>"));
  out << ", " << "operationCompleted="; (__isset.operationCompleted ? (out << to_string(operationCompleted)) : (out << "<null>"));
  out << ", " << "hasResultSet="; (__isset.hasResultSet ? (out << to_string(hasResultSet)) : (out << "<null>"));
  out << ", " << "progressUpdateResponse="; (__isset.progressUpdateResponse ? (out << to_string(progressUpdateResponse)) : (out << "<null>"));
  out << ", " << "numModifiedRows="; (__isset.numModifiedRows ? (out << to_string(numModifiedRows)) : (out << "<null>"));
  out << ")";
}


TCancelOperationReq::~TCancelOperationReq() noexcept {
}


void TCancelOperationReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}
std::ostream& operator<<(std::ostream& out, const TCancelOperationReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCancelOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCancelOperationReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelOperationReq &a, TCancelOperationReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

TCancelOperationReq::TCancelOperationReq(const TCancelOperationReq& other301) {
  operationHandle = other301.operationHandle;
}
TCancelOperationReq& TCancelOperationReq::operator=(const TCancelOperationReq& other302) {
  operationHandle = other302.operationHandle;
  return *this;
}
void TCancelOperationReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCancelOperationReq(";
  out << "operationHandle=" << to_string(operationHandle);
  out << ")";
}


TCancelOperationResp::~TCancelOperationResp() noexcept {
}


void TCancelOperationResp::__set_status(const TStatus& val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const TCancelOperationResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCancelOperationResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelOperationResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCancelOperationResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelOperationResp &a, TCancelOperationResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TCancelOperationResp::TCancelOperationResp(const TCancelOperationResp& other303) {
  status = other303.status;
}
TCancelOperationResp& TCancelOperationResp::operator=(const TCancelOperationResp& other304) {
  status = other304.status;
  return *this;
}
void TCancelOperationResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCancelOperationResp(";
  out << "status=" << to_string(status);
  out << ")";
}


TCloseOperationReq::~TCloseOperationReq() noexcept {
}


void TCloseOperationReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}
std::ostream& operator<<(std::ostream& out, const TCloseOperationReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCloseOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCloseOperationReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCloseOperationReq &a, TCloseOperationReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

TCloseOperationReq::TCloseOperationReq(const TCloseOperationReq& other305) {
  operationHandle = other305.operationHandle;
}
TCloseOperationReq& TCloseOperationReq::operator=(const TCloseOperationReq& other306) {
  operationHandle = other306.operationHandle;
  return *this;
}
void TCloseOperationReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCloseOperationReq(";
  out << "operationHandle=" << to_string(operationHandle);
  out << ")";
}


TCloseOperationResp::~TCloseOperationResp() noexcept {
}


void TCloseOperationResp::__set_status(const TStatus& val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const TCloseOperationResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCloseOperationResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloseOperationResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCloseOperationResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCloseOperationResp &a, TCloseOperationResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TCloseOperationResp::TCloseOperationResp(const TCloseOperationResp& other307) {
  status = other307.status;
}
TCloseOperationResp& TCloseOperationResp::operator=(const TCloseOperationResp& other308) {
  status = other308.status;
  return *this;
}
void TCloseOperationResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCloseOperationResp(";
  out << "status=" << to_string(status);
  out << ")";
}


TGetResultSetMetadataReq::~TGetResultSetMetadataReq() noexcept {
}


void TGetResultSetMetadataReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}
std::ostream& operator<<(std::ostream& out, const TGetResultSetMetadataReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetResultSetMetadataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetResultSetMetadataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetResultSetMetadataReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetResultSetMetadataReq &a, TGetResultSetMetadataReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

TGetResultSetMetadataReq::TGetResultSetMetadataReq(const TGetResultSetMetadataReq& other309) {
  operationHandle = other309.operationHandle;
}
TGetResultSetMetadataReq& TGetResultSetMetadataReq::operator=(const TGetResultSetMetadataReq& other310) {
  operationHandle = other310.operationHandle;
  return *this;
}
void TGetResultSetMetadataReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetResultSetMetadataReq(";
  out << "operationHandle=" << to_string(operationHandle);
  out << ")";
}


TGetResultSetMetadataResp::~TGetResultSetMetadataResp() noexcept {
}


void TGetResultSetMetadataResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetResultSetMetadataResp::__set_schema(const TTableSchema& val) {
  this->schema = val;
__isset.schema = true;
}
std::ostream& operator<<(std::ostream& out, const TGetResultSetMetadataResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetResultSetMetadataResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema.read(iprot);
          this->__isset.schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetResultSetMetadataResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetResultSetMetadataResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.schema) {
    xfer += oprot->writeFieldBegin("schema", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->schema.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetResultSetMetadataResp &a, TGetResultSetMetadataResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.schema, b.schema);
  swap(a.__isset, b.__isset);
}

TGetResultSetMetadataResp::TGetResultSetMetadataResp(const TGetResultSetMetadataResp& other311) {
  status = other311.status;
  schema = other311.schema;
  __isset = other311.__isset;
}
TGetResultSetMetadataResp& TGetResultSetMetadataResp::operator=(const TGetResultSetMetadataResp& other312) {
  status = other312.status;
  schema = other312.schema;
  __isset = other312.__isset;
  return *this;
}
void TGetResultSetMetadataResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetResultSetMetadataResp(";
  out << "status=" << to_string(status);
  out << ", " << "schema="; (__isset.schema ? (out << to_string(schema)) : (out << "<null>"));
  out << ")";
}


TFetchResultsReq::~TFetchResultsReq() noexcept {
}


void TFetchResultsReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}

void TFetchResultsReq::__set_orientation(const TFetchOrientation::type val) {
  this->orientation = val;
}

void TFetchResultsReq::__set_maxRows(const int64_t val) {
  this->maxRows = val;
}

void TFetchResultsReq::__set_fetchType(const int16_t val) {
  this->fetchType = val;
__isset.fetchType = true;
}
std::ostream& operator<<(std::ostream& out, const TFetchResultsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFetchResultsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;
  bool isset_orientation = false;
  bool isset_maxRows = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast313;
          xfer += iprot->readI32(ecast313);
          this->orientation = static_cast<TFetchOrientation::type>(ecast313);
          isset_orientation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxRows);
          isset_maxRows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->fetchType);
          this->__isset.fetchType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_orientation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxRows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchResultsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFetchResultsReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("orientation", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->orientation));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxRows", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->maxRows);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchType) {
    xfer += oprot->writeFieldBegin("fetchType", ::apache::thrift::protocol::T_I16, 4);
    xfer += oprot->writeI16(this->fetchType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchResultsReq &a, TFetchResultsReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
  swap(a.orientation, b.orientation);
  swap(a.maxRows, b.maxRows);
  swap(a.fetchType, b.fetchType);
  swap(a.__isset, b.__isset);
}

TFetchResultsReq::TFetchResultsReq(const TFetchResultsReq& other314) {
  operationHandle = other314.operationHandle;
  orientation = other314.orientation;
  maxRows = other314.maxRows;
  fetchType = other314.fetchType;
  __isset = other314.__isset;
}
TFetchResultsReq& TFetchResultsReq::operator=(const TFetchResultsReq& other315) {
  operationHandle = other315.operationHandle;
  orientation = other315.orientation;
  maxRows = other315.maxRows;
  fetchType = other315.fetchType;
  __isset = other315.__isset;
  return *this;
}
void TFetchResultsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFetchResultsReq(";
  out << "operationHandle=" << to_string(operationHandle);
  out << ", " << "orientation=" << to_string(orientation);
  out << ", " << "maxRows=" << to_string(maxRows);
  out << ", " << "fetchType="; (__isset.fetchType ? (out << to_string(fetchType)) : (out << "<null>"));
  out << ")";
}


TFetchResultsResp::~TFetchResultsResp() noexcept {
}


void TFetchResultsResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TFetchResultsResp::__set_hasMoreRows(const bool val) {
  this->hasMoreRows = val;
__isset.hasMoreRows = true;
}

void TFetchResultsResp::__set_results(const TRowSet& val) {
  this->results = val;
__isset.results = true;
}
std::ostream& operator<<(std::ostream& out, const TFetchResultsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFetchResultsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasMoreRows);
          this->__isset.hasMoreRows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->results.read(iprot);
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchResultsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFetchResultsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hasMoreRows) {
    xfer += oprot->writeFieldBegin("hasMoreRows", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->hasMoreRows);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.results) {
    xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->results.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchResultsResp &a, TFetchResultsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.hasMoreRows, b.hasMoreRows);
  swap(a.results, b.results);
  swap(a.__isset, b.__isset);
}

TFetchResultsResp::TFetchResultsResp(const TFetchResultsResp& other316) {
  status = other316.status;
  hasMoreRows = other316.hasMoreRows;
  results = other316.results;
  __isset = other316.__isset;
}
TFetchResultsResp& TFetchResultsResp::operator=(const TFetchResultsResp& other317) {
  status = other317.status;
  hasMoreRows = other317.hasMoreRows;
  results = other317.results;
  __isset = other317.__isset;
  return *this;
}
void TFetchResultsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFetchResultsResp(";
  out << "status=" << to_string(status);
  out << ", " << "hasMoreRows="; (__isset.hasMoreRows ? (out << to_string(hasMoreRows)) : (out << "<null>"));
  out << ", " << "results="; (__isset.results ? (out << to_string(results)) : (out << "<null>"));
  out << ")";
}


TGetDelegationTokenReq::~TGetDelegationTokenReq() noexcept {
}


void TGetDelegationTokenReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TGetDelegationTokenReq::__set_owner(const std::string& val) {
  this->owner = val;
}

void TGetDelegationTokenReq::__set_renewer(const std::string& val) {
  this->renewer = val;
}
std::ostream& operator<<(std::ostream& out, const TGetDelegationTokenReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetDelegationTokenReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_owner = false;
  bool isset_renewer = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->renewer);
          isset_renewer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_renewer)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetDelegationTokenReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetDelegationTokenReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("renewer", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->renewer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetDelegationTokenReq &a, TGetDelegationTokenReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.owner, b.owner);
  swap(a.renewer, b.renewer);
}

TGetDelegationTokenReq::TGetDelegationTokenReq(const TGetDelegationTokenReq& other318) {
  sessionHandle = other318.sessionHandle;
  owner = other318.owner;
  renewer = other318.renewer;
}
TGetDelegationTokenReq& TGetDelegationTokenReq::operator=(const TGetDelegationTokenReq& other319) {
  sessionHandle = other319.sessionHandle;
  owner = other319.owner;
  renewer = other319.renewer;
  return *this;
}
void TGetDelegationTokenReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetDelegationTokenReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "owner=" << to_string(owner);
  out << ", " << "renewer=" << to_string(renewer);
  out << ")";
}


TGetDelegationTokenResp::~TGetDelegationTokenResp() noexcept {
}


void TGetDelegationTokenResp::__set_status(const TStatus& val) {
  this->status = val;
}

void TGetDelegationTokenResp::__set_delegationToken(const std::string& val) {
  this->delegationToken = val;
__isset.delegationToken = true;
}
std::ostream& operator<<(std::ostream& out, const TGetDelegationTokenResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetDelegationTokenResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delegationToken);
          this->__isset.delegationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetDelegationTokenResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetDelegationTokenResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.delegationToken) {
    xfer += oprot->writeFieldBegin("delegationToken", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->delegationToken);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetDelegationTokenResp &a, TGetDelegationTokenResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.delegationToken, b.delegationToken);
  swap(a.__isset, b.__isset);
}

TGetDelegationTokenResp::TGetDelegationTokenResp(const TGetDelegationTokenResp& other320) {
  status = other320.status;
  delegationToken = other320.delegationToken;
  __isset = other320.__isset;
}
TGetDelegationTokenResp& TGetDelegationTokenResp::operator=(const TGetDelegationTokenResp& other321) {
  status = other321.status;
  delegationToken = other321.delegationToken;
  __isset = other321.__isset;
  return *this;
}
void TGetDelegationTokenResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetDelegationTokenResp(";
  out << "status=" << to_string(status);
  out << ", " << "delegationToken="; (__isset.delegationToken ? (out << to_string(delegationToken)) : (out << "<null>"));
  out << ")";
}


TCancelDelegationTokenReq::~TCancelDelegationTokenReq() noexcept {
}


void TCancelDelegationTokenReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TCancelDelegationTokenReq::__set_delegationToken(const std::string& val) {
  this->delegationToken = val;
}
std::ostream& operator<<(std::ostream& out, const TCancelDelegationTokenReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCancelDelegationTokenReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_delegationToken = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delegationToken);
          isset_delegationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_delegationToken)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelDelegationTokenReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCancelDelegationTokenReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delegationToken", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->delegationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelDelegationTokenReq &a, TCancelDelegationTokenReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.delegationToken, b.delegationToken);
}

TCancelDelegationTokenReq::TCancelDelegationTokenReq(const TCancelDelegationTokenReq& other322) {
  sessionHandle = other322.sessionHandle;
  delegationToken = other322.delegationToken;
}
TCancelDelegationTokenReq& TCancelDelegationTokenReq::operator=(const TCancelDelegationTokenReq& other323) {
  sessionHandle = other323.sessionHandle;
  delegationToken = other323.delegationToken;
  return *this;
}
void TCancelDelegationTokenReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCancelDelegationTokenReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "delegationToken=" << to_string(delegationToken);
  out << ")";
}


TCancelDelegationTokenResp::~TCancelDelegationTokenResp() noexcept {
}


void TCancelDelegationTokenResp::__set_status(const TStatus& val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const TCancelDelegationTokenResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCancelDelegationTokenResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelDelegationTokenResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCancelDelegationTokenResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelDelegationTokenResp &a, TCancelDelegationTokenResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TCancelDelegationTokenResp::TCancelDelegationTokenResp(const TCancelDelegationTokenResp& other324) {
  status = other324.status;
}
TCancelDelegationTokenResp& TCancelDelegationTokenResp::operator=(const TCancelDelegationTokenResp& other325) {
  status = other325.status;
  return *this;
}
void TCancelDelegationTokenResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCancelDelegationTokenResp(";
  out << "status=" << to_string(status);
  out << ")";
}


TRenewDelegationTokenReq::~TRenewDelegationTokenReq() noexcept {
}


void TRenewDelegationTokenReq::__set_sessionHandle(const TSessionHandle& val) {
  this->sessionHandle = val;
}

void TRenewDelegationTokenReq::__set_delegationToken(const std::string& val) {
  this->delegationToken = val;
}
std::ostream& operator<<(std::ostream& out, const TRenewDelegationTokenReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenewDelegationTokenReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionHandle = false;
  bool isset_delegationToken = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionHandle.read(iprot);
          isset_sessionHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delegationToken);
          isset_delegationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_delegationToken)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRenewDelegationTokenReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenewDelegationTokenReq");

  xfer += oprot->writeFieldBegin("sessionHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sessionHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delegationToken", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->delegationToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenewDelegationTokenReq &a, TRenewDelegationTokenReq &b) {
  using ::std::swap;
  swap(a.sessionHandle, b.sessionHandle);
  swap(a.delegationToken, b.delegationToken);
}

TRenewDelegationTokenReq::TRenewDelegationTokenReq(const TRenewDelegationTokenReq& other326) {
  sessionHandle = other326.sessionHandle;
  delegationToken = other326.delegationToken;
}
TRenewDelegationTokenReq& TRenewDelegationTokenReq::operator=(const TRenewDelegationTokenReq& other327) {
  sessionHandle = other327.sessionHandle;
  delegationToken = other327.delegationToken;
  return *this;
}
void TRenewDelegationTokenReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenewDelegationTokenReq(";
  out << "sessionHandle=" << to_string(sessionHandle);
  out << ", " << "delegationToken=" << to_string(delegationToken);
  out << ")";
}


TRenewDelegationTokenResp::~TRenewDelegationTokenResp() noexcept {
}


void TRenewDelegationTokenResp::__set_status(const TStatus& val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const TRenewDelegationTokenResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenewDelegationTokenResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRenewDelegationTokenResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenewDelegationTokenResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenewDelegationTokenResp &a, TRenewDelegationTokenResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TRenewDelegationTokenResp::TRenewDelegationTokenResp(const TRenewDelegationTokenResp& other328) {
  status = other328.status;
}
TRenewDelegationTokenResp& TRenewDelegationTokenResp::operator=(const TRenewDelegationTokenResp& other329) {
  status = other329.status;
  return *this;
}
void TRenewDelegationTokenResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenewDelegationTokenResp(";
  out << "status=" << to_string(status);
  out << ")";
}


TProgressUpdateResp::~TProgressUpdateResp() noexcept {
}


void TProgressUpdateResp::__set_headerNames(const std::vector<std::string> & val) {
  this->headerNames = val;
}

void TProgressUpdateResp::__set_rows(const std::vector<std::vector<std::string> > & val) {
  this->rows = val;
}

void TProgressUpdateResp::__set_progressedPercentage(const double val) {
  this->progressedPercentage = val;
}

void TProgressUpdateResp::__set_status(const TJobExecutionStatus::type val) {
  this->status = val;
}

void TProgressUpdateResp::__set_footerSummary(const std::string& val) {
  this->footerSummary = val;
}

void TProgressUpdateResp::__set_startTime(const int64_t val) {
  this->startTime = val;
}
std::ostream& operator<<(std::ostream& out, const TProgressUpdateResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TProgressUpdateResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_headerNames = false;
  bool isset_rows = false;
  bool isset_progressedPercentage = false;
  bool isset_status = false;
  bool isset_footerSummary = false;
  bool isset_startTime = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->headerNames.clear();
            uint32_t _size330;
            ::apache::thrift::protocol::TType _etype333;
            xfer += iprot->readListBegin(_etype333, _size330);
            this->headerNames.resize(_size330);
            uint32_t _i334;
            for (_i334 = 0; _i334 < _size330; ++_i334)
            {
              xfer += iprot->readString(this->headerNames[_i334]);
            }
            xfer += iprot->readListEnd();
          }
          isset_headerNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size335;
            ::apache::thrift::protocol::TType _etype338;
            xfer += iprot->readListBegin(_etype338, _size335);
            this->rows.resize(_size335);
            uint32_t _i339;
            for (_i339 = 0; _i339 < _size335; ++_i339)
            {
              {
                this->rows[_i339].clear();
                uint32_t _size340;
                ::apache::thrift::protocol::TType _etype343;
                xfer += iprot->readListBegin(_etype343, _size340);
                this->rows[_i339].resize(_size340);
                uint32_t _i344;
                for (_i344 = 0; _i344 < _size340; ++_i344)
                {
                  xfer += iprot->readString(this->rows[_i339][_i344]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->progressedPercentage);
          isset_progressedPercentage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast345;
          xfer += iprot->readI32(ecast345);
          this->status = static_cast<TJobExecutionStatus::type>(ecast345);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->footerSummary);
          isset_footerSummary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          isset_startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_headerNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_progressedPercentage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_footerSummary)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_startTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TProgressUpdateResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TProgressUpdateResp");

  xfer += oprot->writeFieldBegin("headerNames", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headerNames.size()));
    std::vector<std::string> ::const_iterator _iter346;
    for (_iter346 = this->headerNames.begin(); _iter346 != this->headerNames.end(); ++_iter346)
    {
      xfer += oprot->writeString((*_iter346));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->rows.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter347;
    for (_iter347 = this->rows.begin(); _iter347 != this->rows.end(); ++_iter347)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter347).size()));
        std::vector<std::string> ::const_iterator _iter348;
        for (_iter348 = (*_iter347).begin(); _iter348 != (*_iter347).end(); ++_iter348)
        {
          xfer += oprot->writeString((*_iter348));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("progressedPercentage", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->progressedPercentage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->status));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("footerSummary", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->footerSummary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TProgressUpdateResp &a, TProgressUpdateResp &b) {
  using ::std::swap;
  swap(a.headerNames, b.headerNames);
  swap(a.rows, b.rows);
  swap(a.progressedPercentage, b.progressedPercentage);
  swap(a.status, b.status);
  swap(a.footerSummary, b.footerSummary);
  swap(a.startTime, b.startTime);
}

TProgressUpdateResp::TProgressUpdateResp(const TProgressUpdateResp& other349) {
  headerNames = other349.headerNames;
  rows = other349.rows;
  progressedPercentage = other349.progressedPercentage;
  status = other349.status;
  footerSummary = other349.footerSummary;
  startTime = other349.startTime;
}
TProgressUpdateResp& TProgressUpdateResp::operator=(const TProgressUpdateResp& other350) {
  headerNames = other350.headerNames;
  rows = other350.rows;
  progressedPercentage = other350.progressedPercentage;
  status = other350.status;
  footerSummary = other350.footerSummary;
  startTime = other350.startTime;
  return *this;
}
void TProgressUpdateResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TProgressUpdateResp(";
  out << "headerNames=" << to_string(headerNames);
  out << ", " << "rows=" << to_string(rows);
  out << ", " << "progressedPercentage=" << to_string(progressedPercentage);
  out << ", " << "status=" << to_string(status);
  out << ", " << "footerSummary=" << to_string(footerSummary);
  out << ", " << "startTime=" << to_string(startTime);
  out << ")";
}


TGetQueryIdReq::~TGetQueryIdReq() noexcept {
}


void TGetQueryIdReq::__set_operationHandle(const TOperationHandle& val) {
  this->operationHandle = val;
}
std::ostream& operator<<(std::ostream& out, const TGetQueryIdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetQueryIdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operationHandle = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationHandle.read(iprot);
          isset_operationHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operationHandle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetQueryIdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetQueryIdReq");

  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->operationHandle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetQueryIdReq &a, TGetQueryIdReq &b) {
  using ::std::swap;
  swap(a.operationHandle, b.operationHandle);
}

TGetQueryIdReq::TGetQueryIdReq(const TGetQueryIdReq& other351) {
  operationHandle = other351.operationHandle;
}
TGetQueryIdReq& TGetQueryIdReq::operator=(const TGetQueryIdReq& other352) {
  operationHandle = other352.operationHandle;
  return *this;
}
void TGetQueryIdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetQueryIdReq(";
  out << "operationHandle=" << to_string(operationHandle);
  out << ")";
}


TGetQueryIdResp::~TGetQueryIdResp() noexcept {
}


void TGetQueryIdResp::__set_queryId(const std::string& val) {
  this->queryId = val;
}
std::ostream& operator<<(std::ostream& out, const TGetQueryIdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGetQueryIdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_queryId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queryId);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGetQueryIdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetQueryIdResp");

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetQueryIdResp &a, TGetQueryIdResp &b) {
  using ::std::swap;
  swap(a.queryId, b.queryId);
}

TGetQueryIdResp::TGetQueryIdResp(const TGetQueryIdResp& other353) {
  queryId = other353.queryId;
}
TGetQueryIdResp& TGetQueryIdResp::operator=(const TGetQueryIdResp& other354) {
  queryId = other354.queryId;
  return *this;
}
void TGetQueryIdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetQueryIdResp(";
  out << "queryId=" << to_string(queryId);
  out << ")";
}

}}}}} // namespace
